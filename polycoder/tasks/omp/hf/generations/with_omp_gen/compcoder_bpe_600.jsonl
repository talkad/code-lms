{"label": " \nvoid sponge3d_apply(float  ***uu, \n\t\t    sponge1d spo, \n\t\t    fdm3d    fdm) \n \n \n{ \n    int iz,ix,iy,ib,ibz,ibx,iby; \n    float w; \n \n#pragma omp parallel for        schedule(dynamic,1)         private(ib,iz,ix,iy,ibz,ibx,iby,w)       shared(fdm,uu) \n    for(ib=0; ib<fdm->nb; ib++) { \n\tw = spo->w[fdm->nb-ib-1]; \n \n\tibz = fdm->nzpad-ib-1; \n\tfor    (iy=0; iy<fdm->nypad; iy++) { \n\t    for(ix=0; ix<fdm->nxpad; ix++) { \n\t\tuu[iy][ix][ib ] *= w;  \n \n\t\tuu[iy][ix][ibz] *= w;  \n \n\t    } \n\t} \n \n\tibx = fdm->nxpad-ib-1; \n\tfor    (iy=0; iy<fdm->nypad; iy++) { \n\t    for(iz=0; iz<fdm->nzpad; iz++) { \n\t\tuu[iy][ib ][iz] *= w;  \n \n\t\tuu[iy][ibx][iz] *= w;  \n \n\t    } \n\t} \n\t \n\tiby = fdm->nypad-ib-1; \n\tfor    (ix=0; ix<fdm->nxpad; ix++) { \n\t    for(iz=0; iz<fdm->nzpad; iz++) { \n\t\tuu[ib ][ix][iz] *= w;  \n \n\t\tuu[iby][ix][iz] *= w;  \n \n\t    } \n\t} \n \n    } \n} ", "pred": " \nvoid sponge3d_apply(float  ***uu, \n\t\t    sponge1d spo, \n\t\t    fdm3d    fdm) \n \n \n{ \n    int iz,ix,iy,ib,ibz,ibx,iby; \n    float w; \n \n#pragma omp parallel for        schedule(dynamic,1)         private(ib,iz,ix,iy,ibz,ibx,iby,w)       shared(fdm,uu) \n    for(ib=0; ib<fdm->nb; ib++) { \n\tw = spo->w[fdm->nb-ib-1]; \n \n\tibz = fdm->nzpad-ib-1; \n\tfor    (iy=0; iy<fdm->nypad; iy++) { \n\t    for(ix=0; ix<fdm->nxpad; ix++) { \n\t\tuu[iy][ix][ib ] *= w;  \n \n\t\tuu[iy][ix][ibz] *= w;  \n \n\t    } \n\t} \n \n\tibx = fdm->nxpad-ib-1; \n\tfor    (iy=0; iy<fdm->nypad; iy++) { \n\t    for(iz=0; iz<fdm->nzpad; iz++) { \n\t\tuu[iy][ib ][iz] *= w;  \n \n\t\tuu[iy][ibx][iz] *= w;  \n \n\t    } \n\t} \n\t \n\tiby = fdm->nypad-ib-1; \n\tfor    (ix=0; ix<fdm->nxpad; ix++) { \n\t    for(iz=0; iz<fdm->nzpad; iz++) { \n\t\tuu[ib ][ix][iz] *= w;  \n \n\t\tuu[iby][ix][iz] *= w;  \n \n\t    } \n\t} \n \n    } \n} "}
{"label": " \nstatic void nlSparseMatrix_mult_rows( \n        NLSparseMatrix* A, \n        const NLdouble* x, \n        NLdouble* y \n) { \n     \n \n     \n    int m = (int)(A->m); \n    int i,ij; \n    NLCoeff* c = NULL; \n    NLRowColumn* Ri = NULL; \n \n#pragma omp parallel for private(i,ij,c,Ri) \n     \n    for(i=0; i<m; i++) { \n        Ri = &(A->row[i]);        \n        y[i] = 0; \n        for(ij=0; ij<(int)(Ri->size); ij++) { \n            c = &(Ri->coeff[ij]); \n            y[i] += c->value * x[c->index]; \n        } \n    } \n} ", "pred": " \nstatic void nlSparseMatrix_mult_rows( \n        NLSparseMatrix* A, \n        const NLdouble* x, \n        NLdouble* y \n) { \n     \n \n     \n    int m = (int)(A->m); \n    int i,ij; \n    NLCoeff* c = NULL; \n    NLRowColumn* Ri = NULL; \n \n#pragma omp parallel for private(i,ij,c,Ri) \n     \n    for(i=0; i<m; i++) { \n        Ri = &(A->row[i]);        \n        y[i] = 0; \n        for(ij=0; ij<(int)(Ri->size); ij++) { \n            c = &(Ri->coeff[ij]); \n            y[i] += c->value * x[c->index]; \n        } \n    } \n} "}
{"label": "main(int argc, char ** argv) { \n\t \n \n\tlong lower, upper; \n\tsscanf(argv[1], \"%ld\", &lower); \n\tsscanf(argv[2], \"%ld\", &upper); \n \n\tint i;  \n\tlong result = 0.0; \n\t \n\t \n \n\tif(lower == 1) { \n\t\tresult = 1.0; \n\t\tlower = 2; \n\t} \n\t \n #pragma omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10) \n \n\t \n \n\tfor (i = lower; i <= upper; i++) { \n\t\tresult = result + getTotient(i); \n\t} \n\t \n\t \n \n\tprintf(\"Sum of Totients between [%ld..%ld] is %ld \\n\", lower, upper, result); \n\t \n\t \n \n\treturn 0; \n} \n ", "pred": "main(int argc, char ** argv) { \n\t \n \n\tlong lower, upper; \n\tsscanf(argv[1], \"%ld\", &lower); \n\tsscanf(argv[2], \"%ld\", &upper); \n \n\tint i;  \n\tlong result = 0.0; \n\t \n\t \n \n\tif(lower == 1) { \n\t\tresult = 1.0; \n\t\tlower = 2; \n\t} \n\t \n #pragma omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10) \n \n\t \n \n\tfor (i = lower; i <= upper; i++) { \n\t\tresult = result + getTotient(i); \n\t} \n\t \n\t \n \n\tprintf(\"Sum of Totients between [%ld..%ld] is %ld \\n\", lower, upper, result); \n\t \n\t \n \n\treturn 0; \n} \n "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_grain_data_t *data = (dt_iop_grain_data_t *)piece->data; \n \n  unsigned int hash = _hash_string(piece->pipe->image.filename) % (int)fmax(roi_out->width * 0.3, 1.0); \n \n  const int ch = piece->colors; \n   \n \n  const double strength = (data->strength / 100.0); \n  const double octaves = 3; \n   \n \n  const double wd = fminf(piece->buf_in.width, piece->buf_in.height); \n  const double zoom = (1.0 + 8 * data->scale / 100) / 800.0; \n  const int filter = fabsf(roi_out->scale - 1.0f) > 0.01; \n   \n \n   \n \n  const double filtermul = piece->iscale / (roi_out->scale * wd); \n#pragma omp parallel for default(none) shared(data, hash) \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    float *in = ((float *)ivoid) + (size_t)roi_out->width * j * ch; \n    float *out = ((float *)ovoid) + (size_t)roi_out->width * j * ch; \n    for(int i = 0; i < roi_out->width; i++) \n    { \n       \n \n       \n \n      double wx = (roi_out->x + i) / roi_out->scale; \n      double wy = (roi_out->y + j) / roi_out->scale; \n       \n \n       \n \n      double x = wx / wd; \n      double y = wy / wd; \n       \n \n      double noise = 0.0; \n      if(filter) \n      { \n         \n \n        const float fib1 = 34.0, fib2 = 21.0; \n        for(int l = 0; l < fib2; l++) \n        { \n          float px = l / fib2, py = l * (fib1 / fib2); \n          py -= (int)py; \n          float dx = px * filtermul, dy = py * filtermul; \n          noise += (1.0 / fib2) * _simplex_2d_noise(x + dx + hash, y + dy, octaves, 1.0, zoom); \n        } \n      } \n      else \n      { \n        noise = _simplex_2d_noise(x + hash, y, octaves, 1.0, zoom); \n      } \n \n      out[0] = in[0] + dt_lut_lookup_2d_1c(data->grain_lut, (noise * strength) * GRAIN_LIGHTNESS_STRENGTH_SCALE, in[0] / 100.0f); \n      out[1] = in[1]; \n      out[2] = in[2]; \n      out[3] = in[3]; \n \n      out += ch; \n      in += ch; \n    } \n  } \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_grain_data_t *data = (dt_iop_grain_data_t *)piece->data; \n \n  unsigned int hash = _hash_string(piece->pipe->image.filename) % (int)fmax(roi_out->width * 0.3, 1.0); \n \n  const int ch = piece->colors; \n   \n \n  const double strength = (data->strength / 100.0); \n  const double octaves = 3; \n   \n \n  const double wd = fminf(piece->buf_in.width, piece->buf_in.height); \n  const double zoom = (1.0 + 8 * data->scale / 100) / 800.0; \n  const int filter = fabsf(roi_out->scale - 1.0f) > 0.01; \n   \n \n   \n \n  const double filtermul = piece->iscale / (roi_out->scale * wd); \n#pragma omp parallel for default(none) shared(data, hash) \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    float *in = ((float *)ivoid) + (size_t)roi_out->width * j * ch; \n    float *out = ((float *)ovoid) + (size_t)roi_out->width * j * ch; \n    for(int i = 0; i < roi_out->width; i++) \n    { \n       \n \n       \n \n      double wx = (roi_out->x + i) / roi_out->scale; \n      double wy = (roi_out->y + j) / roi_out->scale; \n       \n \n       \n \n      double x = wx / wd; \n      double y = x;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   "}
{"label": " \nstatic MagickBooleanType XShearImage(Image *image,const double degrees, \n  const size_t width,const size_t height,const ssize_t x_offset, \n  const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define XShearImageTag  \"XShear/Image\" \n \n  typedef enum \n  { \n    LEFT, \n    RIGHT \n  } ShearDirection; \n \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PixelInfo \n    background; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickCoreSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  status=MagickTrue; \n  background=image->background_color; \n  progress=0; \n  image_view=AcquireAuthenticCacheView(image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,image,height,1) \n  for (y=0; y < (ssize_t) height; y++) \n  { \n    PixelInfo \n      pixel, \n      source, \n      destination; \n \n    double \n      area, \n      displacement; \n \n    register Quantum \n      *magick_restrict p, \n      *magick_restrict q; \n \n    register ssize_t \n      i; \n \n    ShearDirection \n      direction; \n \n    ssize_t \n      step; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewAuthenticPixels(image_view,0,y_offset+y,image->columns,1, \n      exception); \n    if (p == (Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    p+=x_offset*GetPixelChannels(image); \n    displacement=degrees*(double) (y-height/2.0); \n    if (displacement == 0.0) \n      continue; \n    if (displacement > 0.0) \n      direction=RIGHT; \n    else \n      { \n        displacement*=(-1.0); \n        direction=LEFT; \n      } \n    step=(ssize_t) floor((double) displacement); \n    area=(double) (displacement-step); \n    step++; \n    pixel=background; \n    GetPixelInfo(image,&source); \n    GetPixelInfo(image,&destination); \n    switch (direction) \n    { \n      case LEFT: \n      { \n         \n \n        if (step > x_offset) \n          break; \n        q=p-step*GetPixelChannels(image); \n        for (i=0; i < (ssize_t) width; i++) \n        { \n          if ((x_offset+i) < step) \n            { \n              p+=GetPixelChannels(image); \n              GetPixelInfoPixel(image,p,&pixel); \n              q+=GetPixelChannels(image); \n              continue; \n            } \n          GetPixelInfoPixel(image,p,&source); \n          CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n            &source,(double) GetPixelAlpha(image,p),area,&destination); \n          SetPixelViaPixelInfo(image,&destination,q); \n          GetPixelInfoPixel(image,p,&pixel); \n          p+=GetPixelChannels(image); \n          q+=GetPixelChannels(image); \n        } \n        CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n          &background,(double) background.alpha,area,&destination); \n        SetPixelViaPixelInfo(image,&destination,q); \n        q+=GetPixelChannels(image); \n        for (i=0; i < (step-1); i++) \n        { \n          SetPixelViaPixelInfo(image,&background,q); \n          q+=GetPixelChannels(image); \n        } \n        break; \n      } \n      case RIGHT: \n      { \n         \n \n        p+=width*GetPixelChannels(image); \n        q=p+step*GetPixelChannels(image); \n        for (i=0; i < (ssize_t) width; i++) \n        { \n          p-=GetPixelChannels(image); \n          q-=GetPixelChannels(image); \n          if ((size_t) (x_offset+width+step-i) > image->columns) \n            continue; \n          GetPixelInfoPixel(image,p,&source); \n          CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n            &source,(double) GetPixelAlpha(image,p),area,&destination); \n          SetPixelViaPixelInfo(image,&destination,q); \n          GetPixelInfoPixel(image,p,&pixel); \n        } \n        CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n          &background,(double) background.alpha,area,&destination); \n        q-=GetPixelChannels(image); \n        SetPixelViaPixelInfo(image,&destination,q); \n        for (i=0; i < (step-1); i++) \n        { \n          q-=GetPixelChannels(image); \n ", "pred": " \nstatic MagickBooleanType XShearImage(Image *image,const double degrees, \n  const size_t width,const size_t height,const ssize_t x_offset, \n  const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define XShearImageTag  \"XShear/Image\" \n \n  typedef enum \n  { \n    LEFT, \n    RIGHT \n  } ShearDirection; \n \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PixelInfo \n    background; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickCoreSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  status=MagickTrue; \n  background=image->background_color; \n  progress=0; \n  image_view=AcquireAuthenticCacheView(image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,image,height,1) \n  for (y=0; y < (ssize_t) height; y++) \n  { \n    PixelInfo \n      pixel, \n      source, \n      destination; \n \n    double \n      area, \n      displacement; \n \n    register Quantum \n      *magick_restrict p, \n      *magick_restrict q; \n \n    register ssize_t \n      i; \n \n    ShearDirection \n      direction; \n \n    ssize_t \n      step; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewAuthenticPixels(image_view,0,y_offset+y_offset,image->width,image->height,image->format,image->width,image->height,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image->y,image->format,image->x,image"}
{"label": " \ndouble processMyersGPU(char *refFile, char *qryFile, uint32_t numBuffers, uint32_t numThreads, uint32_t maxMbPerBuffer, uint32_t numTasks) \n{ \n\tvoid \t \t**buffer; \n\ttest_t\t\ttestData[numThreads];  \n \n\tuint32_t \taverageQuerySize, averageCandidatesPerQuery; \n \n\tuint32_t \terror, idBuffer, iteration, threadID, idTask; \n\tdouble\t\tts, ts1; \n \n\tfor(threadID = 0; threadID < numThreads; ++threadID) \n\t\tloadTestData(qryFile, &testData[threadID], &averageQuerySize, &averageCandidatesPerQuery); \n \n\tbpm_gpu_init_(&buffer, numBuffers, maxMbPerBuffer, refFile, PROFILE_REFERENCE_FILE, 0, averageQuerySize, \n\t\t\t\t        averageCandidatesPerQuery, ARCH_SUPPORTED); \n \n\tts = sampleTime(); \n \n  #pragma omp parallel for num_threads(numThreads) schedule(static,1) private(idTask, idBuffer) \n\t\tfor(idTask = 0; idTask < numTasks; ++idTask){ \n      idBuffer = idTask % numBuffers; \n \n       \n \n      printf(\"Host thread %d \\t sent job %d \\t to buffer %d \\t in device %d \\n\", omp_get_thread_num(), idTask, idBuffer, bpm_gpu_buffer_get_id_device_(buffer[idBuffer])); \n \n       \n \n      putIntoBuffer(buffer[idBuffer], &testData[idBuffer]); \n \n      bpm_gpu_send_buffer_(buffer[idBuffer], testData[idBuffer].totalQueriesEntries, testData[idBuffer].numQueries, testData[idBuffer].numCandidates); \n      bpm_gpu_receive_buffer_(buffer[idBuffer]); \n \n       \n \n      getFromBuffer(buffer[idBuffer], &testData[idBuffer]); \n\t\t} \n \n\tts1 = sampleTime(); \n\tbpm_gpu_destroy_(&buffer); \n \n\t \n \n\terror = saveResults(qryFile, &testData[0], numBuffers); \n\tif(error!= 0){fprintf(stderr, \"Error %d, saving results \\n\", error); exit(EXIT_FAILURE);} \n \n\tfreeTestData(&testData[0], numThreads); \n\treturn(ts1-ts); \n} ", "pred": " \ndouble processMyersGPU(char *refFile, char *qryFile, uint32_t numBuffers, uint32_t numThreads, uint32_t maxMbPerBuffer, uint32_t numTasks) \n{ \n\tvoid \t \t**buffer; \n\ttest_t\t\ttestData[numThreads];  \n \n\tuint32_t \taverageQuerySize, averageCandidatesPerQuery; \n \n\tuint32_t \terror, idBuffer, iteration, threadID, idTask; \n\tdouble\t\tts, ts1; \n \n\tfor(threadID = 0; threadID < numThreads; ++threadID) \n\t\tloadTestData(qryFile, &testData[threadID], &averageQuerySize, &averageCandidatesPerQuery); \n \n\tbpm_gpu_init_(&buffer, numBuffers, maxMbPerBuffer, refFile, PROFILE_REFERENCE_FILE, 0, averageQuerySize, \n\t\t\t\t        averageCandidatesPerQuery, ARCH_SUPPORTED); \n \n\tts = sampleTime(); \n \n  #pragma omp parallel for num_threads(numThreads) schedule(static,1) private(idTask, idBuffer) \n\t\tfor(idTask = 0; idTask < numTasks; ++idTask){ \n      idBuffer = idTask % numBuffers; \n \n       \n \n      printf(\"Host thread %d \\t sent job %d \\t to buffer %d \\t in device %d \\n\", omp_get_thread_num(), idTask, idBuffer, bpm_gpu_buffer_get_id_device_(buffer[idBuffer])); \n \n       \n \n      putIntoBuffer(buffer[idBuffer], &testData[idBuffer]); \n \n      bpm_gpu_send_buffer_(buffer[idBuffer], testData[idBuffer].totalQueriesEntries, testData[idBuffer].numQueries, testData[idBuffer].numCandidates); \n      bpm_gpu_receive_buffer_(buffer[idBuffer]); \n \n       \n \n      getFromBuffer(buffer[idBuffer], &testData[idBuffer]); \n\t\t} \n \n\tts1 = sampleTime(); \n\tbpm_gpu_destroy_test_buffer_(buffer[idBuffer]);                                                                                             "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 32; \n  tile_size[3] = 64; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,12);t1++) { \n    lbp=max(ceild(t1,2),ceild(24*t1-Nt+3,24)); \n    ubp=min(floord(Nt+Nz-4,24),floord(12*t1+Nz+9,24)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(3*t1-7,8)),ceild(24*t2-Nz-28,32));t3<=min(min(min(floord(Nt+Ny-4,32),floord(12*t1+Ny+21,32)),floord(24*t2+Ny+20,32)),floord(24*t1-24*t2+Nz+Ny+19,32));t3++) { \n        for (t4=max(max(max(0,ceild(3*t1-15,16)),ceild(24*t2-Nz-60,64)),ceild(32*t3-Ny-60,64));t4<=min(min(min(min(floord(Nt+Nx-4,64),floord(12*t1+Nx+21,64)),floord(24*t2+Nx+20,64)),floord(32*t3+Nx+28,64)),floord(24*t1-24*t2+Nz+Nx+19,64));t4++) { \n          for (t5=max(max(max(max(max(0,12*t1),24*t1-24*t2+1),24*t2-Nz+2),32*t3-Ny+2),64*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,12*t1+23),24*t2+22),32*t3+30),64*t4+62),24*t1-24*t2+Nz+21);t5++) { \n            for (t6=max(max(24*t2,t5+1),-24*t1+24*t2+2*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(32*t3,t5+1);t7<=min(32*t3+31,", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *) tile_size, sizeof(int)*Nz);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": " \nvoid \nfoo (void) \n{ \n  #pragma omp for simd schedule (simd: dynamic, 32) collapse(2) \n  for (int i = 0; i < 10000; i++) \n    for (int j = 0; j < 128; j++) \n      a[i][j] += 3; \n} ", "pred": " \nvoid \nfoo (void) \n{ \n  #pragma omp for simd schedule (simd: dynamic, 32) collapse(2) \n  for (int i = 0; i < 10000; i++) \n    for (int j = 0; j < 128; j++) \n      a[i][j] += 3; \n} "}
{"label": " \nstatic MagickBooleanType RadonTransform(const Image *image, \n  const double threshold,size_t *projection,ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  MatrixInfo \n    *destination_matrixs, \n    *source_matrixs; \n \n  MagickBooleanType \n    status; \n \n  size_t \n    count, \n    width; \n \n  ssize_t \n    j, \n    y; \n \n  unsigned char \n    c; \n \n  unsigned short \n    bits[256]; \n \n  for (width=1; width < ((image->columns+7)/8); width<<=1) ; \n  source_matrixs=AcquireMatrixInfo(width,image->rows,sizeof(unsigned short), \n    exception); \n  destination_matrixs=AcquireMatrixInfo(width,image->rows, \n    sizeof(unsigned short),exception); \n  if ((source_matrixs == (MatrixInfo *) NULL) || \n      (destination_matrixs == (MatrixInfo *) NULL)) \n    { \n      if (destination_matrixs!= (MatrixInfo *) NULL) \n        destination_matrixs=DestroyMatrixInfo(destination_matrixs); \n      if (source_matrixs!= (MatrixInfo *) NULL) \n        source_matrixs=DestroyMatrixInfo(source_matrixs); \n      return(MagickFalse); \n    } \n  if (NullMatrix(source_matrixs) == MagickFalse) \n    { \n      destination_matrixs=DestroyMatrixInfo(destination_matrixs); \n      source_matrixs=DestroyMatrixInfo(source_matrixs); \n      return(MagickFalse); \n    } \n  for (j=0; j < 256; j++) \n  { \n    c=(unsigned char) j; \n    for (count=0; c!= 0; c>>=1) \n      count+=c & 0x01; \n    bits[j]=(unsigned short) count; \n  } \n  status=MagickTrue; \n  image_view=AcquireVirtualCacheView(image,exception); \n  #pragma omp parallel for schedule(static,4) shared(status)      magick_threads(image,image,1,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    register const Quantum \n      *magick_restrict p; \n \n    register ssize_t \n      i, \n      x; \n \n    size_t \n      bit, \n      byte; \n \n    unsigned short \n      value; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    if (p == (const Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    bit=0; \n    byte=0; \n    i=(ssize_t) (image->columns+7)/8; \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      byte<<=1; \n      if (((MagickRealType) GetPixelRed(image,p) < threshold) || \n          ((MagickRealType) GetPixelGreen(image,p) < threshold) || \n          ((MagickRealType) GetPixelBlue(image,p) < threshold)) \n        byte|=0x01; \n      bit++; \n      if (bit == 8) \n        { \n          value=bits[byte]; \n          (void) SetMatrixElement(source_matrixs,--i,y,&value); \n          bit=0; \n          byte=0; \n        } \n      p+=GetPixelChannels(image); \n    } \n    if (bit!= 0) \n      { \n        byte<<=(8-bit); \n        value=bits[byte]; \n        (void) SetMatrixElement(source_matrixs,--i,y,&value); \n      } \n  } \n  RadonProjection(image,source_matrixs,destination_matrixs,-1,projection); \n  (void) NullMatrix(source_matrixs); \n  #pragma omp parallel for schedule(static,4) shared(status)      magick_threads(image,image,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    register const Quantum \n      *magick_restrict p; \n \n    register ssize_t \n      i, \n      x; \n \n    size_t \n      bit, \n      byte; \n \n    unsigned short \n     value; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    if (p == (const Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    bit=0; \n    byte=0; \n    i=0; \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      byte<<=1; \n      if (((MagickRealType) GetPixelRed(image,p) < threshold) || \n          ((MagickRealType) GetPixelGreen(image,p) < threshold) || \n          ((MagickRealType) GetPixelBlue(image,p) < threshold)) \n        byte|=0x01; \n      bit++; \n      if (bit == 8) \n        { \n          value=bits[byte]; \n          (void) SetMatrixElement(source_matrixs,i++,y,&value); \n          bit=0; \n          byte=0; \n        } \n      p+=GetPixelChannels(image); \n    } \n    if (bit!= 0) \n      { \n        byte<<=(8-bit); \n        value=bits[byte]; \n        (void) SetMatrixElement(source_matrixs,i++,y,&", "pred": " \nstatic MagickBooleanType RadonTransform(const Image *image, \n  const double threshold,size_t *projection,ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  MatrixInfo \n    *destination_matrixs, \n    *source_matrixs; \n \n  MagickBooleanType \n    status; \n \n  size_t \n    count, \n    width; \n \n  ssize_t \n    j, \n    y; \n \n  unsigned char \n    c; \n \n  unsigned short \n    bits[256]; \n \n  for (width=1; width < ((image->columns+7)/8); width<<=1) ; \n  source_matrixs=AcquireMatrixInfo(width,image->rows,sizeof(unsigned short), \n    exception); \n  destination_matrixs=AcquireMatrixInfo(width,image->rows, \n    sizeof(unsigned short),exception); \n  if ((source_matrixs == (MatrixInfo *) NULL) || \n      (destination_matrixs == (MatrixInfo *) NULL)) \n    { \n      if (destination_matrixs!= (MatrixInfo *) NULL) \n        destination_matrixs=DestroyMatrixInfo(destination_matrixs); \n      if (source_matrixs!= (MatrixInfo *) NULL) \n        source_matrixs=DestroyMatrixInfo(source_matrixs); \n      return(MagickFalse); \n    } \n  if (NullMatrix(source_matrixs) == MagickFalse) \n    { \n      destination_matrixs=DestroyMatrixInfo(destination_matrixs); \n      source_matrixs=DestroyMatrixInfo(source_matrixs); \n      return(MagickFalse); \n    } \n  for (j=0; j < 256; j++) \n  { \n    c=(unsigned char) j; \n    for (count=0; c!= 0; c>>=1) \n      count+=c & 0x01; \n    bits[j]=(unsigned char)c;\\n      }\\n      if (image->source_type == MagickFalse)\\n      {\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n        \\n\\n "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 16; \n  tile_size[1] = 16; \n  tile_size[2] = 16; \n  tile_size[3] = 32; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0765; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,8);t1++) { \n    lbp=max(ceild(t1,2),ceild(16*t1-Nt+3,16)); \n    ubp=min(floord(Nt+Nz-4,16),floord(8*t1+Nz+5,16)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-1,2)),ceild(16*t2-Nz-12,16));t3<=min(min(min(floord(Nt+Ny-4,16),floord(8*t1+Ny+13,16)),floord(16*t2+Ny+12,16)),floord(16*t1-16*t2+Nz+Ny+11,16));t3++) { \n        for (t4=max(max(max(0,ceild(t1-3,4)),ceild(16*t2-Nz-28,32)),ceild(16*t3-Ny-28,32));t4<=min(min(min(min(floord(Nt+Nx-4,32),floord(8*t1+Nx+13,32)),floord(16*t2+Nx+12,32)),floord(16*t3+Nx+12,32)),floord(16*t1-16*t2+Nz+Nx+11,32));t4++) { \n          for (t5=max(max(max(max(max(0,8*t1),16*t1-16*t2+1),16*t2-Nz+2),16*t3-Ny+2),32*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,8*t1+15),16*t2+14),16*t3+14),32*t4+30),16*t1-16*t2+Nz+13);t5++) { \n            for (t6=max(max(16*t2,t5+1),-16*t1+16*t2+2*t5-15);t6<=min(min(16*t2+15,-16*t1+16*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(16*t3,t5+1);t7<=min(16*t3+15,t5+Ny-2);t7++) { \n                lbv=max(32*t4,t5+1); \n                ubv=min(32*t4+31,t5+Nx-2); \n#pragma ivdep \n#pragma vector always \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = ((alpha * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (beta * (((((A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)] + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) - 1][ (-t5+t8", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 16; \n  tile_size[1] = 16; \n  tile_size[2] = 16; \n  tile_size[3] = 32; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0876;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "}
{"label": " \nvoid sponge2d_apply(float**   uu, \n\t\t    sponge   spo, \n\t\t    fdm2d    fdm) \n \n \n{ \n    int iz,ix,ib,ibz,ibx; \n    float w; \n \n#pragma omp parallel for        schedule(dynamic,1)         private(ib,iz,ix,ibz,ibx,w)        shared(fdm,uu) \n    for(ib=0; ib<fdm->nb; ib++) { \n\tw = spo->w[fdm->nb-ib-1]; \n \n\tibz = fdm->nzpad-ib-1; \n\tfor(ix=0; ix<fdm->nxpad; ix++) { \n \n \n\t    uu[ix][ib ] *= w;  \n \n\t    uu[ix][ibz] *= w;  \n \n  \n \n\t} \n \n\tibx = fdm->nxpad-ib-1; \n\tfor(iz=0; iz<fdm->nzpad; iz++) { \n\t    uu[ib ][iz] *= w;  \n \n\t    uu[ibx][iz] *= w;  \n \n\t} \n \n    } \n} ", "pred": " \nvoid sponge2d_apply(float**   uu, \n\t\t    sponge   spo, \n\t\t    fdm2d    fdm) \n \n \n{ \n    int iz,ix,ib,ibz,ibx; \n    float w; \n \n#pragma omp parallel for        schedule(dynamic,1)         private(ib,iz,ix,ibz,ibx,w)        shared(fdm,uu) \n    for(ib=0; ib<fdm->nb; ib++) { \n\tw = spo->w[fdm->nb-ib-1]; \n \n\tibz = fdm->nzpad-ib-1; \n\tfor(ix=0; ix<fdm->nxpad; ix++) { \n \n \n\t    uu[ix][ib ] *= w;  \n \n\t    uu[ix][ibz] *= w;  \n \n  \n \n\t} \n \n\tibx = fdm->nxpad-ib-1; \n\tfor(iz=0; iz<fdm->nzpad; iz++) { \n\t    uu[ib ][iz] *= w;  \n \n\t    uu[ibx][iz] *= w;  \n \n\t} \n \n    } \n} "}
{"label": " \nint main(int argc, char* argv[]) \n{ \n    bool verb; \n    int it, nt, ih, nh, is, ns, nsg, nrg, left, right, ic, aper, shift, c, cc, hh; \n    int ir, nr, jump, sleft, sright, tap; \n    float datum, length, t0, dt, h0, dh, s0, ds, sg0, dsg, rg0, drg, dist, tau, delta; \n    float r, dr, s, h, coef; \n    float ***tr_in, ***tr_out, **stable, **rtable; \n    sf_file in, out, sgreen, rgreen, interm; \n \n    sf_init (argc,argv); \n    in = sf_input(\"in\"); \n    out = sf_output(\"out\"); \n     \n    if (!sf_getbool(\"verb\",&verb)) verb=false; \n     \n \n \n    if (!sf_getfloat(\"datum\",&datum)) sf_error(\"Need datum=\"); \n     \n \n \n    if (!sf_getint(\"aperture\",&aper)) aper=50; \n     \n \n \n    if (!sf_getint(\"taper\",&tap)) tap=10; \n     \n \n \n    if (!sf_getfloat(\"length\",&length)) length=0.025; \n     \n \n \n     \n \n    if (!sf_histint(in,\"n1\",&nt)) sf_error(\"No nt=\"); \n    if (!sf_histint(in,\"n2\",&nh)) sf_error(\"No nh=\"); \n    if (!sf_histint(in,\"n3\",&ns)) sf_error(\"No ns=\"); \n \n    if (!sf_histfloat(in,\"o1\",&t0)) sf_error(\"No t0=\"); \n    if (!sf_histfloat(in,\"d1\",&dt)) sf_error(\"No dt=\"); \n \n    if (!sf_histfloat(in,\"o2\",&h0)) sf_error(\"No h0=\"); \n    if (!sf_histfloat(in,\"d2\",&dh)) sf_error(\"No dh=\"); \n \n    if (!sf_histfloat(in,\"o3\",&s0)) sf_error(\"No s0=\"); \n    if (!sf_histfloat(in,\"d3\",&ds)) sf_error(\"No ds=\"); \n \n    tr_in = sf_floatalloc3(nt,nh,ns); \n    sf_floatread(tr_in[0][0],nt*nh*ns,in); \n \n     \n \n    tr_out = sf_floatalloc3(nt,nh,ns); \n \n     \n \n    sgreen = sf_input(\"sgreen\"); \n \n    if (!sf_histint(sgreen,\"n1\",&nsg)) sf_error(\"No nsg=\"); \n    if (!sf_histfloat(sgreen,\"o1\",&sg0)) sf_error(\"No sg0=\"); \n    if (!sf_histfloat(sgreen,\"d1\",&dsg)) sf_error(\"No dsg=\"); \n \n    stable = sf_floatalloc2(nsg,nsg); \n    sf_floatread(stable[0],nsg*nsg,sgreen); \n    sf_fileclose(sgreen); \n \n     \n \n    rgreen = sf_input(\"rgreen\"); \n \n    if (!sf_histint(rgreen,\"n1\",&nrg)) sf_error(\"No nrg=\"); \n    if (!sf_histfloat(rgreen,\"o1\",&rg0)) sf_error(\"No rg0=\"); \n    if (!sf_histfloat(rgreen,\"d1\",&drg)) sf_error(\"No drg=\"); \n \n    rtable = sf_floatalloc2(nrg,nrg); \n    sf_floatread(rtable[0],nrg*nrg,rgreen); \n    sf_fileclose(rgreen); \n \n     \n \n    if (NULL!= sf_getstring(\"interm\")) { \n\tinterm = sf_output(\"interm\"); \n    } else { \n\tinterm = NULL; \n    } \n \n     \n \n    filt_init(dt,length); \n \n     \n \n#pragma omp parallel for private(ih,c,left,right,ic,cc,coef,tau,dist,shift,it,delta) \n    for (is=0; is < ns; is++) { \n\tif (verb) sf_warning(\"Processing common-shot gather %d of %d.\",is+1,ns); \n \n\tfor (ih=0; ih < nh; ih++) { \n \n\t    c = (s0+is*ds+h0+ih*dh-rg0)/drg+0.5; \n\t    if (c < 0 || c > nrg-1) sf_error(\"Receiver table too small.\"); \n \n\t     \n \n\t    left  = (ih-aper < 0)?    0:    ih-aper; \n\t    right = (ih+aper > nh-1)? nh-1: ih+aper; \n\t     \n\t    for (ic=left; ic <= right; ic++) { \n\t\t \n\t\tcc = (s0+is*ds+h0+ic*dh-rg0)/drg+0.5; \n\t\tif (cc < 0 || cc > nrg-1) sf_error(\"Receiver table too small.\"); \n \n\t\t \n \n\t\tcoef = 1.; \n\t\tcoef *= (ic-left  >= tap)? 1.: (ic-left)/tap; \n\t\tcoef *= (right-ic >= tap)? 1.: (right-ic)/tap; \n \n\t\t \n \n\t\ttau = rtable[cc][c]; \n \n\t\t \n \n\t\tdist = datum*datum+(ic-ih)*dh*(ic-ih)*dh; \n \n\t\t \n \n\t\tfilt_set(tau); \n \n\t\tshift = 0; \n\t\tdelta = 0.; \n\t\tfor (it=0; it < nt; it++) { \n\t\t    if (((float)it)*dt < tau)  \n\t\t\tcontinue; \n\t\t    else if (shift == 0) \n\t\t\tdelta = (((float)it*dt)-tau)/dt; \n \n\t\t    tr_out[is][ih][it] += coef/SF_PI \n\t\t\t*dh*datum*tau/dist \n\t\t\t*pick(delta,tr_in[is][ic],shift); \n\t\t    shift++; \n\t\t} \n\t    } \n \n\t} \n    } \n \n    if (NULL!= interm) sf_floatwrite(tr_out[0][0],nt*nh*ns,interm); \n \n     \n \n    for (is=0; is < ns; is++) { \n\tfor (ih=0; ih < nh; ih++) { \n\t    for (it=0; it < nt; it++) { \n\t\ttr_in[is][ih", "pred": " \nint main(int argc, char* argv[]) \n{ \n    bool verb; \n    int it, nt, ih, nh, is, ns, nsg, nrg, left, right, ic, aper, shift, c, cc, hh; \n    int ir, nr, jump, sleft, sright, tap; \n    float datum, length, t0, dt, h0, dh, s0, ds, sg0, dsg, rg0, drg, dist, tau, delta; \n    float r, dr, s, h, coef; \n    float ***tr_in, ***tr_out, **stable, **rtable; \n    sf_file in, out, sgreen, rgreen, interm; \n \n    sf_init (argc,argv); \n    in = sf_input(\"in\"); \n    out = sf_output(\"out\"); \n     \n    if (!sf_getbool(\"verb\",&verb)) verb=false; \n     \n \n \n    if (!sf_getfloat(\"datum\",&datum)) sf_error(\"Need datum=\"); \n     \n \n \n    if (!sf_getint(\"aperture\",&aper)) aper=50; \n     \n \n \n    if (!sf_getint(\"taper\",&tap)) tap=10; \n     \n \n \n    if (!sf_getfloat(\"length\",&length)) length=0.025; \n     \n \n \n     \n \n    if (!sf_histint(in,\"n1\",&nt)) sf_error(\"No nt=\"); \n    if (!sf_histint(in,\"n2\",&nh)) sf_error(\"No nh=\"); \n    if (!sf_histint(in,\"n3\",&ns)) sf_error(\"No ns=\"); \n \n    if (!sf_histfloat(in,\"o1\",&t0)) sf_error(\"No t0=\"); \n    if (!sf_histfloat(in,\"d1\",&dt)) sf_error(\"No dt=\"); \n \n    if (!sf_histfloat(in,\"o2(\\\"U\\\")))\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "}
{"label": " \nvoid get_pearson_similarity(float* rating_m, float* rating_n, double* average_matrix, k_similarity_struct * k_similarity_matrix, int start_index_m, int start_index_n, int flag){ \n        \n \n\tprintf(\" in pearson_similarity start_index_m=%d, start_index_n=%d\\n\", start_index_m, start_index_n); \n\t \n\tint nPadded = ( USER_COUNT%8 == 0? USER_COUNT : USER_COUNT + (8-USER_COUNT%8) ); \n  \n\tdouble similarity; \n\t \n        int i,j,m,n,s,k; \n \n\tint ua,ub,uc; \n  \n\tfloat sum_numerator=0; \n\tfloat sum_denominator_square_m=0; \n\tfloat sum_denominator_square_n=0; \n\tfloat sum_denominator=0; \n \n \n\tdouble* sum_numerator_matrix =(double*) _mm_malloc(sizeof(double)*USER_COUNT,64); \n\tdouble* sum_denominator_matrix_m =(double*) _mm_malloc(sizeof(double)*USER_COUNT,64); \n\tdouble* sum_denominator_matrix_n =(double*) _mm_malloc(sizeof(double)*USER_COUNT,64); \n \n\tmemset(sum_numerator_matrix,0,sizeof(double)*USER_COUNT);\t \n\tmemset(sum_denominator_matrix_m,0,sizeof(double)*USER_COUNT);\t \n\tmemset(sum_denominator_matrix_n,0,sizeof(double)*USER_COUNT);\t \n \n \n\t \n \n \n \n\t \n\tint numthreads;\t \n        int item_index; \n \n\tint block_m,block_n; \n\t \n\tint end_m=(ITEM_COUNT<(start_index_m+ITEM_BLOCK)? ITEM_COUNT:(start_index_m+ITEM_BLOCK)); \n\tint end_n=(ITEM_COUNT<(start_index_n+ITEM_BLOCK)? ITEM_COUNT:(start_index_n+ITEM_BLOCK)); \n \n\tprintf(\"the number of threads is %d\\n\", omp_get_num_threads()); \n\t \n\tprintf(\" end_m = %d, end_n = %d\\n\",end_m,end_n); \n \n \n\tdouble a = microtime(); \n \n \n\t \n         \n \n\t \n \n\t \n \n\tunsigned int mn;   \n #pragma omp parallel for \n     \n \n        for (mn = 0; mn < (end_m-start_index_m)*(end_n-start_index_n); mn++)  \n     \n \n        {       \n \n \n       \n \n         \n \n\t\t \n\t\t\tm = start_index_m + mn / ( end_n - start_index_n ); \n\t\t\tn = start_index_n + mn % ( end_n - start_index_n );  \n \n \n\t\t\tblock_m = m - start_index_m; \n\t\t\tblock_n = n - start_index_n;\t \n \n \n \n \n \n\t\t\tsum_numerator=0; \n\t\t\tsum_denominator_square_m=0; \n\t\t\tsum_denominator_square_n=0; \n\t\t\tsum_denominator=0; \n\t\t\t \n\t\t\t \n \n \n\t \n \n \n \n   #pragma simd reduction(+:sum_numerator,sum_denominator_square_m,sum_denominator_square_n)  \n \n \n\t\t\t \n \n \n \n \n \n                        for (i=0;i < USER_COUNT; i++) \n                        {   \n\t\t\t       \t \n \n                               \tsum_numerator += (rating_m[block_m*USER_COUNT+i])*(rating_n[block_n*USER_COUNT+i]); \n                                \n \n\t\t\t\t \n                                 \n \n       \t                        sum_denominator_square_m += powf((rating_m[block_m*USER_COUNT+i]),2.0); \n       \t \n \n             \t                sum_denominator_square_n += powf((rating_n[block_n*USER_COUNT+i]),2.0); \n           \n \n\t \n \n\t \n \n \n \n                        } \n \n \n \n \n \n\t \n                         \n \n                        sum_denominator = sqrt (sum_denominator_square_m*sum_denominator_square_n); \n                        if(sum_denominator!=0) \n\t\t\t\tsimilarity = sum_numerator/sum_denominator; \n\t\t\telse \n\t\t\t\tsimilarity = 0; \n \n \n \n \n \n                \n \n        } \n \n\tdouble b = microtime(); \n\tdouble duration = b-a; \n \n\tprintf(\" time consumed: %fs\\n\", duration); \nexit(0); \n} ", "pred": " \nvoid get_pearson_similarity(float* rating_m, float* rating_n, double* average_matrix, k_similarity_struct * k_similarity_matrix, int start_index_m, int start_index_n, int flag){ \n        \n \n\tprintf(\" in pearson_similarity start_index_m=%d, start_index_n=%d\\n\", start_index_m, start_index_n); \n\t \n\tint nPadded = ( USER_COUNT%8 == 0? USER_COUNT : USER_COUNT + (8-USER_COUNT%8) ); \n  \n\tdouble similarity; \n\t \n        int i,j,m,n,s,k; \n \n\tint ua,ub,uc; \n  \n\tfloat sum_numerator=0; \n\tfloat sum_denominator_square_m=0; \n\tfloat sum_denominator_square_n=0; \n\tfloat sum_denominator=0; \n \n \n\tdouble* sum_numerator_matrix =(double*) _mm_malloc(sizeof(double)*USER_COUNT,64); \n\tdouble* sum_denominator_matrix_m =(double*) _mm_malloc(sizeof(double)*USER_COUNT,64); \n\tdouble* sum_denominator_matrix_n =(double*) _mm_malloc(sizeof(double)*USER_COUNT,64); \n \n\tmemset(sum_numerator_matrix,0,sizeof(double)*USER_COUNT);\t \n\tmemset(sum_denominator_matrix_m,0,sizeof(double)*USER_COUNT);\t \n\tmemset(sum_denominator_matrix_n,0,sizeof(double)*USER_COUNT);\t \n \n \n\t \n \n \n \n\t \n\tint numthreads;\t \n        int item_index; \n \n\tint block_m,block_n; \n\t \n\tint end_m=(ITEM_COUNT<(start_index_m+ITEM_BLOCK)? ITEM_COUNT:(start_index_m+ITEM_BLOCK)); \n\tint end_n=(ITEM_COUNT<(start_index_n+ITEM_BLOCK)? ITEM_COUNT:(start_index_n+ITEM_BLOCK):ITEM_COUNT);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "}
{"label": " \nMagickExport Image *IntegralRotateImage(const Image *image,size_t rotations, \n  ExceptionInfo *exception) \n{ \n#define RotateImageTag  \"Rotate/Image\" \n \n  CacheView \n    *image_view, \n    *rotate_view; \n \n  Image \n    *rotate_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  RectangleInfo \n    page; \n \n   \n \n  assert(image!= (Image *) NULL); \n  page=image->page; \n  rotations%=4; \n  if (rotations == 0) \n    return(CloneImage(image,0,0,MagickTrue,exception)); \n  if ((rotations == 1) || (rotations == 3)) \n    rotate_image=CloneImage(image,image->rows,image->columns,MagickTrue, \n      exception); \n  else \n    rotate_image=CloneImage(image,image->columns,image->rows,MagickTrue, \n      exception); \n  if (rotate_image == (Image *) NULL) \n    return((Image *) NULL); \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  rotate_view=AcquireAuthenticCacheView(rotate_image,exception); \n  switch (rotations) \n  { \n    case 1: \n    { \n      size_t \n        tile_height, \n        tile_width; \n \n      ssize_t \n        tile_y; \n \n       \n \n      GetPixelCacheTileSize(image,&tile_width,&tile_height); \n      tile_width=image->columns; \n      #pragma omp parallel for schedule(static,4) shared(status)          magick_threads(image,image,1,1) \n      for (tile_y=0; tile_y < (ssize_t) image->rows; tile_y+=(ssize_t) tile_height) \n      { \n        register ssize_t \n          tile_x; \n \n        if (status == MagickFalse) \n          continue; \n        tile_x=0; \n        for ( ; tile_x < (ssize_t) image->columns; tile_x+=(ssize_t) tile_width) \n        { \n          MagickBooleanType \n            sync; \n \n          register const Quantum \n            *magick_restrict p; \n \n          register Quantum \n            *magick_restrict q; \n \n          register ssize_t \n            y; \n \n          size_t \n            height, \n            width; \n \n          width=tile_width; \n          if ((tile_x+(ssize_t) tile_width) > (ssize_t) image->columns) \n            width=(size_t) (tile_width-(tile_x+tile_width-image->columns)); \n          height=tile_height; \n          if ((tile_y+(ssize_t) tile_height) > (ssize_t) image->rows) \n            height=(size_t) (tile_height-(tile_y+tile_height-image->rows)); \n          p=GetCacheViewVirtualPixels(image_view,tile_x,tile_y,width,height, \n            exception); \n          if (p == (const Quantum *) NULL) \n            { \n              status=MagickFalse; \n              break; \n            } \n          for (y=0; y < (ssize_t) width; y++) \n          { \n            register const Quantum \n              *magick_restrict tile_pixels; \n \n            register ssize_t \n              x; \n \n            if (status == MagickFalse) \n              continue; \n            q=QueueCacheViewAuthenticPixels(rotate_view,(ssize_t) \n              (rotate_image->columns-(tile_y+height)),y+tile_x,height,1, \n              exception); \n            if (q == (Quantum *) NULL) \n              { \n                status=MagickFalse; \n                continue; \n              } \n            tile_pixels=p+((height-1)*width+y)*GetPixelChannels(image); \n            for (x=0; x < (ssize_t) height; x++) \n            { \n              register ssize_t \n                i; \n \n              if (GetPixelWriteMask(image,tile_pixels) == 0) \n                { \n                  tile_pixels-=width*GetPixelChannels(image); \n                  q+=GetPixelChannels(rotate_image); \n                  continue; \n                } \n              for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n              { \n                PixelChannel channel=GetPixelChannelChannel(image,i); \n                PixelTrait traits=GetPixelChannelTraits(image,channel); \n                PixelTrait rotate_traits=GetPixelChannelTraits(rotate_image, ", "pred": " \nMagickExport Image *IntegralRotateImage(const Image *image,size_t rotations, \n  ExceptionInfo *exception) \n{ \n#define RotateImageTag  \"Rotate/Image\" \n \n  CacheView \n    *image_view, \n    *rotate_view; \n \n  Image \n    *rotate_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  RectangleInfo \n    page; \n \n   \n \n  assert(image!= (Image *) NULL); \n  page=image->page; \n  rotations%=4; \n  if (rotations == 0) \n    return(CloneImage(image,0,0,MagickTrue,exception)); \n  if ((rotations == 1) || (rotations == 3)) \n    rotate_image=CloneImage(image,image->rows,image->columns,MagickTrue, \n      exception); \n  else \n    rotate_image=CloneImage(image,image->columns,image->rows,MagickTrue, \n      exception); \n  if (rotate_image == (Image *) NULL) \n    return((Image *) NULL); \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  rotate_view=AcquireAuthenticCacheView(rotate_image,exception); \n  switch (rotations) \n  { \n    case 1: \n    { \n      size_t \n        tile_height, \n        tile_width; \n \n      ssize_t \n        tile_y; \n \n       \n \n      GetPixelCacheTileSize(image,&tile_width,&tile_height); \n      tile_width=image->columns; \n      #pragma omp parallel for schedule(static,4) shared(status)          magick_threads(image,image,1,1) \n      for (tile_y=0;tile_y<tile_height;tile_y++)\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nvoid BLI_covariance_m_vn_ex( \n        const int n, const float *cos_vn, const int nbr_cos_vn, const float *center, const bool use_sample_correction, \n        float *r_covmat) \n{ \n\tint i, j, k; \n \n\t \n \n\tconst float covfac = 1.0f / (float)(use_sample_correction? nbr_cos_vn - 1 : nbr_cos_vn); \n \n\tmemset(r_covmat, 0, sizeof(*r_covmat) * (size_t)(n * n)); \n \n#pragma omp parallel for default(shared) private(i, j, k) schedule(static) if ((nbr_cos_vn * n) >= 10000) \n\tfor (i = 0; i < n; i++) { \n\t\tfor (j = i; j < n; j++) { \n\t\t\tr_covmat[i * n + j] = 0.0f; \n\t\t\tif (center) { \n\t\t\t\tfor (k = 0; k < nbr_cos_vn; k++) { \n\t\t\t\t\tr_covmat[i * n + j] += (cos_vn[k * n + i] - center[i]) * (cos_vn[k * n + j] - center[j]); \n\t\t\t\t} \n\t\t\t} \n\t\t\telse { \n\t\t\t\tfor (k = 0; k < nbr_cos_vn; k++) { \n\t\t\t\t\tr_covmat[i * n + j] += cos_vn[k * n + i] * cos_vn[k * n + j]; \n\t\t\t\t} \n\t\t\t} \n\t\t\tr_covmat[i * n + j] *= covfac; \n\t\t} \n\t} \n\t \n \n\tfor (i = 1; i < n; i++) { \n\t\tfor (j = 0; j < i; j++) { \n\t\t\tr_covmat[i * n + j] = r_covmat[j * n + i]; \n\t\t} \n\t} \n} ", "pred": " \nvoid BLI_covariance_m_vn_ex( \n        const int n, const float *cos_vn, const int nbr_cos_vn, const float *center, const bool use_sample_correction, \n        float *r_covmat) \n{ \n\tint i, j, k; \n \n\t \n \n\tconst float covfac = 1.0f / (float)(use_sample_correction? nbr_cos_vn - 1 : nbr_cos_vn); \n \n\tmemset(r_covmat, 0, sizeof(*r_covmat) * (size_t)(n * n)); \n \n#pragma omp parallel for default(shared) private(i, j, k) schedule(static) if ((nbr_cos_vn * n) >= 10000) \n\tfor (i = 0; i < n; i++) { \n\t\tfor (j = i; j < n; j++) { \n\t\t\tr_covmat[i * n + j] = 0.0f; \n\t\t\tif (center) { \n\t\t\t\tfor (k = 0; k < nbr_cos_vn; k++) { \n\t\t\t\t\tr_covmat[i * n + j] += (cos_vn[k * n + i] - center[i]) * (cos_vn[k * n + j] - center[j]); \n\t\t\t\t} \n\t\t\t} \n\t\t\telse { \n\t\t\t\tfor (k = 0; k < nbr_cos_vn; k++) { \n\t\t\t\t\tr_covmat[i * n + j] += cos_vn[k * n + i] * cos_vn[k * n + j]; \n\t\t\t\t} \n\t\t\t} \n\t\t\tr_covmat[i * n + j] *= covfac; \n\t\t} \n\t} \n\t \n \n\tfor (i = 1; i < n; i++) { \n\t\tfor (j = 0; j < i; j++) { \n\t\t\tr_covmat[i * n + j] = r_covmat[j * n + i]; \n\t\t} \n\t} \n} "}
{"label": " \nvoid InterfaceAssembly(Simulation *simu,  LinearSolver *solver,schnaps_real theta, schnaps_real dt) \n{ \n \n  int fsize =  simu->wsize / simu->macromesh.nbelems; \n \n  for(int ifa = 0; ifa < simu->macromesh.nbfaces; ifa++){ \n    int ieL = simu->macromesh.face2elem[4 * ifa + 0]; \n    int locfaL = simu->macromesh.face2elem[4 * ifa + 1]; \n    int ieR = simu->macromesh.face2elem[4 * ifa + 2]; \n    field *fL = simu->fd + ieL; \n    field *fR = NULL; \n    int offsetR = -1; \n     \n \n    int offsetL = fsize * ieL; \n    if (ieR >= 0) { \n      fR = simu->fd + ieR; \n      offsetR = fsize * ieR; \n    } \n \n   \n    const unsigned int m = fL->model.m; \n \n \n     \n \n#pragma omp parallel for \n    for(int ipgfL = 0; ipgfL < NPGF(fL->deg, fL->raf, locfaL); ipgfL++) { \n \n      schnaps_real xpgref[3], xpgref_in[3], wpg; \n     \n       \n \n       \n \n      int ipgL = ref_pg_face(fL->deg, fL->raf, locfaL, ipgfL, xpgref, &wpg, xpgref_in); \n     \n       \n \n      schnaps_real vnds[3], xpg[3]; \n      { \n\tschnaps_real dtau[3][3], codtau[3][3]; \n\tschnaps_ref2phy(fL->physnode, \n\t\txpgref, \n\t\tNULL, locfaL,  \n \n\t\txpg, dtau, \n\t\tcodtau, NULL, vnds);  \n \n      } \n     \n      if (fR!= NULL) {   \n \n\tschnaps_real xrefL[3]; \n\t{ \n\t  schnaps_real xpg_in[3]; \n\t  schnaps_ref2phy(fL->physnode, \n\t\t  xpgref_in, \n\t\t  NULL, -1,  \n \n\t\t  xpg_in, NULL, \n\t\t  NULL, NULL, NULL);  \n \n\t  PeriodicCorrection(xpg_in,fL->period); \n\t  schnaps_phy2ref(fR->physnode, xpg_in, xrefL); \n\t \n\t} \n       \n\tint ipgR = ref_ipg(fR->deg,fR->raf, xrefL); \n \n \n\tschnaps_real flux[m]; \n\tschnaps_real wL[m]; \n\tschnaps_real wR[m]; \n \n\tfor (int iv1 = 0; iv1 < m; iv1++){ \n \n\t\t\t     \n \n\t  for(int iv = 0; iv < m; iv++) { \n\t    wL[iv] = (iv == iv1); \n\t    wR[iv] = 0; \n\t  } \n\t  int imem1 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgL, iv1) + offsetL; \n \n\t   \n \n \n\t  fL->model.NumFlux(wL, wR, vnds, flux); \n \n\t   \n \n \n\t  for(int iv2 = 0; iv2 < m; iv2++) { \n\t    int imem2 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgL, iv2) + offsetL;\t\t   \n\t    schnaps_real val = theta * dt * flux[iv2] * wpg;\t\t       \n\t    AddLinearSolver(solver, imem2, imem1, val); \n\t\t       \n\t    imem2 = fR->varindex(fR->deg, fR->raf, fR->model.m, ipgR, iv2) + offsetR; \n\t    val = theta * dt * flux[iv2] * wpg;\t\t       \n\t    AddLinearSolver(solver, imem2, imem1, -val); \n\t  } \n\t\t   \n\t  for(int iv = 0; iv < m; iv++) { \n\t    wL[iv] = 0; \n\t    wR[iv] = (iv == iv1); \n\t  } \n\t  imem1 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgR, iv1) + offsetR; \n \n \n\t  fL->model.NumFlux(wL, wR, vnds, flux); \n \n\t  for(int iv2 = 0; iv2 < m; iv2++) { \n\t    int imem2 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgL, iv2) + offsetL; \n\t    schnaps_real val = theta * dt * flux[iv2] * wpg; \n\t    AddLinearSolver(solver, imem2, imem1, val); \n\t\t     \n\t    imem2 = fR->varindex(fR->deg, fR->raf, fR->model.m, ipgR, iv2) + offsetR;\t\t     \n\t    val = theta *dt * flux[iv2] * wpg;\t\t     \n\t    AddLinearSolver(solver, imem2, imem1, -val); \n\t  } \n\t} \n \n      } else {  \n \n \n\t \n \n\tschnaps_real flux0[m], wL[m]; \n\tfor(int iv = 0; iv < m; iv++) { \n\t  wL[iv] = 0; \n\t} \n\tfL->model.BoundaryFlux(xpg, fL->tnow, wL, vnds, flux0); \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n       \n\tfor(int iv1 = 0; iv1 < m; iv1++) { \n\t  int imem1 = fL->varindex(fL->deg, fL->raf,fL->model.m, ipgL, iv1) + offsetL; \n \n\t  for(int iv = 0; iv < m; iv++) { \n\t    wL[iv] = (iv == iv1); \n\t  } \n \n\t  schnaps_real flux[m]; \n\t  fL->model.BoundaryFlux(xpg, fL->tnow, wL, vnds, flux); \n \n\t  for(int iv2 = 0; iv2 < m; iv2++) { \n\t     \n \n\t    int imem2 = fL->varindex(fL->deg, fL", "pred": " \nvoid InterfaceAssembly(Simulation *simu,  LinearSolver *solver,schnaps_real theta, schnaps_real dt) \n{ \n \n  int fsize =  simu->wsize / simu->macromesh.nbelems; \n \n  for(int ifa = 0; ifa < simu->macromesh.nbfaces; ifa++){ \n    int ieL = simu->macromesh.face2elem[4 * ifa + 0]; \n    int locfaL = simu->macromesh.face2elem[4 * ifa + 1]; \n    int ieR = simu->macromesh.face2elem[4 * ifa + 2]; \n    field *fL = simu->fd + ieL; \n    field *fR = NULL; \n    int offsetR = -1; \n     \n \n    int offsetL = fsize * ieL; \n    if (ieR >= 0) { \n      fR = simu->fd + ieR; \n      offsetR = fsize * ieR; \n    } \n \n   \n    const unsigned int m = fL->model.m; \n \n \n     \n \n#pragma omp parallel for \n    for(int ipgfL = 0; ipgfL < NPGF(fL->deg, fL->raf, locfaL); ipgfL++) { \n \n      schnaps_real xpgref[3], xpgref_in[3], wpg; \n     \n       \n \n       \n \n      int ipgL = ref_pg_face(fL->deg, fL->raf, locfaL, ipgfL, xpgref, &wpg, xpgref_in); \n     \n       \n \n      schnaps_real vnds[3], xpg[3]; \n      { \n\tschnaps_real dtau[3][3], codtau[3][3]; \n\tschnaps_ref2phy(fL->physnode, \n\t\txpgref, \n\t\tNULL, locfaL, dtau, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, x"}
{"label": " \nvoid \n_lw6ker_map_state_spread_gradient (lw6sys_context_t * sys_context, \n\t\t\t\t   _lw6ker_map_state_t * map_state, const lw6map_rules_t * rules, int32_t nb_spreads, u_int32_t team_mask) \n{ \n  int i; \n  int teams_concerned[LW6MAP_MAX_NB_TEAMS]; \n  int n = 0; \n \n  _lw6ker_map_state_apply_cursors (sys_context, map_state, rules, team_mask); \n   \n \n  for (i = 0; i < map_state->max_nb_teams; ++i) \n    { \n      if (map_state->teams[i].active) \n\t{ \n\t  if (lw6ker_team_mask_is_concerned (sys_context, i, team_mask)) \n\t    { \n\t      teams_concerned[n] = i; \n\t      n++; \n\t    } \n\t} \n    } \n   \n \n#pragma omp parallel for \n \n  for (i = 0; i < n; ++i) \n    { \n       \n \n      int j; \n \n      for (j = 0; j < nb_spreads; ++j) \n\t{ \n\t  _lw6ker_spread_update_gradient (sys_context, &(map_state->teams[teams_concerned[i]]), map_state->shape.d == 1, rules->spread_mode); \n\t} \n    } \n} ", "pred": " \nvoid \n_lw6ker_map_state_spread_gradient (lw6sys_context_t * sys_context, \n\t\t\t\t   _lw6ker_map_state_t * map_state, const lw6map_rules_t * rules, int32_t nb_spreads, u_int32_t team_mask) \n{ \n  int i; \n  int teams_concerned[LW6MAP_MAX_NB_TEAMS]; \n  int n = 0; \n \n  _lw6ker_map_state_apply_cursors (sys_context, map_state, rules, team_mask); \n   \n \n  for (i = 0; i < map_state->max_nb_teams; ++i) \n    { \n      if (map_state->teams[i].active) \n\t{ \n\t  if (lw6ker_team_mask_is_concerned (sys_context, i, team_mask)) \n\t    { \n\t      teams_concerned[n] = i; \n\t      n++; \n\t    } \n\t} \n    } \n   \n \n#pragma omp parallel for \n \n  for (i = 0; i < n; ++i) \n    { \n       \n \n      int j; \n \n      for (j = 0; j < nb_spreads; ++j) \n\t{ \n\t  _lw6ker_spread_update_gradient (sys_context, &(map_state->teams[teams_concerned[i]]), map_state->shape.d == 1, rules->spread_mode); \n\t} \n    } \n} "}
{"label": " \nvoid InterfaceCoupling(Simulation *simu,  LinearSolver *solver, int itest) \n{ \n \n  int fsize =  simu->wsize / simu->macromesh.nbelems; \n \n  for(int ifa = 0; ifa < simu->macromesh.nbfaces; ifa++){ \n    int ieL = simu->macromesh.face2elem[4 * ifa + 0]; \n    int locfaL = simu->macromesh.face2elem[4 * ifa + 1]; \n    int ieR = simu->macromesh.face2elem[4 * ifa + 2]; \n    field *fL = simu->fd + ieL; \n    field *fR = NULL; \n    int offsetR = -1; \n     \n \n    int offsetL = fsize * ieL; \n    if (ieR >= 0) { \n      fR = simu->fd + ieR; \n      offsetR = fsize * ieR; \n    } \n \n   \n    const unsigned int m = fL->model.m; \n \n \n     \n \n#pragma omp parallel for \n    for(int ipgfL = 0; ipgfL < NPGF(fL->deg, fL->raf, locfaL); ipgfL++) { \n \n      schnaps_real xpgref[3], xpgref_in[3], wpg; \n     \n       \n \n       \n \n      int ipgL = ref_pg_face(fL->deg, fL->raf, locfaL, ipgfL, xpgref, &wpg, xpgref_in); \n     \n       \n \n      schnaps_real vnds[3], xpg[3]; \n      { \n\tschnaps_real dtau[3][3], codtau[3][3]; \n\tschnaps_ref2phy(fL->physnode, \n\t\txpgref, \n\t\tNULL, locfaL,  \n \n\t\txpg, dtau, \n\t\tcodtau, NULL, vnds);  \n \n      } \n     \n      if (fR!= NULL) {   \n \n\tschnaps_real xrefL[3]; \n\t{ \n\t  schnaps_real xpg_in[3]; \n\t  schnaps_ref2phy(fL->physnode, \n\t\t  xpgref_in, \n\t\t  NULL, -1,  \n \n\t\t  xpg_in, NULL, \n\t\t  NULL, NULL, NULL);  \n \n\t  PeriodicCorrection(xpg_in,fL->period); \n\t  schnaps_phy2ref(fR->physnode, xpg_in, xrefL); \n\t \n\t} \n       \n\tint ipgR = ref_ipg(fR->deg,fR->raf, xrefL); \n \n \n \n\tfor (int iv1 = 0; iv1 < m; iv1++){ \n \n\t\t\t     \n\t  int imem1 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgL, iv1) + offsetL; \n \n\t  for(int iv2 = 0; iv2 < m; iv2++) { \n\t    int imem2 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgL, iv2) + offsetL;\t\t   \n\t    IsNonZero(solver, imem2, imem1); \n\t\t       \n\t    imem2 = fR->varindex(fR->deg, fR->raf, fR->model.m, ipgR, iv2) + offsetR; \n\t    IsNonZero(solver, imem2, imem1); \n\t  } \n\t\t   \n\t  imem1 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgR, iv1) + offsetR; \n \n \n\t  for(int iv2 = 0; iv2 < m; iv2++) { \n\t    int imem2 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgL, iv2) + offsetL; \n\t    IsNonZero(solver, imem2, imem1); \n\t\t     \n\t    imem2 = fR->varindex(fR->deg, fR->raf, fR->model.m, ipgR, iv2) + offsetR;\t\t     \n\t    IsNonZero(solver, imem2, imem1); \n\t  } \n\t} \n \n      } else {  \n \n \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n       \n\tfor(int iv1 = 0; iv1 < m; iv1++) { \n\t  int imem1 = fL->varindex(fL->deg, fL->raf,fL->model.m, ipgL, iv1) + offsetL; \n \n\t  for(int iv2 = 0; iv2 < m; iv2++) { \n\t    int imem2 = fL->varindex(fL->deg, fL->raf,fL->model.m, ipgL, iv2) + offsetL; \n\t    IsNonZero(solver, imem2, imem1); \n\t  } \n\t}  \n \n \n      }  \n \n \n   \n    }  \n \n \n  }  \n \n \n} ", "pred": " \nvoid InterfaceCoupling(Simulation *simu,  LinearSolver *solver, int itest) \n{ \n \n  int fsize =  simu->wsize / simu->macromesh.nbelems; \n \n  for(int ifa = 0; ifa < simu->macromesh.nbfaces; ifa++){ \n    int ieL = simu->macromesh.face2elem[4 * ifa + 0]; \n    int locfaL = simu->macromesh.face2elem[4 * ifa + 1]; \n    int ieR = simu->macromesh.face2elem[4 * ifa + 2]; \n    field *fL = simu->fd + ieL; \n    field *fR = NULL; \n    int offsetR = -1; \n     \n \n    int offsetL = fsize * ieL; \n    if (ieR >= 0) { \n      fR = simu->fd + ieR; \n      offsetR = fsize * ieR; \n    } \n \n   \n    const unsigned int m = fL->model.m; \n \n \n     \n \n#pragma omp parallel for \n    for(int ipgfL = 0; ipgfL < NPGF(fL->deg, fL->raf, locfaL); ipgfL++) { \n \n      schnaps_real xpgref[3], xpgref_in[3], wpg; \n     \n       \n \n       \n \n      int ipgL = ref_pg_face(fL->deg, fL->raf, locfaL, ipgfL, xpgref, &wpg, xpgref_in); \n     \n       \n \n      schnaps_real vnds[3], xpg[3]; \n      { \n\tschnaps_real dtau[3][3], codtau[3][3]; \n\tschnaps_ref2phy(fL->physnode, \n\t\txpgref, \n\t\tNULL, locfaL,  \n \n\t\t(fL->alt_l, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg, xpg"}
{"label": " \ndouble processSmithWatermanCPU(char *refFile, char *qryFile, uint32_t numThreads, uint32_t numBuffers) \n{ \n\ttest_t\t\ttestData; \n\tdouble\t\tts, ts1; \n\tuint32_t \t**matrix; \n\tchar \t \t*query = NULL, *candidate = NULL, *reference = NULL; \n\tuint32_t \tsizeRef, error, tID; \n\tuint32_t \taverageQuerySize, averageCandidatesPerQuery; \n \n\tloadTestData(qryFile, &testData, &averageQuerySize, &averageCandidatesPerQuery); \n\tloadReference(refFile, &reference, &sizeRef);\t \n \n\tmatrix = (uint32_t **) malloc(numThreads * sizeof(uint32_t *)); \n\tfor(tID = 0; tID < numThreads; tID++){ \n\t\tmatrix[tID] = (uint32_t *) malloc((averageQuerySize * 2) * (averageQuerySize * 4) * sizeof(uint32_t)); \n\t\tif (matrix[tID] == NULL) {fprintf(stderr, \"Error allocating SW matrix \\n\"); exit(EXIT_FAILURE);} \n\t} \n \n\tts = sampleTime(); \n \n #pragma omp parallel num_threads(numThreads) \n\t{ \n\t\tuint32_t threadID = omp_get_thread_num(); \n\t\tuint32_t idQuery, idCandidate, sizeQuery, sizeCandidate, positionCandidate; \n\t\tchar \t *query = NULL, *candidate = NULL; \n \n  #pragma omp for schedule(static)  \n\t\tfor (idCandidate = 0; idCandidate < testData.numCandidates; idCandidate++){ \n \n\t\t\tidQuery \t\t\t= testData.candidates[idCandidate].query; \n\t\t\tquery\t\t\t\t= testData.raw_queries + testData.pos_raw_queries[idQuery]; \n\t\t\tcandidate\t\t\t= reference + testData.candidates[idCandidate].position; \n\t\t\tsizeQuery \t\t\t= testData.qinfo[idQuery].size; \n\t\t\tsizeCandidate \t\t= testData.candidates[idCandidate].size; \n\t\t\tpositionCandidate \t= testData.candidates[idCandidate].position; \n \n\t\t\tcomputeSW(query, candidate, idCandidate, sizeQuery, sizeCandidate, sizeRef, positionCandidate, matrix[threadID], testData.results); \n\t\t} \n\t} \n \n\tts1 = sampleTime(); \n \n\terror = saveResults(qryFile, &testData, numBuffers); \n\tif(error!= 0) {fprintf(stderr, \"Error %d, saving results \\n\", error); exit(EXIT_FAILURE);} \n \n\tfreeTestData(&testData, numBuffers); \n\treturn(ts1-ts); \n} ", "pred": " \ndouble processSmithWatermanCPU(char *refFile, char *qryFile, uint32_t numThreads, uint32_t numBuffers) \n{ \n\ttest_t\t\ttestData; \n\tdouble\t\tts, ts1; \n\tuint32_t \t**matrix; \n\tchar \t \t*query = NULL, *candidate = NULL, *reference = NULL; \n\tuint32_t \tsizeRef, error, tID; \n\tuint32_t \taverageQuerySize, averageCandidatesPerQuery; \n \n\tloadTestData(qryFile, &testData, &averageQuerySize, &averageCandidatesPerQuery); \n\tloadReference(refFile, &reference, &sizeRef);\t \n \n\tmatrix = (uint32_t **) malloc(numThreads * sizeof(uint32_t *)); \n\tfor(tID = 0; tID < numThreads; tID++){ \n\t\tmatrix[tID] = (uint32_t *) malloc((averageQuerySize * 2) * (averageQuerySize * 4) * sizeof(uint32_t)); \n\t\tif (matrix[tID] == NULL) {fprintf(stderr, \"Error allocating SW matrix \\n\"); exit(EXIT_FAILURE);} \n\t} \n \n\tts = sampleTime(); \n \n #pragma omp parallel num_threads(numThreads) \n\t{ \n\t\tuint32_t threadID = omp_get_thread_num(); \n\t\tuint32_t idQuery, idCandidate, sizeQuery, sizeCandidate, positionCandidate; \n\t\tchar \t *query = NULL, *candidate = NULL; \n \n  #pragma omp for schedule(static)  \n\t\tfor (idCandidate = 0; idCandidate < testData.numCandidates; idCandidate++){ \n \n\t\t\tidQuery \t\t\t= testData.candidates[idCandidate].query; \n\t\t\tquery\t\t\t\t= testData.raw_queries + testData.pos_raw_queries[idQuery]; \n\t\t\tcandidate\t\t\t= reference + testData.candidates[idCandidate].position; \n\t\t\tsizeQuery \t\t\t= testData.qinfo[idQuery].size; \n\t\t\tsizeCandidate \t\t= testData.candidates[idCandidate].size; \n\t\t\tpositionCandidate    = testData.qinfo[idCandidate].position;                                                                                                                                                         "}
{"label": " \nstatic MagickBooleanType YShearImage(Image *image,const double degrees, \n  const size_t width,const size_t height,const ssize_t x_offset, \n  const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define YShearImageTag  \"YShear/Image\" \n \n  typedef enum \n  { \n    UP, \n    DOWN \n  } ShearDirection; \n \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PixelInfo \n    background; \n \n  ssize_t \n    x; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickCoreSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  status=MagickTrue; \n  progress=0; \n  background=image->background_color; \n  image_view=AcquireAuthenticCacheView(image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,image,width,1) \n  for (x=0; x < (ssize_t) width; x++) \n  { \n    ssize_t \n      step; \n \n    double \n      area, \n      displacement; \n \n    PixelInfo \n      pixel, \n      source, \n      destination; \n \n    register Quantum \n      *magick_restrict p, \n      *magick_restrict q; \n \n    register ssize_t \n      i; \n \n    ShearDirection \n      direction; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewAuthenticPixels(image_view,x_offset+x,0,1,image->rows, \n      exception); \n    if (p == (Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    p+=y_offset*GetPixelChannels(image); \n    displacement=degrees*(double) (x-width/2.0); \n    if (displacement == 0.0) \n      continue; \n    if (displacement > 0.0) \n      direction=DOWN; \n    else \n      { \n        displacement*=(-1.0); \n        direction=UP; \n      } \n    step=(ssize_t) floor((double) displacement); \n    area=(double) (displacement-step); \n    step++; \n    pixel=background; \n    GetPixelInfo(image,&source); \n    GetPixelInfo(image,&destination); \n    switch (direction) \n    { \n      case UP: \n      { \n         \n \n        if (step > y_offset) \n          break; \n        q=p-step*GetPixelChannels(image); \n        for (i=0; i < (ssize_t) height; i++) \n        { \n          if ((y_offset+i) < step) \n            { \n              p+=GetPixelChannels(image); \n              GetPixelInfoPixel(image,p,&pixel); \n              q+=GetPixelChannels(image); \n              continue; \n            } \n          GetPixelInfoPixel(image,p,&source); \n          CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n            &source,(double) GetPixelAlpha(image,p),area, \n            &destination); \n          SetPixelViaPixelInfo(image,&destination,q); \n          GetPixelInfoPixel(image,p,&pixel); \n          p+=GetPixelChannels(image); \n          q+=GetPixelChannels(image); \n        } \n        CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n          &background,(double) background.alpha,area,&destination); \n        SetPixelViaPixelInfo(image,&destination,q); \n        q+=GetPixelChannels(image); \n        for (i=0; i < (step-1); i++) \n        { \n          SetPixelViaPixelInfo(image,&background,q); \n          q+=GetPixelChannels(image); \n        } \n        break; \n      } \n      case DOWN: \n      { \n         \n \n        p+=height*GetPixelChannels(image); \n        q=p+step*GetPixelChannels(image); \n        for (i=0; i < (ssize_t) height; i++) \n        { \n          p-=GetPixelChannels(image); \n          q-=GetPixelChannels(image); \n          if ((size_t) (y_offset+height+step-i) > image->rows) \n            continue; \n          GetPixelInfoPixel(image,p,&source); \n          CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n            &source,(double) GetPixelAlpha(image,p),area, \n            &destination); \n          SetPixelViaPixelInfo(image,&destination,q); \n          GetPixelInfoPixel(image,p,&pixel); \n        } \n        CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n          &background,(double) background.alpha,area,&destination); \n        q-=GetPixelChannels(image); \n        SetPixelViaPixelInfo(image,&destination,q); \n        for (i=0; i < (step-1); i++) \n        { \n  ", "pred": " \nstatic MagickBooleanType YShearImage(Image *image,const double degrees, \n  const size_t width,const size_t height,const ssize_t x_offset, \n  const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define YShearImageTag  \"YShear/Image\" \n \n  typedef enum \n  { \n    UP, \n    DOWN \n  } ShearDirection; \n \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PixelInfo \n    background; \n \n  ssize_t \n    x; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickCoreSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  status=MagickTrue; \n  progress=0; \n  background=image->background_color; \n  image_view=AcquireAuthenticCacheView(image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,image,width,1) \n  for (x=0; x < (ssize_t) width; x++) \n  { \n    ssize_t \n      step; \n \n    double \n      area, \n      displacement; \n \n    PixelInfo \n      pixel, \n      source, \n      destination; \n \n    register Quantum \n      *magick_restrict p, \n      *magick_restrict q; \n \n    register ssize_t \n      i; \n \n    ShearDirection \n      direction; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewAuthenticPixels(image_view,x_offset+x,0,y_offset+y,image->width,image->height,image->format,image->width,image->height,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->format,image->"}
{"label": " \nstatic MagickBooleanType CompositeOverImage(Image *image, \n  const Image *composite_image,const MagickBooleanType clip_to_self, \n  const ssize_t x_offset,const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define CompositeImageTag  \"Composite/Image\" \n \n  CacheView \n    *composite_view, \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n   \n \n  status=MagickTrue; \n  progress=0; \n  composite_view=AcquireVirtualCacheView(composite_image,exception); \n  image_view=AcquireAuthenticCacheView(image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      dynamic_number_threads(image,image->columns,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    const Quantum \n      *pixels; \n \n    register const Quantum \n      *restrict p; \n \n    register Quantum \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    size_t \n      channels; \n \n    if (status == MagickFalse) \n      continue; \n    if (clip_to_self!= MagickFalse) \n      { \n        if (y < y_offset) \n          continue; \n        if ((y-y_offset) >= (ssize_t) composite_image->rows) \n          continue; \n      } \n     \n \n    pixels=(Quantum *) NULL; \n    p=(Quantum *) NULL; \n    if ((y >= y_offset) && ((y-y_offset) < (ssize_t) composite_image->rows)) \n      { \n        p=GetCacheViewVirtualPixels(composite_view,0,y-y_offset, \n          composite_image->columns,1,exception); \n        if (p == (const Quantum *) NULL) \n          { \n            status=MagickFalse; \n            continue; \n          } \n        pixels=p; \n        if (x_offset < 0) \n          p-=x_offset*GetPixelChannels(composite_image); \n      } \n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception); \n    if (q == (Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      MagickRealType \n        alpha, \n        Da, \n        Dc, \n        gamma, \n        Sa, \n        Sc; \n \n      register ssize_t \n        i; \n \n      if (clip_to_self!= MagickFalse) \n        { \n          if (x < x_offset) \n            { \n              q+=GetPixelChannels(image); \n              continue; \n            } \n          if ((x-x_offset) >= (ssize_t) composite_image->columns) \n            break; \n        } \n      if ((pixels == (Quantum *) NULL) || (x < x_offset) || \n          ((x-x_offset) >= (ssize_t) composite_image->columns)) \n        { \n          Quantum \n            source[MaxPixelChannels]; \n \n           \n \n          if (GetPixelMask(image,q)!= 0) \n            { \n              q+=GetPixelChannels(image); \n              continue; \n            } \n          (void) GetOneVirtualPixel(composite_image,x-x_offset,y-y_offset, \n            source,exception); \n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n          { \n            PixelChannel \n              channel; \n \n            PixelTrait \n              composite_traits, \n              traits; \n \n            channel=GetPixelChannelChannel(image,i); \n            traits=GetPixelChannelTraits(image,channel); \n            composite_traits=GetPixelChannelTraits(composite_image,channel); \n            if ((traits == UndefinedPixelTrait) || \n                (composite_traits == UndefinedPixelTrait)) \n              continue; \n            q[i]=source[channel]; \n          } \n          q+=GetPixelChannels(image); \n          continue; \n        } \n       \n \n      if (GetPixelMask(composite_image,p)!= 0) \n        { \n          p+=GetPixelChannels(composite_image); \n          channels=GetPixelChannels(composite_image); \n          if (p >= (pixels+channels*composite_image->columns)) \n            p=pixels; \n          q+=GetPixelChannels(image); \n          continue; \n        } \n      Sa=QuantumScale*GetPixelAlpha(composite_image,p);", "pred": " \nstatic MagickBooleanType CompositeOverImage(Image *image, \n  const Image *composite_image,const MagickBooleanType clip_to_self, \n  const ssize_t x_offset,const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define CompositeImageTag  \"Composite/Image\" \n \n  CacheView \n    *composite_view, \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n   \n \n  status=MagickTrue; \n  progress=0; \n  composite_view=AcquireVirtualCacheView(composite_image,exception); \n  image_view=AcquireAuthenticCacheView(image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      dynamic_number_threads(image,image->columns,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    const Quantum \n      *pixels; \n \n    register const Quantum \n      *restrict p; \n \n    register Quantum \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    size_t \n      channels; \n \n    if (status == MagickFalse) \n      continue; \n    if (clip_to_self!= MagickFalse) \n      { \n        if (y < y_offset) \n          continue; \n        if ((y-y_offset) >= (ssize_t) composite_image->rows) \n          continue; \n      } \n     \n \n    pixels=(Quantum *) NULL; \n    p=(Quantum *) NULL; \n    if ((y >= y_offset) && ((y-y_offset) < (ssize_t) composite_image->rows)) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nstatic void _combine_masks_exclusion(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                     const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      const float pos = both_positive(dest[index], mask); \n      const float neg = (1.0f - pos); \n      const float b1 = dest[index]; \n      dest[index] = pos * MAX((1.0f - b1) * mask, b1 * (1.0f - mask)) + neg * MAX(b1, mask); \n    } \n  } \n  else \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      const float pos = both_positive(dest[index], mask); \n      const float neg = (1.0f - pos); \n      const float b1 = dest[index]; \n      dest[index] = pos * MAX((1.0f - b1) * mask, b1 * (1.0f - mask)) + neg * MAX(b1, mask); \n    } \n  } \n} ", "pred": " \nstatic void _combine_masks_exclusion(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                     const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      const float pos = both_positive(dest[index], mask); \n      const float neg = (1.0f - pos); \n      const float b1 = dest[index]; \n      dest[index] = pos * MAX((1.0f - b1) * mask, b1 * (1.0f - mask)) + neg * MAX(b1, mask); \n    } \n  } \n  else \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      const float pos = both_positive(dest[index], mask); \n      const float neg = (1.0f - pos); \n      const float b1 = dest[index]; \n      dest[index] = pos * MAX((1.0f - b1) * mask, b1 * (1.0f - mask)) + neg * MAX(b1, mask); \n    } \n  } \n} "}
{"label": " \nvoid mul_add_mul(spinor * const R,spinor * const S,spinor * const U,const _Complex double c1,const _Complex double c2, const int N) \n{ \n\tspinorfield_linalg_wrr(R, S, U); \n#pragma omp parallel \n  { \n \n  spinor *r, *s, *u; \n   \n#pragma omp for \n  for (int ix = 0; ix < N; ++ix) \n  { \n    r=(spinor *) R + ix; \n    s=(spinor *) S + ix; \n    u=(spinor *) U + ix; \n     \n    r->s0.c0 = c1 * s->s0.c0 + c2 * u->s0.c0; \n    r->s0.c1 = c1 * s->s0.c1 + c2 * u->s0.c1; \n    r->s0.c2 = c1 * s->s0.c2 + c2 * u->s0.c2; \n \n    r->s1.c0 = c1 * s->s1.c0 + c2 * u->s1.c0; \n    r->s1.c1 = c1 * s->s1.c1 + c2 * u->s1.c1; \n    r->s1.c2 = c1 * s->s1.c2 + c2 * u->s1.c2; \n     \n    r->s2.c0 = c1 * s->s2.c0 + c2 * u->s2.c0; \n    r->s2.c1 = c1 * s->s2.c1 + c2 * u->s2.c1; \n    r->s2.c2 = c1 * s->s2.c2 + c2 * u->s2.c2; \n     \n    r->s3.c0 = c1 * s->s3.c0 + c2 * u->s3.c0; \n    r->s3.c1 = c1 * s->s3.c1 + c2 * u->s3.c1; \n    r->s3.c2 = c1 * s->s3.c2 + c2 * u->s3.c2; \n  } \n  }  \n \n} ", "pred": " \nvoid mul_add_mul(spinor * const R,spinor * const S,spinor * const U,const _Complex double c1,const _Complex double c2, const int N) \n{ \n\tspinorfield_linalg_wrr(R, S, U); \n#pragma omp parallel \n  { \n \n  spinor *r, *s, *u; \n   \n#pragma omp for \n  for (int ix = 0; ix < N; ++ix) \n  { \n    r=(spinor *) R + ix; \n    s=(spinor *) S + ix; \n    u=(spinor *) U + ix; \n     \n    r->s0.c0 = c1 * s->s0.c0 + c2 * u->s0.c0; \n    r->s0.c1 = c1 * s->s0.c1 + c2 * u->s0.c1; \n    r->s0.c2 = c1 * s->s0.c2 + c2 * u->s0.c2; \n \n    r->s1.c0 = c1 * s->s1.c0 + c2 * u->s1.c0; \n    r->s1.c1 = c1 * s->s1.c1 + c2 * u->s1.c1; \n    r->s1.c2 = c1 * s->s1.c2 + c2 * u->s1.c2; \n     \n    r->s2.c0 = c1 * s->s2.c0 + c2 * u->s2.c0; \n    r->s2.c1 = c1 * s->s2.c1 + c2 * u->s2.c1; \n    r->s2.c2 = c1 * s->s2.c2 + c2 * u->s2.c2; \n     \n    r->s3.c0 = c1 * s->s3.c0 + c2 * u->s3.c0; \n    r->s3.c1 = c1 * s->s3.c1 + c2 * u->s3.c1; \n    r->s3.c2 = c1 * s->s3.c2 + c2 * u->s3.c2;               "}
{"label": " \nstatic void _combine_masks_union(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                 const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      dest[index] = MAX(dest[index], mask); \n    } \n  } \n  else \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      dest[index] = MAX(dest[index], mask); \n    } \n  } \n} ", "pred": " \nstatic void _combine_masks_union(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                 const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      dest[index] = MAX(dest[index], mask); \n    } \n  } \n  else \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      dest[index] = MAX(dest[index], mask); \n    } \n  } \n} "}
{"label": " \nMagickExport MagickBooleanType CompositeImage(Image *image, \n  const Image *composite,const CompositeOperator compose, \n  const MagickBooleanType clip_to_self,const ssize_t x_offset, \n  const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define CompositeImageTag  \"Composite/Image\" \n \n  CacheView \n    *composite_view, \n    *image_view; \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *composite_image, \n    *destination_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickRealType \n    amount, \n    destination_dissolve, \n    midpoint, \n    percent_luma, \n    percent_chroma, \n    source_dissolve, \n    threshold; \n \n  MagickStatusType \n    flags; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(composite!= (Image *) NULL); \n  assert(composite->signature == MagickSignature); \n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse) \n    return(MagickFalse); \n  composite_image=CloneImage(composite,0,0,MagickTrue,exception); \n  if (composite_image == (const Image *) NULL) \n    return(MagickFalse); \n  if (IsGrayColorspace(image->colorspace)!= MagickFalse) \n    (void) SetImageColorspace(image,RGBColorspace,exception); \n  (void) SetImageColorspace(composite_image,image->colorspace,exception); \n  if ((compose == OverCompositeOp) || (compose == SrcOverCompositeOp)) \n    { \n      status=CompositeOverImage(image,composite_image,clip_to_self,x_offset, \n        y_offset,exception); \n      composite_image=DestroyImage(composite_image); \n      return(status); \n    } \n  destination_image=(Image *) NULL; \n  amount=0.5; \n  destination_dissolve=1.0; \n  percent_luma=100.0; \n  percent_chroma=100.0; \n  source_dissolve=1.0; \n  threshold=0.05f; \n  switch (compose) \n  { \n    case CopyCompositeOp: \n    { \n      if ((x_offset < 0) || (y_offset < 0)) \n        break; \n      if ((x_offset+(ssize_t) composite_image->columns) >= (ssize_t) image->columns) \n        break; \n      if ((y_offset+(ssize_t) composite_image->rows) >= (ssize_t) image->rows) \n        break; \n      status=MagickTrue; \n      composite_view=AcquireVirtualCacheView(composite_image,exception); \n      image_view=AcquireAuthenticCacheView(image,exception); \n      #pragma omp parallel for schedule(static,4) shared(status)          dynamic_number_threads(image,image->columns,image->rows,1) \n      for (y=0; y < (ssize_t) composite_image->rows; y++) \n      { \n        MagickBooleanType \n          sync; \n \n        register const Quantum \n          *p; \n \n        register Quantum \n          *q; \n \n        register ssize_t \n          x; \n \n        if (status == MagickFalse) \n          continue; \n        p=GetCacheViewVirtualPixels(composite_view,0,y,composite_image->columns, \n          1,exception); \n        q=GetCacheViewAuthenticPixels(image_view,x_offset,y+y_offset, \n          composite_image->columns,1,exception); \n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL)) \n          { \n            status=MagickFalse; \n            continue; \n          } \n        for (x=0; x < (ssize_t) composite_image->columns; x++) \n        { \n          register ssize_t \n            i; \n \n          if (GetPixelMask(composite_image,p)!= 0) \n            { \n              p+=GetPixelChannels(composite_image); \n              q+=GetPixelChannels(image); \n              continue; \n            } \n          for (i=0; i < (ssize_t) GetPixelChannels(composite_image); i++) \n          { \n            PixelChannel \n              channel; \n \n            PixelTrait \n              composite_traits, \n              traits; \n \n            channel=GetPixelChannelChannel(composite_image,i); \n            composite_traits=GetPixelChannelTraits(composite_image,channel); \n            traits=GetPixelChannelTraits(image,channel); \n            if ((traits == UndefinedPixelTrait) || \n                (composite_traits == UndefinedPixelTrait)) \n              continue; \n            SetPixelChannel(image,channel,p[i],q); \n          } \n          p+=GetPixelChannels(composite_image); \n          q+=GetPixelChannels(image); \n        } \n        sync=SyncCacheViewAuthenticPixels(image_view,exception); \n        if (", "pred": " \nMagickExport MagickBooleanType CompositeImage(Image *image, \n  const Image *composite,const CompositeOperator compose, \n  const MagickBooleanType clip_to_self,const ssize_t x_offset, \n  const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define CompositeImageTag  \"Composite/Image\" \n \n  CacheView \n    *composite_view, \n    *image_view; \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *composite_image, \n    *destination_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickRealType \n    amount, \n    destination_dissolve, \n    midpoint, \n    percent_luma, \n    percent_chroma, \n    source_dissolve, \n    threshold; \n \n  MagickStatusType \n    flags; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(composite!= (Image *) NULL); \n  assert(composite->signature == MagickSignature); \n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse) \n    return(MagickFalse); \n  composite_image=CloneImage(composite,0,0,MagickTrue,exception); \n  if (composite_image == (const Image *) NULL) \n    return(MagickFalse); \n  if (IsGrayColorspace(image->colorspace)!= MagickFalse) \n    (void) SetImageColorspace(image,RGBColorspace,exception); \n  (void) SetImageColorspace(composite_image,image->colorspace,exception); \n  if ((compose == OverCompositeOp) || (compose == SrcOverCompositeOp))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         "}
{"label": " \nint main (int argc, char* argv[])  \n{ \n     \n \n    char* corUnit; \n    char* unit; \n    int  zoSize, dataSize, tNumRed, velSize; \n    float *zo, *zoSq, *semb, *velModel, *data; \n    int *count; \n    int is, ir, ip, it, forDataInd, vxInd; \n    float shotPos, curOffset, halfOffset, fabsOffset, offsetSq, curPos, l0, forA; \n    float t0, vel, a, t, forLim, limitLeft, limitRight, bef, aft, sample, curSemb; \n    float sampleSq, sqSample; \n    int vtInd, vInd, tInd, dataInd, indZO, vwhalf, ts, totalCount, ind, ic, iw, offset; \n     \n \n \n \n    sf_init (argc,argv); \n \n \n \n    dataFile = sf_input (\"in\"); \n     \n \n    outFile  = sf_output(\"out\"); \n     \n \n \n    if ( NULL!= sf_getstring(\"aux\") ) { \n\t \n  \n\tauxFile  = sf_output (\"aux\"); \n    } else { \n\tsf_error (\"Need output: partial zero-offset sections\"); \n    } \n \n    if ( NULL!= sf_getstring (\"vel\") ) { \n\t \n  \n\tvelFile  = sf_input (\"vel\"); \n    } else { sf_error (\"Need input: velocity model\"); } \n \n     \n \n \n    if (!sf_histint   (dataFile, \"n1\", &tNum_)   ) sf_error (\"Need n1= in input\"); \n    if (!sf_histfloat (dataFile, \"d1\", &tStep_)  ) sf_error (\"Need d1= in input\"); \n    if (!sf_histfloat (dataFile, \"o1\", &tStart_) ) sf_error (\"Need o1= in input\"); \n \n    if (!sf_histint   (dataFile, \"n2\", &recNum_)   ) sf_error (\"Need n2= in input\"); \n    if (!sf_histfloat (dataFile, \"d2\", &recStep_)  ) sf_error (\"Need d2= in input\"); \n    if (!sf_histfloat (dataFile, \"o2\", &recStart_) ) sf_error (\"Need o2= in input\"); \n     \n    if (!sf_histint   (dataFile, \"n3\", &shotNum_)   ) sf_error (\"Need n3= in input\"); \n    if (!sf_histfloat (dataFile, \"d3\", &shotStep_)  ) sf_error (\"Need d3= in input\"); \n    if (!sf_histfloat (dataFile, \"o3\", &shotStart_) ) sf_error (\"Need o3= in input\"); \n \n     \n \n \n    if (!sf_histint   (velFile, \"n1\", &vtNum_)   ) sf_error (\"Need n1= in input\"); \n    if (!sf_histfloat (velFile, \"d1\", &vtStep_)  ) sf_error (\"Need d1= in input\"); \n    if (!sf_histfloat (velFile, \"o1\", &vtStart_) ) sf_error (\"Need o1= in input\"); \n \n    if (!sf_histint   (velFile, \"n2\", &vxNum_)   ) sf_error (\"Need n2= in input\"); \n    if (!sf_histfloat (velFile, \"d2\", &vxStep_)  ) sf_error (\"Need d2= in input\"); \n    if (!sf_histfloat (velFile, \"o2\", &vxStart_) ) sf_error (\"Need o2= in input\"); \n \n \n \n \n \n \n \n \n\t \n     \n \n     \n \n \n \n \n \n     \n \n    corUnit = (char*) \"m\"; unit = sf_histstring (dataFile, \"unit2\"); if (!unit) sf_error (\"unit2 in data file is not defined\"); \n    if ( strcmp (corUnit, unit) ) { recStep_ *= 1000; recStart_ *= 1000; } \n     \n \n    corUnit = (char*) \"m\"; unit = sf_histstring (dataFile, \"unit3\"); if (!unit) sf_error (\"unit3 in data file is not defined\"); \n    if ( strcmp (corUnit, unit) ) { shotStep_ *= 1000; shotStart_ *= 1000; } \n \n     \n \n     \n \n \n \n \n    if (!sf_getfloat (\"po\",    &pStart_) ) pStart_ = shotStart_; \n     \n \n    if (!sf_getint (\"pn\", &pNum_) ) pNum_ = recNum_; \n     \n \n    if (!pNum_) {sf_warning (\"vn value is changed to 1\"); pNum_ = recNum_;} \n    if (!sf_getfloat (\"pd\",    &pStep_) ) pStep_ = recStep_; \n     \n \n    if (!pStep_) {sf_warning (\"pd value is changed to 50\"); pStep_ = recStep_;} \n \n    if (!sf_getint (\"wh\",   &wh_) )   wh_ = 11; \n     \n \n    if (!wh_) {sf_warning (\"vertical window size is changed to 1\"); wh_ = 1;} \n \n    sf_putint    (outFile, \"n1\", tNum_); \n    sf_putint    (outFile, \"n2\", pNum_); \n    sf_putint    (outFile, \"n3\", 1); \n    sf_putfloat  (outFile, \"d1\", tStep_);  \n    sf_putfloat  (outFile, \"d2\", pStep_); \n    sf_putint    (outFile, \"d3\", 10); \n    sf_putfloat  (outFile, \"o1\", tStart_);  \n    sf_putfloat  (outFile, \"o2\", pStart_); \n    sf_putfloat  (outFile, \"o3\", 0); \n    sf_putstring (outFile, \"label1\", \"time\"); \n    sf_putstring (outFile, \"label2\", \"inline\");  \n    sf_putstring (outFile, \"unit2\",  \"m\");  \n \n    sf_putint    (auxFile, \"n1\", tNum_); \n    sf_putint    (auxFile, \"n2\", pNum_); \n    sf_putint    (auxFile, \"n3\", 1); \n    sf_putfloat  (auxFile, \"d1\", tStep_);  \n    sf_putfloat  (auxFile, \"d2\", pStep_); \n    sf_putint    (auxFile, \"d3\", 10); \n    sf_putfloat  (auxFile, \"o1\", tStart_);  \n    sf_putfloat  (auxFile, \"o2\", pStart_); ", "pred": " \nint main (int argc, char* argv[])  \n{ \n     \n \n    char* corUnit; \n    char* unit; \n    int  zoSize, dataSize, tNumRed, velSize; \n    float *zo, *zoSq, *semb, *velModel, *data; \n    int *count; \n    int is, ir, ip, it, forDataInd, vxInd; \n    float shotPos, curOffset, halfOffset, fabsOffset, offsetSq, curPos, l0, forA; \n    float t0, vel, a, t, forLim, limitLeft, limitRight, bef, aft, sample, curSemb; \n    float sampleSq, sqSample; \n    int vtInd, vInd, tInd, dataInd, indZO, vwhalf, ts, totalCount, ind, ic, iw, offset; \n     \n \n \n \n    sf_init (argc,argv); \n \n \n \n    dataFile = sf_input (\"in\"); \n     \n \n    outFile  = sf_output(\"out\"); \n     \n \n \n    if ( NULL!= sf_getstring(\"aux\") ) { \n\t \n  \n\tauxFile  = sf_output (\"aux\"); \n    } else { \n\tsf_error (\"Need output: partial zero-offset sections\"); \n    } \n \n    if ( NULL!= sf_getstring (\"vel\") ) { \n\t \n  \n\tvelFile  = sf_input (\"vel\"); \n    } else { sf_error (\"Need input: velocity model\"); } \n \n     \n \n \n    if (!sf_histint   (dataFile, \"n1\", &tNum_)   ) sf_error (\"Need n1= in input\"); \n    if (!sf_histfloat (dataFile, \"d1\", &tStep_)  ) sf_error (\"Need d1= in input\"); \n    if (!sf_histfloat (dataFile, \"o1\", &tStart_) ) sf_error (\"Need o1= in input\"); \n \n    if (!sf_histint   (dataFile,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d1,(d"}
{"label": " \nvoid findLinkFlows(double dt)\r \n{\r \n    int i;\r \n\r \n     \n \n#pragma omp parallel num_threads(NumThreads)                                    \n \n{\r \n    #pragma omp for                                                             \n \n    for ( i = 0; i < Nobjects[LINK]; i++)\r \n    {\r \n        if ( isTrueConduit(i) &&!Link[i].bypassed )\r \n            dwflow_findConduitFlow(i, Steps, Omega, dt);\r \n    }\r \n}\r \n\r \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++)\r \n    {\r \n\t    if ( isTrueConduit(i) ) updateNodeFlows(i);\r \n    }\r \n\r \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++)\r \n    {\r \n        if (!isTrueConduit(i) )\r \n        {\t\r \n            if (!Link[i].bypassed ) findNonConduitFlow(i, dt);\r \n            updateNodeFlows(i);\r \n        }\r \n    }\r \n} ", "pred": " \nvoid findLinkFlows(double dt)\r \n{\r \n    int i;\r \n\r \n     \n \n#pragma omp parallel num_threads(NumThreads)                                    \n \n{\r \n    #pragma omp for                                                             \n \n    for ( i = 0; i < Nobjects[LINK]; i++)\r \n    {\r \n        if ( isTrueConduit(i) &&!Link[i].bypassed )\r \n            dwflow_findConduitFlow(i, Steps, Omega, dt);\r \n    }\r \n}\r \n\r \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++)\r \n    {\r \n\t    if ( isTrueConduit(i) ) updateNodeFlows(i);\r \n    }\r \n\r \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++)\r \n    {\r \n        if (!isTrueConduit(i) )\r \n        {\t\r \n            if (!Link[i].bypassed ) findNonConduitFlow(i, dt);\r \n            updateNodeFlows(i);\r \n        }\r \n    }\r \n} "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 32; \n  tile_size[3] = 64; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=Nt-1;t1++) { \n    lbp=ceild(t1+1,2); \n    ubp=min(floord(4*Nt+Nz-9,8),floord(4*t1+Nz-2,8)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(ceild(t1-6,8),ceild(8*t2-Nz-19,32));t3<=min(floord(4*Nt+Ny-9,32),floord(4*t1+Ny-1,32));t3++) { \n        for (t4=max(max(ceild(t1-14,16),ceild(8*t2-Nz-51,64)),ceild(32*t3-Ny-51,64));t4<=min(min(floord(4*Nt+Nx-9,64),floord(4*t1+Nx-1,64)),floord(32*t3+Nx+19,64));t4++) { \n          for (t5=max(max(max(max(0,ceild(8*t2-Nz+5,4)),ceild(32*t3-Ny+5,4)),ceild(64*t4-Nx+5,4)),t1);t5<=min(min(min(Nt-1,t1+1),8*t3+6),16*t4+14);t5++) { \n            for (t6=max(max(8*t2,4*t5+4),-8*t1+8*t2+8*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(32*t3,4*t5+4);t7<=min(32*t3+31,4*t5+Ny-5);t7++) { \n                lbv=max(64*t4,4*t5+4); \n                ubv=min(64*t4+63,4*t5+Nx-5); \n#pragma ivdep \n#pragma vector always \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((2.0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 32; \n  tile_size[3] = 8;   tile_size[4] = 32;   tile_size[5] = 32;   tile_size[6] = 32;   tile_size[7] = 32;   tile_size[8] = 32;   tile_size[9] = 32;   tile_size[10] = 32;   tile_size[11] = 32;   tile_size[12] = 32;   tile_size[13] = 32;   tile_size[14] = 32;   tile_size[15] = 32;   tile_size[16] = 32;   tile_size[17] = 32;   tile_size[18] = 32;   tile_size[19] = 32;   tile_size[20] = 32;   tile_size[21] = 32;   tile_size[22] = 32;   tile_size[23] = 32;   tile_size[24] = 32;   tile_size[25] = 32;   tile_size[26] = 32;   tile_size[27] = 32;   tile_size[28] = 32;   tile_size[29] = 32;   tile_size[30] = 32;   tile_size[31] = 32;   tile_size[32] = 32;   tile_size[33] = 32;   tile_size[34] = 32;   tile_size[35] = 32;   tile_size[36] = 32;   tile_size[37] = 32;   tile_size[38] = 32;   tile_size[39] = 32;   tile_size[40] = 32;   tile_size[41] = 32;   tile_size[42] = 32;   tile_size[43] = 32;   tile_size[44] = 32;   tile_size[45] = 32;   tile_size[46] = 32;   tile_size[47] = 32;   tile_size[48] = 32;   tile_size[49] = 32;   tile_size[50] = 32;   tile_size[51] = 32;   tile_size[52] = 32;   tile_size[53] = 32;   tile_size[54] = 32;   tile_size[55] = 32;   tile_size[56] = 32;   tile_size[57] = 32;   tile_size[58] = 32;   tile_size[59] = 32;   tile_size[60] = 32;   tile_size[61] = 32;   tile_size[62] = 32;   tile_size[63] = 32;   tile_size[64] = 32;   tile_size[65] = 32;   tile_size[66] = 32;   tile_size[67] = 32;   tile_size[68] = 32;   tile_size[69] = 32;   tile_size[70] = 32;   tile_size[72] = 32;   tile_size[73] = 32;   tile_size[73] = 32;   tile_size[74] = 32;   tile_size[75] = 32;   tile_size[76] = 32;   tile_size[77] = 32;   tile_size[78] = 32;   tile_size[78] = 32;   tile_size[79] = 32;   tile_size[80] = 32;   tile_size[81] = 32;   tile_size[81] = 32;   tile_size[82] = 32;   tile_size[83] = 32;   tile_size[83] = 32;   tile_size[84] = 32;   tile_size[85] = 32;   tile_size[86] = 32;   tile_size[86] = 32;   tile_size[87] = 32;   tile_size[88] = 32;   tile_size[89] = 32;   tile_size[90] = 32;   tile_size[91] = 32;   tile_size[92] = 32;   tile_size[93] = 32;   tile_size[93] = 32;   tile_size[93] = 32;   tile_size[94] = 32;   tile_size[95] = 32;   tile_size[96] = 32;   tile_size[96] = 32;   tile_size[97] = 32;   tile_size[98] = 32;   tile_size[99] = 32;   tile_size[100] = 32;   tile_size[101] = 32;   tile_size[102] = 32;   tile_size[103] = 32;   tile_size[104] = 32;   tile_size[105] = 32;   tile_size[106] = 32;   tile_size[106] = 32;   tile_size[107] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size"}
{"label": " \nint findNodeDepths(double dt)\r \n{\r \n    int i;\r \n    int converged;       \n \n    double yOld;         \n \n\r \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++ ) link_setOutfallDepth(i);\r \n\r \n     \n \n     \n \n    converged = TRUE;\r \n#pragma omp parallel num_threads(NumThreads)                                    \n \n{\r \n    #pragma omp for private(yOld)                                               \n \n    for ( i = 0; i < Nobjects[NODE]; i++ )\r \n    {\r \n        if ( Node[i].type == OUTFALL ) continue;\r \n        yOld = Node[i].newDepth;\r \n        setNodeDepth(i, dt);\r \n        Xnode[i].converged = TRUE;\r \n        if ( fabs(yOld - Node[i].newDepth) > HeadTol )\r \n        {\r \n            converged = FALSE;\r \n            Xnode[i].converged = FALSE;\r \n        }\r \n    }\r \n}                                                                               \n \n    return converged;\r \n} ", "pred": " \nint findNodeDepths(double dt)\r \n{\r \n    int i;\r \n    int converged;       \n \n    double yOld;         \n \n\r \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++ ) link_setOutfallDepth(i);\r \n\r \n     \n \n     \n \n    converged = TRUE;\r \n#pragma omp parallel num_threads(NumThreads)                                    \n \n{\r \n    #pragma omp for private(yOld)                                               \n \n    for ( i = 0; i < Nobjects[NODE]; i++ )\r \n    {\r \n        if ( Node[i].type == OUTFALL ) continue;\r \n        yOld = Node[i].newDepth;\r \n        setNodeDepth(i, dt);\r \n        Xnode[i].converged = TRUE;\r \n        if ( fabs(yOld - Node[i].newDepth) > HeadTol )\r \n        {\r \n            converged = FALSE;\r \n            Xnode[i].converged = FALSE;\r \n        }\r \n    }\r \n}                                                                               \n \n    return converged;\r \n} "}
{"label": " \nint wrtieee(float *array, unsigned int n, int header, struct seq_file *out) { \n \n\tunsigned int i, j, l, nbuf, loop; \n\tunsigned char buff[BSIZ]; \n \n\tnbuf = 0; \n\tif (header) { \n\t\tif (n >= 4294967295U / 4) \t \n \n\t\t\tfatal_error(\"wrtieee: grid too large for 4-byte header\",\"\"); \n\t\tl = n * 4; \n \n\t\tbuff[nbuf  ] = (l >> 24) & 255; \n\t\tbuff[nbuf+1] = (l >> 16) & 255; \n\t\tbuff[nbuf+2] = (l >>  8) & 255; \n\t\tbuff[nbuf+3] = l         & 255; \n\t\tnbuf += 4; \n\t} \n\ti = 0; \n\twhile (i < n) { \n\t\tloop = (BSIZ - nbuf)/4; \n\t\tloop  = (n-i) > loop? loop : (n-i); \n#pragma omp parallel for private(j) schedule(static) \n\t\tfor (j = 0 ; j < loop; j++) { \n\t\t    flt2ieee(array[i+j], buff + nbuf + j*4); \n\t\t} \n\t\ti += loop; \n\t\tnbuf += 4*loop; \n \n\t\tif (nbuf >= BSIZ) {\t\t \n \n\t\t    if (ieee_little_endian) swap_buffer(buff, BSIZ); \n\t\t    fwrite_file(buff, 1, BSIZ, out); \n\t\t    nbuf = 0; \n\t\t} \n\t} \n\tif (header) { \n\t\tl = n * 4; \n\t\tbuff[nbuf  ] = (l >> 24) & 255; \n\t\tbuff[nbuf+1] = (l >> 16) & 255; \n\t\tbuff[nbuf+2] = (l >>  8) & 255; \n\t\tbuff[nbuf+3] = l         & 255; \n\t\tnbuf += 4; \n\t} \n\tif (nbuf) { \n\t    if (ieee_little_endian) swap_buffer(buff, nbuf); \n\t    fwrite_file(buff, 1, nbuf, out); \n\t} \n\treturn 0; \n} ", "pred": " \nint wrtieee(float *array, unsigned int n, int header, struct seq_file *out) { \n \n\tunsigned int i, j, l, nbuf, loop; \n\tunsigned char buff[BSIZ]; \n \n\tnbuf = 0; \n\tif (header) { \n\t\tif (n >= 4294967295U / 4) \t \n \n\t\t\tfatal_error(\"wrtieee: grid too large for 4-byte header\",\"\"); \n\t\tl = n * 4; \n \n\t\tbuff[nbuf  ] = (l >> 24) & 255; \n\t\tbuff[nbuf+1] = (l >> 16) & 255; \n\t\tbuff[nbuf+2] = (l >>  8) & 255; \n\t\tbuff[nbuf+3] = l         & 255; \n\t\tnbuf += 4; \n\t} \n\ti = 0; \n\twhile (i < n) { \n\t\tloop = (BSIZ - nbuf)/4; \n\t\tloop  = (n-i) > loop? loop : (n-i); \n#pragma omp parallel for private(j) schedule(static) \n\t\tfor (j = 0 ; j < loop; j++) { \n\t\t    flt2ieee(array[i+j], buff + nbuf + j*4); \n\t\t} \n\t\ti += loop; \n\t\tnbuf += 4*loop; \n \n\t\tif (nbuf >= BSIZ) {\t\t \n \n\t\t    if (ieee_little_endian) swap_buffer(buff, BSIZ); \n\t\t    fwrite_file(buff, 1, BSIZ, out); \n\t\t    nbuf = 0; \n\t\t} \n\t} \n\tif (header) { \n\t\tl = n * 4; \n\t\tbuff[nbuf  ] = (l >> 24) & 255; \n\t\tbuff[nbuf+1] = (l >> 16) & 255; \n\t\tbuff[nbuf+2] = (l >>  8) & 255; \n\t\tbuff[nbuf+3] = l         & 255; \n\t\tnbuf += 4; \n\t} \n\tif (nbuf) { \n\t    if (ieee_little_endian) swap_buffer(buff, BSIZ);                                 "}
{"label": " \nstatic void _combine_masks_difference(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                      const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      dest[index] *= (1.0f - mask * both_positive(dest[index],mask)); \n    } \n  } \n  else \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      dest[index] *= (1.0f - mask * both_positive(dest[index],mask)); \n    } \n  } \n} ", "pred": " \nstatic void _combine_masks_difference(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                      const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      dest[index] *= (1.0f - mask * both_positive(dest[index],mask)); \n    } \n  } \n  else \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      dest[index] *= (1.0f - mask * both_positive(dest[index],mask)); \n    } \n  } \n} "}
{"label": " \nstatic void _combine_masks_intersect(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                     const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      dest[index] = MIN(MAX(dest[index], 0.0f), MAX(mask, 0.0f)); \n    } \n  } \n  else \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      dest[index] = MIN(MAX(dest[index], 0.0f), MAX(mask, 0.0f)); \n    } \n  } \n} ", "pred": " \nstatic void _combine_masks_intersect(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                     const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      dest[index] = MIN(MAX(dest[index], 0.0f), MAX(mask, 0.0f)); \n    } \n  } \n  else \n  { \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(npixels, opacity)    dt_omp_sharedconst(dest, newmask) aligned(dest, newmask : 64)    schedule(simd:static) \n#pragma omp parallel for shared(dest, newmask) \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      dest[index] = MIN(MAX(dest[index], 0.0f), MAX(mask, 0.0f)); \n    } \n  } \n} "}
{"label": " \nint <ompts:testcode:functionname>omp_atomic</ompts:testcode:functionname> (FILE * logFile) \n{ \n    <ompts:orphan:vars> \n\tint sum; \n        int diff; \n        double dsum = 0; \n        double dt = 0.5;\t \n \n        double ddiff; \n        int product; \n        int x; \n        int *logics; \n        int bit_and = 1; \n        int bit_or = 0; \n        int exclusiv_bit_or = 0; \n    </ompts:orphan:vars> \n \n#define DOUBLE_DIGITS 20\t \n \n#define MAX_FACTOR 10 \n#define KNOWN_PRODUCT 3628800\t \n \n    int j; \n    int known_sum; \n    int known_diff; \n    int known_product; \n    int result = 0; \n    int logic_and = 1; \n    int logic_or = 0; \n    double dknown_sum; \n    double rounding_error = 1.E-9; \n    double dpt, div; \n    int logicsArray[LOOPCOUNT]; \n    logics = logicsArray; \n     \n    sum = 0; \n    diff = 0; \n    product = 1; \n \n#pragma omp parallel \n    { \n\t<ompts:orphan> \n\t    int i; \n#pragma omp for \n\t    for (i = 1; i <= LOOPCOUNT; i++) \n\t    { \n\t\t<ompts:check>#pragma omp atomic</ompts:check> \n\t\tsum += i; \n\t    } \n\t</ompts:orphan> \n    } \n    known_sum = (LOOPCOUNT * (LOOPCOUNT + 1)) / 2; \n    if (known_sum!= sum) \n    { \n        fprintf (logFile,  \n                 \"Error in sum with integers: Result was %d instead of %d.\\n\",  \n                 sum, known_sum); \n        result++; \n    } \n     \n#pragma omp parallel \n    { \n        <ompts:orphan>    \n            int i; \n#pragma omp for \n            for (i = 0; i < LOOPCOUNT; i++) \n            { \n                 <ompts:check>#pragma omp atomic</ompts:check> \n                 diff -= i; \n            } \n        </ompts:orphan> \n    } \n    known_diff = ((LOOPCOUNT - 1) * LOOPCOUNT) / 2 * -1; \n    if (diff!= known_diff) \n    { \n        fprintf (logFile, \n              \"Error in difference with integers: Result was %d instead of 0.\\n\", \n               diff); \n        result++; \n    } \n \n     \n \n    dsum = 0; \n    dpt = 1; \n \n    for (j = 0; j < DOUBLE_DIGITS; ++j) \n      { \n        dpt *= dt; \n      } \n    dknown_sum = (1 - dpt) / (1 -dt); \n#pragma omp parallel \n    { \n        <ompts:orphan> \n            int i; \n#pragma omp for \n            for (i = 0; i < DOUBLE_DIGITS; ++i) \n            { \n                <ompts:check>#pragma omp atomic</ompts:check> \n                dsum += pow (dt, i); \n            } \n        </ompts:orphan> \n    } \n \n    if (dsum!= dknown_sum && (fabs (dsum - dknown_sum) > rounding_error)) \n    { \n        fprintf (logFile, \n                 \"Error in sum with doubles: Result was %f instead of: %f (Difference: %E)\\n\", \n                 dsum, dknown_sum, dsum - dknown_sum); \n        result++; \n    } \n \n    dpt = 1; \n \n    for (j = 0; j < DOUBLE_DIGITS; ++j) \n    { \n        dpt *= dt; \n    } \n    ddiff = (1 - dpt) / (1 - dt); \n#pragma omp parallel \n   { \n         <ompts:orphan> \n            int i; \n#pragma omp for \n            for (i = 0; i < DOUBLE_DIGITS; ++i) \n            { \n                <ompts:check>#pragma omp atomic</ompts:check> \n                ddiff -= pow (dt, i); \n            } \n         </ompts:orphan> \n    }  \n    if (fabs (ddiff) > rounding_error) \n    { \n        fprintf (logFile, \n                 \"Error in difference with doubles: Result was %E instead of 0.0\\n\", \n                 ddiff); \n        result++; \n    } \n \n#pragma omp parallel \n    { \n         <ompts:orphan> \n            int i; \n#pragma omp for \n            for (i = 1; i <= MAX_FACTOR; i++) \n            { \n                <ompts:check>#pragma omp atomic", "pred": " \nint <ompts:testcode:functionname>omp_atomic</ompts:testcode:functionname> (FILE * logFile) \n{ \n    <ompts:orphan:vars> \n\tint sum; \n        int diff; \n        double dsum = 0; \n        double dt = 0.5;\t \n \n        double ddiff; \n        int product; \n        int x; \n        int *logics; \n        int bit_and = 1; \n        int bit_or = 0; \n        int exclusiv_bit_or = 0; \n    </ompts:orphan:vars> \n \n#define DOUBLE_DIGITS 20\t \n \n#define MAX_FACTOR 10 \n#define KNOWN_PRODUCT 3628800\t \n \n    int j; \n    int known_sum; \n    int known_diff; \n    int known_product; \n    int result = 0; \n    int logic_and = 1; \n    int logic_or = 0; \n    double dknown_sum; \n    double rounding_error = 1.E-9; \n    double dpt, div; \n    int logicsArray[LOOPCOUNT]; \n    logics = logicsArray; \n     \n    sum = 0; \n    diff = 0; \n    product = 1; \n \n#pragma omp parallel \n    { \n\t<ompts:orphan> \n\t    int i; \n#pragma omp for \n\t    for (i = 1; i <= LOOPCOUNT; i++) \n\t    { \n\t\t<ompts:check>#pragma omp atomic</ompts:check> \n\t\tsum += i; \n\t    } \n\t</ompts:orphan> \n    } \n    known_sum = (LOOPCOUNT * (LOOPCOUNT + 1)) / 2; \n    if (logicsArray[i].a == 0)\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": " \nint \nread_triplet_and_proj( int *__restrict *__restrict triplet,  \n\t\t       double *__restrict *__restrict proj,  \n\t\t       const int *__restrict *__restrict momentum,  \n\t\t       const size_t nnmax,  \n\t\t       const size_t count, \n\t\t       const size_t nmom ) \n{ \n  size_t mu, i, flag = 0 ; \n \n   \n \n  char *str = malloc( (1+strlen(HAVE_PREFIX))*sizeof(char)), tmp[64] ; \n  sprintf( str, \"%s\", HAVE_PREFIX ) ; \n  sprintf( tmp, \"/Local/Moments/TRIPNP.PROJ%d.\", \n\t   #ifndef PROJ_GRACEY \n\t   -1  \n\t   #else \n\t   PROJ_GRACEY  \n\t   #endif  \n\t   ) ; \n  append_char( &str, tmp ) ; \n   \n  for( mu = 0 ; mu < ND-1 ; mu++ ) { \n    sprintf( tmp, \"%zux\", Latt.dims[mu] ) ; \n    append_char( &str, tmp ) ; \n  } \n  sprintf( tmp, \"%zu_%zu.config\", Latt.dims[mu], nnmax ) ; \n  append_char( &str, tmp ) ; \n \n  FILE *config = fopen( str, \"rb\" ) ; \n   \n \n  if( config == NULL ) { \n    flag = 1 ; \n  } else { \n    fclose( config ) ;  \n  } \n \n   \n \n  if( flag == 1 ) { \n    init_delta( ) ; \n     \n \n    FILE *config2 = fopen( str, \"wb\" ) ; \n \n    fprintf( stdout, \"[CUTS] Storing Triplet and Proj list @@@...\\n%s\\n\", \n\t     str ) ; \n \n     \n \n    int **triple = ( int **)malloc( count * sizeof( int* ) ) ; \n    #pragma omp parallel for private(i) \n    for( i = 0 ; i < count ; i++ ) { \n      triple[i] = (int*)malloc( 3 *  sizeof (int ) ) ; \n    } \n    fprintf( stdout, \"[CUTS] Precomputing triplet \\n\" ) ; \n     \n \n    get_triplet( triple, momentum, nnmax, nmom ) ; \n     \n \n    for( i = 0 ; i < count ; i++ ) { \n      fwrite( triple[i], sizeof(int), 3, config2 ) ; \n    } \n    fprintf( stdout, \"[CUTS] Computing projector... \\n\" ) ; \n     \n \n    compute_projector( triple, proj, momentum, count ) ; \n     \n \n    for( i = 0 ; i < count ; i++ ) { \n      fwrite( proj[i], sizeof( double ), ND * ND * ND, config2 ) ; \n    } \n     \n \n    fclose( config2 ) ; \n    free_delta( ) ; \n     \n \n    #pragma omp parallel for private(i) \n    for( i = 0 ; i < count ; i++ ) { \n      free( triple[i] ) ; \n    } \n    free( triple ) ;  \n  } \n \n   \n \n  config = fopen( str, \"rb\" ) ; \n  for( i = 0 ; i < count ; i++ ) { \n    if( fread( triplet[i], sizeof( int ), 3, config )!= 3 ) {  \n      return GLU_FAILURE ;  \n    } \n  } \n   \n \n  for( i = 0 ; i < count ; i++ ) { \n    if( fread( proj[i], sizeof( double ), ND * ND * ND, config ) \n\t!= ND * ND * ND ) { \n      return GLU_FAILURE ;  \n    } \n  } \n   \n \n  fclose( config ) ; \n  free( str ) ; \n   \n \n  init_delta( ) ; \n   \n \n  if( get_triplet( triplet, momentum, nnmax, nmom ) == GLU_FAILURE ) { \n    free_delta( ) ; \n    return GLU_FAILURE ; \n  } \n   \n \n  compute_projector( triplet, proj, momentum, count ) ; \n   \n \n  free_delta( ) ; \n  return GLU_SUCCESS ; \n} ", "pred": " \nint \nread_triplet_and_proj( int *__restrict *__restrict triplet,  \n\t\t       double *__restrict *__restrict proj,  \n\t\t       const int *__restrict *__restrict momentum,  \n\t\t       const size_t nnmax,  \n\t\t       const size_t count, \n\t\t       const size_t nmom ) \n{ \n  size_t mu, i, flag = 0 ; \n \n   \n \n  char *str = malloc( (1+strlen(HAVE_PREFIX))*sizeof(char)), tmp[64] ; \n  sprintf( str, \"%s\", HAVE_PREFIX ) ; \n  sprintf( tmp, \"/Local/Moments/TRIPNP.PROJ%d.\", \n\t   #ifndef PROJ_GRACEY \n\t   -1  \n\t   #else \n\t   PROJ_GRACEY  \n\t   #endif  \n\t   ) ; \n  append_char( &str, tmp ) ; \n   \n  for( mu = 0 ; mu < ND-1 ; mu++ ) { \n    sprintf( tmp, \"%zux\", Latt.dims[mu] ) ; \n    append_char( &str, tmp ) ; \n  } \n  sprintf( tmp, \"%zu_%zu.config\", Latt.dims[mu], nnmax ) ; \n  append_char( &str, tmp ) ; \n \n  FILE *config = fopen( str, \"rb\" ) ; \n   \n \n  if( config == NULL ) { \n    flag = 1 ; \n  } else { \n    fclose( config ) ;  \n  } \n \n   \n \n  if( flag == 1 ) { \n    init_delta( ) ; \n     \n \n    FILE *config2 = fopen( str, \"wb\" ) ; \n \n    fprintf( stdout, \"[CUTS] Storing Triplet and Proj list @@@...\\n%s\\n\", \n\t     str ) ; \n \n     \n \n    int **triple = new int *( str+strlen(\\\"/\\\") ) ) ;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nvoid multiply_matrices(struct mat c, struct mat a, struct mat b) \n{ \n  #ifdef NO_OPENMP \n  long int num_cores = get_num_cpus(); \n  int use_single_core = 1; \n  size_t rows; \n  unsigned int i; \n  pthread_t* threads; \n  struct mult_mat_struct* args; \n  if(num_cores > 1) \n    { \n      if((size_t)num_cores > c.n) \n\t{ \n\t   \n \n\t  num_cores = c.n; \n\t} \n      threads = (pthread_t*)malloc(sizeof(pthread_t) * num_cores); \n      args = (struct mult_mat_struct*)malloc(sizeof(struct mult_mat_struct) * num_cores); \n       \n \n      if(threads!= NULL && args!= NULL) \n\t{ \n\t  use_single_core = 0; \n\t  for(i = 0; i < num_cores; ++i) \n\t    { \n\t      rows = c.n / num_cores; \n\t      args[i].a = a; \n\t      args[i].b = b; \n\t      args[i].c = c; \n\t      args[i].first_row = i * rows; \n\t      args[i].last_row = args[i].first_row + rows; \n\t      if(i == (num_cores - 1)) \n\t\t{ \n\t\t   \n \n\t\t  args[i].last_row = c.n; \n\t\t} \n\t      if(pthread_create(&threads[i], NULL, multiply_matrices_part, &args[i])!= 0) \n\t\t{ \n\t\t  use_single_core = 1; \n\t\t  break; \n\t\t} \n\t    } \n\t   \n \n\t  for(i = 0; i < num_cores; ++i) \n\t    { \n\t      if(pthread_join(threads[i], NULL)!= 0) \n\t\t{ \n\t\t   \n \n\t\t  use_single_core = 1; \n\t\t} \n\t    } \n\t} \n    } \n   \n \n  if(use_single_core == 1) \n    { \n      struct mult_mat_struct s; \n      s.a = a; \n      s.b = b; \n      s.c = c; \n      s.first_row = 0; \n      s.last_row = c.n; \n      multiply_matrices_part(&s); \n    } \n  #else \n  size_t x, y, i, index; \n   \n \n  if(a.n!= c.n || b.n!= c.n) \n    return; \n  #pragma omp parallel for \n  for(y = 0; y < c.n; ++y) \n    { \n      for(x = 0; x < c.n; ++x) \n        { \n           \n \n          index = y * c.n + x; \n          c.data[index] = 0; \n          for(i = 0; i < c.n; ++i) \n            { \n              c.data[index] += a.data[y * c.n + i] * b.data[i * c.n + x]; \n\t    } \n        } \n    } \n  #endif \n} ", "pred": " \nvoid multiply_matrices(struct mat c, struct mat a, struct mat b) \n{ \n  #ifdef NO_OPENMP \n  long int num_cores = get_num_cpus(); \n  int use_single_core = 1; \n  size_t rows; \n  unsigned int i; \n  pthread_t* threads; \n  struct mult_mat_struct* args; \n  if(num_cores > 1) \n    { \n      if((size_t)num_cores > c.n) \n\t{ \n\t   \n \n\t  num_cores = c.n; \n\t} \n      threads = (pthread_t*)malloc(sizeof(pthread_t) * num_cores); \n      args = (struct mult_mat_struct*)malloc(sizeof(struct mult_mat_struct) * num_cores); \n       \n \n      if(threads!= NULL && args!= NULL) \n\t{ \n\t  use_single_core = 0; \n\t  for(i = 0; i < num_cores; ++i) \n\t    { \n\t      rows = c.n / num_cores; \n\t      args[i].a = a; \n\t      args[i].b = b; \n\t      args[i].c = c; \n\t      args[i].first_row = i * rows; \n\t      args[i].last_row = args[i].first_row + rows; \n\t      if(i == (num_cores - 1)) \n\t\t{ \n\t\t   \n \n\t\t  args[i].last_row = c.n; \n\t\t} \n\t      if(pthread_create(&threads[i], NULL, multiply_matrices_part, &args[i])!= 0) \n\t\t{ \n\t\t  use_single_core = 1; \n\t\t  break; \n\t\t} \n\t    } \n\t   \n \n\t  for(i = 0; i < num_cores; ++i) \n\t    { \n\t      if(pthread_join(threads, args, arg_cores, arg_cores))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": " \nvoid THNN_(SpatialSubSampling_updateOutput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *output, \n    THTensor *weight, \n    THTensor *bias, \n    int kW, int kH, \n    int dW, int dH) \n{ \n  THArgCheck(!bias || THTensor_(isContiguous)(bias), 5, \"bias must be contiguous\"); \n \n  real *weight_data = THTensor_(data)(weight); \n  real *bias_data = THTensor_(data)(bias); \n  real *output_data; \n  real *input_data; \n \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n \n  long inputWidth; \n  long inputHeight; \n  long outputWidth; \n  long outputHeight; \n \n  int nInputPlane = THTensor_(size)(weight,0); \n \n  long k; \n \n  THNN_(SpatialSubSampling_shapeCheck)(input, NULL, weight, kW, kH); \n \n  if (input->nDimension == 4) { \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  inputWidth = input->size[dimw]; \n  inputHeight = input->size[dimh]; \n  outputWidth = (inputWidth - kW) / dW + 1; \n  outputHeight = (inputHeight - kH) / dH + 1; \n \n  if (input->nDimension == 3) \n    THTensor_(resize3d)(output, nInputPlane, outputHeight, outputWidth); \n  else \n    THTensor_(resize4d)(output, input->size[0], nInputPlane, outputHeight, outputWidth); \n \n  input = THTensor_(newContiguous)(input); \n  input_data = THTensor_(data)(input); \n  output_data = THTensor_(data)(output); \n \n#pragma omp parallel for private(k) \n  for(k = 0; k < nInputPlane; k++) \n  { \n    long p; \n    for(p = 0; p < nbatch; p++) \n    { \n      long xx, yy; \n       \n \n      real *ptr_output = output_data + p*nInputPlane*outputWidth*outputHeight + k*outputWidth*outputHeight; \n       \n \n      real the_weight = weight_data[k]; \n       \n \n      real z = bias_data[k]; \n      long i; \n      for(i = 0; i < outputWidth*outputHeight; i++) \n        ptr_output[i] = z; \n \n      for(yy = 0; yy < outputHeight; yy++) \n      { \n        for(xx = 0; xx < outputWidth; xx++) \n        { \n           \n \n          real *ptr_input = input_data + p*nInputPlane*inputWidth*inputHeight + k*inputWidth*inputHeight + yy*dH*inputWidth+xx*dW; \n          real sum = 0; \n          long kx, ky; \n \n          for(ky = 0; ky < kH; ky++) \n          { \n            for(kx = 0; kx < kW; kx++) \n              sum += ptr_input[kx]; \n            ptr_input += inputWidth;  \n \n          } \n           \n \n          *ptr_output++ += the_weight*sum; \n        } \n      } \n    } \n  } \n  THTensor_(free)(input); \n} ", "pred": " \nvoid THNN_(SpatialSubSampling_updateOutput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *output, \n    THTensor *weight, \n    THTensor *bias, \n    int kW, int kH, \n    int dW, int dH) \n{ \n  THArgCheck(!bias || THTensor_(isContiguous)(bias), 5, \"bias must be contiguous\"); \n \n  real *weight_data = THTensor_(data)(weight); \n  real *bias_data = THTensor_(data)(bias); \n  real *output_data; \n  real *input_data; \n \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n \n  long inputWidth; \n  long inputHeight; \n  long outputWidth; \n  long outputHeight; \n \n  int nInputPlane = THTensor_(size)(weight,0); \n \n  long k; \n \n  THNN_(SpatialSubSampling_shapeCheck)(input, NULL, weight, kW, kH); \n \n  if (input->nDimension == 4) { \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  inputWidth = input->size[dimw]; \n  inputHeight = input->size[dimh]; \n  outputWidth = (inputWidth - kW) / dW + 1; \n  outputHeight = (inputHeight - kH) / dH + 1; \n \n  if (input->nDimension == 3) \n    THTensor_(resize3d)(output, nInputPlane, outputHeight, outputWidth); \n  else \n    THTensor_(resize4d)(output, input->size[0], nInputPlane, outputHeight, outputWidth); \n \n  input = THTensor_(newContiguous)(input); \n  input_data = THTensor_(data)(input); \n  output_data = THTensor_(data)(output); \n \n#pragma omp parallel for private(k) \n  for(k = 0; k < nInputPlane; k++) \n  { \n    long p; \n    for(p = 0; p < nInputPlane; p++) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "}
{"label": " \nstatic void csr_ax(int startAdr,int stopAdr,int PthIdx,CsrArg *arg) { \n  pCsr    A; \n  double *x,*y,dd; \n  int     i,j,ic; \n \n  A = arg->A; \n  x = arg->x; \n  y = arg->y; \n \n   \n \n  #pragma omp parallel for num_threads(1) \n  for (i=startAdr-1; i<stopAdr; i++) { \n    y[i] = 0.0; \n    for (j=A->row[i]; j<A->row[i+1]; j++) { \n      dd    = A->val[j] * x[A->col[j]]; \n      y[i] += dd; \n    } \n  } \n \n  if ( A->typ & CS_SYM ) { \n     \n \n    for (i=startAdr-1; i<stopAdr; i++) { \n      for (j=A->row[i]+1; j<A->row[i+1]; j++) { \n        ic = A->col[j]; \n\tdd     = A->val[j] * x[i]; \n        y[ic] += dd; \n      } \n    } \n  } \n} ", "pred": " \nstatic void csr_ax(int startAdr,int stopAdr,int PthIdx,CsrArg *arg) { \n  pCsr    A; \n  double *x,*y,dd; \n  int     i,j,ic; \n \n  A = arg->A; \n  x = arg->x; \n  y = arg->y; \n \n   \n \n  #pragma omp parallel for num_threads(1) \n  for (i=startAdr-1; i<stopAdr; i++) { \n    y[i] = 0.0; \n    for (j=A->row[i]; j<A->row[i+1]; j++) { \n      dd    = A->val[j] * x[A->col[j]]; \n      y[i] += dd; \n    } \n  } \n \n  if ( A->typ & CS_SYM ) { \n     \n \n    for (i=startAdr-1; i<stopAdr; i++) { \n      for (j=A->row[i]+1; j<A->row[i+1]; j++) { \n        ic = A->col[j]; \n\tdd     = A->val[j] * x[i]; \n        y[ic] += dd; \n      } \n    } \n  } \n} "}
{"label": "static int dt_brush_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                 dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  if(!module) return 0; \n  double start = dt_get_wtime(); \n  double start2; \n \n  const int px = roi->x; \n  const int py = roi->y; \n  const int width = roi->width; \n  const int height = roi->height; \n  const float scale = roi->scale; \n \n   \n \n  float *points = NULL, *border = NULL, *payload = NULL; \n \n  int points_count, border_count, payload_count; \n \n  if(!_brush_get_points_border(module->dev, form, module->iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, piece->pipe,&points, &points_count, \n                               &border, &border_count, &payload, &payload_count, 0)) \n  { \n    dt_free_align(points); \n    dt_free_align(border); \n    dt_free_align(payload); \n    return 0; \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] brush points took %0.04f sec\\n\", form->name, dt_get_wtime() - start); \n  start = start2 = dt_get_wtime(); \n \n   \n \n  dt_iop_image_fill(buffer, 0.0f, width, height, 1); \n \n  const guint nb_corner = g_list_length(form->points); \n \n   \n \n  for(int i = nb_corner * 3; i < border_count; i++) \n  { \n    const float xx = border[2 * i]; \n    const float yy = border[2 * i + 1]; \n    border[2 * i] = xx * scale - px; \n    border[2 * i + 1] = yy * scale - py; \n  } \n \n  for(int i = nb_corner * 3; i < points_count; i++) \n  { \n    const float xx = points[2 * i]; \n    const float yy = points[2 * i + 1]; \n    points[2 * i] = xx * scale - px; \n    points[2 * i + 1] = yy * scale - py; \n  } \n \n   \n \n  float xmin = 0.0f, xmax = 0.0f, ymin = 0.0f, ymax = 0.0f; \n  xmin = ymin = FLT_MAX; \n  xmax = ymax = FLT_MIN; \n \n  for(int i = nb_corner * 3; i < border_count; i++) \n  { \n     \n \n    const float xx = border[i * 2]; \n    const float yy = border[i * 2 + 1]; \n    xmin = fminf(xx, xmin); \n    xmax = fmaxf(xx, xmax); \n    ymin = fminf(yy, ymin); \n    ymax = fmaxf(yy, ymax); \n  } \n  for(int i = nb_corner * 3; i < points_count; i++) \n  { \n     \n \n    const float xx = points[i * 2]; \n    const float yy = points[i * 2 + 1]; \n    xmin = fminf(xx, xmin); \n    xmax = fmaxf(xx, xmax); \n    ymin = fminf(yy, ymin); \n    ymax = fmaxf(yy, ymax); \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] brush_fill min max took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n \n \n \n   \n \n  if(xmax < 0 || ymax < 0 || xmin >= width || ymin >= height) \n  { \n    dt_free_align(points); \n    dt_free_align(border); \n    dt_free_align(payload); \n    return 1; \n  } \n \n   \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(nb_corner, border_count, width, height)    shared(buffer, points, border, payload) \n#pragma omp parallel for shared(buffer) \n  for(int i = nb_corner * 3; i < border_count; i++) \n  { \n    const int p0[] = { points[i * 2], points[i * 2 + 1] }; \n    const int p1[] = { border[i * 2], border[i * 2 + 1] }; \n \n    if(MAX(p0[0], p1[0]) < 0 || MIN(p0[0], p1[0]) >= width || MAX(p0[1], p1[1]) < 0 \n       || MIN(p0[1], p1[1]) >= height) \n      continue; \n \n    _brush_falloff_roi(buffer, p0, p1, width, height, payload[i * 2], payload[i * 2 + 1]); \n  } \n \n  dt_free_align(points); \n  dt_free_align(border); \n  dt_free_align(payload); \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] brush fill buffer took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start); \n \n  return 1; \n} \n ", "pred": "static int dt_brush_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                 dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  if(!module) return 0; \n  double start = dt_get_wtime(); \n  double start2; \n \n  const int px = roi->x; \n  const int py = roi->y; \n  const int width = roi->width; \n  const int height = roi->height; \n  const float scale = roi->scale; \n \n   \n \n  float *points = NULL, *border = NULL, *payload = NULL; \n \n  int points_count, border_count, payload_count; \n \n  if(!_brush_get_points_border(module->dev, form, module->iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, piece->pipe,&points, &points_count, \n                               &border, &border_count, &payload, &payload_count, 0)) \n  { \n    dt_free_align(points); \n    dt_free_align(border); \n    dt_free_align(payload); \n    return 0; \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] brush points took %0.04f sec\\n\", form->name, dt_get_wtime() - start); \n  start = start2 = dt_get_wtime(); \n \n   \n \n  dt_iop_image_fill(buffer, 0.0f, width, height, 1); \n \n  const guint nb_corner = g_list_length(form->points); \n \n   \n \n  for(int i = nb_corner * 3; i < border_count; i++) \n  { \n    const float * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const * const"}
{"label": " \nvoid mexFunction(int nlhs, mxArray *plhs[], \n                 int nrhs, const mxArray *prhs[]) \n{ \n   \n  \n  int a,b,c,k,M,N, m,n,i,kstart,j,insert,kend; \n  int size1,size2; \n  double *ps,*pM, *pk, *po,*po2; \n  int mRows,nCols; \n  mxArray *infOut[1]; \n  double inf; \n   \n \n \n   \n     \n  if (nrhs!= 2) { \n    mexErrMsgTxt(\"Two input arguments required.\"); \n  }  \n  if (nlhs > 2) { \n    mexErrMsgTxt(\"Too many output arguments.\"); \n  } \n \n   \n \n  if (!(mxIsDouble(prhs[0]))) { \n    mexErrMsgTxt(\"Input array must be of type double.\"); \n  } \n     \n   \n \n  M = mxGetM(prhs[0]); \n  N = mxGetN(prhs[0]); \n   \n   \n \n  pM  = (double *)mxGetPr(prhs[0]); \n  pk  = (double *)mxGetPr(prhs[1]); \n \n  k=(int) pk[0]; \n  plhs[0]=mxCreateDoubleMatrix(k,N,mxREAL); \n  plhs[1]=mxCreateDoubleMatrix(k,N,mxREAL); \n  po=mxGetPr(plhs[0]); \n  po2=mxGetPr(plhs[1]); \n   \n  mexCallMATLAB(1,infOut,0,NULL,\"inf\"); \n  ps=mxGetPr(infOut[0]);  \n  inf=ps[0]; \n \n#pragma omp parallel shared(pM,po,po2) private(kstart,kend,i,j,m,insert) \n  { \n#pragma omp for \n  for(n=0;n<N;n++){ \n    kstart=n*k; \n    kend=kstart+k; \n    for(j=kstart;j<kend;j++) po[j]=inf; \n   for(m=0;m<M;m++){ \n    i=n*M+m; \n     if(pM[i]<po[kend-1]) { \n        \n \n       for(j=kstart;j<kend && po[j]<pM[i];j++); \n       insert=j; \n        \n \n       for(j=kend-1;j>insert;j--){po[j]=po[j-1];po2[j]=po2[j-1];} \n        \n \n       if(insert<kend) {po[insert]=pM[i];po2[insert]=m+1;} \n       } \n    }\t \n   } \n  } \n} ", "pred": " \nvoid mexFunction(int nlhs, mxArray *plhs[], \n                 int nrhs, const mxArray *prhs[]) \n{ \n   \n  \n  int a,b,c,k,M,N, m,n,i,kstart,j,insert,kend; \n  int size1,size2; \n  double *ps,*pM, *pk, *po,*po2; \n  int mRows,nCols; \n  mxArray *infOut[1]; \n  double inf; \n   \n \n \n   \n     \n  if (nrhs!= 2) { \n    mexErrMsgTxt(\"Two input arguments required.\"); \n  }  \n  if (nlhs > 2) { \n    mexErrMsgTxt(\"Too many output arguments.\"); \n  } \n \n   \n \n  if (!(mxIsDouble(prhs[0]))) { \n    mexErrMsgTxt(\"Input array must be of type double.\"); \n  } \n     \n   \n \n  M = mxGetM(prhs[0]); \n  N = mxGetN(prhs[0]); \n   \n   \n \n  pM  = (double *)mxGetPr(prhs[0]); \n  pk  = (double *)mxGetPr(prhs[1]); \n \n  k=(int) pk[0]; \n  plhs[0]=mxCreateDoubleMatrix(k,N,mxREAL); \n  plhs[1]=mxCreateDoubleMatrix(k,N,mxREAL); \n  po=mxGetPr(plhs[0]); \n  po2=mxGetPr(plhs[1]); \n   \n  mexCallMATLAB(1,infOut,0,NULL,\"inf\"); \n  ps=mxGetPr(infOut[0]);  \n  inf=ps[0]; \n \n#pragma omp parallel shared(pM,po,po2) private(kstart,kend,i,j,m,insert) \n  { \n#pragma omp for \n  for(n=0;n<N;n++){ \n    kstart=n*k; \n                                                                                                                                                                                                                                                                                    "}
{"label": " \nvoid \nfoo (unsigned long long int a, unsigned long long int b, unsigned long long int c) \n{ \n  unsigned long long int i; \n  #pragma omp parallel \n  #pragma omp for reduction (task, *: j) schedule (guided) \n  for (i = a; i < b; i += c) \n    { \n      j++; \n      bar (&j); \n    } \n} ", "pred": " \nvoid \nfoo (unsigned long long int a, unsigned long long int b, unsigned long long int c) \n{ \n  unsigned long long int i; \n  #pragma omp parallel \n  #pragma omp for reduction (task, *: j) schedule (guided) \n  for (i = a; i < b; i += c) \n    { \n      j++; \n      bar (&j); \n    } \n} "}
{"label": " \nvoid sgemm_host_omp(float *a, float *b, float *c, int n, int m, int q) \n{ \n    #pragma omp parallel \n    { \n        int k = 0; \n        #pragma omp for \n        for (int i = 0; i < n; i++) \n            for (int j = 0; j < q; j++) \n                c[k++] = 0.0; \n \n        #pragma omp for \n        for (int i = 0; i < n; i++) { \n            for (int k = 0; k < m; k++) { \n                for (int j = 0; j < q; j++) \n                    c[i * q + j] += a[i * m + k] * b[k * q + j]; \n    \t\t} \n\t    } \n\t} \n} ", "pred": " \nvoid sgemm_host_omp(float *a, float *b, float *c, int n, int m, int q) \n{ \n    #pragma omp parallel \n    { \n        int k = 0; \n        #pragma omp for \n        for (int i = 0; i < n; i++) \n            for (int j = 0; j < q; j++) \n                c[k++] = 0.0; \n \n        #pragma omp for \n        for (int i = 0; i < n; i++) { \n            for (int k = 0; k < m; k++) { \n                for (int j = 0; j < q; j++) \n                    c[i * q + j] += a[i * m + k] * b[k * q + j]; \n    \t\t} \n\t    } \n\t} \n} "}
{"label": " \nint grow(float *p, float *q, int c, int n) \n{ \n    const int s = (n + 2) * c; \n    const int a = (c - 1); \n \n    float *P; \n    float *Q; \n \n    int N = 0; \n    int i; \n    int j; \n    int d; \n \n    memcpy(q, p, (size_t) (n + 2) * (n + 2) * c * sizeof (float)); \n \n    #pragma omp parallel for private(j, P, Q, d) reduction(+:N) \n    for     (i = 1; i <= n; i++) \n        for (j = 1; j <= n; j++) \n        { \n            P = p + ((n + 2) * i + j) * c; \n            Q = q + ((n + 2) * i + j) * c; \n \n            if (Q[a] == 0) \n            { \n                d = 0; \n \n                if ((Q - s - c)[a]) { accumulate(P, Q - s - c, a); d++; } \n                if ((Q - s    )[a]) { accumulate(P, Q - s   , a); d++; } \n                if ((Q - s + c)[a]) { accumulate(P, Q - s + c, a); d++; } \n \n                if ((Q     - c)[a]) { accumulate(P, Q     - c, a); d++; } \n                if ((Q     + c)[a]) { accumulate(P, Q     + c, a); d++; } \n \n                if ((Q + s - c)[a]) { accumulate(P, Q + s - c, a); d++; } \n                if ((Q + s    )[a]) { accumulate(P, Q + s   , a); d++; } \n                if ((Q + s + c)[a]) { accumulate(P, Q + s + c, a); d++; } \n \n                if (d) \n                { \n                    divide(P, (float) d, a); \n                    N++; \n                } \n            } \n        } \n    return N; \n} ", "pred": " \nint grow(float *p, float *q, int c, int n) \n{ \n    const int s = (n + 2) * c; \n    const int a = (c - 1); \n \n    float *P; \n    float *Q; \n \n    int N = 0; \n    int i; \n    int j; \n    int d; \n \n    memcpy(q, p, (size_t) (n + 2) * (n + 2) * c * sizeof (float)); \n \n    #pragma omp parallel for private(j, P, Q, d) reduction(+:N) \n    for     (i = 1; i <= n; i++) \n        for (j = 1; j <= n; j++) \n        { \n            P = p + ((n + 2) * i + j) * c; \n            Q = q + ((n + 2) * i + j) * c; \n \n            if (Q[a] == 0) \n            { \n                d = 0; \n \n                if ((Q - s - c)[a]) { accumulate(P, Q - s - c, a); d++; } \n                if ((Q - s    )[a]) { accumulate(P, Q - s   , a); d++; } \n                if ((Q - s + c)[a]) { accumulate(P, Q - s + c, a); d++; } \n \n                if ((Q     - c)[a]) { accumulate(P, Q     - c, a); d++; } \n                if ((Q     + c)[a]) { accumulate(P, Q     + c, a); d++; } \n \n                if ((Q      + c)[a]) { accumulate(P, Q, d); d += d; }                  if ((Q      + c)[a]) { accumulate(P, Q, d); d += d; }                  if ((Q      + c)[a]) { accumulate(P, Q, d); d += d; }                  if ((Q      + c)[a]) { accumulate(P, Q, d); d += d; }                  if ((Q      + c)[a]) { accumulate(P, Q, d); d += d; }                  if ((Q      + c)[a]) { accumulate(P, Q, d); d += d; }                  if"}
{"label": " \nstatic void \ncompute_projector( int *__restrict *__restrict triplet,  \n\t\t   double *__restrict *__restrict proj,  \n\t\t   const int *__restrict *__restrict momentum,  \n\t\t   const size_t count ) \n{ \n   \n \n  size_t i ; \n  #pragma omp parallel for private(i) \n  for( i = 0 ; i < count ; i++ ) { \n    double mom[ 3 ][ ND ] ; \n    size_t mu ; \n \n    for( mu = 0 ; mu < ND ; mu ++ ) { \n      #ifdef PSQ_MOM \n       \n \n      mom[ 0 ][ mu ] = momentum[ triplet[ i ][ 0 ] ][ mu ] * Latt.twiddles[ mu ] ; \n      mom[ 1 ][ mu ] = momentum[ triplet[ i ][ 1 ] ][ mu ] * Latt.twiddles[ mu ] ; \n      mom[ 2 ][ mu ] = momentum[ triplet[ i ][ 2 ] ][ mu ] * Latt.twiddles[ mu ] ; \n      #else \n       \n \n      mom[ 0 ][ mu ] = 2.0 * sin( momentum[ triplet[ i ][ 0 ] ][ mu ] * Latt.twiddles[ mu ] ) ; \n      mom[ 1 ][ mu ] = 2.0 * sin( momentum[ triplet[ i ][ 1 ] ][ mu ] * Latt.twiddles[ mu ] ) ; \n      mom[ 2 ][ mu ] = 2.0 * sin( momentum[ triplet[ i ][ 2 ] ][ mu ] * Latt.twiddles[ mu ] ) ; \n      #endif \n    } \n \n    size_t nu, rho ; \n    for( mu = 0 ; mu < ND ; mu ++ ) { \n      for( nu = 0 ; nu < ND ; nu ++ ) { \n\tfor( rho = 0 ; rho < ND ; rho ++ ) { \n\t  const size_t z = rho + ND * ( nu + ND * mu ) ;  \n\t   \n \n          #ifdef PROJ_GRACEY \n\t  proj[i][z] = get_proj_gracey( mom[ 0 ], \t\t\t\t\tmom[ 1 ],\t \t\t\t\t\tmu, nu, rho ) ; \n          #else \n\t  proj[i][z] = get_proj( mom[ 0 ], \t\t\t\t mom[ 1 ], \t\t\t\t mom[ 2 ], \t\t\t\t mu, nu, rho ) ; \n          #endif \n\t} } } \n  } \n  return ; \n} ", "pred": " \nstatic void \ncompute_projector( int *__restrict *__restrict triplet,  \n\t\t   double *__restrict *__restrict proj,  \n\t\t   const int *__restrict *__restrict momentum,  \n\t\t   const size_t count ) \n{ \n   \n \n  size_t i ; \n  #pragma omp parallel for private(i) \n  for( i = 0 ; i < count ; i++ ) { \n    double mom[ 3 ][ ND ] ; \n    size_t mu ; \n \n    for( mu = 0 ; mu < ND ; mu ++ ) { \n      #ifdef PSQ_MOM \n       \n \n      mom[ 0 ][ mu ] = momentum[ triplet[ i ][ 0 ] ][ mu ] * Latt.twiddles[ mu ] ; \n      mom[ 1 ][ mu ] = momentum[ triplet[ i ][ 1 ] ][ mu ] * Latt.twiddles[ mu ] ; \n      mom[ 2 ][ mu ] = momentum[ triplet[ i ][ 2 ] ][ mu ] * Latt.twiddles[ mu ] ; \n      #else \n       \n \n      mom[ 0 ][ mu ] = 2.0 * sin( momentum[ triplet[ i ][ 0 ] ][ mu ] * Latt.twiddles[ mu ] ) ; \n      mom[ 1 ][ mu ] = 2.0 * sin( momentum[ triplet[ i ][ 1 ] ][ mu ] * Latt.twiddles[ mu ] ) ; \n      mom[ 2 ][ mu ] = 2.0 * sin( momentum[ triplet[ i ][ 2 ] ][ mu ] * Latt.twiddles[ mu ] ) ; \n      #endif \n    } \n \n    size_t nu, rho ; \n    for( mu = 0 ; mu < ND ; mu ++ ) { \n      for( nu = 0 ; nu < ND ; nu ++ ) { \n\tfor( rho = 0 ; rho < ND ; rho ++ ) { \n\t  const size_t z = rho + ND * ( nu + ND * mu ) ;  \n\t   \n \n          #ifdef PROJ_GRACEY \n\t  proj[i][z * Latt.twtz_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_a_"}
{"label": " \nint main(int argc, char** argv) { \n    int i, j, k; \n    int ni = NI; \n    int nj = NJ; \n    int nk = NK; \n    int nl = NL; \n     \n     \n \n    init_array(); \n     \n     \n#pragma omp parallel for private (j, k) schedule(static) check \n    for (i = 0; i < ni; i++) \n        for (j = 0; j < nj; j++) { \n            C[i][j] = 0; \n            for (k = 0; k < nk; ++k) \n                C[i][j] += A[i][k] * B[k][j]; \n        } \n#pragma omp parallel for private (j, k) schedule(static) check \n    for (i = 0; i < ni; i++) \n        for (j = 0; j < nl; j++) { \n            E[i][j] = 0; \n            for (k = 0; k < nj; ++k) \n                E[i][j] += C[i][k] * D[k][j]; \n        } \n     \n    double total = 0; \n    for(int y=0; y<ni; ++y){ \n        for(int x=0; x<ni; ++x) { \n            total+= E[y][x]; \n        } \n    } \n    printf(\"Total: %f\\n\",total); \n    return 0; \n} ", "pred": " \nint main(int argc, char** argv) { \n    int i, j, k; \n    int ni = NI; \n    int nj = NJ; \n    int nk = NK; \n    int nl = NL; \n     \n     \n \n    init_array(); \n     \n     \n#pragma omp parallel for private (j, k) schedule(static) check \n    for (i = 0; i < ni; i++) \n        for (j = 0; j < nj; j++) { \n            C[i][j] = 0; \n            for (k = 0; k < nk; ++k) \n                C[i][j] += A[i][k] * B[k][j]; \n        } \n#pragma omp parallel for private (j, k) schedule(static) check \n    for (i = 0; i < ni; i++) \n        for (j = 0; j < nl; j++) { \n            E[i][j] = 0; \n            for (k = 0; k < nj; ++k) \n                E[i][j] += C[i][k] * D[k][j]; \n        } \n     \n    double total = 0; \n    for(int y=0; y<ni; ++y){ \n        for(int x=0; x<ni; ++x) { \n            total+= E[y][x]; \n        } \n    } \n    printf(\"Total: %f\\n\",total); \n    return 0; \n} "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 16; \n  tile_size[3] = 2048; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0765; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,12);t1++) { \n    lbp=max(ceild(t1,2),ceild(24*t1-Nt+3,24)); \n    ubp=min(floord(Nt+Nz-4,24),floord(12*t1+Nz+9,24)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(3*t1-3,4)),ceild(24*t2-Nz-12,16));t3<=min(min(min(floord(Nt+Ny-4,16),floord(12*t1+Ny+21,16)),floord(24*t2+Ny+20,16)),floord(24*t1-24*t2+Nz+Ny+19,16));t3++) { \n        for (t4=max(max(max(0,ceild(3*t1-511,512)),ceild(24*t2-Nz-2044,2048)),ceild(16*t3-Ny-2044,2048));t4<=min(min(min(min(floord(Nt+Nx-4,2048),floord(12*t1+Nx+21,2048)),floord(24*t2+Nx+20,2048)),floord(16*t3+Nx+12,2048)),floord(24*t1-24*t2+Nz+Nx+19,2048));t4++) { \n          for (t5=max(max(max(max(max(0,12*t1),24*t1-24*t2+1),24*t2-Nz+2),16*t3-Ny+2),2048*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,12*t1+23),24*t2+22),16*t3+14),2048*t4+2046),24*t1-24*t2+Nz+21);t5++) { \n            for (t6=max(max(24*t2,t5+1),-24*t1+24*t2+2*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(16*t3,t5+1);t7<=min(16*t3+15,t5+Ny-2);t7++) { \n                lbv=max(2048*t4,t5+1); \n                ubv=min(2048*t4+2047,t5+Nx-2); \n#pragma ivdep \n#pragma vector always \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = ((alpha * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (beta * (((((A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)] + A[ t5 % 2][ (-t5+t", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 16; \n  tile_size[3] = 2048; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0876;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "}
{"label": " \nstatic  \nvoid kernel_deriche(int w, int h, DATA_TYPE alpha, \n       DATA_TYPE POLYBENCH_2D(imgIn, W, H, w, h), \n       DATA_TYPE POLYBENCH_2D(imgOut, W, H, w, h), \n       DATA_TYPE POLYBENCH_2D(y1, W, H, w, h), \n       DATA_TYPE POLYBENCH_2D(y2, W, H, w, h)) { \n    int i,j; \n    DATA_TYPE xm1, tm1, ym1, ym2; \n    DATA_TYPE xp1, xp2; \n    DATA_TYPE tp1, tp2; \n    DATA_TYPE yp1, yp2; \n    \n    DATA_TYPE k; \n    DATA_TYPE a1, a2, a3, a4, a5, a6, a7, a8; \n    DATA_TYPE b1, b2, c1, c2; \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nk = (SCALAR_VAL(1.0)-EXP_FUN(-alpha))*(SCALAR_VAL(1.0)-EXP_FUN(-alpha))/(SCALAR_VAL(1.0)+SCALAR_VAL(2.0)*alpha*EXP_FUN(-alpha)-EXP_FUN(SCALAR_VAL(2.0)*alpha)); a1 = a5 = k; a2 = a6 = k*EXP_FUN(-alpha)*(alpha-SCALAR_VAL(1.0)); a3 = a7 = k*EXP_FUN(-alpha)*(alpha+SCALAR_VAL(1.0)); a4 = a8 = -k*EXP_FUN(SCALAR_VAL(-2.0)*alpha); b1 = POW_FUN(SCALAR_VAL(2.0),-alpha); b2 = -EXP_FUN(SCALAR_VAL(-2.0)*alpha);; \nc1 = c2 = 1;; \nif (_PB_H >= 1) { \n  for (t2=0;t2<=_PB_W-1;t2++) { \n    ym1 = SCALAR_VAL(0.0);; \n    ym2 = SCALAR_VAL(0.0);; \n    xm1 = SCALAR_VAL(0.0);; \n    for (t4=0;t4<=_PB_H-1;t4++) { \n      y1[t2][t4] = a1*imgIn[t2][t4] + a2*xm1 + b1*ym1 + b2*ym2; xm1 = imgIn[t2][t4]; ym2 = ym1; ym1 = y1[t2][t4];; \n    } \n  } \n} \nif (_PB_H <= 0) { \n  for (t2=0;t2<=_PB_W-1;t2++) { \n    ym1 = SCALAR_VAL(0.0);; \n    ym2 = SCALAR_VAL(0.0);; \n    xm1 = SCALAR_VAL(0.0);; \n  } \n} \nif (_PB_H >= 1) { \n  for (t2=0;t2<=_PB_W-1;t2++) { \n    yp1 = SCALAR_VAL(0.0);; \n    yp2 = SCALAR_VAL(0.0);; \n    xp1 = SCALAR_VAL(0.0);; \n    xp2 = SCALAR_VAL(0.0);; \n    for (t4=-_PB_H+1;t4<=0;t4++) { \n      y2[t2][-t4] = a3*xp1 + a4*xp2 + b1*yp1 + b2*yp2; xp2 = xp1; xp1 = imgIn[t2][-t4]; yp2 = yp1; yp1 = y2[t2][-t4];; \n    } \n  } \n} \nif (_PB_H <= 0) { \n  for (t2=0;t2<=_PB_W-1;t2++) { \n    yp1 = SCALAR_VAL(0.0);; \n    yp2 = SCALAR_VAL(0.0);; \n    xp1 = SCALAR_VAL(0.0);; \n    xp2 = SCALAR_VAL(0.0);; \n  } \n} \nif (_PB_H >= 1) { \n  lbp=0; \n  ubp=_PB_W-1; \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5) \n  for (t2=lbp;t2<=ubp;t2++) { \n    for (t4=0;t4<=_PB_H-1;t4++) { \n      imgOut[t2][t4] = c1 * (y1[t2][t4] + y2[t2][t4]);; \n    } \n  } \n} \nif (_PB_W >= 1) { \n  for (t2=0;t2<=_PB_H-1;t2++) { \n    tm1 = SCALAR_VAL(0.0);; \n    ym1 = SCALAR_VAL(0.0);; \n    ym2 = SCALAR_VAL(0.0);; \n    for (t4=0;t4<=_PB_W-1;t4++) { \n      y1[t4][t2] = a5*imgOut[t4][t2] + a6*tm1 + b1*ym1 + b2*ym2; tm1 = imgOut[t4][t2]; ym2 = ym1; ym1 = y1 [t4][t2];; \n    } \n  } \n} \nif (_PB_W <= 0) { \n  for (t2=0;t2<=_PB_H-1;t2++) { \n    tm1 = SCALAR_VAL(0.0);; \n    ym1 = SCALAR_VAL(0.0);; \n    ym2 = SCALAR_VAL(0.0);; \n  } \n} \nif (_PB_W >= 1) { \n  for (t2=0;t2<=_PB_H-1;t2++) { \n    tp1 = SCALAR_VAL(0.0);; \n    tp2 = SCALAR_VAL(0.0);; \n    yp1 = SCALAR_VAL(0.0);; \n    yp2 = SCALAR_VAL(0.0);; \n    for (t4=-_PB_W+1;t4<=0;t4++) { \n      y2[-t4][t2] = a7*tp1 + a8*tp2 + b1*yp1 + b2*yp2; tp2 = tp1; tp1 = imgOut[-t4][t2]; yp2 = yp1; yp1 = y2[-t4][t2];; \n    } \n  } \n} \nif (_PB_W <= 0) { \n  for (t2=0;t2<=_PB_H-1;t2++) { \n    tp1 = SCALAR_VAL(0", "pred": " \nstatic  \nvoid kernel_deriche(int w, int h, DATA_TYPE alpha, \n       DATA_TYPE POLYBENCH_2D(imgIn, W, H, w, h), \n       DATA_TYPE POLYBENCH_2D(imgOut, W, H, w, h), \n       DATA_TYPE POLYBENCH_2D(y1, W, H, w, h), \n       DATA_TYPE POLYBENCH_2D(y2, W, H, w, h)) { \n    int i,j; \n    DATA_TYPE xm1, tm1, ym1, ym2; \n    DATA_TYPE xp1, xp2; \n    DATA_TYPE tp1, tp2; \n    DATA_TYPE yp1, yp2; \n    \n    DATA_TYPE k; \n    DATA_TYPE a1, a2, a3, a4, a5, a6, a7, a8; \n    DATA_TYPE b1, b2, c1, c2; \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nk = (SCALAR_VAL(1.0)-EXP_FUN(-alpha))*(SCALAR_VAL(1.0)-EXP_FUN(-alpha))/(SCALAR_VAL(1.0)+SCALAR_VAL(2.0)*alpha*EXP_FUN(-alpha)-EXP_FUN(SCALAR_VAL(2.0)*alpha)); a1 = a5 = k; a2 = a6 = k*EXP_FUN(-alpha)*(alpha-SCALAR_VAL(1.0)); a3 = a7 = k*EXP_FUN(-alpha)*(alpha+SCALAR_VAL(1.0)); a4 = a8 = -k*EXP_FUN(SCALAR_VAL(-2.0)*alpha); b1 = POW_FUN(SCALAR_VAL(2.0),-alpha); b2 = -EXP_FUN(SCALAR_VAL(-2.0)*alpha);; \nc1 = c2 = 1;; \nif (_PB_H >= 1) { \nn                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nint main(int argc, char* argv[]) \n{ \n    bool verb,fsrf,snap,expl,dabc,sout,uses; \n    int  jsnap,ntsnap,jdata; \n    char *atype; \n    int ompnth=1; \n \n     \n \n    sf_file Fwav=NULL;  \n \n    sf_file Fsou=NULL;  \n \n    sf_file Frec=NULL;  \n \n    sf_file Fvel=NULL;  \n \n    sf_file Fang=NULL;  \n \n    sf_file Fdat=NULL;  \n \n    sf_file Fwfl=NULL;  \n \n \n     \n \n    sf_axis at,az,ax,ay; \n    sf_axis as,ar; \n \n    int     nt,nz,nx,ny,ns,nr,nb; \n    int     it,iz,ix,iy; \n    float   dt,dz,dx,dy,dt2; \n \n     \n \n    fdm3d    fdm=NULL; \n    abcone3d abc=NULL; \n    sponge   spo=NULL; \n \n     \n \n    float  *ww=NULL;            \n \n    pt3d   *ss=NULL;            \n \n    pt3d   *rr=NULL;            \n \n    float  *dd=NULL;            \n \n \n    float ***tt=NULL; \n    float ***vp=NULL;            \n \n \n    float ***vpn=NULL; \n    float ***vpz=NULL; \n    float ***vpx=NULL; \n    float ***vsz=NULL; \n \n    float ***tht=NULL,***sit=NULL,***cot=NULL; \n    float ***phi=NULL,***sip=NULL,***cop=NULL; \n    float st,ct,sp,cp; \n \n    float ***pm=NULL,***po=NULL,***pp=NULL,***pa=NULL,***pt=NULL;  \n \n    float ***qm=NULL,***qo=NULL,***qp=NULL,***qa=NULL,***qt=NULL;  \n \n    float ***sf=NULL;  \n \n \n     \n \n    lint3d cs,cr; \n \n     \n \n    float cox,cax,cbx,c1x,c2x; \n    float coy,cay,cby,c1y,c2y; \n    float coz,caz,cbz,c1z,c2z; \n \n     \n \n    sf_axis   acz=NULL,acx=NULL,acy=NULL; \n    int       nqz,nqx,nqy; \n    float     oqz,oqx,oqy; \n    float     dqz,dqx,dqy; \n    float     ***pc=NULL; \n \n    float H1p,H2p,H1q,H2q; \n \n     \n \n     \n \n    sf_init(argc,argv); \n \n     \n \n    if (NULL == (atype = sf_getstring(\"atype\"))) atype = \"i\"; \n    switch(atype[0]) { \n\tcase 't': \n\t    sf_warning(\"TTI model\"); \n\t    break; \n \n\tcase 'v': \n\t    sf_warning(\"VTI model\"); \n\t    break; \n \n\tcase 'i': \n\tdefault: \n\t    sf_warning(\"ISO model\"); \n\t    break; \n    } \n \n     \n \n     \n \n    ompnth=omp_init(); \n     \n \n \n     \n \n    if(! sf_getbool(\"verb\",&verb)) verb=false;  \n \n    if(! sf_getbool(\"snap\",&snap)) snap=false;  \n \n    if(! sf_getbool(\"free\",&fsrf)) fsrf=false;  \n \n    if(! sf_getbool(\"expl\",&expl)) expl=false;  \n \n    if(! sf_getbool(\"dabc\",&dabc)) dabc=false;  \n \n    if(! sf_getbool(\"sout\",&sout)) sout=false;  \n \n    if(! sf_getbool(\"uses\",&uses)) uses=false;  \n \n     \n \n \n     \n \n     \n \n    Fwav = sf_input (\"in\" );  \n \n    Fvel = sf_input (\"vel\");  \n \n    Fsou = sf_input (\"sou\");  \n \n    Frec = sf_input (\"rec\");  \n \n    Fang = sf_input (\"ang\");  \n \n    Fwfl = sf_output(\"wfl\");  \n \n    Fdat = sf_output(\"out\");  \n \n \n     \n \n     \n \n    at = sf_iaxa(Fwav,2); sf_setlabel(at,\"t\"); if(verb) sf_raxa(at);  \n \n    ax = sf_iaxa(Fvel,2); sf_setlabel(ax,\"x\"); if(verb) sf_raxa(ax);  \n \n    ay = sf_iaxa(Fvel,3); sf_setlabel(ay,\"y\"); if(verb) sf_raxa(ay);  \n \n    az = sf_iaxa(Fvel,1); sf_setlabel(az,\"z\"); if(verb) sf_raxa(az);  \n \n \n    as = sf_iaxa(Fsou,2); sf_setlabel(as,\"s\"); if(verb) sf_raxa(as);  \n \n    ar = sf_iaxa(Frec,2); sf_setlabel(ar,\"r\"); if(verb) sf_raxa(ar);  \n \n \n    nt = sf_n(at); dt = sf_d(at); \n    nz = sf_n(az); dz = sf_d(az); \n    nx = sf_n(ax); dx = sf_d(ax); \n    ny = sf_n(ay); dy = sf_d(ay); \n \n    ns = sf_n(as); \n    nr = sf_n(ar); \n     \n \n \n     \n \n     \n \n    if(! sf_getint(\"jdata\",&jdata)) jdata=1; \n    if(snap) {   \n \n\tif(! sf_getint(\"jsnap\",&jsnap)) jsnap=nt", "pred": " \nint main(int argc, char* argv[]) \n{ \n    bool verb,fsrf,snap,expl,dabc,sout,uses; \n    int  jsnap,ntsnap,jdata; \n    char *atype; \n    int ompnth=1; \n \n     \n \n    sf_file Fwav=NULL;  \n \n    sf_file Fsou=NULL;  \n \n    sf_file Frec=NULL;  \n \n    sf_file Fvel=NULL;  \n \n    sf_file Fang=NULL;  \n \n    sf_file Fdat=NULL;  \n \n    sf_file Fwfl=NULL;  \n \n \n     \n \n    sf_axis at,az,ax,ay; \n    sf_axis as,ar; \n \n    int     nt,nz,nx,ny,ns,nr,nb; \n    int     it,iz,ix,iy; \n    float   dt,dz,dx,dy,dt2; \n \n     \n \n    fdm3d    fdm=NULL; \n    abcone3d abc=NULL; \n    sponge   spo=NULL; \n \n     \n \n    float  *ww=NULL;            \n \n    pt3d   *ss=NULL;            \n \n    pt3d   *rr=NULL;            \n \n    float  *dd=NULL;            \n \n \n    float ***tt=NULL; \n    float ***vp=NULL;            \n \n \n    float ***vpn=NULL; \n    float ***vpz=NULL; \n    float ***vpx=NULL; \n    float ***vsz=NULL; \n \n    float ***tht=NULL,***sit=NULL,***cot=NULL; \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         "}
{"label": " \nvoid THNN_(SpatialConvolutionLocal_updateGradInput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *gradOutput, \n    THTensor *gradInput, \n    THTensor *weight, \n    THTensor *finput, \n    THTensor *fgradInput, \n    int kW, int kH, \n    int dW, int dH, \n    int padW, int padH, \n    long inputWidth, long inputHeight, \n    long outputWidth, long outputHeight) \n{ \n  int freeWeight = THNN_(view_weight_local)(&weight); \n \n  THNN_(SpatialConvolutionLocal_shapeCheck) \n    (input, gradOutput, weight, NULL, kH, kW, dH, dW, padH, padW, \n     inputHeight, inputWidth, outputHeight, outputWidth); \n \n  input = THTensor_(newContiguous)(input); \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n  long nInputPlane = THTensor_(size)(weight,2)/(kW*kH); \n  long nOutputPlane = THTensor_(size)(weight,1); \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(resizeAs)(fgradInput, finput); \n  THTensor_(transpose)(weight, weight, 1, 2); \n \n  if(input->nDimension == 3) \n  { \n    THNN_(SpatialConvolutionLocal_updateGradInput_frame) \n      (gradInput, gradOutput, weight, \n       fgradInput, kW, kH, dW, dH, padW, padH, \n       nInputPlane, inputWidth, inputHeight, \n       nOutputPlane, outputWidth, outputHeight); \n  } \n  else \n  { \n    long T = input->size[0]; \n    long t; \n \n#pragma omp parallel for private(t) \n    for(t = 0; t < T; t++) \n    { \n      THTensor *gradInput_t = THTensor_(newSelect)(gradInput, 0, t); \n      THTensor *gradOutput_t = THTensor_(newSelect)(gradOutput, 0, t); \n      THTensor *fgradInput_t = THTensor_(newSelect)(fgradInput, 0, t); \n \n      THNN_(SpatialConvolutionLocal_updateGradInput_frame) \n\t(gradInput_t, gradOutput_t, weight, fgradInput_t, \n\t kW, kH, dW, dH, padW, padH, \n\t nInputPlane, inputWidth, inputHeight, \n\t nOutputPlane, outputWidth, outputHeight); \n \n      THTensor_(free)(gradInput_t); \n      THTensor_(free)(gradOutput_t); \n      THTensor_(free)(fgradInput_t); \n    } \n  } \n \n  THTensor_(transpose)(weight, weight, 1, 2); \n \n  THTensor_(free)(input); \n  THTensor_(free)(gradOutput); \n  if (freeWeight) \n    THTensor_(free)(weight); \n \n} ", "pred": " \nvoid THNN_(SpatialConvolutionLocal_updateGradInput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *gradOutput, \n    THTensor *gradInput, \n    THTensor *weight, \n    THTensor *finput, \n    THTensor *fgradInput, \n    int kW, int kH, \n    int dW, int dH, \n    int padW, int padH, \n    long inputWidth, long inputHeight, \n    long outputWidth, long outputHeight) \n{ \n  int freeWeight = THNN_(view_weight_local)(&weight); \n \n  THNN_(SpatialConvolutionLocal_shapeCheck) \n    (input, gradOutput, weight, NULL, kH, kW, dH, dW, padH, padW, \n     inputHeight, inputWidth, outputHeight, outputWidth); \n \n  input = THTensor_(newContiguous)(input); \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n  long nInputPlane = THTensor_(size)(weight,2)/(kW*kH); \n  long nOutputPlane = THTensor_(size)(weight,1); \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(resizeAs)(fgradInput, finput); \n  THTensor_(transpose)(weight, weight, 1, 2); \n \n  if(input->nDimension == 3) \n  { \n    THNN_(SpatialConvolutionLocal_updateGradInput_frame) \n      (gradInput, gradOutput, weight, \n       fgradInput, kW, kH, dW, dH, padW, padH, \n       nInputPlane, inputWidth, inputHeight, \n       nOutputPlane, outputWidth, outputHeight); \n  } \n  else \n  { \n    long T = input->size[0]; \n    long t; \n \n#pragma omp parallel for private(t) \n    for(t = 0; t < T; t++) \n    { \n      THTensor *gradInput_t = THTensor_(newContiguous)(gradInput, input);                                                                                                                                                                                                                                                                                                         "}
{"label": " \nvoid x_solve() \n{ \n  int i, j, k, m, n, isize; \n \n   \n \n   \n \n \n  if (timeron) timer_start(t_xsolve); \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n  isize = grid_points[0]-1; \n \n   \n \n   \n \n   \n \n #pragma scop \n  #pragma omp parallel for default(shared) shared(isize) private(i,j,k,m,n) \n  for (k = 1; k <= grid_points[2]-2; k++) { \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      for (i = 0; i <= isize; i++) { \n        tmp1 = rho_i[k][j][i]; \n        tmp2 = tmp1 * tmp1; \n        tmp3 = tmp1 * tmp2; \n         \n \n         \n \n         \n \n        fjac[i][0][0] = 0.0; \n        fjac[i][1][0] = 1.0; \n        fjac[i][2][0] = 0.0; \n        fjac[i][3][0] = 0.0; \n        fjac[i][4][0] = 0.0; \n \n        fjac[i][0][1] = -(u[k][j][i][1] * tmp2 * u[k][j][i][1]) \n          + c2 * qs[k][j][i]; \n        fjac[i][1][1] = ( 2.0 - c2 ) * ( u[k][j][i][1] / u[k][j][i][0] ); \n        fjac[i][2][1] = - c2 * ( u[k][j][i][2] * tmp1 ); \n        fjac[i][3][1] = - c2 * ( u[k][j][i][3] * tmp1 ); \n        fjac[i][4][1] = c2; \n \n        fjac[i][0][2] = - ( u[k][j][i][1]*u[k][j][i][2] ) * tmp2; \n        fjac[i][1][2] = u[k][j][i][2] * tmp1; \n        fjac[i][2][2] = u[k][j][i][1] * tmp1; \n        fjac[i][3][2] = 0.0; \n        fjac[i][4][2] = 0.0; \n \n        fjac[i][0][3] = - ( u[k][j][i][1]*u[k][j][i][3] ) * tmp2; \n        fjac[i][1][3] = u[k][j][i][3] * tmp1; \n        fjac[i][2][3] = 0.0; \n        fjac[i][3][3] = u[k][j][i][1] * tmp1; \n        fjac[i][4][3] = 0.0; \n \n        fjac[i][0][4] = ( c2 * 2.0 * square[k][j][i] - c1 * u[k][j][i][4] ) \n          * ( u[k][j][i][1] * tmp2 ); \n        fjac[i][1][4] = c1 *  u[k][j][i][4] * tmp1  \n          - c2 * ( u[k][j][i][1]*u[k][j][i][1] * tmp2 + qs[k][j][i] ); \n        fjac[i][2][4] = - c2 * ( u[k][j][i][2]*u[k][j][i][1] ) * tmp2; \n        fjac[i][3][4] = - c2 * ( u[k][j][i][3]*u[k][j][i][1] ) * tmp2; \n        fjac[i][4][4] = c1 * ( u[k][j][i][1] * tmp1 ); \n \n        njac[i][0][0] = 0.0; \n        njac[i][1][0] = 0.0; \n        njac[i][2][0] = 0.0; \n        njac[i][3][0] = 0.0; \n        njac[i][4][0] = 0.0; \n \n        njac[i][0][1] = - con43 * c3c4 * tmp2 * u[k][j][i][1]; \n        njac[i][1][1] =   con43 * c3c4 * tmp1; \n        njac[i][2][1] =   0.0; \n        njac[i][3][1] =   0.0; \n        njac[i][4][1] =   0.0; \n \n        njac[i][0][2] = - c3c4 * tmp2 * u[k][j][i][2]; \n        njac[i][1][2] =   0.0; \n        njac[i][2][2] =   c3c4 * tmp1; \n        njac[i][3][2] =   0.0; \n        njac[i][4][2] =   0.0; \n \n        njac[i][0][3] = - c3c4 * tmp2 * u[k][j][i][3]; \n        njac[i][1][3] =   0.0; \n        njac[i][2][3] =   0.0; \n        njac[i][3][3] =   c3c4 * tmp1; \n        njac[i][4][3] =   0.0; \n \n        njac[i][0][4] = - ( con43 * c3c4 \n            - c1345 ) * tmp3 * (u[k][j][i][1]*u[k][j][i][1]) \n          - ( c3c4 - c1345 ) * tmp3 * (u[k][j][i][2]*u[k][j][i][2]) \n          - ( c3c4 - c1345 ) * tmp3 * (u[k][j][i][3]*u[k][j][i][3]) \n          - c1345 * tmp2 * u[k][j][i][4];", "pred": " \nvoid x_solve() \n{ \n  int i, j, k, m, n, isize; \n \n   \n \n   \n \n \n  if (timeron) timer_start(t_xsolve); \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n  isize = grid_points[0]-1; \n \n   \n \n   \n \n   \n \n #pragma scop \n  #pragma omp parallel for default(shared) shared(isize) private(i,j,k,m,n) \n  for (k = 1; k <= grid_points[2]-2; k++) { \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      for (i = 0; i <= isize; i++) { \n        tmp1 = rho_i[k][j][i]; \n        tmp2 = tmp1 * tmp1; \n        tmp3 = tmp1 * tmp2; \n         \n \n         \n \n         \n \n        fjac[i][0][0] = 0.0; \n        fjac[i][1][0] = 1.0; \n        fjac[i][2][0] = 0.0; \n        fjac[i][3][0] = 0.0; \n        fjac[i][4][0] = 0.0; \n \n        fjac[i][0][1] = -(u[k][j][i][1] * tmp2 * u[k][j][i][1]) \n          + c2 * qs[k][j][i]; \n        fjac[i][1][1] = ( 2.0 - c2 ) * ( u[k][j][i][1] / u[k][j][i][0] ); \n        fjac[i][2][1] = - c2 * ( u[k][j][i][2] * tmp3 * u[k][j][i][2] * u[k][j][i][3] );\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \nvoid dt_histogram_worker(dt_dev_histogram_collection_params_t *const histogram_params, \n                         dt_dev_histogram_stats_t *histogram_stats, const void *const pixel, \n                         uint32_t **histogram, const dt_worker Worker) \n{ \n  const int nthreads = omp_get_max_threads(); \n \n  const size_t bins_total = (size_t)4 * histogram_params->bins_count; \n  const size_t buf_size = bins_total * sizeof(uint32_t); \n  void *partial_hists = calloc(nthreads, buf_size); \n \n  if(histogram_params->mul == 0) histogram_params->mul = (double)(histogram_params->bins_count - 1); \n \n  const dt_histogram_roi_t *const roi = histogram_params->roi; \n \n#pragma omp parallel for schedule(static) default(none) shared(partial_hists) \n  for(int j = roi->crop_y; j < roi->height - roi->crop_height; j++) \n  { \n    uint32_t *thread_hist = (uint32_t *)partial_hists + bins_total * omp_get_thread_num(); \n    Worker(histogram_params, pixel, thread_hist, j); \n  } \n \n  *histogram = realloc(*histogram, buf_size); \n  memset(*histogram, 0, buf_size); \n  uint32_t *hist = *histogram; \n \n#pragma omp parallel for schedule(static) default(none) shared(hist, partial_hists) \n  for(size_t k = 0; k < bins_total; k++) \n  { \n    for(size_t n = 0; n < nthreads; n++) \n    { \n      const uint32_t *thread_hist = (uint32_t *)partial_hists + bins_total * n; \n      hist[k] += thread_hist[k]; \n    } \n  } \n  *histogram = realloc(*histogram, buf_size); \n  memmove(*histogram, partial_hists, buf_size); \n  free(partial_hists); \n \n  histogram_stats->bins_count = histogram_params->bins_count; \n  histogram_stats->pixels = (roi->width - roi->crop_width - roi->crop_x) \n                            * (roi->height - roi->crop_height - roi->crop_y); \n} ", "pred": " \nvoid dt_histogram_worker(dt_dev_histogram_collection_params_t *const histogram_params, \n                         dt_dev_histogram_stats_t *histogram_stats, const void *const pixel, \n                         uint32_t **histogram, const dt_worker Worker) \n{ \n  const int nthreads = omp_get_max_threads(); \n \n  const size_t bins_total = (size_t)4 * histogram_params->bins_count; \n  const size_t buf_size = bins_total * sizeof(uint32_t); \n  void *partial_hists = calloc(nthreads, buf_size); \n \n  if(histogram_params->mul == 0) histogram_params->mul = (double)(histogram_params->bins_count - 1); \n \n  const dt_histogram_roi_t *const roi = histogram_params->roi; \n \n#pragma omp parallel for schedule(static) default(none) shared(partial_hists) \n  for(int j = roi->crop_y; j < roi->height - roi->crop_height; j++) \n  { \n    uint32_t *thread_hist = (uint32_t *)partial_hists + bins_total * omp_get_thread_num(); \n    Worker(histogram_params, pixel, thread_hist, j); \n  } \n \n  *histogram = realloc(*histogram, buf_size); \n  memset(*histogram, 0, buf_size); \n  uint32_t *hist = *histogram; \n \n#pragma omp parallel for schedule(static) default(none) shared(hist, partial_hists) \n  for(size_t k = 0; k < bins_total; k++) \n  { \n    for(size_t n = 0; n < nthreads; n++) \n    { \n      const uint32_t *thread_hist = (uint32_t *)partial_hists + bins_total * n; \n      hist[k] += thread_hist[k]; \n    } \n  }                                                                                                                                                           "}
{"label": " \nstatic void cracker_core(uint64_t range_start, uint64_t range_end, uint64_t range_offs, uint64_t priv_key_shadow[4], \n                         uint32_t *longest_match, uint8_t hex_prefix[MAX_CRACK_BYTES], size_t prefix_chars_len) \n{ \n    #pragma omp parallel for firstprivate(priv_key_shadow) shared(longest_match, range_start, range_end, range_offs, hex_prefix, prefix_chars_len) schedule(static) default(none) \n \n    for (uint64_t batch = range_start; batch < range_end; ++batch) { \n        uint8_t *priv_key = (uint8_t *) priv_key_shadow; \n         \n \n        uint64_t *counter = priv_key_shadow + 2; \n         \n \n        *counter += batch + range_offs; \n        uint8_t pub_key[KEY_LEN] = {0}; \n \n        crypto_scalarmult_curve25519_base(pub_key, priv_key); \n \n        const unsigned matching = (unsigned) match_hex_prefix(pub_key, hex_prefix, prefix_chars_len); \n \n         \n \n        uint32_t l_longest_match; \n        #pragma omp atomic read \n        l_longest_match = *longest_match; \n \n        if (matching > l_longest_match) { \n            #pragma omp atomic write \n            *longest_match = matching; \n \n            #pragma omp critical \n            { \n                printf(\"%u chars matching: \\n\", matching); \n                printf(\"Public key: \"); \n                print_key(pub_key); \n                printf(\"\\nSecret key: \"); \n                print_key(priv_key); \n                printf(\"\\n\"); \n            } \n        } \n    } \n} ", "pred": " \nstatic void cracker_core(uint64_t range_start, uint64_t range_end, uint64_t range_offs, uint64_t priv_key_shadow[4], \n                         uint32_t *longest_match, uint8_t hex_prefix[MAX_CRACK_BYTES], size_t prefix_chars_len) \n{ \n    #pragma omp parallel for firstprivate(priv_key_shadow) shared(longest_match, range_start, range_end, range_offs, hex_prefix, prefix_chars_len) schedule(static) default(none) \n \n    for (uint64_t batch = range_start; batch < range_end; ++batch) { \n        uint8_t *priv_key = (uint8_t *) priv_key_shadow; \n         \n \n        uint64_t *counter = priv_key_shadow + 2; \n         \n \n        *counter += batch + range_offs; \n        uint8_t pub_key[KEY_LEN] = {0}; \n \n        crypto_scalarmult_curve25519_base(pub_key, priv_key); \n \n        const unsigned matching = (unsigned) match_hex_prefix(pub_key, hex_prefix, prefix_chars_len); \n \n         \n \n        uint32_t l_longest_match; \n        #pragma omp atomic read \n        l_longest_match = *longest_match; \n \n        if (matching > l_longest_match) { \n            #pragma omp atomic write \n            *longest_match = matching; \n \n            #pragma omp critical \n            { \n                printf(\"%u chars matching: \\n\", matching); \n{\"\\n                                                                                                                                                       "}
{"label": "int\tlp; \n \n  #pragma omp parallel for \n  for (lp=0; 0 ==!(lp<thds); lp++) { \n    buf[lp] += omp_get_num_threads (); \n  } \n} \n \n \nmain () \n{ \n  thds = omp_ ", "pred": "int\tlp; \n \n  #pragma omp parallel for \n  for (lp=0; 0 ==!(lp<thds); lp++) { \n    buf[lp] += omp_get_num_threads (); \n  } \n} \n \n \nmain () \n{ \n  thds = omp_ "}
{"label": "tatic int dt_ellipse_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                   dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start1 = dt_get_wtime(); \n  double start2 = start1; \n \n   \n \n  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form->points)->data); \n  const int wi = piece->pipe->iwidth, hi = piece->pipe->iheight; \n  const float center[2] = { ellipse->center[0] * wi, ellipse->center[1] * hi }; \n  const float radius[2] = { ellipse->radius[0] * MIN(wi, hi), ellipse->radius[1] * MIN(wi, hi) }; \n  const float total[2] = { (ellipse->flags & DT_MASKS_ELLIPSE_PROPORTIONAL? ellipse->radius[0] * (1.0f + ellipse->border) : ellipse->radius[0] + ellipse->border) * MIN(wi, hi), \n                           (ellipse->flags & DT_MASKS_ELLIPSE_PROPORTIONAL? ellipse->radius[1] * (1.0f + ellipse->border) : ellipse->radius[1] + ellipse->border) * MIN(wi, hi) }; \n \n  const float a = radius[0]; \n  const float b = radius[1]; \n  const float ta = total[0]; \n  const float tb = total[1]; \n  const float alpha = (ellipse->rotation / 180.0f) * M_PI; \n  const float cosa = cosf(alpha); \n  const float sina = sinf(alpha); \n \n  const float a2 = a * a; \n  const float b2 = b * b; \n  const float ta2 = ta * ta; \n  const float tb2 = tb * tb; \n \n   \n \n   \n \n  const int w = roi->width; \n  const int h = roi->height; \n  const int px = roi->x; \n  const int py = roi->y; \n  const float iscale = 1.0f / roi->scale; \n  const int grid = CLAMP((10.0f * roi->scale + 2.0f) / 3.0f, 1, 4);  \n \n  const int gw = (w + grid - 1) / grid + 1;   \n \n  const int gh = (h + grid - 1) / grid + 1;   \n \n \n   \n \n  memset(buffer, 0, sizeof(float) * w * h); \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] ellipse init took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n   \n \n  const float lambda = (ta - tb) / (ta + tb); \n  const int l = (int)(M_PI * (ta + tb) * (1.0f + (3.0f * lambda * lambda) / (10.0f + sqrtf(4.0f - 3.0f * lambda * lambda)))); \n  const size_t ellpts = MIN(360, l); \n  float *ell = dt_alloc_align_float(ellpts * 2); \n  if(ell == NULL) return 0; \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(ellpts, center, ta, tb, cosa, sina)    shared(ell) \n#pragma omp parallel for shared(points) \n  for(int n = 0; n < ellpts; n++) \n  { \n    const float phi = (2.0f * M_PI * n) / ellpts; \n    const float cosp = cosf(phi); \n    const float sinp = sinf(phi); \n    ell[2 * n] = center[0] + ta * cosa * cosp - tb * sina * sinp; \n    ell[2 * n + 1] = center[1] + ta * sina * cosp + tb * cosa * sinp; \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] ellipse outline took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n  if(!dt_dev_distort_transform_plus(module->dev, piece->pipe, module->iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, ell, \n                                        ellpts)) \n  { \n    dt_free_align(ell); \n    return 0; \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] ellipse outline transform took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n  float xmin = FLT_MAX, ymin = FLT_MAX, xmax = FLT_MIN, ymax = FLT_MIN; \n  for(int n = 0; n < ellpts; n++) \n  { \n     \n \n    if(!(isnormal(ell[2 * n]) && isnormal(ell[2 * n + 1]))) continue; \n \n    xmin = MIN(xmin, ell[2 * n]); \n    xmax = MAX(xmax, ell[2 * n]); \n    ymin = MIN(ymin, ell[2 * n + 1]); \n    ymax = MAX(ymax, ell[2 * n + 1]); \n  } \n \n  printf(\"xmin %f, xmax %f, ymin %f, ymax %f\\n\", xmin, xmax, ymin, ymax); \n  printf(\"wi %d, hi %d, iscale %f\\n\", wi, hi, iscale); \n  printf(\"w %d, h %d, px %d, py %d\\n\", w, h, px, py); \n \n   \n \n  const int bbxm = CLAMP((int)floorf(xmin / iscale - px) / grid - 1, 0, gw - 1); \n  const int bbXM = CLAMP((int)ceilf(xmax / iscale - px) / grid + 2, 0, gw - 1); \n  const int bbym = CLAMP((int)floorf(ymin / iscale - py) / grid - 1, 0, gh - 1); \n  const int bbYM = CLAMP((int)ceilf(ymax / iscale - py) / grid + 2, 0, gh - 1); \n  const int bbw = bbXM - bbxm + 1; \n  const int b", "pred": "tatic int dt_ellipse_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                   dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start1 = dt_get_wtime(); \n  double start2 = start1; \n \n   \n \n  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form->points)->data); \n  const int wi = piece->pipe->iwidth, hi = piece->pipe->iheight; \n  const float center[2] = { ellipse->center[0] * wi, ellipse->center[1] * hi }; \n  const float radius[2] = { ellipse->radius[0] * MIN(wi, hi), ellipse->radius[1] * MIN(wi, hi) }; \n  const float total[2] = { (ellipse->flags & DT_MASKS_ELLIPSE_PROPORTIONAL? ellipse->radius[0] * (1.0f + ellipse->border) : ellipse->radius[0] + ellipse->border) * MIN(wi, hi), \n                           (ellipse->flags & DT_MASKS_ELLIPSE_PROPORTIONAL? ellipse->radius[1] * (1.0f + ellipse->border) : ellipse->radius[1] + ellipse->border) * MIN(wi, hi) }; \n \n  const float a = radius[0]; \n  const float b = radius[1]; \n  const float ta = total[0]; \n  const float tb = total[1]; \n  const float alpha = (ellipse->rotation / 180.0f) * M_PI; \n  const float cosa = cosf(alpha); \n  const float sina = sinf(alpha); \n \n  const float a2 = a * a; \n  const float b2 = b * b; \n  const float ta2 = ta * ta; \n{\"\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nstatic void process_common_cleanup(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                   const void *const ivoid, void *const ovoid, \n                                   const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_zonesystem_data_t *d = (dt_iop_zonesystem_data_t *)piece->data; \n  dt_iop_zonesystem_gui_data_t *g = (dt_iop_zonesystem_gui_data_t *)self->gui_data; \n \n  const int width = roi_out->width; \n  const int height = roi_out->height; \n  const int ch = piece->colors; \n  const int size = d->params.size; \n \n  if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, width, height); \n \n   \n \n  if(self->dev->gui_attached \n     && (piece->pipe->type & DT_DEV_PIXELPIPE_PREVIEW) == DT_DEV_PIXELPIPE_PREVIEW \n     && g && g->in_preview_buffer \n     && g->out_preview_buffer) \n  { \n    float Lmax[] = { 100.0f }; \n    float Lmin[] = { 0.0f }; \n \n     \n \n    const int radius = 8; \n    const float sigma = 2.5 * (radius * roi_in->scale / piece->iscale); \n \n    dt_gaussian_t *gauss = dt_gaussian_init(width, height, 1, Lmax, Lmin, sigma, DT_IOP_GAUSSIAN_ZERO); \n \n    float *tmp = g_malloc_n((size_t)width * height, sizeof(float)); \n \n    if(gauss && tmp) \n    { \n#pragma omp parallel for default(none)        dt_omp_firstprivate(ch, height, width, ivoid)        shared(tmp)        schedule(static) \n      for(size_t k = 0; k < (size_t)width * height; k++) tmp[k] = ((float *)ivoid)[ch * k]; \n \n      dt_gaussian_blur(gauss, tmp, tmp); \n \n       \n \n      dt_pthread_mutex_lock(&g->lock); \n#pragma omp parallel for default(none)        dt_omp_firstprivate(height, size, width)        shared(tmp, g)        schedule(static) \n      for(size_t k = 0; k < (size_t)width * height; k++) \n      { \n        g->in_preview_buffer[k] = CLAMPS(tmp[k] * (size - 1) / 100.0f, 0, size - 2); \n      } \n      dt_pthread_mutex_unlock(&g->lock); \n \n \n#pragma omp parallel for default(none)        dt_omp_firstprivate(ch, height, ovoid, width)        shared(tmp)        schedule(static) \n      for(size_t k = 0; k < (size_t)width * height; k++) tmp[k] = ((float *)ovoid)[ch * k]; \n \n      dt_gaussian_blur(gauss, tmp, tmp); \n \n \n       \n \n      dt_pthread_mutex_lock(&g->lock); \n#pragma omp parallel for default(none)        dt_omp_firstprivate(height, size, width)        shared(tmp, g)        schedule(static) \n      for(size_t k = 0; k < (size_t)width * height; k++) \n      { \n        g->out_preview_buffer[k] = CLAMPS(tmp[k] * (size - 1) / 100.0f, 0, size - 2); \n      } \n      dt_pthread_mutex_unlock(&g->lock); \n    } \n \n    g_free(tmp); \n    if(gauss) dt_gaussian_free(gauss); \n  } \n} ", "pred": " \nstatic void process_common_cleanup(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                   const void *const ivoid, void *const ovoid, \n                                   const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_zonesystem_data_t *d = (dt_iop_zonesystem_data_t *)piece->data; \n  dt_iop_zonesystem_gui_data_t *g = (dt_iop_zonesystem_gui_data_t *)self->gui_data; \n \n  const int width = roi_out->width; \n  const int height = roi_out->height; \n  const int ch = piece->colors; \n  const int size = d->params.size; \n \n  if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, width, height); \n \n   \n \n  if(self->dev->gui_attached \n     && (piece->pipe->type & DT_DEV_PIXELPIPE_PREVIEW) == DT_DEV_PIXELPIPE_PREVIEW \n     && g && g->in_preview_buffer \n     && g->out_preview_buffer) \n  { \n    float Lmax[] = { 100.0f }; \n    float Lmin[] = { 0.0f }; \n \n     \n \n    const int radius = 8; \n    const float sigma = 2.5 * (radius * roi_in->scale / piece->iscale); \n \n    dt_gaussian_t *gauss = dt_gaussian_init(width, height, 1, Lmax, Lmin, sigma, DT_IOP_GAUSSIAN_ZERO); \n \n    float *tmp = g_malloc_n((size_t)width, size_t);\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "}
{"label": "tatic void scale_restricted_range(struct raw_info * raw_info, uint16_t * image_data) \n{ \n    uint32_t pixel_count = raw_info->width * raw_info->height; \n     \n \n    int32_t min_level = image_data[0]; \n    int32_t max_level = image_data[0]; \n    for(uint32_t i = 1; i < pixel_count; ++i) \n    { \n        if(image_data[i] < min_level) min_level = image_data[i]; \n        if(image_data[i] > max_level) max_level = image_data[i]; \n    } \n    printf(\"min_level = %d, max_level = %d\\n\", min_level, max_level); \n    raw_info->black_level = MAX(min_level, raw_info->black_level); \n    raw_info->white_level = MAX(max_level, raw_info->white_level); \n \n    int32_t scaled_white_level = 16200; \n    double scale_ratio = (double)(scaled_white_level - raw_info->black_level) / (double)(raw_info->white_level - raw_info->black_level); \n    raw_info->white_level = scaled_white_level; \n \n#pragma omp parallel for \n    for(uint32_t i = 0; i < pixel_count; ++i) \n    { \n        image_data[i] = MIN( (uint16_t)((double)((image_data[i] - raw_info->black_level) * scale_ratio + raw_info->black_level) + 0.5), 16383); \n    } \n} \n \n ", "pred": "tatic void scale_restricted_range(struct raw_info * raw_info, uint16_t * image_data) \n{ \n    uint32_t pixel_count = raw_info->width * raw_info->height; \n     \n \n    int32_t min_level = image_data[0]; \n    int32_t max_level = image_data[0]; \n    for(uint32_t i = 1; i < pixel_count; ++i) \n    { \n        if(image_data[i] < min_level) min_level = image_data[i]; \n        if(image_data[i] > max_level) max_level = image_data[i]; \n    } \n    printf(\"min_level = %d, max_level = %d\\n\", min_level, max_level); \n    raw_info->black_level = MAX(min_level, raw_info->black_level); \n    raw_info->white_level = MAX(max_level, raw_info->white_level); \n \n    int32_t scaled_white_level = 16200; \n    double scale_ratio = (double)(scaled_white_level - raw_info->black_level) / (double)(raw_info->white_level - raw_info->black_level); \n    raw_info->white_level = scaled_white_level; \n \n#pragma omp parallel for \n    for(uint32_t i = 0; i < pixel_count; ++i) \n    { \n        image_data[i] = MIN( (uint16_t)((double)((image_data[i] - raw_info->black_level) * scale_ratio + raw_info->black_level) + 0.5), 16383); \n    } \n} \n \n "}
{"label": " \nMagickExport Image *RecolorImage(const Image *image,const unsigned long order, \n  const double *color_matrix,ExceptionInfo *exception) \n{ \n#define RecolorImageTag  \"Recolor/Image\" \n \n  Image \n    *recolor_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  register const double \n    *k; \n \n  ViewInfo \n    **image_view, \n    **recolor_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  recolor_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (recolor_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(recolor_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&recolor_image->exception); \n      recolor_image=DestroyImage(recolor_image); \n      return((Image *) NULL); \n    } \n  if (image->debug!= MagickFalse) \n    { \n      char \n        format[MaxTextExtent], \n        *message; \n \n      long \n        u, \n        v; \n \n      (void) LogMagickEvent(TransformEvent,GetMagickModule(), \n        \"  Recolor image with %ldx%ld color matrix:\",order,order); \n      message=AcquireString(\"\"); \n      k=color_matrix; \n      for (v=0; v < (long) order; v++) \n      { \n        *message='\\0'; \n        (void) FormatMagickString(format,MaxTextExtent,\"%ld: \",v); \n        (void) ConcatenateString(&message,format); \n        for (u=0; u < (long) order; u++) \n        { \n          (void) FormatMagickString(format,MaxTextExtent,\"%+f \",*k++); \n          (void) ConcatenateString(&message,format); \n        } \n        (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"%s\",message); \n      } \n      message=DestroyString(message); \n    } \n   \n \n  status=MagickTrue; \n  k=color_matrix; \n  image_view=AcquireCacheViewThreadSet(image); \n  recolor_view=AcquireCacheViewThreadSet(recolor_image); \n  #pragma omp parallel for \n  for (y=0; y < (long) image->rows; y++) \n  { \n    MagickPixelPacket \n      pixel, \n      recolor_pixel; \n \n    register const IndexPacket \n      *indexes; \n \n    register const PixelPacket \n      *p; \n \n    register long \n      id, \n      x; \n \n    register IndexPacket \n      *recolor_indexes; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    p=AcquireCacheViewPixels(image_view[id],0,y,image->columns,1,exception); \n    q=GetCacheViewPixels(recolor_view[id],0,y,recolor_image->columns,1); \n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewIndexes(image_view[id]); \n    recolor_indexes=GetCacheViewIndexes(recolor_view[id]); \n    GetMagickPixelPacket(image,&pixel); \n    GetMagickPixelPacket(image,&recolor_pixel); \n    for (x=0; x < (long) image->columns; x++) \n    { \n      SetMagickPixelPacket(image,p,indexes,&pixel); \n      SetMagickPixelPacket(recolor_image,p,indexes,&recolor_pixel); \n      switch (order) \n      { \n        case 0: \n          break; \n        case 1: \n        { \n          recolor_pixel.red=k[0]*pixel.red; \n          break; \n        } \n        case 2: \n        { \n          recolor_pixel.red=k[0]*pixel.red+k[1]*pixel.green; \n          recolor_pixel.green=k[2]*pixel.red+k[3]*pixel.green; \n          break; \n        } \n        case 3: \n        { \n          recolor_pixel.red=k[0]*pixel.red+k[1]*pixel.green+k[2]*pixel.blue; \n          recolor_pixel.green=k[3]*pixel.red+k[4]*pixel.green+k[5]*pixel.blue; \n          recolor_pixel.blue=k[6]*pixel.red+k[7]*pixel.green+k[8]*pixel.blue; \n          break; \n        } \n        case 4: \n        { \n          recolor_pixel.red=k[0]*pixel.red+k[1]*pixel.green+k[2]*pixel.blue+ \n            k[12]*QuantumRange; \n          recolor_pixel.green=k[4]*pixel.red+k[5]*pixel.green+k[6]*pixel.blue+ \n            k[13]*QuantumRange; \n          recolor_pixel.blue=k[8]*pixel.red+k[9]*pixel.green+k[10]*pixel.blue+ \n            k[14]*QuantumRange; \n    ", "pred": " \nMagickExport Image *RecolorImage(const Image *image,const unsigned long order, \n  const double *color_matrix,ExceptionInfo *exception) \n{ \n#define RecolorImageTag  \"Recolor/Image\" \n \n  Image \n    *recolor_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  register const double \n    *k; \n \n  ViewInfo \n    **image_view, \n    **recolor_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  recolor_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (recolor_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(recolor_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&recolor_image->exception); \n      recolor_image=DestroyImage(recolor_image); \n      return((Image *) NULL); \n    } \n  if (image->debug!= MagickFalse) \n    { \n      char \n        format[MaxTextExtent], \n        *message; \n \n      long \n        u, \n        v; \n \n      (void) LogMagickEvent(TransformEvent,GetMagickModule(), \n        \"  Recolor image with %ldx%ld color matrix:\",order,order); \n      message=AcquireString(\"\"); \n      k=color_matrix; \n      for (v=0; v < (long) order; v++) \n      { \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           "}
{"label": " \nvoid prefix_sums(LONG_T *input, LONG_T* result, LONG_T* p, LONG_T n) { \n     \n    LONG_T i; \n     \n    LONG_T j, r, start, end, add_value; \n    int tid, nthreads; \n \n    tid = omp_get_thread_num(); \n    nthreads = omp_get_num_threads(); \n    r = n/nthreads; \n \n    result[0] = 0; \n \n    #pragma omp for \n    for (i=1; i<n+1; i++) \n        result[i] = input[i-1]; \n \n    start =  tid*r + 1; \n    end   = (tid+1)*r; \n \n    if (tid == nthreads-1) \n        end = n+1; \n \n    for (j=start; j<end; j++) \n        result[j] = input[j-1] + result[j-1]; \n \n    p[tid] = result[end-1]; \n \n    #pragma omp barrier \n \n    if (tid == 0) { \n        for (j=1; j<nthreads; j++) \n            p[j] += p[j-1]; \n    } \n \n    #pragma omp barrier \n \n    if (tid>0) { \n        add_value=p[tid-1]; \n        for (j=start-1; j<end; j++) \n            result[j] += add_value; \n    } \n \n \n    result[0] = 0; \n    for (i=1; i<n+1; i++) { \n        result[i] = result[i-1] + input[i-1]; \n    } \n \n     \n} ", "pred": " \nvoid prefix_sums(LONG_T *input, LONG_T* result, LONG_T* p, LONG_T n) { \n     \n    LONG_T i; \n     \n    LONG_T j, r, start, end, add_value; \n    int tid, nthreads; \n \n    tid = omp_get_thread_num(); \n    nthreads = omp_get_num_threads(); \n    r = n/nthreads; \n \n    result[0] = 0; \n \n    #pragma omp for \n    for (i=1; i<n+1; i++) \n        result[i] = input[i-1]; \n \n    start =  tid*r + 1; \n    end   = (tid+1)*r; \n \n    if (tid == nthreads-1) \n        end = n+1; \n \n    for (j=start; j<end; j++) \n        result[j] = input[j-1] + result[j-1]; \n \n    p[tid] = result[end-1]; \n \n    #pragma omp barrier \n \n    if (tid == 0) { \n        for (j=1; j<nthreads; j++) \n            p[j] += p[j-1]; \n    } \n \n    #pragma omp barrier \n \n    if (tid>0) { \n        add_value=p[tid-1]; \n        for (j=start-1; j<end; j++) \n            result[j] += add_value; \n    } \n \n \n    result[0] = 0; \n    for (i=1; i<n+1; i++) { \n        result[i] = result[i-1] + input[i-1]; \n    } \n \n     \n} "}
{"label": " \nMagickExport Image *SwirlImage(const Image *image,double degrees, \n  ExceptionInfo *exception) \n{ \n#define SwirlImageTag  \"Swirl/Image\" \n \n  Image \n    *swirl_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    radius; \n \n  PointInfo \n    center, \n    scale; \n \n  ResampleFilter \n    **resample_filter; \n \n  ViewInfo \n    **image_view, \n    **swirl_view; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  swirl_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (swirl_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(swirl_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&swirl_image->exception); \n      swirl_image=DestroyImage(swirl_image); \n      return((Image *) NULL); \n    } \n  if (swirl_image->background_color.opacity!= OpaqueOpacity) \n    swirl_image->matte=MagickTrue; \n   \n \n  center.x=(double) image->columns/2.0; \n  center.y=(double) image->rows/2.0; \n  radius=MagickMax(center.x,center.y); \n  scale.x=1.0; \n  scale.y=1.0; \n  if (image->columns > image->rows) \n    scale.y=(double) image->columns/(double) image->rows; \n  else \n    if (image->columns < image->rows) \n      scale.x=(double) image->rows/(double) image->columns; \n  degrees=(double) DegreesToRadians(degrees); \n   \n \n  status=MagickTrue; \n  resample_filter=AcquireResampleFilterThreadSet(image,exception); \n  image_view=AcquireCacheViewThreadSet(image); \n  swirl_view=AcquireCacheViewThreadSet(swirl_image); \n  #pragma omp parallel for \n  for (y=0; y < (long) image->rows; y++) \n  { \n    MagickPixelPacket \n      pixel; \n \n    MagickRealType \n      distance; \n \n    PointInfo \n      delta; \n \n    register const IndexPacket \n      *indexes; \n \n    register const PixelPacket \n      *p; \n \n    register IndexPacket \n      *swirl_indexes; \n \n    register PixelPacket \n      *q; \n \n    register long \n      id, \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=GetCacheViewPixels(swirl_view[id],0,y,swirl_image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    swirl_indexes=GetCacheViewIndexes(swirl_view[id]); \n    delta.y=scale.y*(double) (y-center.y); \n    GetMagickPixelPacket(swirl_image,&pixel); \n    for (x=0; x < (long) image->columns; x++) \n    { \n       \n \n      delta.x=scale.x*(double) (x-center.x); \n      distance=delta.x*delta.x+delta.y*delta.y; \n      if (distance >= (radius*radius)) \n        { \n          p=AcquireCacheViewPixels(image_view[id],x,y,1,1,exception); \n          if (p == (const PixelPacket *) NULL) \n            break; \n          indexes=AcquireCacheViewIndexes(image_view[id]); \n          SetMagickPixelPacket(image,p,indexes,&pixel); \n        } \n      else \n        { \n          MagickRealType \n            cosine, \n            factor, \n            sine; \n \n           \n \n          factor=1.0-sqrt((double) distance)/radius; \n          sine=sin((double) (degrees*factor*factor)); \n          cosine=cos((double) (degrees*factor*factor)); \n          pixel=ResamplePixelColor(resample_filter[id],(double) ((cosine* \n            delta.x-sine*delta.y)/scale.x+center.x),(double) ((sine*delta.x+ \n            cosine*delta.y)/scale.y+center.y)); \n        } \n      SetPixelPacket(swirl_image,&pixel,q,swirl_indexes+x); \n      q++; \n    } \n    if (SyncCacheView(swirl_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,SwirlImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  swirl_view=DestroyCacheViewThreadSet(swirl_view); \n  image_view=DestroyCacheViewThreadSet(image_view); \n  resample_filter=DestroyResampleFilterThreadSet(resample_filter); \n  if (status == MagickFalse) \n    swirl_image=DestroyImage(swirl_image); \n  return(swirl_image); \n} ", "pred": " \nMagickExport Image *SwirlImage(const Image *image,double degrees, \n  ExceptionInfo *exception) \n{ \n#define SwirlImageTag  \"Swirl/Image\" \n \n  Image \n    *swirl_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    radius; \n \n  PointInfo \n    center, \n    scale; \n \n  ResampleFilter \n    **resample_filter; \n \n  ViewInfo \n    **image_view, \n    **swirl_view; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  swirl_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (swirl_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(swirl_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&swirl_image->exception); \n      swirl_image=DestroyImage(swirl_image); \n      return((Image *) NULL); \n    } \n  if (swirl_image->background_color.opacity!= OpaqueOpacity) \n    swirl_image->matte=MagickTrue; \n   \n \n  center.x=(double) image->columns/2.0; \n  center.y=(double) image->rows/2.0; \n  radius=MagickMax(center.x,center.y); \n  scale.x=1.0; \n  scale.y=1.0; \n  if (image->columns > image->rows) \n    scale.y=(double) image->columns/(double) image->rows; \n  else \n    if (image->columns < image->rows)   scale.y=(double) image->columns/(double) image->columns/2.0;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "}
{"label": " \nMagickExport Image *ColorizeImage(const Image *image,const char *opacity, \n  const PixelPacket colorize,ExceptionInfo *exception) \n{ \n#define ColorizeImageTag  \"Colorize/Image\" \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *colorize_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickPixelPacket \n    pixel; \n \n  MagickStatusType \n    flags; \n \n  ViewInfo \n    **colorize_view, \n    **image_view; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  colorize_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (colorize_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(colorize_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&colorize_image->exception); \n      colorize_image=DestroyImage(colorize_image); \n      return((Image *) NULL); \n    } \n  if (opacity == (const char *) NULL) \n    return(colorize_image); \n   \n \n  flags=ParseGeometry(opacity,&geometry_info); \n  pixel.red=geometry_info.rho; \n  pixel.green=geometry_info.rho; \n  pixel.blue=geometry_info.rho; \n  pixel.opacity=(MagickRealType) OpaqueOpacity; \n  if ((flags & SigmaValue)!= 0) \n    pixel.green=geometry_info.sigma; \n  if ((flags & XiValue)!= 0) \n    pixel.blue=geometry_info.xi; \n  if ((flags & PsiValue)!= 0) \n    pixel.opacity=geometry_info.psi; \n   \n \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(image); \n  colorize_view=AcquireCacheViewThreadSet(colorize_image); \n  #pragma omp parallel for \n  for (y=0; y < (long) image->rows; y++) \n  { \n    register const PixelPacket \n      *p; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    p=AcquireCacheViewPixels(image_view[id],0,y,image->columns,1,exception); \n    q=GetCacheViewPixels(colorize_view[id],0,y,colorize_image->columns,1); \n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (long) image->columns; x++) \n    { \n      q->red=(Quantum) ((p->red*(100.0-pixel.red)+ \n        colorize.red*pixel.red)/100.0); \n      q->green=(Quantum) ((p->green*(100.0-pixel.green)+ \n        colorize.green*pixel.green)/100.0); \n      q->blue=(Quantum) ((p->blue*(100.0-pixel.blue)+ \n        colorize.blue*pixel.blue)/100.0); \n      q->opacity=(Quantum) ((p->opacity*(100.0-pixel.opacity)+ \n        colorize.opacity*pixel.opacity)/100.0); \n      p++; \n      q++; \n    } \n    if (SyncCacheView(colorize_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,ColorizeImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  image_view=DestroyCacheViewThreadSet(image_view); \n  colorize_view=DestroyCacheViewThreadSet(colorize_view); \n  if (status == MagickFalse) \n    colorize_image=DestroyImage(colorize_image); \n  return(colorize_image); \n} ", "pred": " \nMagickExport Image *ColorizeImage(const Image *image,const char *opacity, \n  const PixelPacket colorize,ExceptionInfo *exception) \n{ \n#define ColorizeImageTag  \"Colorize/Image\" \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *colorize_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickPixelPacket \n    pixel; \n \n  MagickStatusType \n    flags; \n \n  ViewInfo \n    **colorize_view, \n    **image_view; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  colorize_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (colorize_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(colorize_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&colorize_image->exception); \n      colorize_image=DestroyImage(colorize_image); \n      return((Image *) NULL); \n    } \n  if (opacity == (const char *) NULL) \n    return(colorize_image); \n   \n \n  flags=ParseGeometry(opacity,&geometry_info); \n  pixel.red=geometry_info.rho; \n  pixel.green=geometry_info.rho; \n  pixel.blue=geometry_info.rho; \n  pixel.opacity=(MagickRealType) OpaqueOpacity; \n  if ((flags & SigmaValue)!= 0) \n    pixel.green=geometry_info.sigma; \n  if ((flags & XiValue)!= 0) \n    pixel.blue=geometry_info.sigma;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           "}
{"label": " \nMagickExport Image *FxImageChannel(const Image *image,const ChannelType channel, \n  const char *expression,ExceptionInfo *exception) \n{ \n#define FxImageTag  \"Fx/Image\" \n \n  FxInfo \n    **fx_info; \n \n  Image \n    *fx_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    alpha; \n \n  ViewInfo \n    **fx_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  fx_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (fx_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(fx_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&fx_image->exception); \n      fx_image=DestroyImage(fx_image); \n      return((Image *) NULL); \n    } \n  fx_info=AcquireFxThreadSet(image,expression,exception); \n  if (fx_info == (FxInfo **) NULL) \n    { \n      fx_image=DestroyImage(fx_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  status=FxEvaluateExpression(fx_info[0],&alpha,exception); \n  if (status == MagickFalse) \n    { \n      fx_image=DestroyImage(fx_image); \n      fx_info=DestroyFxThreadSet(fx_info); \n      return((Image *) NULL); \n    } \n  status=MagickTrue; \n  fx_view=AcquireCacheViewThreadSet(fx_image); \n  #pragma omp parallel for \n  for (y=0; y < (long) fx_image->rows; y++) \n  { \n    IndexPacket \n      *fx_indexes; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=GetCacheViewPixels(fx_view[id],0,y,fx_image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    fx_indexes=GetCacheViewIndexes(fx_view[id]); \n    for (x=0; x < (long) fx_image->columns; x++) \n    { \n      MagickRealType \n        alpha; \n \n      if ((channel & RedChannel)!= 0) \n        { \n          (void) FxEvaluateChannelExpression(fx_info[id],RedChannel,x,y, \n            &alpha,exception); \n          q->red=RoundToQuantum((MagickRealType) QuantumRange*alpha); \n        } \n      if ((channel & GreenChannel)!= 0) \n        { \n          (void) FxEvaluateChannelExpression(fx_info[id],GreenChannel,x,y, \n            &alpha,exception); \n          q->green=RoundToQuantum((MagickRealType) QuantumRange*alpha); \n        } \n      if ((channel & BlueChannel)!= 0) \n        { \n          (void) FxEvaluateChannelExpression(fx_info[id],BlueChannel,x,y, \n            &alpha,exception); \n          q->blue=RoundToQuantum((MagickRealType) QuantumRange*alpha); \n        } \n      if ((channel & OpacityChannel)!= 0) \n        { \n          (void) FxEvaluateChannelExpression(fx_info[id],OpacityChannel,x,y, \n            &alpha,exception); \n          if (image->matte == MagickFalse) \n            q->opacity=RoundToQuantum((MagickRealType) QuantumRange*alpha); \n          else \n            q->opacity=RoundToQuantum((MagickRealType) (QuantumRange- \n              QuantumRange*alpha)); \n        } \n      if (((channel & IndexChannel)!= 0) && \n          (fx_image->colorspace == CMYKColorspace)) \n        { \n          (void) FxEvaluateChannelExpression(fx_info[id],IndexChannel,x,y, \n            &alpha,exception); \n          fx_indexes[x]=(IndexPacket) RoundToQuantum((MagickRealType) \n            QuantumRange*alpha); \n        } \n      q++; \n    } \n    if (SyncCacheView(fx_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,FxImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  fx_image->matte=fx_info[0]->matte; \n  fx_view=DestroyCacheViewThreadSet(fx_view); \n  fx_info=DestroyFxThreadSet(fx_info); \n  if (status == MagickFalse) \n    fx_image=DestroyImage(fx_image); \n  return(fx_image); \n} ", "pred": " \nMagickExport Image *FxImageChannel(const Image *image,const ChannelType channel, \n  const char *expression,ExceptionInfo *exception) \n{ \n#define FxImageTag  \"Fx/Image\" \n \n  FxInfo \n    **fx_info; \n \n  Image \n    *fx_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    alpha; \n \n  ViewInfo \n    **fx_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  fx_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (fx_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(fx_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&fx_image->exception); \n      fx_image=DestroyImage(fx_image); \n      return((Image *) NULL); \n    } \n  fx_info=AcquireFxThreadSet(image,expression,exception); \n  if (fx_info == (FxInfo **) NULL) \n    { \n      fx_image=DestroyImage(fx_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  status=FxEvaluateExpression(fx_info[0],&alpha,exception); \n  if (status == MagickFalse) \n    { \n      fx_image=DestroyImage(fx_image); \n      fx_info=DestroyFxThreadSet(fx_info); \n      return((Image *) NULL); \n    } \n  status=MagickTrue; \n  fx_view=AcquireCacheViewThreadSet(fx_image); \n  #pragma omp parallel for ich_info->Add(\\\"image_info\\\",\\\"\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "}
{"label": "tatic void make_14bit(uint16_t * raw_image_buff, size_t raw_image_size, struct raw_info * raw_info) \n{ \n    uint32_t pixel_count = raw_image_size / 2; \n    int bits_shift = 14 - raw_info->bits_per_pixel; \n    raw_info->black_level <<= bits_shift; \n    raw_info->white_level <<= bits_shift; \n    raw_info->bits_per_pixel = 14; \n    raw_info->frame_size = raw_info->width * raw_info->height * 14 / 8; \n \n    #pragma omp parallel for \n    for(uint32_t i = 0; i < pixel_count; ++i) \n    { \n        raw_image_buff[i] <<= bits_shift; \n    } \n} \n \n ", "pred": "tatic void make_14bit(uint16_t * raw_image_buff, size_t raw_image_size, struct raw_info * raw_info) \n{ \n    uint32_t pixel_count = raw_image_size / 2; \n    int bits_shift = 14 - raw_info->bits_per_pixel; \n    raw_info->black_level <<= bits_shift; \n    raw_info->white_level <<= bits_shift; \n    raw_info->bits_per_pixel = 14; \n    raw_info->frame_size = raw_info->width * raw_info->height * 14 / 8; \n \n    #pragma omp parallel for \n    for(uint32_t i = 0; i < pixel_count; ++i) \n    { \n        raw_image_buff[i] <<= bits_shift; \n    } \n} \n \n "}
{"label": " \nMagickExport Image *SketchImage(const Image *image,const double radius, \n  const double sigma,const double angle,ExceptionInfo *exception) \n{ \n  Image \n    *blend_image, \n    *blur_image, \n    *dodge_image, \n    *random_image, \n    *sketch_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  ViewInfo \n    **random_view; \n \n   \n \n  random_image=CloneImage(image,image->columns << 1,image->rows << 1, \n    MagickTrue,exception); \n  if (random_image == (Image *) NULL) \n    return((Image *) NULL); \n  status=MagickTrue; \n  random_view=AcquireCacheViewThreadSet(random_image); \n  #pragma omp parallel for \n  for (y=0; y < (long) random_image->rows; y++) \n  { \n    MagickPixelPacket \n      pixel; \n \n    register IndexPacket \n      *indexes; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=SetCacheViewPixels(random_view[id],0,y,random_image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewIndexes(random_view[id]); \n    GetMagickPixelPacket(random_image,&pixel); \n    for (x=0; x < (long) random_image->columns; x++) \n    { \n      pixel.red=(MagickRealType) (QuantumRange*GetPseudoRandomValue()); \n      pixel.green=pixel.red; \n      pixel.blue=pixel.red; \n      if (image->colorspace == CMYKColorspace) \n        pixel.index=pixel.red; \n      SetPixelPacket(random_image,&pixel,q,indexes+x); \n      q++; \n    } \n    if (SyncCacheView(random_view[id]) == MagickFalse) \n      status=MagickFalse; \n  } \n  random_view=DestroyCacheViewThreadSet(random_view); \n  if (status == MagickFalse) \n    { \n      random_image=DestroyImage(random_image); \n      return(random_image); \n    } \n  blur_image=MotionBlurImage(random_image,radius,sigma,angle,exception); \n  random_image=DestroyImage(random_image); \n  if (blur_image == (Image *) NULL) \n    return((Image *) NULL); \n  dodge_image=EdgeImage(blur_image,radius,exception); \n  blur_image=DestroyImage(blur_image); \n  if (dodge_image == (Image *) NULL) \n    return((Image *) NULL); \n  (void) NormalizeImage(dodge_image); \n  (void) NegateImage(dodge_image,MagickFalse); \n  (void) TransformImage(&dodge_image,(char *) NULL,\"50%\"); \n  sketch_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (sketch_image == (Image *) NULL) \n    { \n      dodge_image=DestroyImage(dodge_image); \n      return((Image *) NULL); \n    } \n  (void) CompositeImage(sketch_image,ColorDodgeCompositeOp,dodge_image,0,0); \n  dodge_image=DestroyImage(dodge_image); \n  blend_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (blend_image == (Image *) NULL) \n    { \n      sketch_image=DestroyImage(sketch_image); \n      return((Image *) NULL); \n    } \n  blend_image->geometry=AcquireString(\"20x80\"); \n  (void) CompositeImage(sketch_image,BlendCompositeOp,blend_image,0,0); \n  blend_image=DestroyImage(blend_image); \n  return(sketch_image); \n} ", "pred": " \nMagickExport Image *SketchImage(const Image *image,const double radius, \n  const double sigma,const double angle,ExceptionInfo *exception) \n{ \n  Image \n    *blend_image, \n    *blur_image, \n    *dodge_image, \n    *random_image, \n    *sketch_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  ViewInfo \n    **random_view; \n \n   \n \n  random_image=CloneImage(image,image->columns << 1,image->rows << 1, \n    MagickTrue,exception); \n  if (random_image == (Image *) NULL) \n    return((Image *) NULL); \n  status=MagickTrue; \n  random_view=AcquireCacheViewThreadSet(random_image); \n  #pragma omp parallel for \n  for (y=0; y < (long) random_image->rows; y++) \n  { \n    MagickPixelPacket \n      pixel; \n \n    register IndexPacket \n      *indexes; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=SetCacheViewPixels(random_view[id],0,y,random_image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewIndexes(random_view[id]); \n    GetMagickPixelPacket(random_image,&pixel); \n    for (x=0; x < (long) random_image->columns; x++) \n    { \n      pixel.red=(MagickRealType) (QuantumRange*GetPseudoRandomValue()); \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_colormapping_data_t *data = (dt_iop_colormapping_data_t *)piece->data; \n  dt_iop_colormapping_gui_data_t *g = (dt_iop_colormapping_gui_data_t *)self->gui_data; \n  float *in = (float *)ivoid; \n  float *out = (float *)ovoid; \n \n  const int width = roi_in->width; \n  const int height = roi_in->height; \n  const int ch = piece->colors; \n \n  const float scale = piece->iscale / roi_in->scale; \n  const float sigma_s = 50.0f / scale; \n  const float sigma_r = 8.0f;  \n \n \n   \n \n  if(self->dev->gui_attached && g && piece->pipe->type == DT_DEV_PIXELPIPE_PREVIEW && (data->flag & ACQUIRE)) \n  { \n    dt_pthread_mutex_lock(&g->lock); \n    if(g->buffer) free(g->buffer); \n \n    g->buffer = malloc((size_t)width * height * ch * sizeof(float)); \n    g->width = width; \n    g->height = height; \n    g->ch = ch; \n \n    if(g->buffer) memcpy(g->buffer, in, (size_t)width * height * ch * sizeof(float)); \n \n    dt_pthread_mutex_unlock(&g->lock); \n  } \n \n   \n \n  if(data->flag & HAS_TARGET && data->flag & HAS_SOURCE) \n  { \n     \n \n \n    float dominance = data->dominance / 100.0f; \n    float equalization = data->equalization / 100.0f; \n \n     \n \n    int *const mapio = malloc(data->n * sizeof(int)); \n \n    get_cluster_mapping(data->n, data->target_mean, data->target_weight, data->source_mean, \n                        data->source_weight, dominance, mapio); \n \n    float(*const var_ratio)[2] = malloc(2 * data->n * sizeof(float)); \n \n    for(int i = 0; i < data->n; i++) \n    { \n      var_ratio[i][0] \n          = (data->target_var[i][0] > 0.0f)? data->source_var[mapio[i]][0] / data->target_var[i][0] : 0.0f; \n      var_ratio[i][1] \n          = (data->target_var[i][1] > 0.0f)? data->source_var[mapio[i]][1] / data->target_var[i][1] : 0.0f; \n    } \n \n \n \n#pragma omp parallel for default(none) schedule(static) shared(data, in, out, equalization) \n    for(int k = 0; k < height; k++) \n    { \n      size_t j = (size_t)ch * width * k; \n      for(int i = 0; i < width; i++) \n      { \n        const float L = in[j]; \n        out[j] = 0.5f * ((L * (1.0f - equalization) \n                          + data->source_ihist[data->target_hist[(int)CLAMP( \n                                HISTN * L / 100.0f, 0.0f, (float)HISTN - 1.0f)]] * equalization) - L) + 50.0f; \n        out[j] = CLAMP(out[j], 0.0f, 100.0f); \n        j += ch; \n      } \n    } \n \n    if(equalization > 0.001f) \n    { \n       \n \n      dt_bilateral_t *b = dt_bilateral_init(width, height, sigma_s, sigma_r); \n      if(!b) \n      { \n        free(var_ratio); \n        free(mapio); \n        return; \n      } \n      dt_bilateral_splat(b, out); \n      dt_bilateral_blur(b); \n      dt_bilateral_slice(b, out, out, -1.0f); \n      dt_bilateral_free(b); \n    } \n \n    float *const weight_buf = malloc(data->n * dt_get_num_threads() * sizeof(float)); \n \n#pragma omp parallel for default(none) schedule(static) shared(data, in, out, equalization) \n    for(int k = 0; k < height; k++) \n    { \n      float *weight = weight_buf + data->n * dt_get_thread_num(); \n      size_t j = (size_t)ch * width * k; \n      for(int i = 0; i < width; i++) \n      { \n        const float L = in[j]; \n        const float Lab[3] = { L, in[j + 1], in[j + 2] }; \n \n         \n \n        out[j] = 2.0f * (out[j] - 50.0f) + L; \n        out[j] = CLAMP(out[j], 0.0f, 100.0f); \n \n        get_clusters(in + j, data->n, data->target_mean, weight); \n        out[j + 1] = out[j + 2] = 0.0f; \n        for(int c = 0; c < data->n; c++) \n        { \n          out[j + 1] += weight[c] * ((Lab[1] - data->target_mean[c][0]) * var_ratio[c][0] \n                                     + data->source_mean[mapio[c]][0]); \n          out[j + 2] += weight[c] * ((Lab[2] - data->target_mean[c][1]) * var_ratio[c][1] \n                  ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_colormapping_data_t *data = (dt_iop_colormapping_data_t *)piece->data; \n  dt_iop_colormapping_gui_data_t *g = (dt_iop_colormapping_gui_data_t *)self->gui_data; \n  float *in = (float *)ivoid; \n  float *out = (float *)ovoid; \n \n  const int width = roi_in->width; \n  const int height = roi_in->height; \n  const int ch = piece->colors; \n \n  const float scale = piece->iscale / roi_in->scale; \n  const float sigma_s = 50.0f / scale; \n  const float sigma_r = 8.0f;  \n \n \n   \n \n  if(self->dev->gui_attached && g && piece->pipe->type == DT_DEV_PIXELPIPE_PREVIEW && (data->flag & ACQUIRE)) \n  { \n    dt_pthread_mutex_lock(&g->lock); \n    if(g->buffer) free(g->buffer); \n \n    g->buffer = malloc((size_t)width * height * ch * sizeof(float)); \n    g->width = width; \n    g->height = height; \n    g->ch = ch; \n \n    if(g->buffer) memcpy(g->buffer, in, (size_t)width * height * ch * sizeof(float)); \n \n    dt_pthread_mutex_unlock(&g->lock); \n  } \n \n   \n \n  if(data->flag & HAS_TARGET && data->flag & HAS_SOURCE) \n  { \n     \n \n \n    float dominance = data->dominance / 100.0f; \n    float equalization = data->equalization / 100.0f; \n \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         "}
{"label": " \nint main(int argc, char* argv[]){ \n \n    if(argc < 1+7){ \n        printf(\"Usage: [inTrain] [inTest] [outTrain] [outTest] [r] [sigma] [KernelType]\\n\"); \n        printf(\"KernelType: {Gauss, Laplace, ProdLaplace}\\n\"); \n        return -1; \n    } \n     \n    int i;  \n \n    int idx = 0; \n    char* trainFile = argv[++idx]; \n    char* testFile = argv[++idx]; \n    char* trainOut = argv[++idx]; \n    char* testOut = argv[++idx]; \n    int r = atoi(argv[++idx]); \n    double sigma = atof(argv[++idx]); \n    char* Kernel = argv[++idx];                                                                                                   \n     \n    KERNEL mKernel; \n    if (strcmp(Kernel, \"Gauss\") == 0) { \n        mKernel = Gaussian; \n    } \n    else if (strcmp(Kernel, \"Laplace\") == 0) { \n        mKernel = Laplace; \n    } \n    else if (strcmp(Kernel, \"ProdLaplace\") == 0) { \n        mKernel = ProdLaplace; \n    } \n    else { \n        printf(\"KRR_OneVsOne. Error: unidentified kernel type!\\n\"); \n        return -1; \n    } \n \n     \n \n     \n \n    double *Xtrain = NULL, *Xtest = NULL; \n    double *ytrain = NULL, *ytest = NULL; \n    int n = 0, m = 0, d = 0; \n    if (ReadLibSVM(trainFile, &Xtrain, &ytrain, &d, &n) == -1) { \n        return -1; \n    } \n    if (ReadLibSVM(testFile, &Xtest, &ytest, &d, &m) == -1) { \n        return -1; \n    } \n    printf(\"Generate fourier feature: finish loading data\\n\"); \n     \n     \n \n    int Seed = 0;   \n    srandom(Seed); \n     \n \n     \n \n     \n \n    double *w = (double *)malloc(d*r*sizeof(double));  \n    double *b = (double *)malloc(r*sizeof(double)); \n    switch (mKernel) { \n        case Gaussian: \n            StandardNormal(w, d*r); \n            break; \n        case Laplace: \n            for (i = 0; i < r; i++) { \n                MultivariateStudentT1(w+i*d, d); \n            } \n            break; \n        case ProdLaplace: \n            StudentT1(w, d*r); \n            break; \n    } \n    #pragma omp parallel for private(i) \n    for (i = 0; i < d*r; i++) { \n        w[i] /= sigma; \n    } \n  \n     \n \n     \n \n \n    UniformRandom01(b, r); \n    #pragma omp parallel for private(i) \n    for (i = 0; i < r; i++) { \n        b[i] *= TWO_PI; \n    } \n \n     \n \n     \n \n \n    printf(\"Generate fourier feature: finish generating w and b\\n\"); \n \n     \n \n    double *Ztrain = (double *)malloc(n*r*sizeof(double)); \n    ComputeFeatureMatrix(n, d, r, Xtrain, w, b, Ztrain, sigma); \n    double *Ztest = (double *)malloc(m*r*sizeof(double)); \n    ComputeFeatureMatrix(m, d, r, Xtest, w, b, Ztest, sigma); \n \n    printf(\"Generate fourier feature: finish computing feature matrix\\n\"); \n     \n     \n \n    if (WriteLibSVM(trainOut, Ztrain, ytrain, r, n) == -1){ \n        return -1; \n    } \n    if (WriteLibSVM(testOut, Ztest, ytest, r, m) == -1){ \n        return -1; \n    } \n \n    printf(\"Generate fourier feature: finish storing data\\n\"); \n     \n    free(Xtrain); \n    free(ytrain); \n    free(Xtest); \n    free(ytest); \n    free(w); \n    free(b); \n    free(Ztrain); \n    free(Ztest); \n \n    return 0; \n} ", "pred": " \nint main(int argc, char* argv[]){ \n \n    if(argc < 1+7){ \n        printf(\"Usage: [inTrain] [inTest] [outTrain] [outTest] [r] [sigma] [KernelType]\\n\"); \n        printf(\"KernelType: {Gauss, Laplace, ProdLaplace}\\n\"); \n        return -1; \n    } \n     \n    int i;  \n \n    int idx = 0; \n    char* trainFile = argv[++idx]; \n    char* testFile = argv[++idx]; \n    char* trainOut = argv[++idx]; \n    char* testOut = argv[++idx]; \n    int r = atoi(argv[++idx]); \n    double sigma = atof(argv[++idx]); \n    char* Kernel = argv[++idx];                                                                                                   \n     \n    KERNEL mKernel; \n    if (strcmp(Kernel, \"Gauss\") == 0) { \n        mKernel = Gaussian; \n    } \n    else if (strcmp(Kernel, \"Laplace\") == 0) { \n        mKernel = Laplace; \n    } \n    else if (strcmp(Kernel, \"ProdLaplace\") == 0) { \n        mKernel = ProdLaplace; \n    } \n    else { \n        printf(\"KRR_OneVsOne. Error: unidentified kernel type!\\n\"); \n        return -1; \n    } \n \n     \n \n     \n \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "}
{"label": " \nvoid mat_mult_mat(real* mat1, real* mat2, int m, int n, int o, real* out, gmx_bool bMP) \n{ \n   \n \n  int i, percent_calcs, finished_calcs; \n  percent_calcs  = 1; \n  finished_calcs = 0; \n \n  #pragma omp parallel for schedule(dynamic) if (bMP) \n  for (i = 0; i < m; i++) { \n    int j, k; \n    for (k = 0; k < o; k++) { \n      out[(i * m) + k] = 0; \n      for (j = 0; j < n; j++) { \n        out[(i * m) + k] += mat1[(i * m) + j] * mat2[(j * n) + k]; \n      } \n    } \n     \n \n    #pragma omp critical \n    { \n      finished_calcs++; \n      while ((double)(finished_calcs) / m >= (double)percent_calcs / 100) \n      { \n        fprintf(stderr, \"Approximately %i percent complete. \\r\", percent_calcs); \n        percent_calcs++; \n      } \n    }  \n \n  }  \n \n  fprintf(stderr, \"\\n\"); \n} ", "pred": " \nvoid mat_mult_mat(real* mat1, real* mat2, int m, int n, int o, real* out, gmx_bool bMP) \n{ \n   \n \n  int i, percent_calcs, finished_calcs; \n  percent_calcs  = 1; \n  finished_calcs = 0; \n \n  #pragma omp parallel for schedule(dynamic) if (bMP) \n  for (i = 0; i < m; i++) { \n    int j, k; \n    for (k = 0; k < o; k++) { \n      out[(i * m) + k] = 0; \n      for (j = 0; j < n; j++) { \n        out[(i * m) + k] += mat1[(i * m) + j] * mat2[(j * n) + k]; \n      } \n    } \n     \n \n    #pragma omp critical \n    { \n      finished_calcs++; \n      while ((double)(finished_calcs) / m >= (double)percent_calcs / 100) \n      { \n        fprintf(stderr, \"Approximately %i percent complete. \\r\", percent_calcs); \n        percent_calcs++; \n      } \n    }  \n \n  }  \n \n  fprintf(stderr, \"\\n\"); \n} "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_colorzones_data_t *d = (dt_iop_colorzones_data_t *)(piece->data); \n  dt_iop_colorzones_gui_data_t *g = (dt_iop_colorzones_gui_data_t *)self->gui_data; \n \n  const int ch = piece->colors; \n  const float normalize_C = 1.f / (128.0f * sqrtf(2.f)); \n \n   \n \n  if((piece->pipe->type & DT_DEV_PIXELPIPE_FULL) == DT_DEV_PIXELPIPE_FULL && g && g->display_mask && self->dev->gui_attached \n     && (self == self->dev->gui_module) && (piece->pipe == self->dev->pipe)) \n  { \n    const dt_iop_colorzones_channel_t display_channel = g->channel; \n \n    memcpy(ovoid, ivoid, roi_out->width * roi_out->height * ch * sizeof(float)); \n \n#pragma omp parallel for default(none) schedule(static)                                                                dt_omp_firstprivate(normalize_C, ch, ivoid, ovoid, roi_out, display_channel) shared(d) \n    for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n    { \n      float *in = (float *)ivoid + ch * k; \n      float *out = (float *)ovoid + ch * k; \n \n      float LCh[3]; \n \n      dt_Lab_2_LCH(in, LCh); \n \n      float select = 0.0f; \n      switch(d->channel) \n      { \n        case DT_IOP_COLORZONES_L: \n          select = LCh[0] * 0.01f; \n          break; \n        case DT_IOP_COLORZONES_C: \n          select = LCh[1] * normalize_C; \n          break; \n        case DT_IOP_COLORZONES_h: \n        default: \n          select = LCh[2]; \n          break; \n      } \n      select = CLAMP(select, 0.f, 1.f); \n \n      out[3] = fabsf(lookup(d->lut[display_channel], select) -.5f) * 4.f; \n      out[3] = CLAMP(out[3], 0.f, 1.f); \n    } \n \n    piece->pipe->mask_display = DT_DEV_PIXELPIPE_DISPLAY_MASK; \n    piece->pipe->bypass_blendif = 1; \n \n    return; \n  } \n \n  if(d->mode == DT_IOP_COLORZONES_MODE_SMOOTH) \n  { \n    process_v3(self, piece, ivoid, ovoid, roi_in, roi_out); \n    return; \n  } \n \n#pragma omp parallel for default(none) dt_omp_firstprivate(normalize_C, ch, ivoid, ovoid, roi_out) shared(d)           schedule(static) \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    float *in = (float *)ivoid + ch * k; \n    float *out = (float *)ovoid + ch * k; \n \n    float LCh[3]; \n \n    dt_Lab_2_LCH(in, LCh); \n \n    float select = 0.0f; \n    switch(d->channel) \n    { \n      case DT_IOP_COLORZONES_L: \n        select = LCh[0] * 0.01f; \n        break; \n      case DT_IOP_COLORZONES_C: \n        select = LCh[1] * normalize_C; \n        break; \n      case DT_IOP_COLORZONES_h: \n      default: \n        select = LCh[2]; \n        break; \n    } \n    select = CLAMP(select, 0.f, 1.f); \n \n    LCh[0] *= powf(2.0f, 4.0f * (lookup(d->lut[0], select) -.5f)); \n    LCh[1] *= 2.f * lookup(d->lut[1], select); \n    LCh[2] += lookup(d->lut[2], select) -.5f; \n \n    dt_LCH_2_Lab(LCh, out); \n \n    out[3] = in[3]; \n  } \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_colorzones_data_t *d = (dt_iop_colorzones_data_t *)(piece->data); \n  dt_iop_colorzones_gui_data_t *g = (dt_iop_colorzones_gui_data_t *)self->gui_data; \n \n  const int ch = piece->colors; \n  const float normalize_C = 1.f / (128.0f * sqrtf(2.f)); \n \n   \n \n  if((piece->pipe->type & DT_DEV_PIXELPIPE_FULL) == DT_DEV_PIXELPIPE_FULL && g && g->display_mask && self->dev->gui_attached \n     && (self == self->dev->gui_module) && (piece->pipe == self->dev->pipe)) \n  { \n    const dt_iop_colorzones_channel_t display_channel = g->channel; \n \n    memcpy(ovoid, ivoid, roi_out->width * roi_out->height * ch * sizeof(float)); \n \n#pragma omp parallel for default(none) schedule(static)                                                                dt_omp_firstprivate(normalize_C, ch, ivoid, ovoid, roi_out, display_channel) shared(d) \n    for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n    { \n      float *in = (float *)ivoid + ch * k; \n      float *out = (float *)ovoid + ch * k; \n \n      float LCh[3]; \n \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "}
{"label": " \nint main() \n{ \n  init_arrays(); \n \n  double annot_t_start=0, annot_t_end=0, annot_t_total=0; \n  int annot_i; \n \n  for (annot_i=0; annot_i<REPS; annot_i++) \n  { \n    annot_t_start = rtclock(); \n \n     \nregister int i,j,k,t;  \nregister int c1t, c2t, c3t, c4t, c5t, c6t, c7t, c8t, c9t, c10t, c11t, c12t;  \nregister int newlb_c1, newlb_c2, newlb_c3, newlb_c4, newlb_c5, newlb_c6,  \n  newlb_c7, newlb_c8, newlb_c9, newlb_c10, newlb_c11, newlb_c12;  \nregister int newub_c1, newub_c2, newub_c3, newub_c4, newub_c5, newub_c6,  \n  newub_c7, newub_c8, newub_c9, newub_c10, newub_c11, newub_c12;  \n \n \n \n#define ceild(n,d)  ceil(((double)(n))/((double)(d))) \n#define floord(n,d) floor(((double)(n))/((double)(d))) \n#define max(x,y)    ((x) > (y)? (x) : (y)) \n#define min(x,y)    ((x) < (y)? (x) : (y)) \n \n\t \n\tint c1, c2, c3, c4, c5, c6, c7, c8, c9; \n \n\tregister int lb, ub, lb1, ub1, lb2, ub2; \n \n \nfor (c1=-1;c1<=floord(2*T+N-4,32);c1++) { \n\tlb1=max(max(0,ceild(32*c1-T+1,32)),ceild(16*c1-15,32)); \n\tub1=min(min(floord(32*c1+31,32),floord(32*c1+N+29,64)),floord(T+N-3,32)); \n#pragma omp parallel for shared(c1,lb1,ub1) private(c2,c3,c4,c5,c6,c7,c8,c9) \n\tfor (c2=lb1; c2<=ub1; c2++) { \n{ \n  for (c3=max(max(max(max(ceild(64*c2-N-508,512),ceild(16*c1-255,256)),ceild(16*c2-255,256)),0),ceild(64*c1-64*c2-509,512)); c3<=min(min(min(min(floord(T+N-3,256),floord(32*c2+T+N+28,512)),floord(32*c1+N+60,512)),floord(32*c1-32*c2+N+29,256)),floord(64*c2+N+59,512)); c3++ ) { \n    for (c6=max(max(max(max(max(ceild(16*c1-31,32),0),ceild(16*c2-31,32)),8*c3),ceild(64*c2-N-60,64)),ceild(64*c1-64*c2-61,64)); c6<=min(min(min(min(min(8*c3+7,floord(32*c1-32*c2+N+29,32)),floord(32*c2+T+N+28,64)),floord(64*c2+N+59,64)),floord(32*c1+N+60,64)),floord(T+N-3,32)); c6++ ) { \n      for (c7t=max(max(max(max(32*c6-N+2,-32*c2+64*c6-N-29),32*c2-N+2),0),32*c1-32*c2); c7t<=min(min(min(min(32*c1-32*c2+31,T-1),-32*c2+64*c6+62),32*c2+30),floord(64*c6+61,2))-7; c7t=c7t+8) { \n        for (c7=c7t; c7<=c7t+7; c7=c7+1) { \n          for (c8=max(max(64*c6-c7-N+2,c7+1),32*c2); c8<=min(min(32*c2+31,c7+N-2),64*c6-c7+62); c8++ ) { \n            register int cbv_1, cbv_2; \n            cbv_1=max(64*c6,c7+c8+1); \n            cbv_2=min(c7+c8+N-2,64*c6+63)-7; \n#pragma ivdep \n#pragma vector always \n            for (c9t=cbv_1; c9t<=cbv_2; c9t=c9t+8) { \n              double scv_1, scv_2, scv_3, scv_4, scv_5, scv_6, scv_7, scv_8; \n              scv_1=A[-c7+c8][-c7-c8+(c9t+7)]; \n              scv_2=A[-c7+c8][-c7-c8+(c9t+1)]; \n              scv_3=A[-c7+c8][-c7-c8+(c9t+3)]; \n              scv_4=A[-c7+c8][-c7-c8+(c9t+2)]; \n              scv_5=A[-c7+c8][-c7-c8+(c9t+4)]; \n              scv_6=A[-c7+c8][-c7-c8+c9t]; \n              scv_7=A[-c7+c8][-c7-c8+(c9t+5)]; \n              scv_8=A[-c7+c8][-c7-c8+(c9t+6)]; \n              scv_6=(A[1+-c7+c8][1+-c7-c8+c9t]+A[1+-c7+c8][-c7-c8+c9t]+A[1+-c7+c8][-c7-c8+c9t-1]+A[-c7+c8][1+-c7-c8+c9t]+scv_6+A[-c7+c8][-c7-c8+c9t-1]+A[-c7+c8-1][1+-c7-c8+c9t]+A[-c7+c8-1][-c7-c8+c9t]+A[-c7+c8-", "pred": " \nint main() \n{ \n  init_arrays(); \n \n  double annot_t_start=0, annot_t_end=0, annot_t_total=0; \n  int annot_i; \n \n  for (annot_i=0; annot_i<REPS; annot_i++) \n  { \n    annot_t_start = rtclock(); \n \n     \nregister int i,j,k,t;  \nregister int c1t, c2t, c3t, c4t, c5t, c6t, c7t, c8t, c9t, c10t, c11t, c12t;  \nregister int newlb_c1, newlb_c2, newlb_c3, newlb_c4, newlb_c5, newlb_c6,  \n  newlb_c7, newlb_c8, newlb_c9, newlb_c10, newlb_c11, newlb_c12;  \nregister int newub_c1, newub_c2, newub_c3, newub_c4, newub_c5, newub_c6,  \n  newub_c7, newub_c8, newub_c9, newub_c10, newub_c11, newub_c12;  \n \n \n \n#define ceild(n,d)  ceil(((double)(n))/((double)(d))) \n#define floord(n,d) floor(((double)(n))/((double)(d))) \n#define max(x,y)    ((x) > (y)? (x) : (y)) \n#define min(x,y)    ((x) < (y)? (x) : (y)) \n \n\t \n\tint c1, c2, c3, c4, c5, c6, c7, c8, c9; \n \n\tregister int lb, ub, lb1, ub1, lb2, ub2; \n \n \nfor (c1=-1;c1<=floord(2*T+N-4,32);c1++) { \n\tlb1=max(max(0,ceild(32*c1-T+1,32)),ceild(16*c1-15,32)); \n\tub1=min(min(floord(32*c1+31,32),floord(32*c1+31,32),c2);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": " \nstatic void kmeans(const float *col, const int width, const int height, const int n, float mean_out[n][2], \n                   float var_out[n][2], float weight_out[n]) \n{ \n  const int nit = 40;                        \n \n  const int samples = width * height * 0.2;  \n \n \n  float(*const mean)[2] = malloc(2 * n * sizeof(float)); \n  float(*const var)[2] = malloc(2 * n * sizeof(float)); \n  int *const cnt = malloc(n * sizeof(int)); \n  int count; \n \n  float a_min = FLT_MAX, b_min = FLT_MAX, a_max = FLT_MIN, b_max = FLT_MIN; \n \n  for(int s = 0; s < samples; s++) \n  { \n    const int j = CLAMP(dt_points_get() * height, 0, height - 1); \n    const int i = CLAMP(dt_points_get() * width, 0, width - 1); \n \n    const float a = col[4 * (width * j + i) + 1]; \n    const float b = col[4 * (width * j + i) + 2]; \n \n    a_min = fmin(a, a_min); \n    a_max = fmax(a, a_max); \n    b_min = fmin(b, b_min); \n    b_max = fmax(b, b_max); \n  } \n \n   \n \n  for(int k = 0; k < n; k++) \n  { \n    mean_out[k][0] = 0.9f * (a_min + (a_max - a_min) * dt_points_get()); \n    mean_out[k][1] = 0.9f * (b_min + (b_max - b_min) * dt_points_get()); \n    var_out[k][0] = var_out[k][1] = weight_out[k] = 0.0f; \n    mean[k][0] = mean[k][1] = var[k][0] = var[k][1] = 0.0f; \n  } \n  for(int it = 0; it < nit; it++) \n  { \n    for(int k = 0; k < n; k++) cnt[k] = 0; \n \n \n#pragma omp parallel for default(none) schedule(static) shared(col, mean_out) \n    for(int s = 0; s < samples; s++) \n    { \n      const int j = CLAMP(dt_points_get() * height, 0, height - 1); \n      const int i = CLAMP(dt_points_get() * width, 0, width - 1); \n       \n \n      for(int k = 0; k < n; k++) \n      { \n        const float L = col[4 * (width * j + i)]; \n        const float Lab[3] = { L, col[4 * (width * j + i) + 1], col[4 * (width * j + i) + 2] }; \n         \n \n        const int c = get_cluster(Lab, n, mean_out); \n#pragma omp atomic \n        cnt[c]++; \n \n \n#pragma omp atomic \n        var[c][0] += Lab[1] * Lab[1]; \n#pragma omp atomic \n        var[c][1] += Lab[2] * Lab[2]; \n#pragma omp atomic \n        mean[c][0] += Lab[1]; \n#pragma omp atomic \n        mean[c][1] += Lab[2]; \n      } \n    } \n     \n \n    for(int k = 0; k < n; k++) \n    { \n      if(cnt[k] == 0) continue; \n      mean_out[k][0] = mean[k][0] / cnt[k]; \n      mean_out[k][1] = mean[k][1] / cnt[k]; \n      var_out[k][0] = var[k][0] / cnt[k] - mean_out[k][0] * mean_out[k][0]; \n      var_out[k][1] = var[k][1] / cnt[k] - mean_out[k][1] * mean_out[k][1]; \n      mean[k][0] = mean[k][1] = var[k][0] = var[k][1] = 0.0f; \n    } \n \n     \n \n    count = 0; \n    for(int k = 0; k < n; k++) count += cnt[k]; \n    for(int k = 0; k < n; k++) weight_out[k] = (count > 0)? (float)cnt[k] / count : 0.0f; \n \n     \n \n     \n \n     \n \n  } \n \n  free(cnt); \n  free(var); \n  free(mean); \n \n  for(int k = 0; k < n; k++) \n  { \n     \n \n    if(var_out[k][0] == 0.0f || var_out[k][1] == 0.0f) \n      mean_out[k][0] = mean_out[k][1] = var_out[k][0] = var_out[k][1] = weight_out[k] = 0; \n \n     \n \n    var_out[k][0] = sqrtf(var_out[k][0]); \n    var_out[k][1] = sqrtf(var_out[k][1]); \n  } \n \n   \n \n   \n \n  for(int i = 0; i < n - 1; i++) \n  { \n    for(int j = 0; j < n - 1 - i; j++) \n    { \n      if(weight_out[j] > weight_out[j + 1]) \n      { \n        float temp_mean[2] = { mean_out[j + 1][0], mean_out[j + 1][1] }; \n        float temp_var[2] = { var_out[j + 1][0], var_out[j + 1][1] }; \n        float temp_weight = weight_out[j + 1]; \n \n        mean_out[j + 1][0] = mean_out[j][0]; \n        mean_out[j + 1][1] = mean_out[j][1]; \n        var_out[j + 1][0] = var_out[j][0]; \n        var_out[j + 1][1] = var_out[j][1]; \n        weight_out[j + 1] = weight_out[j]; \n \n        mean_out[j][0] = temp_mean[0]; \n        mean_out[j", "pred": " \nstatic void kmeans(const float *col, const int width, const int height, const int n, float mean_out[n][2], \n                   float var_out[n][2], float weight_out[n]) \n{ \n  const int nit = 40;                        \n \n  const int samples = width * height * 0.2;  \n \n \n  float(*const mean)[2] = malloc(2 * n * sizeof(float)); \n  float(*const var)[2] = malloc(2 * n * sizeof(float)); \n  int *const cnt = malloc(n * sizeof(int)); \n  int count; \n \n  float a_min = FLT_MAX, b_min = FLT_MAX, a_max = FLT_MIN, b_max = FLT_MIN; \n \n  for(int s = 0; s < samples; s++) \n  { \n    const int j = CLAMP(dt_points_get() * height, 0, height - 1); \n    const int i = CLAMP(dt_points_get() * width, 0, width - 1); \n \n    const float a = col[4 * (width * j + i) + 1]; \n    const float b = col[4 * (width * j + i) + 2]; \n \n    a_min = fmin(a, a_min); \n    a_max = fmax(a, a_max); \n    b_min = fmin(b, b_min); \n    b_max = fmax(b, b_max); \n  } \n \n   \n \n  for(int k = 0; k < n; k++) \n  { \n    mean_out[k][0] = 0.9f * (a_min + (a_max - a_min) * dt_points_get()); \n    mean_out[k][1] = 0.9f * (b_min + (b_max - b_min) * dt_points_get()); \n    var_out[k][0] = var_out[k][1] = weight_out[k] = 0.0f; \n    mean[k][0] = mean[k][0];                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": " \n__attribute__((noinline, noclone)) void \nfoo (struct A (*x)[3][2], struct A *y, struct D w[1][2], int p1, long p2, long p3, int p4, \n     int p5, long p6, short p7) \n{ \n  struct C a[p7 + 4]; \n  short b[p7]; \n  int i; \n  for (i = 0; i < p7 + 4; i++) \n    { \n      if (i < p7) \n\tb[i] = -6; \n      a[i].t = 0; \n    } \n  #pragma omp parallel for reduction(+:x[0:p1 + 1][:p2], z[:p3])        reduction(*:y[:p4]) reduction(|:a[:p5])        reduction(&:w[0:p6 - 1][:p6]) reduction(maxb:b) \n  for (i = 0; i < 128; i++) \n    { \n      x[i / 64][i % 3][(i / 4) & 1].t += i; \n      if ((i & 15) == 1) \n\ty[0].t *= 3; \n      if ((i & 31) == 2) \n\ty[1].t *= 7; \n      if ((i & 63) == 3) \n\ty[2].t *= 17; \n      z[i / 32].t += (i & 3); \n      if (i < 4) \n\tz[i].t += i; \n      a[i / 32].t |= 1ULL << (i & 30); \n      w[0][i & 1].t &= ~(1L << (i / 17 * 3)); \n      if ((i % 79) > b[0]) \n\tb[0] = i % 79; \n      if ((i % 13) > b[1]) \n\tb[1] = i % 13; \n      if ((i % 23) > b[2]) \n\tb[2] = i % 23; \n      if ((i % 85) > b[3]) \n\tb[3] = i % 85; \n      if ((i % 192) > b[4]) \n\tb[4] = i % 192; \n    } \n  for (i = 0; i < 9; i++) \n    if (a[i].t!= (i < 4? 0x55555555ULL : 0)) \n      __builtin_abort (); \n  if (b[0]!= 78 || b[1]!= 12 || b[2]!= 22 || b[3]!= 84 || b[4]!= 127) \n    __builtin_abort (); \n} ", "pred": " \n__attribute__((noinline, noclone)) void \nfoo (struct A (*x)[3][2], struct A *y, struct D w[1][2], int p1, long p2, long p3, int p4, \n     int p5, long p6, short p7) \n{ \n  struct C a[p7 + 4]; \n  short b[p7]; \n  int i; \n  for (i = 0; i < p7 + 4; i++) \n    { \n      if (i < p7) \n\tb[i] = -6; \n      a[i].t = 0; \n    } \n  #pragma omp parallel for reduction(+:x[0:p1 + 1][:p2], z[:p3])        reduction(*:y[:p4]) reduction(|:a[:p5])        reduction(&:w[0:p6 - 1][:p6]) reduction(maxb:b) \n  for (i = 0; i < 128; i++) \n    { \n      x[i / 64][i % 3][(i / 4) & 1].t += i; \n      if ((i & 15) == 1) \n\ty[0].t *= 3; \n      if ((i & 31) == 2) \n\ty[1].t *= 7; \n      if ((i & 63) == 3) \n\ty[2].t *= 17; \n      z[i / 32].t += (i & 3); \n      if (i < 4) \n\tz[i].t += i; \n      a[i / 32].t |= 1ULL << (i & 30); \n      w[0][i & 1].t &= ~(1L << (i / 17 * 3)); \n      if ((i % 79) > b[0]) \n\tb[0] = i % 79; \n      if ((i % 13) > b[1]) \n\tb[1] = i % 13; \n      if ((i % 23) > b[2]) \n\tb[2] = i % 23; \n      if ((i % 85) > b[3])                                                                                                                                                                 "}
{"label": " \nvoid update_momenta(int * mnllist, double step, const int no,  \n\t\t    hamiltonian_field_t * const hf) { \n \n#pragma omp parallel for \n  for(int i = 0; i < (VOLUMEPLUSRAND + g_dbw2rand);i++) {  \n    for(int mu=0;mu<4;mu++) {  \n      _zero_su3adj(hf->derivative[i][mu]); \n    } \n  } \n   \n  for(int k = 0; k < no; k++) { \n    if(monomial_list[ mnllist[k] ].derivativefunction!= NULL) { \n      monomial_list[ mnllist[k] ].derivativefunction(mnllist[k], hf); \n    } \n  } \n   \n  xchange_deri(hf->derivative); \n     \n#pragma omp parallel for \n  for(int i = 0; i < VOLUME; i++) { \n    for(int mu = 0; mu < 4; mu++) { \n       \n \n      _su3adj_minus_const_times_su3adj(hf->momenta[i][mu], step, hf->derivative[i][mu]);  \n    } \n  } \n \n  return; \n} ", "pred": " \nvoid update_momenta(int * mnllist, double step, const int no,  \n\t\t    hamiltonian_field_t * const hf) { \n \n#pragma omp parallel for \n  for(int i = 0; i < (VOLUMEPLUSRAND + g_dbw2rand);i++) {  \n    for(int mu=0;mu<4;mu++) {  \n      _zero_su3adj(hf->derivative[i][mu]); \n    } \n  } \n   \n  for(int k = 0; k < no; k++) { \n    if(monomial_list[ mnllist[k] ].derivativefunction!= NULL) { \n      monomial_list[ mnllist[k] ].derivativefunction(mnllist[k], hf); \n    } \n  } \n   \n  xchange_deri(hf->derivative); \n     \n#pragma omp parallel for \n  for(int i = 0; i < VOLUME; i++) { \n    for(int mu = 0; mu < 4; mu++) { \n       \n \n      _su3adj_minus_const_times_su3adj(hf->momenta[i][mu], step, hf->derivative[i][mu]);  \n    } \n  } \n \n  return; \n} "}
{"label": "tatic void undo_14bit(uint16_t * raw_image_buff, size_t raw_image_size, uint32_t bpp) \n{ \n    uint32_t pixel_count = raw_image_size / 2; \n    int bits_shift = 14 - bpp; \n     \n \n    uint32_t rounding_number = (uint32_t)pow(2, bits_shift - 1); \n \n    #pragma omp parallel for \n    for(uint32_t i = 0; i < pixel_count; ++i) \n    { \n        raw_image_buff[i] = (raw_image_buff[i] + rounding_number) >> bits_shift; \n    } \n} \n \n ", "pred": "tatic void undo_14bit(uint16_t * raw_image_buff, size_t raw_image_size, uint32_t bpp) \n{ \n    uint32_t pixel_count = raw_image_size / 2; \n    int bits_shift = 14 - bpp; \n     \n \n    uint32_t rounding_number = (uint32_t)pow(2, bits_shift - 1); \n \n    #pragma omp parallel for \n    for(uint32_t i = 0; i < pixel_count; ++i) \n    { \n        raw_image_buff[i] = (raw_image_buff[i] + rounding_number) >> bits_shift; \n    } \n} \n \n "}
{"label": " \nMagickExport Image *WaveImage(const Image *image,const double amplitude, \n  const double wave_length,ExceptionInfo *exception) \n{ \n#define WaveImageTag  \"Wave/Image\" \n \n  Image \n    *wave_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    *sine_map; \n \n  register long \n    i; \n \n  ResampleFilter \n    **resample_filter; \n \n  ViewInfo \n    **wave_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  wave_image=CloneImage(image,image->columns,(unsigned long) (image->rows+2.0* \n    fabs(amplitude)),MagickTrue,exception); \n  if (wave_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(wave_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&wave_image->exception); \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (wave_image->background_color.opacity!= OpaqueOpacity) \n    wave_image->matte=MagickTrue; \n   \n \n  sine_map=(MagickRealType *) AcquireQuantumMemory((size_t) wave_image->columns, \n    sizeof(*sine_map)); \n  if (sine_map == (MagickRealType *) NULL) \n    { \n      wave_image=DestroyImage(wave_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  for (i=0; i < (long) wave_image->columns; i++) \n    sine_map[i]=fabs(amplitude)+amplitude*sin((2*MagickPI*i)/wave_length); \n   \n \n  status=MagickTrue; \n  resample_filter=AcquireResampleFilterThreadSet(image,exception); \n  wave_view=AcquireCacheViewThreadSet(wave_image); \n  #pragma omp parallel for \n  for (y=0; y < (long) wave_image->rows; y++) \n  { \n    MagickPixelPacket \n      pixel; \n \n    register IndexPacket \n      *indexes; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=SetCacheViewPixels(wave_view[id],0,y,wave_image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewIndexes(wave_view[id]); \n    GetMagickPixelPacket(wave_image,&pixel); \n    (void) SetResampleFilterVirtualPixelMethod(resample_filter[id], \n      BackgroundVirtualPixelMethod); \n    for (x=0; x < (long) wave_image->columns; x++) \n    { \n      pixel=ResamplePixelColor(resample_filter[id],(double) x,(double) (y- \n        sine_map[x])); \n      SetPixelPacket(wave_image,&pixel,q,indexes+x); \n      q++; \n    } \n    if (SyncCacheView(wave_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,WaveImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  wave_view=DestroyCacheViewThreadSet(wave_view); \n  resample_filter=DestroyResampleFilterThreadSet(resample_filter); \n  sine_map=(MagickRealType *) RelinquishMagickMemory(sine_map); \n  if (status == MagickFalse) \n    wave_image=DestroyImage(wave_image); \n  return(wave_image); \n} ", "pred": " \nMagickExport Image *WaveImage(const Image *image,const double amplitude, \n  const double wave_length,ExceptionInfo *exception) \n{ \n#define WaveImageTag  \"Wave/Image\" \n \n  Image \n    *wave_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    *sine_map; \n \n  register long \n    i; \n \n  ResampleFilter \n    **resample_filter; \n \n  ViewInfo \n    **wave_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  wave_image=CloneImage(image,image->columns,(unsigned long) (image->rows+2.0* \n    fabs(amplitude)),MagickTrue,exception); \n  if (wave_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(wave_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&wave_image->exception); \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (wave_image->background_color.opacity!= OpaqueOpacity) \n    wave_image->matte=MagickTrue; \n   \n \n  sine_map=(MagickRealType *) AcquireQuantumMemory((size_t) wave_image->columns, \n    sizeof(*sine_map)); \n  if (sine_map == (MagickRealType *) NULL) \n    { \n      wave_image=DestroyImage(wave_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  for (i=0; i<(int) wave_image->columns,size_t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "}
{"label": " \nvoid test_collapse() { \n  int i; \n \n \n#pragma omp target parallel for collapse \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n#pragma omp target parallel for collapse( \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n#pragma omp target parallel for collapse() \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n#pragma omp target parallel for collapse(, \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n#pragma omp target parallel for collapse(, ) \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n \n \n#pragma omp target parallel for collapse 4) \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n \n \n#pragma omp target parallel for collapse(4 \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n#pragma omp target parallel for collapse(4, \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n#pragma omp target parallel for collapse(4, ) \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n#pragma omp target parallel for collapse(4) \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n#pragma omp target parallel for collapse(4 4) \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n#pragma omp target parallel for collapse(4,, 4) \n  for (i = 0; i < 16; ++i) \n    ;  \n \n#pragma omp target parallel for collapse(4) \n  for (int i1 = 0; i1 < 16; ++i1) \n    for (int i2 = 0; i2 < 16; ++i2) \n      for (int i3 = 0; i3 < 16; ++i3) \n        for (int i4 = 0; i4 < 16; ++i4) \n          foo(); \n \n \n \n \n#pragma omp target parallel for collapse(4, 8) \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n#pragma omp target parallel for collapse(2.5) \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n#pragma omp target parallel for collapse(foo()) \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n#pragma omp target parallel for collapse(-5) \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n#pragma omp target parallel for collapse(0) \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n#pragma omp target parallel for collapse(5 - 5) \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n#pragma omp target parallel for collapse(2) firstprivate(i) \n  for (i = 0; i < 16; ++i)  \n \n \n \n    for (int j = 0; j < 16; ++j) \n \n \n \n \n#pragma omp for reduction(+ : i, j) \n      for (int k = 0; k < 16; ++k) \n        i += j; \n} ", "pred": " \nvoid test_collapse() { \n  int i; \n \n \n#pragma omp target parallel for collapse \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n#pragma omp target parallel for collapse( \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n#pragma omp target parallel for collapse() \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n#pragma omp target parallel for collapse(, \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n#pragma omp target parallel for collapse(, ) \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n \n \n#pragma omp target parallel for collapse 4) \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n \n \n#pragma omp target parallel for collapse(4 \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n#pragma omp target parallel for collapse(4, \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n#pragma omp target parallel for collapse(4, ) \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n#pragma omp target parallel for collapse(4) \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n#pragma omp target parallel for collapse(4 4) \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n#pragma omp target parallel for collapse(4,, 4) \n  for (i = 0; i < 16; ++i) \n    ;  \n \n#pragma omp target parallel for collapse(4) \n  for (int i1 = 0; i1 < 16; ++i1) \n    for (int i2 = 0; i2 < 16; ++i2)\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "}
{"label": " \nMagickExport Image *TintImage(const Image *image,const char *opacity, \n  const PixelPacket tint,ExceptionInfo *exception) \n{ \n#define TintImageTag  \"Tint/Image\" \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *tint_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickStatusType \n    flags; \n \n  MagickPixelPacket \n    color_vector, \n    pixel; \n \n  ViewInfo \n    **image_view, \n    **tint_view; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  tint_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (tint_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(tint_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&tint_image->exception); \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (opacity == (const char *) NULL) \n    return(tint_image); \n   \n \n  flags=ParseGeometry(opacity,&geometry_info); \n  pixel.red=geometry_info.rho; \n  if ((flags & SigmaValue)!= 0) \n    pixel.green=geometry_info.sigma; \n  else \n    pixel.green=pixel.red; \n  if ((flags & XiValue)!= 0) \n    pixel.blue=geometry_info.xi; \n  else \n    pixel.blue=pixel.red; \n  if ((flags & PsiValue)!= 0) \n    pixel.opacity=geometry_info.psi; \n  else \n    pixel.opacity=(MagickRealType) OpaqueOpacity; \n  color_vector.red=(MagickRealType) (pixel.red*tint.red/100.0- \n    PixelIntensity(&tint)); \n  color_vector.green=(MagickRealType) (pixel.green*tint.green/100.0- \n    PixelIntensity(&tint)); \n  color_vector.blue=(MagickRealType) (pixel.blue*tint.blue/100.0- \n    PixelIntensity(&tint)); \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(image); \n  tint_view=AcquireCacheViewThreadSet(tint_image); \n  #pragma omp parallel for \n  for (y=0; y < (long) image->rows; y++) \n  { \n    register const PixelPacket \n      *p; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    p=AcquireCacheViewPixels(image_view[id],0,y,image->columns,1,exception); \n    q=GetCacheViewPixels(tint_view[id],0,y,tint_image->columns,1); \n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (long) image->columns; x++) \n    { \n      MagickPixelPacket \n        pixel; \n \n      MagickRealType \n        weight; \n \n      weight=QuantumScale*p->red-0.5; \n      pixel.red=(MagickRealType) p->red+color_vector.red*(1.0-(4.0* \n        (weight*weight))); \n      q->red=RoundToQuantum(pixel.red); \n      weight=QuantumScale*p->green-0.5; \n      pixel.green=(MagickRealType) p->green+color_vector.green*(1.0-(4.0* \n        (weight*weight))); \n      q->green=RoundToQuantum(pixel.green); \n      weight=QuantumScale*p->blue-0.5; \n      pixel.blue=(MagickRealType) p->blue+color_vector.blue*(1.0-(4.0* \n        (weight*weight))); \n      q->blue=RoundToQuantum(pixel.blue); \n      q->opacity=p->opacity; \n      p++; \n      q++; \n    } \n    if (SyncCacheView(tint_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,TintImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  tint_view=DestroyCacheViewThreadSet(tint_view); \n  image_view=DestroyCacheViewThreadSet(image_view); \n  if (status == MagickFalse) \n    tint_image=DestroyImage(tint_image); \n  return(tint_image); \n} ", "pred": " \nMagickExport Image *TintImage(const Image *image,const char *opacity, \n  const PixelPacket tint,ExceptionInfo *exception) \n{ \n#define TintImageTag  \"Tint/Image\" \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *tint_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickStatusType \n    flags; \n \n  MagickPixelPacket \n    color_vector, \n    pixel; \n \n  ViewInfo \n    **image_view, \n    **tint_view; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  tint_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (tint_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(tint_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&tint_image->exception); \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (opacity == (const char *) NULL) \n    return(tint_image); \n   \n \n  flags=ParseGeometry(opacity,&geometry_info); \n  pixel.red=geometry_info.rho; \n  if ((flags & SigmaValue)!= 0) \n    pixel.green=geometry_info.sigma; \n  else \n    pixel.green=pixel.red; \n  if ((flags & XiValue)!= 0) \n    pixel.blue=geometry_info.xi; \n  else \n    pixel.blue=pixel.red; \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nMagickExport Image *ImplodeImage(const Image *image,const double amount, \n  ExceptionInfo *exception) \n{ \n#define ImplodeImageTag  \"Implode/Image\" \n \n  Image \n    *implode_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    radius; \n \n  PointInfo \n    center, \n    scale; \n \n  ResampleFilter \n    **resample_filter; \n \n  ViewInfo \n    **image_view, \n    **implode_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  implode_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (implode_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(implode_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&implode_image->exception); \n      implode_image=DestroyImage(implode_image); \n      return((Image *) NULL); \n    } \n  if (implode_image->background_color.opacity!= OpaqueOpacity) \n    implode_image->matte=MagickTrue; \n   \n \n  scale.x=1.0; \n  scale.y=1.0; \n  center.x=0.5*image->columns; \n  center.y=0.5*image->rows; \n  radius=center.x; \n  if (image->columns > image->rows) \n    scale.y=(double) image->columns/(double) image->rows; \n  else \n    if (image->columns < image->rows) \n      { \n        scale.x=(double) image->rows/(double) image->columns; \n        radius=center.y; \n      } \n   \n \n  status=MagickTrue; \n  resample_filter=AcquireResampleFilterThreadSet(image,exception); \n  image_view=AcquireCacheViewThreadSet(image); \n  implode_view=AcquireCacheViewThreadSet(implode_image); \n  #pragma omp parallel for \n  for (y=0; y < (long) image->rows; y++) \n  { \n    MagickPixelPacket \n      pixel; \n \n    MagickRealType \n      distance; \n \n    PointInfo \n      delta; \n \n    register const IndexPacket \n      *indexes; \n \n    register const PixelPacket \n      *p; \n \n    register IndexPacket \n      *implode_indexes; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=GetCacheViewPixels(implode_view[id],0,y,implode_image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    implode_indexes=GetCacheViewIndexes(implode_view[id]); \n    delta.y=scale.y*(double) (y-center.y); \n    GetMagickPixelPacket(implode_image,&pixel); \n    for (x=0; x < (long) image->columns; x++) \n    { \n       \n \n      delta.x=scale.x*(double) (x-center.x); \n      distance=delta.x*delta.x+delta.y*delta.y; \n      if (distance >= (radius*radius)) \n        { \n          p=AcquireCacheViewPixels(image_view[id],x,y,1,1,exception); \n          if (p == (const PixelPacket *) NULL) \n            break; \n          indexes=AcquireCacheViewIndexes(image_view[id]); \n          SetMagickPixelPacket(image,p,indexes,&pixel); \n        } \n      else \n        { \n          double \n            factor; \n \n           \n \n          factor=1.0; \n          if (distance > 0.0) \n            factor=pow(sin((double) (MagickPI*sqrt((double) distance)/ \n              radius/2)),-amount); \n          pixel=ResamplePixelColor(resample_filter[id],(double) \n            (factor*delta.x/scale.x+center.x),(double) (factor*delta.y/ \n            scale.y+center.y)); \n        } \n      SetPixelPacket(implode_image,&pixel,q,implode_indexes+x); \n      q++; \n    } \n    if (SyncCacheView(implode_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,ImplodeImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  implode_view=DestroyCacheViewThreadSet(implode_view); \n  image_view=DestroyCacheViewThreadSet(image_view); \n  resample_filter=DestroyResampleFilterThreadSet(resample_filter); \n  if (status == MagickFalse) \n    implode_image=DestroyImage(implode_image); \n  return(implode_image); \n} ", "pred": " \nMagickExport Image *ImplodeImage(const Image *image,const double amount, \n  ExceptionInfo *exception) \n{ \n#define ImplodeImageTag  \"Implode/Image\" \n \n  Image \n    *implode_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    radius; \n \n  PointInfo \n    center, \n    scale; \n \n  ResampleFilter \n    **resample_filter; \n \n  ViewInfo \n    **image_view, \n    **implode_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  implode_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (implode_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(implode_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&implode_image->exception); \n      implode_image=DestroyImage(implode_image); \n      return((Image *) NULL); \n    } \n  if (implode_image->background_color.opacity!= OpaqueOpacity) \n    implode_image->matte=MagickTrue; \n   \n \n  scale.x=1.0; \n  scale.y=1.0; \n  center.x=0.5*image->columns; \n  center.y=0.5*image->rows; \n  radius=center.x; \n  if (image->columns > image->rows) \n    scale.y=(double) image->columns/(double) image->rows; \n  else \n    if (image->columns < image->rows) \n      {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "}
{"label": " \nMagickExport Image *ShadowImage(const Image *image,const double opacity, \n  const double sigma,const long x_offset,const long y_offset, \n  ExceptionInfo *exception) \n{ \n  Image \n    *border_image, \n    *clone_image, \n    *shadow_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  RectangleInfo \n    border_info; \n \n  ViewInfo \n    **image_view; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  clone_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (clone_image == (Image *) NULL) \n    return((Image *) NULL); \n  (void) SetImageVirtualPixelMethod(clone_image,EdgeVirtualPixelMethod); \n  border_info.width=(unsigned long) (2.0*sigma+0.5); \n  border_info.height=(unsigned long) (2.0*sigma+0.5); \n  border_info.x=0; \n  border_info.y=0; \n  (void) QueryColorDatabase(\"none\",&clone_image->border_color,exception); \n  border_image=BorderImage(clone_image,&border_info,exception); \n  clone_image=DestroyImage(clone_image); \n  if (border_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (border_image->matte == MagickFalse) \n    (void) SetImageAlphaChannel(border_image,ResetAlphaChannel); \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(border_image); \n  #pragma omp parallel for \n  for (y=0; y < (long) border_image->rows; y++) \n  { \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=GetCacheViewPixels(image_view[id],0,y,border_image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (long) border_image->columns; x++) \n    { \n      q->red=border_image->background_color.red; \n      q->green=border_image->background_color.green; \n      q->blue=border_image->background_color.blue; \n      if (border_image->matte == MagickFalse) \n        q->opacity=border_image->background_color.opacity; \n      else \n        q->opacity=RoundToQuantum((MagickRealType) QuantumRange-(QuantumRange- \n          q->opacity)*opacity/100.0); \n      q++; \n    } \n    if (SyncCacheView(image_view[id]) == MagickFalse) \n      status=MagickFalse; \n  } \n  image_view=DestroyCacheViewThreadSet(image_view); \n  shadow_image=BlurImageChannel(border_image,AlphaChannel,0.0,sigma,exception); \n  border_image=DestroyImage(border_image); \n  if (shadow_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (shadow_image->page.width == 0) \n    shadow_image->page.width=shadow_image->columns; \n  if (shadow_image->page.height == 0) \n    shadow_image->page.height=shadow_image->rows; \n  shadow_image->page.width+=x_offset-(long) border_info.width; \n  shadow_image->page.height+=y_offset-(long) border_info.height; \n  shadow_image->page.x+=x_offset-(long) border_info.width; \n  shadow_image->page.y+=y_offset-(long) border_info.height; \n  return(shadow_image); \n} ", "pred": " \nMagickExport Image *ShadowImage(const Image *image,const double opacity, \n  const double sigma,const long x_offset,const long y_offset, \n  ExceptionInfo *exception) \n{ \n  Image \n    *border_image, \n    *clone_image, \n    *shadow_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  RectangleInfo \n    border_info; \n \n  ViewInfo \n    **image_view; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  clone_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (clone_image == (Image *) NULL) \n    return((Image *) NULL); \n  (void) SetImageVirtualPixelMethod(clone_image,EdgeVirtualPixelMethod); \n  border_info.width=(unsigned long) (2.0*sigma+0.5); \n  border_info.height=(unsigned long) (2.0*sigma+0.5); \n  border_info.x=0; \n  border_info.y=0; \n  (void) QueryColorDatabase(\"none\",&clone_image->border_color,exception); \n  border_image=BorderImage(clone_image,&border_info,exception); \n  clone_image=DestroyImage(clone_image); \n  if (border_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (border_image->matte == MagickFalse) \n    (void) SetImageAlphaChannel(border_image,ResetAlphaChannel); \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(border_image); \n  #pragma omp parallel for \n  for (y=0; y < (long) border_image->rows; y++) \n  { \n    register long \n      id, \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": " \nint user1_init_primitives(int inittype, FTYPE (*prim)[NSTORE2][NSTORE3][NPR], FTYPE (*pstag)[NSTORE2][NSTORE3][NPR], FTYPE (*ucons)[NSTORE2][NSTORE3][NPR], FTYPE (*vpot)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Bhat)[NSTORE2][NSTORE3][NPR], FTYPE (*panalytic)[NSTORE2][NSTORE3][NPR], FTYPE (*pstaganalytic)[NSTORE2][NSTORE3][NPR], FTYPE (*vpotanalytic)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Bhatanalytic)[NSTORE2][NSTORE3][NPR], \n                          FTYPE (*F1)[NSTORE2][NSTORE3][NPR],FTYPE (*F2)[NSTORE2][NSTORE3][NPR],FTYPE (*F3)[NSTORE2][NSTORE3][NPR], FTYPE (*Atemp)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3]) \n{ \n  int whichvel, whichcoord; \n  int initreturn; \n  int i = 0, j = 0, k = 0, l; \n  FTYPE r,th,X[NDIM],V[NDIM]; \n  int normalize_densities(FTYPE (*prim)[NSTORE2][NSTORE3][NPR]); \n  int normalize_field(FTYPE (*prim)[NSTORE2][NSTORE3][NPR], FTYPE (*pstag)[NSTORE2][NSTORE3][NPR], FTYPE (*ucons)[NSTORE2][NSTORE3][NPR], FTYPE (*vpot)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Bhat)[NSTORE2][NSTORE3][NPR]); \n  int init_atmosphere(int *whichvel, int *whichcoord, int i, int j, int k, FTYPE *pr); \n  int pl,pliter; \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  trifprintf(\"Assign primitives\\n\"); \n \n   \n \n   \n \n  init_3dnpr_fullloop(0.0,prim); \n \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n#pragma omp parallel private(i,j,k,initreturn,whichvel,whichcoord) OPENMPGLOBALPRIVATEFULL \n  { \n    OPENMP3DLOOPVARSDEFINE; \n     \n \n    OPENMP3DLOOPSETUPFULL; \n#pragma omp for schedule(OPENMPSCHEDULE(),OPENMPCHUNKSIZE(blocksize)) \n    OPENMP3DLOOPBLOCK{ \n      OPENMP3DLOOPBLOCK2IJK(i,j,k); \n \n      initreturn=init_dsandvels(inittype, CENT, &whichvel, &whichcoord,t,i,j,k,MAC(prim,i,j,k),MAC(pstag,i,j,k));  \n \n      if(initreturn>0){ \n        FAILSTATEMENT(\"init.c:init_primitives()\", \"init_dsandvels()\", 1); \n      } \n      else MYFUN(transform_primitive_vB(whichvel, whichcoord, i,j,k, prim, pstag),\"init.c:init_primitives\",\"transform_primitive_vB()\",0); \n \n    } \n  } ", "pred": " \nint user1_init_primitives(int inittype, FTYPE (*prim)[NSTORE2][NSTORE3][NPR], FTYPE (*pstag)[NSTORE2][NSTORE3][NPR], FTYPE (*ucons)[NSTORE2][NSTORE3][NPR], FTYPE (*vpot)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Bhat)[NSTORE2][NSTORE3][NPR], FTYPE (*panalytic)[NSTORE2][NSTORE3][NPR], FTYPE (*pstaganalytic)[NSTORE2][NSTORE3][NPR], FTYPE (*vpotanalytic)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Bhatanalytic)[NSTORE2][NSTORE3][NPR], \n                          FTYPE (*F1)[NSTORE2][NSTORE3][NPR],FTYPE (*F2)[NSTORE2][NSTORE3][NPR],FTYPE (*F3)[NSTORE2][NSTORE3][NPR], FTYPE (*Atemp)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3]) \n{ \n  int whichvel, whichcoord; \n  int initreturn; \n  int i = 0, j = 0, k = 0, l; \n  FTYPE r,th,X[NDIM],V[NDIM]; \n  int normalize_densities(FTYPE (*prim)[NSTORE2][NSTORE3][NPR]); \n  int normalize_field(FTYPE (*prim)[NSTORE2][NSTORE3][NPR], FTYPE (*pstag)[NSTORE2][NSTORE3][NPR], FTYPE (*ucons)[NSTORE2][NSTORE3][NPR], FTYPE (*vpot)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Bhat)[NSTORE2][NSTORE3][NPR]); \n  int init_atmosphere(int *whichvel, int *whichcoord, int i, int j, int k, FTYPE *pr); \n  int pl,pliter;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nint gmx_isd(int argc,char *argv[]) \n{ \n  const char *desc[] = { \n    \"[TT]g_isd[tt].\" \n  }; \n   \n   \n   \n  static gmx_bool bANG=FALSE, bDIH=FALSE, bANGDIH=FALSE, bDRMS=FALSE; \n  static gmx_bool bPHIPSI=FALSE, bSRMS=FALSE, bPCOR=FALSE, bMAMMOTH=FALSE; \n  static gmx_bool bACOR=FALSE, bESA=FALSE, bRMSD=FALSE, bMIR=FALSE; \n  static gmx_bool bRG=FALSE, bSRG=FALSE, bE2E=FALSE, bSE2E=FALSE; \n  static gmx_bool bANG2=FALSE, bDIH2=FALSE, bANGDIH2=FALSE, bANGDIH2G=FALSE; \n  static gmx_bool bRROT=FALSE, bSDRMS=FALSE, bPHIPSI2=FALSE, bRMSDIH=FALSE; \n  static user_bf = -1, user_ef = -1, user_td = -1; \n  static int nt          = -1; \n  static real setmax     = -1.0; \n  static real rcutoff    =  1.1; \n  static real noisefloor =  0.0; \n  static gmx_bool bNoise = FALSE; \n  static gmx_bool bMP    = FALSE; \n  t_pargs pa[] = { \n    { \"-ang\", FALSE, etBOOL, {&bANG}, \n    \"ISDM: Mean cosine of difference of backbone angles for each \" \n    \"set of three atoms. Assumes only CA atoms.\" }, \n    { \"-dih\", FALSE, etBOOL, {&bDIH}, \n    \"ISDM: Mean cosine of difference of backbone dihedrals for \" \n    \"each set of four atoms. Assumes only CA atoms.\" }, \n    { \"-angdih\", FALSE, etBOOL, {&bANGDIH}, \n    \"ISDM: Geometric mean of ang and dih ISDMs.\" }, \n    { \"-ang2\", FALSE, etBOOL, {&bANG2}, \n    \"ISDM: Attempts to euclideanize -ang.\" }, \n    { \"-dih2\", FALSE, etBOOL, {&bDIH2}, \n    \"ISDM: Attempts to euclideanize -dih.\" }, \n    { \"-angdih2\", FALSE, etBOOL, {&bANGDIH2}, \n    \"ISDM: Attempts to euclideanize -angdih.\" }, \n    { \"-angdih2g\", FALSE, etBOOL, {&bANGDIH2G}, \n    \"ISDM: Attempts to euclideanize -angdih. Geometric mean.\" }, \n    { \"-rmsdih\", FALSE, etBOOL, {&bRMSDIH}, \n    \"ISDM: RMSD of alpha carbon dihedrals.\" }, \n    { \"-phipsi\", FALSE, etBOOL, {&bPHIPSI}, \n    \"ISDM: Mean cosine of difference of phi and psi angles. \" \n    \"Assumes only backbone atoms.\" }, \n    { \"-phipsi2\", FALSE, etBOOL, {&bPHIPSI2}, \n    \"ISDM: Attempts to euclideanize -phipsi.\" }, \n    { \"-drms\", FALSE, etBOOL, {&bDRMS}, \n    \"ISDM: Mean difference of the paired distances matrix for all \" \n    \"atoms. Distance RMS(D).\" }, \n    { \"-sdrms\", FALSE, etBOOL, {&bSDRMS}, \n    \"ISDM: Mean difference of the paired distances matrix for all \" \n    \"atoms scaled by 2 * geometric mean of Rg. Scaled distance \" \n    \"RMS(D).\" }, \n    { \"-rg\", FALSE, etBOOL, {&bRG}, \n    \"ISDM: Calculates difference in Rg. Only compares size. \" }, \n    { \"-srg\", FALSE, etBOOL, {&bSRG}, \n    \"ISDM: Calculates difference in Rg scaled by mean Rg. \" }, \n    { \"-e2e\", FALSE, etBOOL, {&bE2E}, \n    \"ISDM: Calculates difference in end-to-end distance. \" }, \n    { \"-se2e\", FALSE, etBOOL, {&bSE2E}, \n    \"ISDM: Calculates difference in end-to-end distance scaled \" \n    \"by (2 * Rg). \" }, \n    { \"-mir\", FALSE, etBOOL, {&bMIR}, \n    \"ISDM: RMSD with the mirror of the reference structure. \" }, \n    { \"-rrot\", FALSE, etBOOL, {&bRROT}, \n    \"ISDM: RMSD with random rotation of reference structure. \" }, \n    { \"-srms\", FALSE, etBOOL, {&bSRMS}, \n    \"ISDM: Scaled RMSD. RMSD between the structure and reference \" \n    \"divided by the RMSD between the structure and mirror of the \" \n    \"reference created by multiplying the coordinates by the \" \n    \"negative identity matrix.\" }, \n    { \"-rmsd\", FALSE, etBOOL, {&bRMSD}, \n    \"ISDM: Standard RMSD.\" }, \n    { \"-pcor\", FALSE, etBOOL, {&bPCOR}, \n    \"ISDM: Position correlation. Correlation coefficient of the \" \n    \"positions is computed after alignment. Only positive \" \n    \"correlation is considered. Negative correlations are set to \" \n    \"zero.\" }, \n    { \"-acor\", FALSE, etBOOL, {&bACOR}, \n    \"ISDM: Angle correlation. Correlation coefficient of the \" \n    \"backbone angles (see ang ISDM) is computed. \" \n    \"Only positive correlation is considered. Negative correlations \" \n    \"are set to zero.\" }, \n    { \"-mammoth\", FALSE, etBOOL, {&bMAMMOTH}, \n    \"ISDM: MAMMOTH (MAtching Molecular Models Obtained from \" \n    \"Theory). Compares segments of residues chosen by sequence \" \n    \"alignment. Attempts to focus on correct secondary structure \" \n    \"moreso than tertiary structure. Source code modified for \" \n    \"compatibility. For this ISDM, please cite: \\n\\n\" \n    \"Ortiz, AR, Strauss, CE, Olmea, O (2002). MAMMOTH \" \n    \"(Matching molecular models obtained from theory): An automated \" \n    \"method for model comparison. Protein Sci. 11 (11), 2606\u20132621.\\n\"}, \n    { \"-esa\", FALSE, etBOOL, {&bESA}, \n    \"ISDM: Elastic shape analysis. Based on image analysis. \" \n    \"Warps structure onto the reference structure. Original source \" \n    \"code ported from Matlab to C. For this ISDM, please cite: \\n\\n\" \n    \"Liu W, Srivastava A, Zhang J (2011) A Mathematical Framework \" \n    \"for Protein Structure Comparison. PLoS Comput Biol 7(2): \" \n    \"e1001075.\\n\\nAssume only CA atoms.\" }, \n    { \"-mp\", FALSE, etBOOL, {&bMP}, \n    \"Use OpenMP commands for parallel processing. \"}, \n    { \"-nt\", FALSE, etINT,", "pred": " \nint gmx_isd(int argc,char *argv[]) \n{ \n  const char *desc[] = { \n    \"[TT]g_isd[tt].\" \n  }; \n   \n   \n   \n  static gmx_bool bANG=FALSE, bDIH=FALSE, bANGDIH=FALSE, bDRMS=FALSE; \n  static gmx_bool bPHIPSI=FALSE, bSRMS=FALSE, bPCOR=FALSE, bMAMMOTH=FALSE; \n  static gmx_bool bACOR=FALSE, bESA=FALSE, bRMSD=FALSE, bMIR=FALSE; \n  static gmx_bool bRG=FALSE, bSRG=FALSE, bE2E=FALSE, bSE2E=FALSE; \n  static gmx_bool bANG2=FALSE, bDIH2=FALSE, bANGDIH2=FALSE, bANGDIH2G=FALSE; \n  static gmx_bool bRROT=FALSE, bSDRMS=FALSE, bPHIPSI2=FALSE, bRMSDIH=FALSE; \n  static user_bf = -1, user_ef = -1, user_td = -1; \n  static int nt          = -1; \n  static real setmax     = -1.0; \n  static real rcutoff    =  1.1; \n  static real noisefloor =  0.0; \n  static gmx_bool bNoise = FALSE; \n  static gmx_bool bMP    = FALSE; \n  t_pargs pa[] = { \n    { \"-ang\", FALSE, etBOOL, {&bANG}, \n    \"ISDM: Mean cosine of difference of backbone angles for each \" \n    \"set of three atoms. Assumes only CA atoms.\" }, \n    { \"-dih\", FALSE, etBOOL, {&bDIH}, \n    \"ISDM: Mean cosine of difference of backbone dihedrals for \" \n    \"each set of four atoms. Assumes only CA atoms.\" }, \n    { \"-angdih\", FALSE, etBOOL, {&bANGDIH}, \n    \"ISDM: Geometric mean of ang and dih ISDMs.\" }, \n    { \"-ang2,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": "  int\tcnt = 0; \n \n  for (i = 1; i<thds; i*=2) \n    ; \n \n  #pragma omp for \n  for (lp=1; lp<=i; lp=lp*2) { \n    buf[cnt ++] += omp_get_num_threads (); \n  } \n} \n \n \nmain () \n{ \n  thds = omp_get_max_thre ", "pred": "  int\tcnt = 0; \n \n  for (i = 1; i<thds; i*=2) \n    ; \n \n  #pragma omp for \n  for (lp=1; lp<=i; lp=lp*2) { \n    buf[cnt ++] += omp_get_num_threads (); \n  } \n} \n \n \nmain () \n{ \n  thds = omp_get_max_thre "}
{"label": " \nMagickExport Image *ConvolveImageChannel(const Image *image, \n  const ChannelType channel,const unsigned long order,const double *kernel, \n  ExceptionInfo *exception) \n{ \n#define ConvolveImageTag  \"Convolve/Image\" \n \n  Image \n    *convolve_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  unsigned long \n    width; \n \n  ViewInfo \n    **convolve_view, \n    **image_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  width=order; \n  if ((width % 2) == 0) \n    ThrowImageException(OptionError,\"KernelWidthMustBeAnOddNumber\"); \n  convolve_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (convolve_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(convolve_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&convolve_image->exception); \n      convolve_image=DestroyImage(convolve_image); \n      return((Image *) NULL); \n    } \n   \n \n  if (image->debug!= MagickFalse) \n    { \n      char \n        format[MaxTextExtent], \n        *message; \n \n      long \n        u, \n        v; \n \n      register const double \n        *k; \n \n      (void) LogMagickEvent(TransformEvent,GetMagickModule(), \n        \"  ConvolveImage with %ldx%ld kernel:\",width,width); \n      message=AcquireString(\"\"); \n      k=kernel; \n      for (v=0; v < (long) width; v++) \n      { \n        *message='\\0'; \n        (void) FormatMagickString(format,MaxTextExtent,\"%ld: \",v); \n        (void) ConcatenateString(&message,format); \n        for (u=0; u < (long) width; u++) \n        { \n          (void) FormatMagickString(format,MaxTextExtent,\"%+f \",*k++); \n          (void) ConcatenateString(&message,format); \n        } \n        (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"%s\",message); \n      } \n      message=DestroyString(message); \n    } \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(image); \n  convolve_view=AcquireCacheViewThreadSet(convolve_image); \n  #pragma omp parallel for \n  for (y=0; y < (long) image->rows; y++) \n  { \n    const IndexPacket \n      *indexes; \n \n    IndexPacket \n      *convolve_indexes; \n \n    register const PixelPacket \n      *p; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    p=AcquireCacheViewPixels(image_view[id],-((long) width/2L),y-(long) \n      (width/2L),image->columns+width,width,exception); \n    q=GetCacheViewPixels(convolve_view[id],0,y,convolve_image->columns,1); \n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=AcquireCacheViewIndexes(image_view[id]); \n    convolve_indexes=GetCacheViewIndexes(convolve_view[id]); \n    for (x=0; x < (long) image->columns; x++) \n    { \n      long \n        j, \n        v; \n \n      MagickRealType \n        alpha, \n        gamma; \n \n      MagickPixelPacket \n        pixel; \n \n      register const double \n        *k; \n \n      register long \n        u; \n \n      GetMagickPixelPacket(image,&pixel); \n      gamma=0.0; \n      k=kernel; \n      j=0; \n      for (v=0; v < (long) width; v++) \n      { \n        for (u=0; u < (long) width; u++) \n        { \n          alpha=1.0; \n          if (((channel & OpacityChannel)!= 0) && \n              (image->matte!= MagickFalse)) \n            alpha=(MagickRealType) (QuantumScale*(QuantumRange- \n              (p+u+j)->opacity)); \n          if ((channel & RedChannel)!= 0) \n            pixel.red+=(*k)*alpha*(p+u+j)->red; \n          if ((channel & GreenChannel)!= 0) \n            pixel.green+=(*k)*alpha*(p+u+j)->green; \n          if ((channel & BlueChannel)!= 0) \n            pixel.blue+=(*k)*alpha*(p+u+j)->blue; \n          if ((channel & OpacityChannel)!= 0) \n            pixel.opacity+=(*k)*(p+u+j)->opacity; \n          if (((channel & IndexChannel)!= 0) && \n              (image->colorspace == CMYKColorspace)) \n            pixel.index+=(*k)*alpha*indexes[x+u+j]; \n     ", "pred": " \nMagickExport Image *ConvolveImageChannel(const Image *image, \n  const ChannelType channel,const unsigned long order,const double *kernel, \n  ExceptionInfo *exception) \n{ \n#define ConvolveImageTag  \"Convolve/Image\" \n \n  Image \n    *convolve_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  unsigned long \n    width; \n \n  ViewInfo \n    **convolve_view, \n    **image_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  width=order; \n  if ((width % 2) == 0) \n    ThrowImageException(OptionError,\"KernelWidthMustBeAnOddNumber\"); \n  convolve_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (convolve_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(convolve_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&convolve_image->exception); \n      convolve_image=DestroyImage(convolve_image); \n      return((Image *) NULL); \n    } \n   \n \n  if (image->debug!= MagickFalse) \n    { \n      char \n        format[MaxTextExtent], \n        *message; \n \n      long \n        u, \n        v; \n \n      register const double \n        *k; \n \n      (void) LogMagickEvent(TransformEvent,GetMagickModule(), \n        \"  ConvolveImage,\\\"\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "}
{"label": " \nMagickExport MagickBooleanType EvaluateImageChannel(Image *image, \n  const ChannelType channel,const MagickEvaluateOperator op,const double value, \n  ExceptionInfo *exception) \n{ \n#define EvaluateImageTag  \"Evaluate/Image \" \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  ViewInfo \n    **image_view; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  if (SetImageStorageClass(image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&image->exception); \n      return(MagickFalse); \n    } \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(image); \n  #pragma omp parallel for \n  for (y=0; y < (long) image->rows; y++) \n  { \n    register IndexPacket \n      *indexes; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=GetCacheViewPixels(image_view[id],0,y,image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetIndexes(image); \n    for (x=0; x < (long) image->columns; x++) \n    { \n      if ((channel & RedChannel)!= 0) \n        q->red=ApplyEvaluateOperator(q->red,op,value); \n      if ((channel & GreenChannel)!= 0) \n        q->green=ApplyEvaluateOperator(q->green,op,value); \n      if ((channel & BlueChannel)!= 0) \n        q->blue=ApplyEvaluateOperator(q->blue,op,value); \n      if ((channel & OpacityChannel)!= 0) \n        { \n          if (image->matte == MagickFalse) \n            q->opacity=ApplyEvaluateOperator(q->opacity,op,value); \n          else \n            q->opacity=(Quantum) QuantumRange-ApplyEvaluateOperator( \n              (Quantum) (QuantumRange-q->opacity),op,value); \n        } \n      if (((channel & IndexChannel)!= 0) && (indexes!= (IndexPacket *) NULL)) \n        indexes[x]=(IndexPacket) ApplyEvaluateOperator(indexes[x],op,value); \n      q++; \n    } \n    if (SyncCacheView(image_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,EvaluateImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  image_view=DestroyCacheViewThreadSet(image_view); \n  return(status); \n} ", "pred": " \nMagickExport MagickBooleanType EvaluateImageChannel(Image *image, \n  const ChannelType channel,const MagickEvaluateOperator op,const double value, \n  ExceptionInfo *exception) \n{ \n#define EvaluateImageTag  \"Evaluate/Image \" \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  ViewInfo \n    **image_view; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  if (SetImageStorageClass(image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&image->exception); \n      return(MagickFalse); \n    } \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(image); \n  #pragma omp parallel for \n  for (y=0; y < (long) image->rows; y++) \n  { \n    register IndexPacket \n      *indexes; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=GetCacheViewPixels(image_view[id],0,y,image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetIndexes(image); \n    for (x=0; x < (long) image->columns; x++) \n    { \n      if ((channel & RedChannel)!= 0) \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           "}
{"label": " \nMagickExport MagickBooleanType SolarizeImage(Image *image, \n  const double threshold) \n{ \n#define SolarizeImageTag  \"Solarize/Image\" \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  ViewInfo \n    **image_view; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  if (image->storage_class == PseudoClass) \n    { \n      register long \n        i; \n \n       \n \n      for (i=0; i < (long) image->colors; i++) \n      { \n        if ((MagickRealType) image->colormap[i].red > threshold) \n          image->colormap[i].red=(Quantum) QuantumRange-image->colormap[i].red; \n        if ((MagickRealType) image->colormap[i].green > threshold) \n          image->colormap[i].green=(Quantum) QuantumRange- \n            image->colormap[i].green; \n        if ((MagickRealType) image->colormap[i].blue > threshold) \n          image->colormap[i].blue=(Quantum) QuantumRange- \n            image->colormap[i].blue; \n      } \n    } \n   \n \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(image); \n  #pragma omp parallel for \n  for (y=0; y < (long) image->rows; y++) \n  { \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=GetCacheViewPixels(image_view[id],0,y,image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (long) image->columns; x++) \n    { \n      if ((MagickRealType) q->red > threshold) \n        q->red=(Quantum) QuantumRange-q->red; \n      if ((MagickRealType) q->green > threshold) \n        q->green=(Quantum) QuantumRange-q->green; \n      if ((MagickRealType) q->blue > threshold) \n        q->blue=(Quantum) QuantumRange-q->blue; \n      q++; \n    } \n    if (SyncCacheView(image_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,SolarizeImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  image_view=DestroyCacheViewThreadSet(image_view); \n  return(status); \n} ", "pred": " \nMagickExport MagickBooleanType SolarizeImage(Image *image, \n  const double threshold) \n{ \n#define SolarizeImageTag  \"Solarize/Image\" \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  ViewInfo \n    **image_view; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  if (image->storage_class == PseudoClass) \n    { \n      register long \n        i; \n \n       \n \n      for (i=0; i < (long) image->colors; i++) \n      { \n        if ((MagickRealType) image->colormap[i].red > threshold) \n          image->colormap[i].red=(Quantum) QuantumRange-image->colormap[i].red; \n        if ((MagickRealType) image->colormap[i].green > threshold) \n          image->colormap[i].green=(Quantum) QuantumRange- \n            image->colormap[i].green; \n        if ((MagickRealType) image->colormap[i].blue > threshold) \n          image->colormap[i].blue=(Quantum) QuantumRange- \n            image->colormap[i].blue; \n      } \n    } \n   \n \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(image); \n  #pragma omp parallel for \n  for (y=0; y < (long) image->rows; y++) \n  { \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n                                                                                                                                                                                                                                                                                                                                                                                                                   "}
{"label": " \nMagickExport Image *MorphImages(const Image *image, \n  const unsigned long number_frames,ExceptionInfo *exception) \n{ \n#define MorphImageTag  \"Morph/Image\" \n \n  Image \n    *morph_image, \n    *morph_images; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    scene; \n \n  MagickRealType \n    alpha, \n    beta; \n \n  register const Image \n    *next; \n \n  register long \n    i; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  morph_images=CloneImage(image,0,0,MagickTrue,exception); \n  if (morph_images == (Image *) NULL) \n    return((Image *) NULL); \n  if (GetNextImageInList(image) == (Image *) NULL) \n    { \n       \n \n      for (i=1; i < (long) number_frames; i++) \n      { \n        morph_image=CloneImage(image,0,0,MagickTrue,exception); \n        if (morph_image == (Image *) NULL) \n          { \n            morph_images=DestroyImageList(morph_images); \n            return((Image *) NULL); \n          } \n        AppendImageToList(&morph_images,morph_image); \n        if ((image->progress_monitor!= (MagickProgressMonitor) NULL) && \n            (QuantumTick(i,number_frames)!= MagickFalse)) \n          { \n            status=image->progress_monitor(MorphImageTag,i,number_frames, \n              image->client_data); \n            if (status == MagickFalse) \n              break; \n          } \n      } \n      return(GetFirstImageInList(morph_images)); \n    } \n   \n \n  scene=0; \n  next=image; \n  for ( ; GetNextImageInList(next)!= (Image *) NULL; next=GetNextImageInList(next)) \n  { \n    MagickBooleanType \n      progress; \n \n    for (i=0; i < (long) number_frames; i++) \n    { \n      ViewInfo \n        **image_view, \n        **morph_view; \n \n      beta=(MagickRealType) (i+1.0)/(MagickRealType) (number_frames+1.0); \n      alpha=1.0-beta; \n      morph_image=ZoomImage(next,(unsigned long) (alpha*next->columns+beta* \n        GetNextImageInList(next)->columns+0.5),(unsigned long) (alpha* \n        next->rows+beta*GetNextImageInList(next)->rows+0.5),exception); \n      if (morph_image == (Image *) NULL) \n        { \n          morph_images=DestroyImageList(morph_images); \n          return((Image *) NULL); \n        } \n      if (SetImageStorageClass(morph_image,DirectClass) == MagickFalse) \n        { \n          InheritException(exception,&morph_image->exception); \n          morph_image=DestroyImage(morph_image); \n          return((Image *) NULL); \n        } \n      AppendImageToList(&morph_images,morph_image); \n      morph_images=GetLastImageInList(morph_images); \n      morph_image=ZoomImage(GetNextImageInList(next),morph_images->columns, \n        morph_images->rows,exception); \n      if (morph_image == (Image *) NULL) \n        { \n          morph_images=DestroyImageList(morph_images); \n          return((Image *) NULL); \n        } \n      image_view=AcquireCacheViewThreadSet(morph_image); \n      morph_view=AcquireCacheViewThreadSet(morph_images); \n      #pragma omp parallel for \n      for (y=0; y < (long) morph_images->rows; y++) \n      { \n        register const PixelPacket \n          *p; \n \n        register long \n          id, \n          x; \n \n        register PixelPacket \n          *q; \n \n    if (status == MagickFalse) \n      continue; \n        id=GetCacheViewThreadId(); \n        p=AcquireCacheViewPixels(image_view[id],0,y,morph_image->columns,1, \n          exception); \n        q=GetCacheViewPixels(morph_view[id],0,y,morph_images->columns,1); \n        if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n          { \n            status=MagickFalse; \n            continue; \n          } \n        for (x=0; x < (long) morph_images->columns; x++) \n        { \n          q->red=RoundToQuantum(alpha*q->red+beta*p->red); \n          q->green=RoundToQuantum(alpha*q->green+beta*p->green); \n          q->blue=RoundToQuantum(alpha*q->blue+beta*p->blue); \n          q->opacity=RoundToQuantum(alpha*q->opacity+beta*p->opacity); \n          p++; \n          q++; \n        } \n        if (SyncCacheView(morph_view[id]) == MagickFalse) \n          status=MagickFalse; \n  ", "pred": " \nMagickExport Image *MorphImages(const Image *image, \n  const unsigned long number_frames,ExceptionInfo *exception) \n{ \n#define MorphImageTag  \"Morph/Image\" \n \n  Image \n    *morph_image, \n    *morph_images; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    scene; \n \n  MagickRealType \n    alpha, \n    beta; \n \n  register const Image \n    *next; \n \n  register long \n    i; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  morph_images=CloneImage(image,0,0,MagickTrue,exception); \n  if (morph_images == (Image *) NULL) \n    return((Image *) NULL); \n  if (GetNextImageInList(image) == (Image *) NULL) \n    { \n       \n \n      for (i=1; i < (long) number_frames; i++) \n      { \n        morph_image=CloneImage(image,0,0,MagickTrue,exception); \n        if (morph_image == (Image *) NULL) \n          { \n            morph_images=DestroyImageList(morph_images); \n            return((Image *) NULL); \n          } \n        AppendImageToList(&morph_images,morph_image); \n        if ((image->progress_monitor!= (MagickProgressMonitor) NULL) && \n            (QuantumTick(i,number_frames)!= MagickFalse)) \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           "}
{"label": " \nvoid process_v3(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o, \n                const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_colorzones_data_t *d = (dt_iop_colorzones_data_t *)(piece->data); \n  const int ch = piece->colors; \n#pragma omp parallel for default(none) dt_omp_firstprivate(ch, i, o, roi_out) shared(d) schedule(static) \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    float *in = (float *)i + ch * k; \n    float *out = (float *)o + ch * k; \n    const float a = in[1], b = in[2]; \n    const float h = fmodf(atan2f(b, a) + 2.0f * DT_M_PI_F, 2.0f * DT_M_PI_F) / (2.0f * DT_M_PI_F); \n    const float C = sqrtf(b * b + a * a); \n    float select = 0.0f; \n    float blend = 0.0f; \n    switch(d->channel) \n    { \n      case DT_IOP_COLORZONES_L: \n        select = fminf(1.0f, in[0] / 100.0f); \n        break; \n      case DT_IOP_COLORZONES_C: \n        select = fminf(1.0f, C / 128.0f); \n        break; \n      default: \n      case DT_IOP_COLORZONES_h: \n        select = h; \n        blend = powf(1.0f - C / 128.0f, 2.0f); \n        break; \n    } \n    const float Lm = (blend *.5f + (1.0f - blend) * lookup(d->lut[0], select)) -.5f; \n    const float hm = (blend *.5f + (1.0f - blend) * lookup(d->lut[2], select)) -.5f; \n    blend *= blend;  \n \n     \n \n    const float Cm = 2.0f * lookup(d->lut[1], select); \n    const float L = in[0] * powf(2.0f, 4.0f * Lm); \n    out[0] = L; \n    out[1] = cosf(2.0f * DT_M_PI_F * (h + hm)) * Cm * C; \n    out[2] = sinf(2.0f * DT_M_PI_F * (h + hm)) * Cm * C; \n    out[3] = in[3]; \n  } \n} ", "pred": " \nvoid process_v3(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o, \n                const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_colorzones_data_t *d = (dt_iop_colorzones_data_t *)(piece->data); \n  const int ch = piece->colors; \n#pragma omp parallel for default(none) dt_omp_firstprivate(ch, i, o, roi_out) shared(d) schedule(static) \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    float *in = (float *)i + ch * k; \n    float *out = (float *)o + ch * k; \n    const float a = in[1], b = in[2]; \n    const float h = fmodf(atan2f(b, a) + 2.0f * DT_M_PI_F, 2.0f * DT_M_PI_F) / (2.0f * DT_M_PI_F); \n    const float C = sqrtf(b * b + a * a); \n    float select = 0.0f; \n    float blend = 0.0f; \n    switch(d->channel) \n    { \n      case DT_IOP_COLORZONES_L: \n        select = fminf(1.0f, in[0] / 100.0f); \n        break; \n      case DT_IOP_COLORZONES_C: \n        select = fminf(1.0f, C / 128.0f); \n        break; \n      default: \n      case DT_IOP_COLORZONES_h: \n        select = h; \n        blend = powf(1.0f - C / 128.0f, 2.0f); \n{\"\\t                                                                                                                                                                                                                                                                                             "}
{"label": " \nvoid mzd_process_rows6(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, \n\t\t       rci_t const *L2, mzd_t const *T3, rci_t const *L3, mzd_t const *T4, rci_t const *L4, \n\t\t       mzd_t const *T5, rci_t const *L5) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int const rem = k % 6; \n \n  int const ka = k / 6 + ((rem >= 5)? 1 : 0); \n  int const kb = k / 6 + ((rem >= 4)? 1 : 0); \n  int const kc = k / 6 + ((rem >= 3)? 1 : 0); \n  int const kd = k / 6 + ((rem >= 2)? 1 : 0); \n  int const ke = k / 6 + ((rem >= 1)? 1 : 0);; \n  int const kf = k / 6; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n  word const kc_bm = __M4RI_LEFT_BITMASK(kc); \n  word const kd_bm = __M4RI_LEFT_BITMASK(kd); \n  word const ke_bm = __M4RI_LEFT_BITMASK(ke); \n  word const kf_bm = __M4RI_LEFT_BITMASK(kf); \n \n#pragma omp parallel for private(r) shared(startrow, stoprow) schedule(static,512)  \n \n  for(r = startrow; r < stoprow; ++r) { \n    word bits = mzd_read_bits(M, r, startcol, k); \n    rci_t const x0 = L0[ bits & ka_bm ]; bits>>=ka; \n    rci_t const x1 = L1[ bits & kb_bm ]; bits>>=kb; \n    rci_t const x2 = L2[ bits & kc_bm ]; bits>>=kc; \n    rci_t const x3 = L3[ bits & kd_bm ]; bits>>=kd; \n    rci_t const x4 = L4[ bits & ke_bm ]; bits>>=ke; \n    rci_t const x5 = L5[ bits & kf_bm ]; \n \n     \n \n    if(((x0 | x1) | (x2 | x3) | (x4 | x5)) == 0)  \n \n      continue; \n \n    word *m0 = M->rows[r] + blocknum; \n    word const *t[6]; \n    t[0] = T0->rows[x0] + blocknum; \n    t[1] = T1->rows[x1] + blocknum; \n    t[2] = T2->rows[x2] + blocknum; \n    t[3] = T3->rows[x3] + blocknum; \n    t[4] = T4->rows[x4] + blocknum; \n    t[5] = T5->rows[x5] + blocknum; \n \n    _mzd_combine_6( m0, t, wide); \n  } \n \n  __M4RI_DD_MZD(M); \n} ", "pred": " \nvoid mzd_process_rows6(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, \n\t\t       rci_t const *L2, mzd_t const *T3, rci_t const *L3, mzd_t const *T4, rci_t const *L4, \n\t\t       mzd_t const *T5, rci_t const *L5) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int const rem = k % 6; \n \n  int const ka = k / 6 + ((rem >= 5)? 1 : 0); \n  int const kb = k / 6 + ((rem >= 4)? 1 : 0); \n  int const kc = k / 6 + ((rem >= 3)? 1 : 0); \n  int const kd = k / 6 + ((rem >= 2)? 1 : 0); \n  int const ke = k / 6 + ((rem >= 1)? 1 : 0);; \n  int const kf = k / 6; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n  word const kc_bm = __M4RI_LEFT_BITMASK(kc); \n  word const kd_bm = __M4RI_LEFT_BITMASK(kd); \n  word const ke_bm = __M4RI_LEFT_BITMASK(ke); \n  word const kf_bm = __M4RI_LEFT_BITMASK(kf); \n \n#pragma omp parallel for private(r) shared(startrow, stoprow) schedule(static,512)  \n \n  for(r = startrow; r < stoprow; ++r) { \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \nstatic int dt_ellipse_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                   dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start2 = dt_get_wtime(); \n \n   \n \n  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form->points)->data); \n \n   \n \n  const int w = roi->width; \n  const int h = roi->height; \n  const int px = roi->x; \n  const int py = roi->y; \n  const float iscale = 1.0f / roi->scale; \n  const int mesh = 4; \n  const int mw = (w + mesh - 1) / mesh + 1; \n  const int mh = (h + mesh - 1) / mesh + 1; \n \n  float *points = malloc((size_t)mw * mh * 2 * sizeof(float)); \n  if(points == NULL) return 0; \n \n#pragma omp parallel for default(none) shared(points) \n#pragma omp parallel for shared(points) \n  for(int j = 0; j < mh; j++) \n    for(int i = 0; i < mw; i++) \n    { \n      size_t index = (size_t)j * mw + i; \n      points[index * 2] = (mesh * i + px) * iscale; \n      points[index * 2 + 1] = (mesh * j + py) * iscale; \n    } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] ellipse draw took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n  if(!dt_dev_distort_backtransform_plus(module->dev, piece->pipe, 0, module->priority, points, \n                                        (size_t)mw * mh)) \n  { \n    free(points); \n    return 0; \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] ellipse transform took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n  const int wi = piece->pipe->iwidth, hi = piece->pipe->iheight; \n  const float center[2] = { ellipse->center[0] * wi, ellipse->center[1] * hi }; \n  const float radius[2] = { ellipse->radius[0] * MIN(wi, hi), ellipse->radius[1] * MIN(wi, hi) }; \n  const float total[2] = { (ellipse->flags & DT_MASKS_ELLIPSE_PROPORTIONAL? ellipse->radius[0] * (1.0f + ellipse->border) : ellipse->radius[0] + ellipse->border) * MIN(wi, hi), \n                           (ellipse->flags & DT_MASKS_ELLIPSE_PROPORTIONAL? ellipse->radius[1] * (1.0f + ellipse->border) : ellipse->radius[1] + ellipse->border) * MIN(wi, hi) }; \n \n  float a, b, ta, tb, alpha; \n \n  if(radius[0] >= radius[1]) \n  { \n    a = radius[0]; \n    b = radius[1]; \n    ta = total[0]; \n    tb = total[1]; \n    alpha = (ellipse->rotation / 180.0f) * M_PI; \n  } \n  else \n  { \n    a = radius[1]; \n    b = radius[0]; \n    ta = total[1]; \n    tb = total[0]; \n    alpha = ((ellipse->rotation - 90.0f) / 180.0f) * M_PI; \n  } \n \n#pragma omp parallel for default(none) shared(points, a, b, ta, tb, alpha) \n#pragma omp parallel for shared(points, a, b, ta, tb, alpha) \n  for(int i = 0; i < mh; i++) \n    for(int j = 0; j < mw; j++) \n    { \n      size_t index = (size_t)i * mw + j; \n      float x = points[index * 2] - center[0]; \n      float y = points[index * 2 + 1] - center[1]; \n      float v = atan2(y, x) - alpha; \n      float cosv = cos(v); \n      float sinv = sin(v); \n      float radius2 = a * a * b * b / (a * a * sinv * sinv + b * b * cosv * cosv); \n      float total2 = ta * ta * tb * tb / (ta * ta * sinv * sinv + tb * tb * cosv * cosv); \n      float l2 = x * x + y * y; \n \n      if(l2 < radius2) \n        points[index * 2] = 1.0f; \n      else if(l2 < total2) \n      { \n        float f = (total2 - l2) / (total2 - radius2); \n        points[index * 2] = f * f; \n      } \n      else \n        points[index * 2] = 0.0f; \n    } \n \n \n \n#pragma omp parallel for default(none) shared(points, buffer) \n#pragma omp parallel for shared(points, buffer) \n  for(int j = 0; j < h; j++) \n  { \n    int jj = j % mesh; \n    int mj = j / mesh; \n    for(int i = 0; i < w; i++) \n    { \n      int ii = i % mesh; \n      int mi = i / mesh; \n      size_t mindex = (size_t)mj * mw + mi; \n      buffer[(size_t)j * w + i] \n          = (points[mindex * 2] * (mesh - ii) * (mesh - jj) + points[(mindex + 1) * 2] * ii * (mesh - jj) \n             + points[(mindex + mw) * 2] * (mesh - ii) * jj + points", "pred": " \nstatic int dt_ellipse_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                   dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start2 = dt_get_wtime(); \n \n   \n \n  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form->points)->data); \n \n   \n \n  const int w = roi->width; \n  const int h = roi->height; \n  const int px = roi->x; \n  const int py = roi->y; \n  const float iscale = 1.0f / roi->scale; \n  const int mesh = 4; \n  const int mw = (w + mesh - 1) / mesh + 1; \n  const int mh = (h + mesh - 1) / mesh + 1; \n \n  float *points = malloc((size_t)mw * mh * 2 * sizeof(float)); \n  if(points == NULL) return 0; \n \n#pragma omp parallel for default(none) shared(points) \n#pragma omp parallel for shared(points) \n  for(int j = 0; j < mh; j++) \n    for(int i = 0; i < mw; i++) \n    { \n      size_t index = (size_t)j * mw + i; \n      points[index * 2] = (mesh * i + px) * iscale; \n      points[index * 2 + 1] = (mesh * j + py) * iscale; \n    } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] ellipse draw took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \nn                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_UINT16) \n  {  \n \n \n    const uint16_t *const in = (const uint16_t *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n#pragma omp parallel for SIMD() default(none) schedule(static) collapse(2) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t pin = (size_t)(roi_in->width * (j + csy) + csx) + i; \n        const size_t pout = (size_t)j * roi_out->width + i; \n \n        const int id = BL(roi_out, d, j, i); \n        out[pout] = (in[pin] - d->sub[id]) / d->div[id]; \n      } \n    } \n \n    piece->pipe->dsc.filters = dt_rawspeed_crop_dcraw_filters(self->dev->image_storage.buf_dsc.filters, csx, csy); \n    adjust_xtrans_filters(piece->pipe, csx, csy); \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_FLOAT) \n  {  \n \n \n    const float *const in = (const float *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n#pragma omp parallel for SIMD() default(none) schedule(static) collapse(2) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t pin = (size_t)(roi_in->width * (j + csy) + csx) + i; \n        const size_t pout = (size_t)j * roi_out->width + i; \n \n        const int id = BL(roi_out, d, j, i); \n        out[pout] = (in[pin] - d->sub[id]) / d->div[id]; \n      } \n    } \n \n    piece->pipe->dsc.filters = dt_rawspeed_crop_dcraw_filters(self->dev->image_storage.buf_dsc.filters, csx, csy); \n    adjust_xtrans_filters(piece->pipe, csx, csy); \n  } \n  else \n  {  \n \n \n    const float *const in = (const float *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n    const float sub = d->sub[0], div = d->div[0]; \n \n    const int ch = piece->colors; \n \n#pragma omp parallel for SIMD() default(none) schedule(static) collapse(3) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        for(int c = 0; c < ch; c++) \n        { \n          const size_t pin = (size_t)ch * (roi_in->width * (j + csy) + csx + i) + c; \n          const size_t pout = (size_t)ch * (j * roi_out->width + i) + c; \n \n          out[pout] = (in[pin] - sub) / div; \n        } \n      } \n    } \n  } \n \n  for(int k = 0; k < 4; k++) piece->pipe->dsc.processed_maximum[k] = 1.0f; \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_UINT16) \n  {  \n \n \n    const uint16_t *const in = (const uint16_t *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n#pragma omp parallel for SIMD() default(none) schedule(static) collapse(2) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t pin = (size_t)(roi_in->width * (j + csy) + csx) + i; \n        const size_t pout = (size_t)j * roi_out->width + i; \n \n        const int id = BL(roi_out, d, j, i); \n        out[pout] = (in[pin] - d->sub[id]) / d->div[id]; \n      } \n    } \n \n    piece->pipe->dsc.filters = dt_rawspeed_crop_dcraw_filters(self->dev->image_storage.buf_dsc.filters, csx, csy); \n    adjust_xtrans_filters(piece->pipe, d, d, d, c, c, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d"}
{"label": " \nstatic int crypt_all(int *pcount, struct db_salt *salt) \n{ \n\tint count = *pcount; \n\tint index; \n \n\tif (saved_salt->v.type) { \n\t\t \n \n\t\t \n \n\t\tmemset(crypt_key, 0, count * BINARY_SIZE); \n\t\treturn count; \n\t} \n \n#pragma omp parallel for default(none) private(index) shared(count, saved_key, saved_salt, crypt_key) \n\tfor (index = 0; index < count; index += MAX_KEYS_PER_CRYPT) { \n\t\tunsigned char pwd_ver[(2+64)*MAX_KEYS_PER_CRYPT]; \n\t\tint lens[MAX_KEYS_PER_CRYPT], i; \n\t\tunsigned char *pin[MAX_KEYS_PER_CRYPT], *pout[MAX_KEYS_PER_CRYPT]; \n\t\tfor (i = 0; i < MAX_KEYS_PER_CRYPT; ++i) { \n\t\t\tlens[i] = strlen(saved_key[i+index]); \n\t\t\tpin[i] = (unsigned char*)saved_key[i+index]; \n\t\t\tpout[i] = &pwd_ver[i*(2+2*KEY_LENGTH(saved_salt->v.mode))]; \n\t\t} \n\t\tpbkdf2_sha1_sse((const unsigned char **)pin, lens, saved_salt->salt, SALT_LENGTH(saved_salt->v.mode), KEYING_ITERATIONS, pout, 2+2*KEY_LENGTH(saved_salt->v.mode), 0); \n\t\tfor (i = 0; i < MAX_KEYS_PER_CRYPT; ++i) { \n\t\t\tif (!memcmp(&(pout[i][KEY_LENGTH(saved_salt->v.mode)<<1]), saved_salt->passverify, 2)) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\thmac_sha1(&(pout[i][KEY_LENGTH(saved_salt->v.mode)]), KEY_LENGTH(saved_salt->v.mode), \n\t\t\t\t\t\t   (const unsigned char*)saved_salt->datablob, saved_salt->comp_len, \n\t\t\t\t\t\t   crypt_key[index+i], BINARY_SIZE); \n\t\t\t} \n\t\t\telse \n\t\t\t\tmemset(crypt_key[index+i], 0, BINARY_SIZE); \n\t\t} \n\t\tint LEN = 2+2*KEY_LENGTH(saved_salt->v.mode); \n\t\tunion { \n\t\t\t \n \n\t\t\t \n \n\t\t\tunsigned char pwd_ver[4+64]; \n\t\t\tARCH_WORD_32 w; \n\t\t} x; \n\t\tunsigned char *pwd_ver = x.pwd_ver; \n\t\tLEN += 2; \n\t\tpbkdf2_sha1((unsigned char *)saved_key[index], \n\t\t       strlen(saved_key[index]), saved_salt->salt, SALT_LENGTH(saved_salt->v.mode), \n\t\t       KEYING_ITERATIONS, pwd_ver, LEN, 0); \n\t\talter_endianity(pwd_ver, LEN); \n\t\tif (!memcmp(&(pwd_ver[KEY_LENGTH(saved_salt->v.mode)<<1]), saved_salt->passverify, 2)) \n\t\t{ \n\t\t\t \n \n\t\t\thmac_sha1(&(pwd_ver[KEY_LENGTH(saved_salt->v.mode)]), KEY_LENGTH(saved_salt->v.mode), \n                       (const unsigned char*)saved_salt->datablob, saved_salt->comp_len, \n                       crypt_key[index], BINARY_SIZE); \n\t\t} \n\t\telse \n\t\t\tmemset(crypt_key[index], 0, BINARY_SIZE); \n\t} \n\treturn count; \n} ", "pred": " \nstatic int crypt_all(int *pcount, struct db_salt *salt) \n{ \n\tint count = *pcount; \n\tint index; \n \n\tif (saved_salt->v.type) { \n\t\t \n \n\t\t \n \n\t\tmemset(crypt_key, 0, count * BINARY_SIZE); \n\t\treturn count; \n\t} \n \n#pragma omp parallel for default(none) private(index) shared(count, saved_key, saved_salt, crypt_key) \n\tfor (index = 0; index < count; index += MAX_KEYS_PER_CRYPT) { \n\t\tunsigned char pwd_ver[(2+64)*MAX_KEYS_PER_CRYPT]; \n\t\tint lens[MAX_KEYS_PER_CRYPT], i; \n\t\tunsigned char *pin[MAX_KEYS_PER_CRYPT], *pout[MAX_KEYS_PER_CRYPT]; \n\t\tfor (i = 0; i < MAX_KEYS_PER_CRYPT; ++i) { \n\t\t\tlens[i] = strlen(saved_key[i+index]); \n\t\t\tpin[i] = (unsigned char*)saved_key[i+index]; \n\t\t\tpout[i] = &pwd_ver[i*(2+2*KEY_LENGTH(saved_salt->v.mode))]; \n\t\t} \n\t\tpbkdf2_sha1_sse((const unsigned char **)pin, lens, saved_salt->salt, SALT_LENGTH(saved_salt->v.mode), KEYING_ITERATIONS, pout, 2+2*KEY_LENGTH(saved_salt->v.mode), 0); \n\t\tfor (i = 0; i < MAX_KEYS_PER_CRYPT; ++i) { \n\t\t\tif (!memcmp(&(pout[i][KEY_LENGTH(saved_salt->v.mode)<<1]), saved_salt->passverify, 2)) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\thmac_sha1(&(pout[i][KEY_LENGTH(saved_salt->v.mode)]), KEY_LENGTH(saved_salt->v.mode), \n\t\t\t\t\t\t   (const unsigned char*)saved_salt->passverify);\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " \nmzd_t *_mzd_mul_m4rm(mzd_t *C, mzd_t const *A, mzd_t const *B, int k, int clear) { \n   \n \n \n  rci_t        x[__M4RI_M4RM_NTABLES]; \n  rci_t       *L[__M4RI_M4RM_NTABLES]; \n  word  const *t[__M4RI_M4RM_NTABLES]; \n  mzd_t       *T[__M4RI_M4RM_NTABLES]; \n  mzd_t  *Talign[__M4RI_M4RM_NTABLES]; \n  int c_align = (__M4RI_ALIGNMENT(C->rows[0], 16) == 8); \n \n  word *c; \n \n  rci_t const a_nr = A->nrows; \n  rci_t const a_nc = A->ncols; \n  rci_t const b_nc = B->ncols; \n \n  if (b_nc < m4ri_radix-10 || a_nr < 16) { \n    if(clear) \n      return mzd_mul_naive(C, A, B); \n    else \n      return mzd_addmul_naive(C, A, B); \n  } \n \n   \n \n  if (clear) { \n    mzd_set_ui(C, 0); \n  } \n \n  const int blocksize = __M4RI_MUL_BLOCKSIZE; \n \n  if(k==0) { \n     \n \n    k = (int)log2((__M4RI_CPU_L2_CACHE/64)/(double)B->width); \n    if ((__M4RI_CPU_L2_CACHE - 64*__M4RI_TWOPOW(k)*B->width) > (64*__M4RI_TWOPOW(k+1)*B->width - __M4RI_CPU_L2_CACHE)) \n      k++; \n \n    rci_t const klog = round(0.75 * log2_floor(MIN(MIN(a_nr,a_nc),b_nc))); \n \n    if(klog < k) \n      k = klog; \n \n    if (k<2) \n      k=2; \n    else if(k>6) \n      k=6; \n  } \n \n  const wi_t wide = C->width; \n  const word bm = __M4RI_TWOPOW(k)-1; \n \n  rci_t *buffer = (rci_t*)m4ri_mm_malloc(__M4RI_M4RM_NTABLES * __M4RI_TWOPOW(k) * sizeof(rci_t)); \n  for(int z=0; z<__M4RI_M4RM_NTABLES; z++) { \n    L[z] = buffer + z*__M4RI_TWOPOW(k); \n     \n \n    Talign[z] = mzd_init(__M4RI_TWOPOW(k), b_nc+m4ri_radix); \n    T[z] = mzd_init_window(Talign[z], 0, c_align*m4ri_radix, Talign[z]->nrows, b_nc + c_align*m4ri_radix); \n    T[z] = mzd_init(__M4RI_TWOPOW(k), b_nc); \n  } \n \n   \n \n  int const kk = __M4RI_M4RM_NTABLES * k; \n  assert(kk <= m4ri_radix); \n  rci_t const end = a_nc / kk; \n \n  for (rci_t giantstep = 0; giantstep < a_nr; giantstep += blocksize) { \n    for(rci_t i = 0; i < end; ++i) { \n      for(int z=0; z<__M4RI_M4RM_NTABLES; z++) { \n        mzd_make_table( B, kk*i + k*z, 0, k, T[z], L[z]); \n      } \n \n      const rci_t blockend = MIN(giantstep+blocksize, a_nr); \n#pragma omp parallel for schedule(static,512) private(x,t) \n      for(rci_t j = giantstep; j < blockend; j++) { \n        const word a = mzd_read_bits(A, j, kk*i, kk); \n \n        switch(__M4RI_M4RM_NTABLES) { \n        case 8: t[7] = T[ 7]->rows[ L[7][ (a >> 7*k) & bm ] ]; \n        case 7: t[6] = T[ 6]->rows[ L[6][ (a >> 6*k) & bm ] ]; \n        case 6: t[5] = T[ 5]->rows[ L[5][ (a >> 5*k) & bm ] ]; \n        case 5: t[4] = T[ 4]->rows[ L[4][ (a >> 4*k) & bm ] ]; \n        case 4: t[3] = T[ 3]->rows[ L[3][ (a >> 3*k) & bm ] ]; \n        case 3: t[2] = T[ 2]->rows[ L[2][ (a >> 2*k) & bm ] ]; \n        case 2: t[1] = T[ 1]->rows[ L[1][ (a >> 1*k) & bm ] ]; \n        case 1: t[0] = T[ 0]->rows[ L[0][ (a >> 0*k) & bm ] ]; \n          break; \n        default: \n          m4ri_die(\"__M4RI_M4RM_NTABLES must be <= 8 but got %d\", __M4RI_M4RM_NTABLES); \n        } \n \n        c = C->rows[j]; \n \n        switch(__M4RI_M4RM_NTABLES) { \n        case 8: _mzd_combine_8(c, t, wide); break; \n        case 7: _mzd_combine_7(c, t, wide); break; \n        case 6: _mzd_combine_6(c, t, wide); break; \n        case 5: _mzd_combine_5(c, t, wide); break; \n        case 4: _mzd_combine_4(c, t, wide); break; \n        case 3: _mzd_combine_3(c, t, wide); break; \n        case 2: _mzd_combine_2(c, t, wide); break; \n        case 1: _mzd_combine(c, t[0], wide); \n          break; \n      ", "pred": " \nmzd_t *_mzd_mul_m4rm(mzd_t *C, mzd_t const *A, mzd_t const *B, int k, int clear) { \n   \n \n \n  rci_t        x[__M4RI_M4RM_NTABLES]; \n  rci_t       *L[__M4RI_M4RM_NTABLES]; \n  word  const *t[__M4RI_M4RM_NTABLES]; \n  mzd_t       *T[__M4RI_M4RM_NTABLES]; \n  mzd_t  *Talign[__M4RI_M4RM_NTABLES]; \n  int c_align = (__M4RI_ALIGNMENT(C->rows[0], 16) == 8); \n \n  word *c; \n \n  rci_t const a_nr = A->nrows; \n  rci_t const a_nc = A->ncols; \n  rci_t const b_nc = B->ncols; \n \n  if (b_nc < m4ri_radix-10 || a_nr < 16) { \n    if(clear) \n      return mzd_mul_naive(C, A, B); \n    else \n      return mzd_addmul_naive(C, A, B); \n  } \n \n   \n \n  if (clear) { \n    mzd_set_ui(C, 0); \n  } \n \n  const int blocksize = __M4RI_MUL_BLOCKSIZE; \n \n  if(k==0) { \n     \n \n    k = (int)log2((__M4RI_CPU_L2_CACHE/64)/(double)B->width); \n    if ((__M4RI_CPU_L2_CACHE - 64*__M4RI_TWOPOW(k)*B->width) > (64*__M4RI_TWOPOW(k+1)*B->width - __M4RI_CPU_L2_CACHE)) \n      k++; \n \n    rci_t const k = (__M4RI_CPU_L2_CACHE/64)/(double)B->width;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "}
{"label": " \nvoid process(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, void *const ovoid, \n             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int ch = piece->colors; \n  const dt_iop_rgblevels_data_t *const d = (dt_iop_rgblevels_data_t *)piece->data; \n  dt_iop_rgblevels_params_t *p = (dt_iop_rgblevels_params_t *)&d->params; \n  dt_iop_rgblevels_gui_data_t *g = (dt_iop_rgblevels_gui_data_t *)self->gui_data; \n  const dt_iop_order_iccprofile_info_t *const work_profile = dt_ioppr_get_pipe_work_profile_info(piece->pipe); \n \n   \n \n  if(g && piece->pipe->type == DT_DEV_PIXELPIPE_PREVIEW) \n  { \n    dt_pthread_mutex_lock(&g->lock); \n    if(g->call_auto_levels == 1 &&!darktable.gui->reset) \n    { \n      g->call_auto_levels = -1; \n \n      dt_pthread_mutex_unlock(&g->lock); \n \n      memcpy(&g->params, p, sizeof(dt_iop_rgblevels_params_t)); \n \n      int box[4] = { 0 }; \n      _get_selected_area(self, piece, g, roi_in, box); \n      _auto_levels((const float *const)ivoid, roi_in->width, roi_in->height, box, &(g->params), g->channel, work_profile); \n \n      dt_pthread_mutex_lock(&g->lock); \n \n      g->call_auto_levels = 2; \n \n      dt_pthread_mutex_unlock(&g->lock); \n    } \n    else \n    { \n      dt_pthread_mutex_unlock(&g->lock); \n    } \n  } \n \n  const float mult[3] = { 1.f / (d->params.levels[0][2] - d->params.levels[0][0]), \n                          1.f / (d->params.levels[1][2] - d->params.levels[1][0]), \n                          1.f / (d->params.levels[2][2] - d->params.levels[2][0]) }; \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(work_profile, d, ch, ivoid, ovoid, roi_out, mult)    schedule(static) \n  for(int k = 0; k < roi_out->height; k++) \n  { \n    float *in = (float *)ivoid + (size_t)k * ch * roi_out->width; \n    float *out = (float *)ovoid + (size_t)k * ch * roi_out->width; \n \n    for(int j = 0; j < roi_out->width; j++, in += ch, out += ch) \n    { \n      if(d->params.autoscale == DT_IOP_RGBLEVELS_INDEPENDENT_CHANNELS || d->params.preserve_colors == DT_RGB_NORM_NONE) \n      { \n        for(int c = 0; c < 3; c++) \n        { \n          const float L_in = in[c]; \n \n          if(L_in <= d->params.levels[c][0]) \n          { \n             \n \n            out[c] = 0.0f; \n          } \n          else if(L_in >= d->params.levels[c][2]) \n          { \n            const float percentage = (L_in - d->params.levels[c][0]) * mult[c]; \n            out[c] = pow(percentage, d->inv_gamma[c]); \n          } \n          else \n          { \n             \n \n            const float percentage = (L_in - d->params.levels[c][0]) * mult[c]; \n            out[c] = d->lut[c][CLAMP((int)(percentage * 0x10000ul), 0, 0xffff)]; \n          } \n        } \n      } \n      else \n      { \n        const int ch_levels = 0; \n \n        float ratio = 1.f; \n        const float lum = dt_rgb_norm(in, d->params.preserve_colors, work_profile); \n        if(lum > d->params.levels[ch_levels][0]) \n        { \n          float curve_lum; \n          if(lum >= d->params.levels[ch_levels][2]) \n          { \n            const float percentage = (lum - d->params.levels[ch_levels][0]) * mult[ch_levels]; \n            curve_lum = pow(percentage, d->inv_gamma[ch_levels]); \n          } \n          else \n          { \n             \n \n            const float percentage = (lum - d->params.levels[ch_levels][0]) * mult[ch_levels]; \n            curve_lum = d->lut[ch_levels][CLAMP((int)(percentage * 0x10000ul), 0, 0xffff)]; \n          } \n \n          ratio = curve_lum / lum; \n \n          for(int c = 0; c < 3; c++) \n          { \n            out[c] = (ratio * in[c]); \n          } \n        } \n        else \n        { \n          for(int c = 0; c < 3; c++) out[c] = 0.f; \n        } \n      } \n ", "pred": " \nvoid process(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, void *const ovoid, \n             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int ch = piece->colors; \n  const dt_iop_rgblevels_data_t *const d = (dt_iop_rgblevels_data_t *)piece->data; \n  dt_iop_rgblevels_params_t *p = (dt_iop_rgblevels_params_t *)&d->params; \n  dt_iop_rgblevels_gui_data_t *g = (dt_iop_rgblevels_gui_data_t *)self->gui_data; \n  const dt_iop_order_iccprofile_info_t *const work_profile = dt_ioppr_get_pipe_work_profile_info(piece->pipe); \n \n   \n \n  if(g && piece->pipe->type == DT_DEV_PIXELPIPE_PREVIEW) \n  { \n    dt_pthread_mutex_lock(&g->lock); \n    if(g->call_auto_levels == 1 &&!darktable.gui->reset) \n    { \n      g->call_auto_levels = -1; \n \n      dt_pthread_mutex_unlock(&g->lock); \n \n      memcpy(&g->params, p, sizeof(dt_iop_rgblevels_params_t)); \n \n      int box[4] = { 0 }; \n      _get_selected_area(self, piece, g, roi_in, box); \n      _auto_levels((const float *const)ivoid, roi_in->width, roi_in->height, box, &(g->params), g->channel, work_profile); \n \n      dt_pthread_mutex_lock(&g->lock); \n \n      g->call_auto_levels = 2; \n \n      dt_pthread_mutex_unlock(&g->lock);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         "}
{"label": " \nvoid process_sse2(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_UINT16) \n  {  \n \n#pragma omp parallel for default(none) schedule(static) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const uint16_t *in = ((uint16_t *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      float *out = ((float *)ovoid) + (size_t)roi_out->width * j; \n \n      int i = 0; \n \n       \n \n      while((!dt_is_aligned(in, 16) ||!dt_is_aligned(out, 16)) && (i < roi_out->width)) \n      { \n        const int id = BL(roi_out, d, j, i); \n        *out = (((float)(*in)) - d->sub[id]) / d->div[id]; \n        i++; \n        in++; \n        out++; \n      } \n \n      const __m128 sub = _mm_set_ps(d->sub[BL(roi_out, d, j, i + 3)], d->sub[BL(roi_out, d, j, i + 2)], \n                                    d->sub[BL(roi_out, d, j, i + 1)], d->sub[BL(roi_out, d, j, i)]); \n \n      const __m128 div = _mm_set_ps(d->div[BL(roi_out, d, j, i + 3)], d->div[BL(roi_out, d, j, i + 2)], \n                                    d->div[BL(roi_out, d, j, i + 1)], d->div[BL(roi_out, d, j, i)]); \n \n       \n \n      for(; i < roi_out->width - (8 - 1); i += 8, in += 8) \n      { \n        const __m128i input = _mm_load_si128((__m128i *)in); \n \n        __m128i ilo = _mm_unpacklo_epi16(input, _mm_set1_epi16(0)); \n        __m128i ihi = _mm_unpackhi_epi16(input, _mm_set1_epi16(0)); \n \n        __m128 flo = _mm_cvtepi32_ps(ilo); \n        __m128 fhi = _mm_cvtepi32_ps(ihi); \n \n        flo = _mm_div_ps(_mm_sub_ps(flo, sub), div); \n        fhi = _mm_div_ps(_mm_sub_ps(fhi, sub), div); \n \n        _mm_stream_ps(out, flo); \n        out += 4; \n        _mm_stream_ps(out, fhi); \n        out += 4; \n      } \n \n       \n \n      for(; i < roi_out->width; i++, in++, out++) \n      { \n        const int id = BL(roi_out, d, j, i); \n        *out = (((float)(*in)) - d->sub[id]) / d->div[id]; \n      } \n    } \n \n    piece->pipe->dsc.filters = dt_rawspeed_crop_dcraw_filters(self->dev->image_storage.buf_dsc.filters, csx, csy); \n    adjust_xtrans_filters(piece->pipe, csx, csy); \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_FLOAT) \n  {  \n \n#pragma omp parallel for default(none) schedule(static) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      float *out = ((float *)ovoid) + (size_t)roi_out->width * j; \n \n      int i = 0; \n \n       \n \n      while((!dt_is_aligned(in, 16) ||!dt_is_aligned(out, 16)) && (i < roi_out->width)) \n      { \n        const int id = BL(roi_out, d, j, i); \n        *out = (*in - d->sub[id]) / d->div[id]; \n        i++; \n        in++; \n        out++; \n      } \n \n      const __m128 sub = _mm_set_ps(d->sub[BL(roi_out, d, j, i + 3)], d->sub[BL(roi_out, d, j, i + 2)], \n                                    d->sub[BL(roi_out, d, j, i + 1)], d->sub[BL(roi_out, d, j, i)]); \n \n      const __m128 div = _mm_set_ps(d->div[BL(roi_out, d, j, i + 3)], d->div[BL(roi_out, d, j, i + 2)], \n                                    d->div[BL(roi_out, d, j, i + 1)], d->div[BL(roi_out, d, j, i)]); \n \n       \n \n      for(; i < roi_out->width - (", "pred": " \nvoid process_sse2(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_UINT16) \n  {  \n \n#pragma omp parallel for default(none) schedule(static) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const uint16_t *in = ((uint16_t *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      float *out = ((float *)ovoid) + (size_t)roi_out->width * j; \n \n      int i = 0; \n \n       \n \n      while((!dt_is_aligned(in, 16) ||!dt_is_aligned(out, 16)) && (i < roi_out->width)) \n      { \n        const int id = BL(roi_out, d, j, i); \n        *out = (((float)(*in)) - d->sub[id]) / d->div[id]; \n        i++; \n        in++; \n        out++; \n      } \n \n      const __m128 sub = _mm_set_ps(d->sub[BL(roi_out, d, j, i + 3)], 0);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_soften_data_t *data = (dt_iop_soften_data_t *)piece->data; \n  float *in = (float *)ivoid; \n  float *out = (float *)ovoid; \n  const int ch = piece->colors; \n \n  const float brightness = 1.0 / exp2f(-data->brightness); \n  const float saturation = data->saturation / 100.0; \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(ch, brightness, roi_out, saturation)    shared(in, out)    schedule(static) \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    size_t index = ch * k; \n    float h, s, l; \n    rgb2hsl(&in[index], &h, &s, &l); \n    s *= saturation; \n    l *= brightness; \n    hsl2rgb(&out[index], h, CLIP(s), CLIP(l)); \n  } \n \n  const float w = piece->iwidth * piece->iscale; \n  const float h = piece->iheight * piece->iscale; \n  int mrad = sqrt(w * w + h * h) * 0.01; \n  int rad = mrad * (fmin(100.0, data->size + 1) / 100.0); \n  const int radius = MIN(mrad, ceilf(rad * roi_in->scale / piece->iscale)); \n \n  const int size = roi_out->width > roi_out->height? roi_out->width : roi_out->height; \n \n  __m128 *const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(__m128)); \n \n  for(int iteration = 0; iteration < BOX_ITERATIONS; iteration++) \n  { \n#pragma omp parallel for default(none)      dt_omp_firstprivate(ch, radius, roi_out, scanline_buf, size)      shared(out)      schedule(static) \n     \n \n    for(int y = 0; y < roi_out->height; y++) \n    { \n      __m128 *scanline = scanline_buf + size * dt_get_thread_num(); \n      size_t index = (size_t)y * roi_out->width; \n      __m128 L = _mm_setzero_ps(); \n      int hits = 0; \n      for(int x = -radius; x < roi_out->width; x++) \n      { \n        int op = x - radius - 1; \n        int np = x + radius; \n        if(op >= 0) \n        { \n          L = _mm_sub_ps(L, _mm_load_ps(&out[(index + op) * ch])); \n          hits--; \n        } \n        if(np < roi_out->width) \n        { \n          L = _mm_add_ps(L, _mm_load_ps(&out[(index + np) * ch])); \n          hits++; \n        } \n        if(x >= 0) scanline[x] = _mm_div_ps(L, _mm_set_ps1(hits)); \n      } \n \n      for(int x = 0; x < roi_out->width; x++) _mm_store_ps(&out[(index + x) * ch], scanline[x]); \n    } \n \n     \n \n    const int opoffs = -(radius + 1) * roi_out->width; \n    const int npoffs = (radius)*roi_out->width; \n#pragma omp parallel for default(none)      dt_omp_firstprivate(ch, npoffs, opoffs, radius, roi_out, scanline_buf, size)      shared(out)      schedule(static) \n    for(int x = 0; x < roi_out->width; x++) \n    { \n      __m128 *scanline = scanline_buf + size * dt_get_thread_num(); \n      __m128 L = _mm_setzero_ps(); \n      int hits = 0; \n      size_t index = (size_t)x - radius * roi_out->width; \n      for(int y = -radius; y < roi_out->height; y++) \n      { \n        int op = y - radius - 1; \n        int np = y + radius; \n \n        if(op >= 0) \n        { \n          L = _mm_sub_ps(L, _mm_load_ps(&out[(index + opoffs) * ch])); \n          hits--; \n        } \n        if(np < roi_out->height) \n        { \n          L = _mm_add_ps(L, _mm_load_ps(&out[(index + npoffs) * ch])); \n          hits++; \n        } \n        if(y >= 0) scanline[y] = _mm_div_ps(L, _mm_set_ps1(hits)); \n        index += roi_out->width; \n      } \n \n      for(int y = 0; y < roi_out->height; y++) \n        _mm_store_ps(&out[((size_t)y * roi_out->width + x) * ch], scanline[y]); \n    } \n  } \n \n  dt_free_align(scanline_buf); \n \n  const __m128 amount = _mm_set1_ps(data->amount / 100.0); \n  const __m128 amount_1 = _mm_set1_ps(1 - (data->amount) / 100.0); \n#pragma omp parallel for default(none)    dt_omp_firstprivate(ch, amount, amount_1, roi_out)    shared(in, out, data)    schedule(static) \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    int index = ch * k; \n    _mm_store_ps(&out[index], _mm_add_ps(_mm_mul_ps(_mm_load_ps(&in[index]), amount_1), \n         ", "pred": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_soften_data_t *data = (dt_iop_soften_data_t *)piece->data; \n  float *in = (float *)ivoid; \n  float *out = (float *)ovoid; \n  const int ch = piece->colors; \n \n  const float brightness = 1.0 / exp2f(-data->brightness); \n  const float saturation = data->saturation / 100.0; \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(ch, brightness, roi_out, saturation)    shared(in, out)    schedule(static) \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    size_t index = ch * k; \n    float h, s, l; \n    rgb2hsl(&in[index], &h, &s, &l); \n    s *= saturation; \n    l *= brightness; \n    hsl2rgb(&out[index], h, CLIP(s), CLIP(l)); \n  } \n \n  const float w = piece->iwidth * piece->iscale; \n  const float h = piece->iheight * piece->iscale; \n  int mrad = sqrt(w * w + h * h) * 0.01; \n  int rad = mrad * (fmin(100.0, data->size + 1) / 100.0); \n  const int radius = MIN(mrad, ceilf(rad * roi_in->scale / piece->iscale)); \n \n  const int size = roi_out->width > roi_out->height? roi_out->width : roi_out->height; \n \n  __m128 *const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(int));  const float * const"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 24; \n  tile_size[3] = 1024; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0765; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,4);t1++) { \n    lbp=max(ceild(t1,2),ceild(8*t1-Nt+3,8)); \n    ubp=min(floord(Nt+Nz-4,8),floord(4*t1+Nz+1,8)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-5,6)),ceild(8*t2-Nz-20,24));t3<=min(min(min(floord(Nt+Ny-4,24),floord(4*t1+Ny+5,24)),floord(8*t2+Ny+4,24)),floord(8*t1-8*t2+Nz+Ny+3,24));t3++) { \n        for (t4=max(max(max(0,ceild(t1-255,256)),ceild(8*t2-Nz-1020,1024)),ceild(24*t3-Ny-1020,1024));t4<=min(min(min(min(floord(Nt+Nx-4,1024),floord(4*t1+Nx+5,1024)),floord(8*t2+Nx+4,1024)),floord(24*t3+Nx+20,1024)),floord(8*t1-8*t2+Nz+Nx+3,1024));t4++) { \n          for (t5=max(max(max(max(max(0,4*t1),8*t1-8*t2+1),8*t2-Nz+2),24*t3-Ny+2),1024*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,4*t1+7),8*t2+6),24*t3+22),1024*t4+1022),8*t1-8*t2+Nz+5);t5++) { \n            for (t6=max(max(8*t2,t5+1),-8*t1+8*t2+2*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(24*t3,t5+1);t7<=min(24*t3+23,t5+Ny-2);t7++) { \n                lbv=max(1024*t4,t5+1); \n                ubv=min(1024*t4+1023,t5+Nx-2); \n#pragma ivdep \n#pragma vector always \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = ((alpha * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (beta * (((((A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)] + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) - 1][ (-t", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 24; \n  tile_size[3] = 1024; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0876;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "}
{"label": " \nvoid mzd_process_rows3(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, rci_t const *L2) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int rem = k % 3; \n \n  int const ka = k / 3 + ((rem >= 2)? 1 : 0); \n  int const kb = k / 3 + ((rem >= 1)? 1 : 0); \n  int const kc = k / 3; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n  word const kc_bm = __M4RI_LEFT_BITMASK(kc); \n \n#pragma omp parallel for private(r) shared(startrow, stoprow) schedule(static,512)  \n \n  for(r= startrow; r < stoprow; ++r) { \n    word bits = mzd_read_bits(M, r, startcol, k); \n    rci_t const x0 = L0[ bits & ka_bm ]; bits>>=ka; \n    rci_t const x1 = L1[ bits & kb_bm ]; bits>>=kb; \n    rci_t const x2 = L2[ bits & kc_bm ]; \n    if((x0 | x1 | x2) == 0)  \n \n      continue; \n \n    word *m0 = M->rows[r] + blocknum; \n    word const *t[3]; \n    t[0] = T0->rows[x0] + blocknum; \n    t[1] = T1->rows[x1] + blocknum; \n    t[2] = T2->rows[x2] + blocknum; \n \n    _mzd_combine_3( m0, t, wide); \n  } \n \n  __M4RI_DD_MZD(M); \n} ", "pred": " \nvoid mzd_process_rows3(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, rci_t const *L2) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int rem = k % 3; \n \n  int const ka = k / 3 + ((rem >= 2)? 1 : 0); \n  int const kb = k / 3 + ((rem >= 1)? 1 : 0); \n  int const kc = k / 3; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n  word const kc_bm = __M4RI_LEFT_BITMASK(kc); \n \n#pragma omp parallel for private(r) shared(startrow, stoprow) schedule(static,512)  \n \n  for(r= startrow; r < stoprow; ++r) { \n    word bits = mzd_read_bits(M, r, startcol, k); \n    rci_t const x0 = L0[ bits & ka_bm ]; bits>>=ka; \n    rci_t const x1 = L1[ bits & kb_bm ]; bits>>=kb; \n    rci_t const x2 = L2[ bits & kc_bm ]; \n    if((x0 | x1 | x2) == 0)  \n \n      continue; \n \n    word *m0 = M->rows[r] + blocknum; \n    word const *t[3]; \n    t[0] = T0->rows[x0] + blocknum; \n    t[1] = T1->rows[x1] + blocknum; \n    t[2] = T1->rows[x2] + blocknum;                                                  "}
{"label": " \nvoid mzd_process_rows2(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int const ka = k / 2; \n  int const kb = k - k / 2; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n \n#pragma omp parallel for private(r) shared(startrow, stoprow) schedule(static,512)  \n \n  for(r = startrow; r < stoprow; ++r) { \n    word bits = mzd_read_bits(M, r, startcol, k); \n    rci_t const x0 = L0[ bits & ka_bm ]; bits>>=ka; \n    rci_t const x1 = L1[ bits & kb_bm ]; \n    if((x0 | x1) == 0)\t \n \n      continue; \n    word *m0 = M->rows[r] + blocknum; \n    word const *t[2]; \n    t[0] = T0->rows[x0] + blocknum; \n    t[1] = T1->rows[x1] + blocknum; \n \n    _mzd_combine_2( m0, t, wide); \n  } \n \n  __M4RI_DD_MZD(M); \n} ", "pred": " \nvoid mzd_process_rows2(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int const ka = k / 2; \n  int const kb = k - k / 2; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n \n#pragma omp parallel for private(r) shared(startrow, stoprow) schedule(static,512)  \n \n  for(r = startrow; r < stoprow; ++r) { \n    word bits = mzd_read_bits(M, r, startcol, k); \n    rci_t const x0 = L0[ bits & ka_bm ]; bits>>=ka; \n    rci_t const x1 = L1[ bits & kb_bm ]; \n    if((x0 | x1) == 0)\t \n \n      continue; \n    word *m0 = M->rows[r] + blocknum; \n    word const *t[2]; \n    t[0] = T0->rows[x0] + blocknum; \n    t[1] = T1->rows[x1] + blocknum; \n \n    _mzd_combine_2( m0, t, wide); \n  } \n \n  __M4RI_DD_MZD(M); \n} "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 32; \n  tile_size[3] = 32; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=Nt-1;t1++) { \n    lbp=ceild(t1+1,2); \n    ubp=min(floord(4*Nt+Nz-9,8),floord(4*t1+Nz-2,8)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(ceild(t1-6,8),ceild(8*t2-Nz-19,32));t3<=min(floord(4*Nt+Ny-9,32),floord(4*t1+Ny-1,32));t3++) { \n        for (t4=max(max(ceild(t1-6,8),ceild(8*t2-Nz-19,32)),ceild(32*t3-Ny-19,32));t4<=min(min(floord(4*Nt+Nx-9,32),floord(4*t1+Nx-1,32)),floord(32*t3+Nx+19,32));t4++) { \n          for (t5=max(max(max(max(0,ceild(8*t2-Nz+5,4)),ceild(32*t3-Ny+5,4)),ceild(32*t4-Nx+5,4)),t1);t5<=min(min(min(Nt-1,t1+1),8*t3+6),8*t4+6);t5++) { \n            for (t6=max(max(8*t2,4*t5+4),-8*t1+8*t2+8*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(32*t3,4*t5+4);t7<=min(32*t3+31,4*t5+Ny-5);t7++) { \n                lbv=max(32*t4,4*t5+4); \n                ubv=min(32*t4+31,4*t5+Nx-5); \n#pragma ivdep \n#pragma vector always \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((2.0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 32; \n  tile_size[3] = 8;   tile_size[4] = 32;   tile_size[5] = 32;   tile_size[6] = 32;   tile_size[7] = 32;   tile_size[8] = 32;   tile_size[9] = 32;   tile_size[10] = 32;   tile_size[11] = 32;   tile_size[12] = 32;   tile_size[13] = 32;   tile_size[14] = 32;   tile_size[15] = 32;   tile_size[16] = 32;   tile_size[17] = 32;   tile_size[18] = 32;   tile_size[19] = 32;   tile_size[20] = 32;   tile_size[21] = 32;   tile_size[22] = 32;   tile_size[23] = 32;   tile_size[24] = 32;   tile_size[25] = 32;   tile_size[26] = 32;   tile_size[27] = 32;   tile_size[28] = 32;   tile_size[29] = 32;   tile_size[30] = 32;   tile_size[31] = 32;   tile_size[32] = 32;   tile_size[33] = 32;   tile_size[34] = 32;   tile_size[35] = 32;   tile_size[36] = 32;   tile_size[37] = 32;   tile_size[38] = 32;   tile_size[39] = 32;   tile_size[40] = 32;   tile_size[41] = 32;   tile_size[42] = 32;   tile_size[43] = 32;   tile_size[44] = 32;   tile_size[45] = 32;   tile_size[46] = 32;   tile_size[47] = 32;   tile_size[48] = 32;   tile_size[49] = 32;   tile_size[50] = 32;   tile_size[51] = 32;   tile_size[52] = 32;   tile_size[53] = 32;   tile_size[54] = 32;   tile_size[55] = 32;   tile_size[56] = 32;   tile_size[57] = 32;   tile_size[58] = 32;   tile_size[59] = 32;   tile_size[60] = 32;   tile_size[61] = 32;   tile_size[62] = 32;   tile_size[63] = 32;   tile_size[64] = 32;   tile_size[65] = 32;   tile_size[66] = 32;   tile_size[67] = 32;   tile_size[68] = 32;   tile_size[69] = 32;   tile_size[70] = 32;   tile_size[72] = 32;   tile_size[73] = 32;   tile_size[73] = 32;   tile_size[74] = 32;   tile_size[75] = 32;   tile_size[76] = 32;   tile_size[77] = 32;   tile_size[78] = 32;   tile_size[78] = 32;   tile_size[79] = 32;   tile_size[80] = 32;   tile_size[81] = 32;   tile_size[81] = 32;   tile_size[82] = 32;   tile_size[83] = 32;   tile_size[83] = 32;   tile_size[84] = 32;   tile_size[85] = 32;   tile_size[86] = 32;   tile_size[86] = 32;   tile_size[87] = 32;   tile_size[88] = 32;   tile_size[89] = 32;   tile_size[90] = 32;   tile_size[91] = 32;   tile_size[92] = 32;   tile_size[93] = 32;   tile_size[93] = 32;   tile_size[93] = 32;   tile_size[94] = 32;   tile_size[95] = 32;   tile_size[96] = 32;   tile_size[96] = 32;   tile_size[97] = 32;   tile_size[98] = 32;   tile_size[99] = 32;   tile_size[100] = 32;   tile_size[101] = 32;   tile_size[102] = 32;   tile_size[103] = 32;   tile_size[104] = 32;   tile_size[105] = 32;   tile_size[106] = 32;   tile_size[106] = 32;   tile_size[107] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size"}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_soften_data_t *const d = (const dt_iop_soften_data_t *const)piece->data; \n \n  const int ch = piece->colors; \n \n  const float brightness = 1.0 / exp2f(-d->brightness); \n  const float saturation = d->saturation / 100.0; \n \n  const float *const in = (const float *const)ivoid; \n  float *const out = (float *const)ovoid; \n \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(brightness, ch, in, out, roi_out, saturation)    schedule(static) \n  for(size_t k = 0; k < (size_t)ch * roi_out->width * roi_out->height; k += ch) \n  { \n    float h, s, l; \n    rgb2hsl(&in[k], &h, &s, &l); \n    s *= saturation; \n    l *= brightness; \n    hsl2rgb(&out[k], h, CLIP(s), CLIP(l)); \n  } \n \n  const float w = piece->iwidth * piece->iscale; \n  const float h = piece->iheight * piece->iscale; \n  int mrad = sqrt(w * w + h * h) * 0.01; \n  int rad = mrad * (fmin(100.0, d->size + 1) / 100.0); \n  const int radius = MIN(mrad, ceilf(rad * roi_in->scale / piece->iscale)); \n \n  const int size = roi_out->width > roi_out->height? roi_out->width : roi_out->height; \n \n  const size_t scanline_size = (size_t)4 * size; \n  float *const scanline_buf = dt_alloc_align(64, scanline_size * dt_get_num_threads() * sizeof(float)); \n \n  for(int iteration = 0; iteration < BOX_ITERATIONS; iteration++) \n  { \n#pragma omp parallel for default(none)      dt_omp_firstprivate(ch, radius, out, roi_out, scanline_buf, scanline_size)      schedule(static) \n     \n \n    for(int y = 0; y < roi_out->height; y++) \n    { \n      float *scanline = scanline_buf + scanline_size * dt_get_thread_num(); \n      __attribute__((aligned(64))) float L[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; \n \n      size_t index = (size_t)y * roi_out->width; \n      int hits = 0; \n      for(int x = -radius; x < roi_out->width; x++) \n      { \n        int op = x - radius - 1; \n        int np = x + radius; \n        if(op >= 0) \n        { \n          for(int c = 0; c < 4; c++) \n          { \n            L[c] -= out[((index + op) * ch) + c]; \n          } \n          hits--; \n        } \n        if(np < roi_out->width) \n        { \n          for(int c = 0; c < 4; c++) \n          { \n            L[c] += out[((index + np) * ch) + c]; \n          } \n          hits++; \n        } \n        if(x >= 0) \n        { \n          for(int c = 0; c < 4; c++) \n          { \n            scanline[4 * x + c] = L[c] / hits; \n          } \n        } \n      } \n \n      for(int x = 0; x < roi_out->width; x++) \n      { \n        for(int c = 0; c < 4; c++) \n        { \n          out[(index + x) * ch + c] = scanline[4 * x + c]; \n        } \n      } \n    } \n \n     \n \n    const int opoffs = -(radius + 1) * roi_out->width; \n    const int npoffs = (radius)*roi_out->width; \n#pragma omp parallel for default(none)      dt_omp_firstprivate(ch, npoffs, opoffs, radius, out, roi_out,                          scanline_buf, scanline_size)      schedule(static) \n    for(int x = 0; x < roi_out->width; x++) \n    { \n      float *scanline = scanline_buf + scanline_size * dt_get_thread_num(); \n      __attribute__((aligned(64))) float L[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; \n \n      int hits = 0; \n      size_t index = (size_t)x - radius * roi_out->width; \n      for(int y = -radius; y < roi_out->height; y++) \n      { \n        int op = y - radius - 1; \n        int np = y + radius; \n \n        if(op >= 0) \n        { \n          for(int c = 0; c < 4; c++) \n          { \n            L[c] -= out[((index + opoffs) * ch) + c]; \n          } \n          hits--; \n        } \n        if(np < roi_out->height) \n        { \n          for(int c = 0; c < 4; c++) \n          { \n            L[c] += out[((index + npoffs) * ch) + c]; \n          } \n          hits++; \n        } \n", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_soften_data_t *const d = (const dt_iop_soften_data_t *const)piece->data; \n \n  const int ch = piece->colors; \n \n  const float brightness = 1.0 / exp2f(-d->brightness); \n  const float saturation = d->saturation / 100.0; \n \n  const float *const in = (const float *const)ivoid; \n  float *const out = (float *const)ovoid; \n \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(brightness, ch, in, out, roi_out, saturation)    schedule(static) \n  for(size_t k = 0; k < (size_t)ch * roi_out->width * roi_out->height; k += ch) \n  { \n    float h, s, l; \n    rgb2hsl(&in[k], &h, &s, &l); \n    s *= saturation; \n    l *= brightness; \n    hsl2rgb(&out[k], h, CLIP(s), CLIP(l)); \n  } \n \n  const float w = piece->iwidth * piece->iscale; \n  const float h = piece->iheight * piece->iscale; \n  int mrad = sqrt(w * w + h * h) * 0.01; \n  int rad = mrad * (fmin(100.0, d->size + 1) / 100.0); \n  const int radius = MIN(mrad, ceilf(rad * roi_in->scale / piece->iscale)); \n \n  const int size = roi_out->width > roi_out->height? roi_out->width : roi_out->height; \n \n  const size_t scanline_size = (size_t)4 * size; \n  float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_align(size, size, size, size, size, size);\\n    const float *const scanline_buf = dt_alloc_"}
{"label": " \nbyte _libaroma_ctl_pager_window_invalidate(LIBAROMA_WINDOWP win, byte sync){ \n  LIBAROMA_CONTROLP ctl=(LIBAROMA_CONTROLP) win->client_data; \n  _LIBAROMA_CTL_CHECK( \n    _libaroma_ctl_pager_handler, _LIBAROMA_CTL_PAGERP, 0 \n  ); \n  if (me->win!=win){ \n    return 0; \n  } \n  if ((me->win->dc)&&(me->win->bg)){ \n    libaroma_draw(me->win->dc,me->win->bg,0,0,0); \n     \n \n    int i; \n  #pragma omp parallel for \n    for (i=0;i<win->childn;i++){ \n       \n \n      libaroma_control_draw(win->childs[i], 0); \n    } \n  } \n  if (sync){ \n    return _libaroma_ctl_pager_window_sync(win,0,0,win->w,win->h); \n  } \n  return 1; \n} ", "pred": " \nbyte _libaroma_ctl_pager_window_invalidate(LIBAROMA_WINDOWP win, byte sync){ \n  LIBAROMA_CONTROLP ctl=(LIBAROMA_CONTROLP) win->client_data; \n  _LIBAROMA_CTL_CHECK( \n    _libaroma_ctl_pager_handler, _LIBAROMA_CTL_PAGERP, 0 \n  ); \n  if (me->win!=win){ \n    return 0; \n  } \n  if ((me->win->dc)&&(me->win->bg)){ \n    libaroma_draw(me->win->dc,me->win->bg,0,0,0); \n     \n \n    int i; \n  #pragma omp parallel for \n    for (i=0;i<win->childn;i++){ \n       \n \n      libaroma_control_draw(win->childs[i], 0); \n    } \n  } \n  if (sync){ \n    return _libaroma_ctl_pager_window_sync(win,0,0,win->w,win->h); \n  } \n  return 1; \n} "}
{"label": "oid gcc(const long out_dims[DIMS], complex float* out_data, const long caldims[DIMS], const complex float* cal_data) \n{ \n\tint ro = out_dims[READ_DIM]; \n \n\t \n \n \n\tlong tmp_dims[DIMS]; \n\tmd_copy_dims(DIMS, tmp_dims, caldims); \n\ttmp_dims[READ_DIM] = ro; \n\tcomplex float* tmp = md_alloc(DIMS, tmp_dims, CFL_SIZE); \n \n\tmd_resize_center(DIMS, tmp_dims, tmp, caldims, cal_data, CFL_SIZE); \n\tifftuc(DIMS, tmp_dims, READ_FLAG, tmp, tmp); \n \n\t \n \n \n\tlong tmp2_dims[DIMS]; \n\tmd_select_dims(DIMS, ~READ_FLAG, tmp2_dims, tmp_dims); \n \n\tlong out2_dims[DIMS]; \n\tmd_select_dims(DIMS, ~READ_FLAG, out2_dims, out_dims); \n \n \n#pragma omp parallel for \n\tfor (int i = 0; i < ro; i++) { \n \n\t\tcomplex float* tmp2 = md_alloc(DIMS, tmp2_dims, CFL_SIZE); \n\t\tcomplex float* out2 = md_alloc(DIMS, out2_dims, CFL_SIZE); \n \n\t\tlong pos[DIMS] = { [READ_DIM] = i }; \n\t\tmd_copy_block(DIMS, pos, tmp2_dims, tmp2, tmp_dims, tmp, CFL_SIZE); \n \n\t\tscc(out2_dims, out2, tmp2_dims, tmp2); \n \n\t\tmd_copy_block(DIMS, pos, out_dims, out_data, out2_dims, out2, CFL_SIZE); \n \n\t\tmd_free(out2); \n\t\tmd_free(tmp2); \n\t} \n} \n \n ", "pred": "oid gcc(const long out_dims[DIMS], complex float* out_data, const long caldims[DIMS], const complex float* cal_data) \n{ \n\tint ro = out_dims[READ_DIM]; \n \n\t \n \n \n\tlong tmp_dims[DIMS]; \n\tmd_copy_dims(DIMS, tmp_dims, caldims); \n\ttmp_dims[READ_DIM] = ro; \n\tcomplex float* tmp = md_alloc(DIMS, tmp_dims, CFL_SIZE); \n \n\tmd_resize_center(DIMS, tmp_dims, tmp, caldims, cal_data, CFL_SIZE); \n\tifftuc(DIMS, tmp_dims, READ_FLAG, tmp, tmp); \n \n\t \n \n \n\tlong tmp2_dims[DIMS]; \n\tmd_select_dims(DIMS, ~READ_FLAG, tmp2_dims, tmp_dims); \n \n\tlong out2_dims[DIMS]; \n\tmd_select_dims(DIMS, ~READ_FLAG, out2_dims, out_dims); \n \n \n#pragma omp parallel for \n\tfor (int i = 0; i < ro; i++) { \n \n\t\tcomplex float* tmp2 = md_alloc(DIMS, tmp2_dims, CFL_SIZE); \n\t\tcomplex float* out2 = md_alloc(DIMS, out2_dims, CFL_SIZE); \n \n\t\tlong pos[DIMS] = { [READ_DIM] = i }; \n\t\tmd_copy_block(DIMS, pos, tmp2_dims, tmp2, tmp_dims, tmp, CFL_SIZE); \n \n\t\tscc(out2_dims, out2, tmp2_dims, tmp2); \n \n\t\tmd_copy_block(DIMS, pos, out_dims, out_data, out2_dims, out2, CFL_SIZE); \n \n\t\tmd_free(out2); \n\t\tmd_free(tmp2); \n\t} \n} \n \n "}
{"label": " \nvoid mzd_process_rows4(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, rci_t const *L2,  \n                       mzd_t const *T3, rci_t const *L3) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int const rem = k % 4; \n \n  int const ka = k / 4 + ((rem >= 3)? 1 : 0); \n  int const kb = k / 4 + ((rem >= 2)? 1 : 0); \n  int const kc = k / 4 + ((rem >= 1)? 1 : 0); \n  int const kd = k / 4; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n  word const kc_bm = __M4RI_LEFT_BITMASK(kc); \n  word const kd_bm = __M4RI_LEFT_BITMASK(kd); \n \n#pragma omp parallel for private(r) shared(startrow, stoprow) schedule(static,512)  \n \n  for(r = startrow; r < stoprow; ++r) { \n    word bits = mzd_read_bits(M, r, startcol, k); \n    rci_t const x0 = L0[ bits & ka_bm ]; bits>>=ka; \n    rci_t const x1 = L1[ bits & kb_bm ]; bits>>=kb; \n    rci_t const x2 = L2[ bits & kc_bm ]; bits>>=kc; \n    rci_t const x3 = L3[ bits & kd_bm ]; \n    if(((x0 | x1) | (x2 | x3)) == 0)  \n \n      continue; \n \n    word *m0 = M->rows[r] + blocknum; \n    word const *t[4]; \n    t[0] = T0->rows[x0] + blocknum; \n    t[1] = T1->rows[x1] + blocknum; \n    t[2] = T2->rows[x2] + blocknum; \n    t[3] = T3->rows[x3] + blocknum; \n \n    _mzd_combine_4( m0, t, wide); \n  } \n \n  __M4RI_DD_MZD(M); \n} ", "pred": " \nvoid mzd_process_rows4(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, rci_t const *L2,  \n                       mzd_t const *T3, rci_t const *L3) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int const rem = k % 4; \n \n  int const ka = k / 4 + ((rem >= 3)? 1 : 0); \n  int const kb = k / 4 + ((rem >= 2)? 1 : 0); \n  int const kc = k / 4 + ((rem >= 1)? 1 : 0); \n  int const kd = k / 4; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n  word const kc_bm = __M4RI_LEFT_BITMASK(kc); \n  word const kd_bm = __M4RI_LEFT_BITMASK(kd); \n \n#pragma omp parallel for private(r) shared(startrow, stoprow) schedule(static,512)  \n \n  for(r = startrow; r < stoprow; ++r) { \n    word bits = mzd_read_bits(M, r, startcol, k); \n    rci_t const x0 = L0[ bits & ka_bm ]; bits>>=ka; \n    rci_t const x1 = L1[ bits & kb_bm ]; bits>>=kb; \n    rci_t const x2 = L2[ bits & kc_bm ]; bits>>=kc; \n    rci_t const x3 = L3[ bits & kd_bm ]; bits>>=kc;                                                                                                                                                                                                           "}
{"label": "d dt_colorspaces_cygm_to_rgb(float *out, int num, double CAM_to_RGB[3][4]) \n{ \n#pragma omp parallel for default(none) shared(out, num, CAM_to_RGB) schedule(static) \n  for(int i = 0; i < num; i++) \n  { \n    float *in = &out[i*4]; \n    float o[3] = {0.0f,0.0f,0.0f}; \n    for(int c = 0; c < 3; c++) \n      for(int k = 0; k < 4; k++) \n        o[c] += CAM_to_RGB[c][k] * in[k]; \n    for(int c = 0; c < 3; c++) \n      in[c] = o[c]; \n  } \n} \n \nvo ", "pred": "d dt_colorspaces_cygm_to_rgb(float *out, int num, double CAM_to_RGB[3][4]) \n{ \n#pragma omp parallel for default(none) shared(out, num, CAM_to_RGB) schedule(static) \n  for(int i = 0; i < num; i++) \n  { \n    float *in = &out[i*4]; \n    float o[3] = {0.0f,0.0f,0.0f}; \n    for(int c = 0; c < 3; c++) \n      for(int k = 0; k < 4; k++) \n        o[c] += CAM_to_RGB[c][k] * in[k]; \n    for(int c = 0; c < 3; c++) \n      in[c] = o[c]; \n  } \n} \n \nvo "}
{"label": " \nint main(int argc,char *argv[]) \n{ \n  const char *desc[] = { \n\t\t  \"[PAR]\", \n\t\t    \"________________[PAR]\", \n\t\t    \"Basic Options.[PAR]\", \n\t\t    \"----------------[PAR]\", \n \n    \"g_lomepro is a grid based tool to calculate Local Membrane Properties \", \n    \"of molecular dynamics trajectories [REF].\", \n    \"Thickness (-thick), area per lipid (APL) (-apl), Curvature (-curve) and \", \n    \"SCD Order parameters (-order) can be calculated.[PAR]\", \n \n    \"The user should specify a reference structure file (option -s) and a trajectoy file (option -f).\", \n    \"An index group (option -n) together with the option -num_lip are used to specify the representative lipid atom(s)\", \n    \"(Phosphorous, headgroups, whole lipid, etc.) and the total number of lipids.[PAR]\", \n \n    \"The number of grid elements in x and y axes can be specified (default 10) with -binx and -biny.[PAR]\", \n \n    \"With the option -prot a group of atoms (i.e. Protein) embedded in the membrane can be\", \n    \"explicitly considered for membrane property calculation.\", \n    \"If relevant, the center of mass displacement removal of the Protein group in the\", \n    \"trajectory file should be done *before* running g_lomepro (i.e. 'trjconv -fit').[PAR]\", \n \n    \"-precision option (default 1.5) defines the radius (nm) used to search for lipids when considering protein atoms.[PAR]\", \n \n    \"_________________________[PAR]\", \n    \"Property Specific Options[PAR]\", \n    \"-------------------------[PAR]\", \n \n     \n \n    \"Thickness (-thick):[PAR]\", \n \n    \"output: time averages (avg) and standard deviation (sd)\", \n    \"as matrix (dat) files and as pdb files with the thickness values in the B-factor field.[PAR]\", \n \n    \"-prot_val (default 0) specifies the thickness value for the grid elements occupied by the protein group on both leaflets.[PAR]\", \n \n    \"-scale factor (default 0.75) scales the thickness value in a grid element\", \n    \"in the situations where a grid cell is assigned a protein atom on one leaflet and the corresponding\", \n    \"grid cell on another leaflet has a lipid assigned[PAR]\", \n \n \n    \"...........................................................................[PAR]\", \n    \"APL option outputs (-apl):[PAR]\", \n \n    \"output: time averages (avg) and standard deviation (sd)\", \n    \"as matrix (dat) files and as pdb files with the APL values in the B-factor field.\", \n    \"In addition APL values for every lipid/protein averaged over trajectory are printed out,\", \n    \"as well as the APL value for every lipid/protein at every time step. [PAR]\", \n \n    \"...........................................................................[PAR]\", \n    \"Curvature (-curve):[PAR]\", \n \n    \"output: time averaged mean and gaussian curvature for the top and bottom leaflets separately\", \n    \"(in pdb and matrix.dat formats)[PAR]\", \n \n    \"-r_filter_low (default 0) relatively set lower bound for filtering in\", \n    \"frequency space (after FFT) controls high pass or band pass filters[PAR]\", \n \n    \"-r_filter_high (default -1) relatively set higher bound for filtering in\", \n    \"frequency space (after FFT) controls low pass or band pass filters[PAR]\", \n \n    \"-q_filter_low  (default 0) absolute value of lower bound (nm^-1) for filtering in\", \n    \"frequency space (after FFT) controls high pass or band pass filters[PAR]\", \n \n    \"-q_filter_high (default 100000) absolute value of higher bound (nm^-1) for \", \n    \"filtering in frequency space (after FFT) controls low pass or band pass filters[PAR]\", \n \n    \"-scale_mcurve (default 1) mean curvature values may be small, apply scaling\", \n    \" when printing pdb (no scaling for matrix output)[PAR]\", \n \n    \"-scale_gcurve (default 1) gaussian curvature values may be small, \", \n    \"apply scaling when printing pdb (no scaling for matrix output)[PAR]\", \n \n    \"-inv_mean_curve (default FALSE) allows inverting the signs of the mean curvature.\", \n    \"In the original g_lomepro paper, the sign of the mean curvature was determined from a point of view of an observer looking down onto a bilayer leaflet.\", \n    \"This way the positive mean curvature was assigned to the surface which bent towards the bilayer center.\", \n    \"Setting this flag to TRUE inverts the sign: the mean curvature becomes positive when the surface bends away from the bilayer midpoint.\", \n \n \n    \"...........................................................................[PAR]\", \n    \"Scd Order parameter (-order):[PAR]\", \n \n    \"output: time averaged pdb and data matrices containing -Scd order parameters are written for\", \n    \"every acyl chain atom for the top and bottom leaflets separately. \", \n    \"Also the average -Scd values for every lipid are printed out.[PAR]\", \n \n    \"NOTE: many output files are generated (acyl_chain_atoms x top_down_leaflets)[PAR]\", \n \n    \"Index file is required to contain separate groups for sn1 and sn2 chains with the acyl chain carbon atoms.[PAR]\", \n \n    \"-unsat option (default 0) defines the number of unsaturated acyl chains [0|1|2].\", \n    \"Currently one double bond is allowed per acyl chain.\", \n    \"The carbons around a double bond need to be defined in a separate group in the index file.\", \n    \"In case one double bond is selected, the chain with the double bond needs to be selected as chain-1 (sn-1) [PAR]. \", \n \n    \"In combination with -prot, -order_val controls the Scd values (default -1) asigned to the grid points occupied by protein atoms.[PAR]\", \n \n    \"-nt (number of threads) option can be used to speed up the Scd calculation by running on a number of threads in parallel.[PAR]\", \n \n \n    \"________________[PAR]\", \n    \"Other Options.[PAR]\", \n    \"----------------[PAR]\", \n \n    \"-normal flag allows to selecting axis normal to the bilayer (default 2, z-axis).[PAR]\", \n \n    \"If -breath option is set the grid is modified according to the box at every step.\", \n    \"This may be useful for highly fluctuating boxes.[PAR]\", \n \n    \"-swapxy may be useful in combination with the -normal flag, when the normal axis is not matching Oz.\", \n    \"If the flag is set to TRUE, Ox and Oy axes are swapped. [PAR]\", \n \n    \"-nonflat option can be used to treat highly curved bilayers.\", \n    \"If the option is set, a group of lipid tail atoms will be required in an index file.\", \n    \"The tail atoms will be used to split the leaflets into top/bottom layers.[PAR]\", \n \n    \"-mov_pdb and -mov_dat can be used to export multiple-model pdb files or movie matrix files.\", \n    \"Since pdb files may quickly increase in size, only one pdb file is generated, irrespective of the number of selected properties.\", \n    \"The pdb movie file contains, the coordinates of a grid. In case -thick option is selected, the pdb movie file\", \n    \"also contains membrane thickness in the B-factor field", "pred": " \nint main(int argc,char *argv[]) \n{ \n  const char *desc[] = { \n\t\t  \"[PAR]\", \n\t\t    \"________________[PAR]\", \n\t\t    \"Basic Options.[PAR]\", \n\t\t    \"----------------[PAR]\", \n \n    \"g_lomepro is a grid based tool to calculate Local Membrane Properties \", \n    \"of molecular dynamics trajectories [REF].\", \n    \"Thickness (-thick), area per lipid (APL) (-apl), Curvature (-curve) and \", \n    \"SCD Order parameters (-order) can be calculated.[PAR]\", \n \n    \"The user should specify a reference structure file (option -s) and a trajectoy file (option -f).\", \n    \"An index group (option -n) together with the option -num_lip are used to specify the representative lipid atom(s)\", \n    \"(Phosphorous, headgroups, whole lipid, etc.) and the total number of lipids.[PAR]\", \n \n    \"The number of grid elements in x and y axes can be specified (default 10) with -binx and -biny.[PAR]\", \n \n    \"With the option -prot a group of atoms (i.e. Protein) embedded in the membrane can be\", \n    \"explicitly considered for membrane property calculation.\", \n    \"If relevant, the center of mass displacement removal of the Protein group in the\", \n    \"trajectory file should be done *before* running g_lomepro (i.e. 'trjconv -fit').[PAR]\", \n \n    \"-precision option (default 1.5) defines the radius (nm) used to search for lipids when considering protein atoms.[PAR]\", \n \n    \"_________________________[PAR]\", \n    \"Property Specific Options[PAR]\", \n    \"-------------------------[PAR]\", \n \n     \n \n    \"Thickness (-thick):[PAR]\", \n \n    \"output: time averages (avg) and standard deviation (sd)\", \n    \"as matrix (dat) files and as pdb files with the thickness values in the B-factor field.[PAR]\", \n \n    \"-prot_val (default 0) specifies the thickness value for the grid elements occupied by the protein group on both leaflets.[PAR]\", \n{\"username,\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   "}
{"label": " \nstatic void \nRandomAccessUpdate(uint64_t TableSize, uint64_t *Table) { \n    uint64_t i; \n    uint64_t *ran; \n    int j; \n \n    uint32_t unitCnt = __htc_get_unit_count(); \n    uint64_t ranSize = unitCnt * NUM_THREADS; \n    ran = (uint64_t *)malloc(ranSize*sizeof(uint64_t)); \n    if (! ran) { \n        printf( \"Failed to allocate memory for the ran array (%ld).\\n\",  \n                ranSize); \n        exit(1); \n    } \n \n#pragma omp parallel for \n    for (j=0; j<ranSize; j++) { \n        ran[j] = HPCC_starts ((NUPDATE/ranSize) * j); \n    } \n \n    fprintf(stderr,\"ran array has been initialized\\n\"); fflush(stderr); \n \n    uint32_t updates_per_unit = NUPDATE/unitCnt; \n    printf(\"will use %d units and %d threads per unit, %d total threads\\n\",unitCnt,NUM_THREADS,unitCnt*NUM_THREADS); \n    printf(\"NUPDATE is %ld updates_per_unit is %ld\\n\", NUPDATE, updates_per_unit); \n \n#pragma omp parallel num_threads(unitCnt) \n    { \n        int unit = omp_get_thread_num(); \n        uint64_t *unitran = ran + (unit * NUM_THREADS); \n \n#pragma omp target device(unit) \n        { \n#pragma omp parallel num_threads(NUM_THREADS)  \n            {  \n                uint64_t pran = unitran[omp_get_thread_num()]; \n#pragma omp for schedule(static, 1) nowait  \n                for (i=0; i< updates_per_unit; i++) { \n                    pran = (pran << 1) ^ ((int64_t) pran < 0? POLY : 0); \n                    Table[pran & (TableSize-1)] ^= pran; \n                } \n            } \n        } \n    } \n} ", "pred": " \nstatic void \nRandomAccessUpdate(uint64_t TableSize, uint64_t *Table) { \n    uint64_t i; \n    uint64_t *ran; \n    int j; \n \n    uint32_t unitCnt = __htc_get_unit_count(); \n    uint64_t ranSize = unitCnt * NUM_THREADS; \n    ran = (uint64_t *)malloc(ranSize*sizeof(uint64_t)); \n    if (! ran) { \n        printf( \"Failed to allocate memory for the ran array (%ld).\\n\",  \n                ranSize); \n        exit(1); \n    } \n \n#pragma omp parallel for \n    for (j=0; j<ranSize; j++) { \n        ran[j] = HPCC_starts ((NUPDATE/ranSize) * j); \n    } \n \n    fprintf(stderr,\"ran array has been initialized\\n\"); fflush(stderr); \n \n    uint32_t updates_per_unit = NUPDATE/unitCnt; \n    printf(\"will use %d units and %d threads per unit, %d total threads\\n\",unitCnt,NUM_THREADS,unitCnt*NUM_THREADS); \n    printf(\"NUPDATE is %ld updates_per_unit is %ld\\n\", NUPDATE, updates_per_unit); \n \n#pragma omp parallel num_threads(unitCnt) \n    { \n        int unit = omp_get_thread_num(); \n        uint64_t *unitran = ran + (unit * NUM_THREADS); \n \n#pragma omp target device(unit) \n        { \n#pragma omp parallel num_threads(NUM_THREADS)  \n            {  \n                uint64_t pran = unitran[omp_get_thread_num()]; \n#pragma omp for schedule(static, 1) nowait  \n                                                                                                                                                                        "}
{"label": "d dt_colorspaces_rgb_to_cygm(float *out, int num, double RGB_to_CAM[4][3]) \n{ \n#pragma omp parallel for default(none) shared(out, num, RGB_to_CAM) schedule(static) \n  for(int i = 0; i < num; i++) \n  { \n    float *in = &out[i*3]; \n    float o[4] = {0.0f,0.0f,0.0f,0.0f}; \n    for(int c = 0; c < 4; c++) \n      for(int k = 0; k < 3; k++) \n        o[c] += RGB_to_CAM[c][k] * in[k]; \n    for(int c = 0; c < 4; c++) \n      in[c] = o[c]; \n  } \n} \n \n \n ", "pred": "d dt_colorspaces_rgb_to_cygm(float *out, int num, double RGB_to_CAM[4][3]) \n{ \n#pragma omp parallel for default(none) shared(out, num, RGB_to_CAM) schedule(static) \n  for(int i = 0; i < num; i++) \n  { \n    float *in = &out[i*3]; \n    float o[4] = {0.0f,0.0f,0.0f,0.0f}; \n    for(int c = 0; c < 4; c++) \n      for(int k = 0; k < 3; k++) \n        o[c] += RGB_to_CAM[c][k] * in[k]; \n    for(int c = 0; c < 4; c++) \n      in[c] = o[c]; \n  } \n} \n \n \n "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 16; \n  tile_size[1] = 16; \n  tile_size[2] = 24; \n  tile_size[3] = 2048; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=floord(Nt-1,2);t1++) { \n    lbp=max(ceild(t1,2),ceild(4*t1-Nt+2,4)); \n    ubp=min(floord(4*Nt+Nz-9,16),floord(8*t1+Nz+2,16)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(max(0,ceild(t1-2,3)),ceild(2*t1-2*t2-1,3)),ceild(16*t2-Nz-11,24));t3<=min(min(min(floord(4*Nt+Ny-9,24),floord(8*t1+Ny+7,24)),floord(16*t2+Ny+3,24)),floord(16*t1-16*t2+Nz+Ny+5,24));t3++) { \n        for (t4=max(max(max(0,ceild(t1-255,256)),ceild(16*t2-Nz-2035,2048)),ceild(24*t3-Ny-2035,2048));t4<=min(min(min(min(floord(4*Nt+Nx-9,2048),floord(8*t1+Nx+7,2048)),floord(16*t2+Nx+3,2048)),floord(24*t3+Nx+11,2048)),floord(16*t1-16*t2+Nz+Nx+5,2048));t4++) { \n          for (t5=max(max(max(max(max(0,ceild(16*t2-Nz+5,4)),ceild(24*t3-Ny+5,4)),ceild(2048*t4-Nx+5,4)),2*t1),4*t1-4*t2+1);t5<=min(min(min(min(min(floord(16*t1-16*t2+Nz+10,4),Nt-1),2*t1+3),4*t2+2),6*t3+4),512*t4+510);t5++) { \n            for (t6=max(max(16*t2,4*t5+4),-16*t1+16*t2+8*t5-15);t6<=min(min(16*t2+15,-16*t1+16*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(24*t3,4*t5+4);t7<=min(24*t3+23,4*t5+Ny-5);t7++) { \n                lbv=max(2048*t4,", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 16; \n  tile_size[1] = 16; \n  tile_size[2] = 24; \n  tile_size[3] = 24;  tile_size[4] = 24;  tile_size[5] = 24;  tile_size[6] = 24;  tile_size[7] = 24;  tile_size[8] = 24;  tile_size[7] = 24;  tile_size[8] = 24;  tile_size[9] = 24;  tile_size[10] = 24;  tile_size[11] = 24;  tile_size[12] = 24;  tile_size[13] = 24;  tile_size[14] = 24;  tile_size[15] = 24;  tile_size[16] = 24;  tile_size[17] = 24;  tile_size[18] = 24;  tile_size[19] = 24;  tile_size[20] = 24;  tile_size[21] = 24;  tile_size[22] = 24;  tile_size[23] = 24;  tile_size[24] = 24;  tile_size[25] = 24;  tile_size[26] = 24;  tile_size[27] = 24;  tile_size[28] = 24;  tile_size[29] = 24;  tile_size[30] = 24;  tile_size[31] = 24;  tile_size[32] = 24;  tile_size[33] = 24;  tile_size[34] = 24;  tile_size[35] = 24;  tile_size[36] = 24;  tile_size[37] = 24;  tile_size[38] = 24;  tile_size[39] = 24;  tile_size[40] = 24;  tile_size[41] = 24;  tile_size[42] = 24;  tile_size[43] = 24;  tile_size[44] = 24;  tile_size[45] = 24;  tile_size[46] = 24;  tile_size[47] = 24;  tile_size[48] = 24;  tile_size[49] = 24;  tile_size[50] = 24;  tile_size[51] = 24;  tile_size[52] = 24;  tile_size[53] = 24;  tile_size[54] = 24;  tile_size[55] = 24;  tile_size[55] = 24;  tile_size[56] = 24;  tile_size[57] = 24;  tile_size[58] = 24;  tile_size[59] = 24;  tile_size[60] = 24;  tile_size[61] = 24;  tile_size[61] = 24;  tile_size[62] = 24;  tile_size[63] = 24;  tile_size[64] = 24;  tile_size[65] = 24;  tile_size[66] = 24;  tile_size[67] = 24;  tile_size[68] = 24;  tile_size[69] = 24;  tile_size[70] = 24;  tile_size[72] = 24;  tile_size[73] = 24;  tile_size[73] = 24;  tile_size[74] = 24;  tile_size[75] = 24;  tile_size[76] = 24;  tile_size[77] = 24;  tile_size[78] = 24;  tile_size[78] = 24;  tile_size[81] = 24;  tile_size[81] = 24;  tile_size[82] = 24;  tile_size[83] = 24;  tile_size[83] = 24;  tile_size[84] = 24;  tile_size[85] = 24;  tile_size[86] = 24;  tile_size[86] = 24;  tile_size[87] = 24;  tile_size[88] = 24;  tile_size[89] = 24;  tile_size[90] = 24;  tile_size[91] = 24;  tile_size[92] = 24;  tile_size[93] = 24;  tile_size[93] = 24;  tile_size[94] = 24;  tile_size[95] = 24;  tile_size[96] = 24;  tile_size[96] = 24;  tile_size[97] = 24;  tile_size[98] = 24;  tile_size[99] = 24;  tile_size[100] = 24;  tile_size[100] = 24;  tile_size[101] = 24;  tile_size[102] = 24;  tile_size[103] = 24;  tile_size[104] = 24;  tile_size[104] = 24;  tile_size[105] = 24;  tile_size[106] = 24;  tile_size[106] = 24;  tile_size[107] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109] = 24;  tile_size[109"}
{"label": " \nstatic void CA_correct(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in2, \n                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int width = roi_in->width; \n  const int height = roi_in->height; \n  const uint32_t filters = piece->pipe->dsc.filters; \n  memcpy(out, in2, width * height * sizeof(float)); \n  const float *const in = out; \n  const double cared = 0, cablue = 0; \n  const double caautostrength = 4; \n \n   \n \n  const int ts = 128; \n  const int tsh = ts / 2; \n   \n \n  const int v1 = ts, v2 = 2 * ts, v3 = 3 * ts, \n            v4 = 4 * ts;  \n \n \n   \n \n  for(int i = 0; i < 2; i++) \n    for(int j = 0; j < 2; j++) \n      if(FC(i, j, filters) == 3) \n      { \n        printf(\"CA correction supports only RGB Colour filter arrays\\n\"); \n        return; \n      } \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n  const gboolean autoCA = (cared == 0 && cablue == 0); \n   \n \n   \n \n   \n \n  float *Gtmp = (float(*))calloc((height) * (width), sizeof *Gtmp); \n \n   \n \n  float *RawDataTmp = (float *)malloc(height * width * sizeof(float) / 2 + 4); \n \n  float blockave[2][2] = { { 0, 0 }, { 0, 0 } }, blocksqave[2][2] = { { 0, 0 }, { 0, 0 } }, \n        blockdenom[2][2] = { { 0, 0 }, { 0, 0 } }, blockvar[2][2]; \n \n   \n \n  gboolean processpasstwo = TRUE; \n \n  const int border = 8; \n  const int border2 = 16; \n \n  const int vz1 = (height + border2) % (ts - border2) == 0? 1 : 0; \n  const int hz1 = (width + border2) % (ts - border2) == 0? 1 : 0; \n  const int vblsz = ceil((float)(height + border2) / (ts - border2) + 2 + vz1); \n  const int hblsz = ceil((float)(width + border2) / (ts - border2) + 2 + hz1); \n \n  char *buffer1 = (char *)calloc(vblsz * hblsz * (2 * 2 + 1), sizeof(float)); \n \n   \n \n  float *blockwt = (float *)buffer1; \n  float(*blockshifts)[2][2] = (float(*)[2][2])(buffer1 + (vblsz * hblsz * sizeof(float))); \n \n  double fitparams[2][2][16]; \n \n   \n \n  int polyord = 4, numpar = 16; \n \n  const float eps = 1e-5f, eps2 = 1e-10f;  \n \n \n#pragma omp parallel \n  { \n     \n \n \n     \n \n    int GRBdir[2][3]; \n \n    int shifthfloor[3], shiftvfloor[3], shifthceil[3], shiftvceil[3]; \n \n     \n \n    float coeff[2][3][2]; \n     \n \n    float CAshift[2][2]; \n     \n \n     \n \n    float shifthfrac[3], shiftvfrac[3]; \n     \n \n    float blockavethr[2][2] = { { 0, 0 }, { 0, 0 } }, blocksqavethr[2][2] = { { 0, 0 }, { 0, 0 } }, \n          blockdenomthr[2][2] = { { 0, 0 }, { 0, 0 } }; \n \n     \n \n    const int buffersize = 3 * sizeof(float) * ts * ts + 6 * sizeof(float) * ts * tsh + 8 * 64 + 63; \n    char *buffer = (char *)malloc(buffersize); \n    char *data = (char *)(((uintptr_t)buffer + (uintptr_t)63) / 64 * 64); \n \n     \n \n     \n \n \n     \n \n    float *rgb[3]; \n    rgb[0] = (float(*))data; \n    rgb[1] = (float(*))(data + 1 * sizeof(float) * ts * ts + 1 * 64); \n    rgb[2] = (float(*))(data + 2 * sizeof(float) * ts * ts + 2 * 64); \n \n     \n \n    float *rbhpfh = (float(*))(data + 3 * sizeof(float) * ts * ts + 3 * 64); \n     \n \n    float *rbhpfv = (float(*))(data + 3 * sizeof(float) * ts * ts + sizeof(float) * ts * tsh + 4 * 64); \n     \n \n    float *rblpfh = (float(*))(data + 4 * sizeof(float) * ts * ts + 5 * 64); \n     \n \n    float *rblpfv = (float(*))(data + 4 * sizeof(float) * ts * ts + sizeof(float) * ts * tsh + 6 * 64); \n     \n \n    float *grblpfh = (float(*))(data + 5 * sizeof(float) * ts * ts + 7 * 64); \n     \n \n    float *grblpfv = (float(*))(data + 5 * sizeof(float) * ts * ts + sizeof(float) * ts * tsh + 8 * 64); \n     \n \n    float *grbdiff = rbhpfh;  \n \n     \n \n    float *gshift = rbhpfv;  \n \n \n \n    if(autoCA) \n    { \n \n \n#pragma omp for collapse(2) schedule(static) nowait \n      for(int top = -border; top < height; top += ts - border2) \n        for(int left = -border; left < width; left += ts - border2) \n        { \n          memset(buffer, 0, buffersize); \n          const int vblock = ((top + border) / (ts - border2)) + 1; \n          const int hblock = ((left + border) / (ts - border2)) + 1; \n          const int bottom = MIN(top + ts, height + border); \n          const int right = MIN(left + ts, width + border); \n          const int rr1 =", "pred": " \nstatic void CA_correct(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in2, \n                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int width = roi_in->width; \n  const int height = roi_in->height; \n  const uint32_t filters = piece->pipe->dsc.filters; \n  memcpy(out, in2, width * height * sizeof(float)); \n  const float *const in = out; \n  const double cared = 0, cablue = 0; \n  const double caautostrength = 4; \n \n   \n \n  const int ts = 128; \n  const int tsh = ts / 2; \n   \n \n  const int v1 = ts, v2 = 2 * ts, v3 = 3 * ts, \n            v4 = 4 * ts;  \n \n \n   \n \n  for(int i = 0; i < 2; i++) \n    for(int j = 0; j < 2; j++) \n      if(FC(i, j, filters) == 3) \n      { \n        printf(\"CA correction supports only RGB Colour filter arrays\\n\"); \n        return; \n      } \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n  const gboolean autoCA = (cared == 0 && cablue == 0); \n   \n \n   \n \n   \n \n  float *Gtmp = (float(*))calloc((height) * (width), sizeof *Gtmp); \n \n   \n \n  float *RawDataTmp = (float *)malloc(height * width * sizeof(float) / 2 + 4); \n \n  float blockave[2][2] = { { 0, 0 }, { 0, 0 } }, blocksqave[2][2] = { { 0, 0 }, { 0, 0 } }, \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "}
{"label": " \nint distort_backtransform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *const restrict points, \n                          size_t points_count) \n{ \n  dt_iop_rawprepare_data_t *d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n  if(d->x == 0 && d->y == 0) return 1; \n \n  const float scale = piece->buf_in.scale / piece->iscale; \n \n  const float x = (float)d->x * scale, y = (float)d->y * scale; \n \n#pragma omp parallel for simd default(none)      dt_omp_firstprivate(points_count, points, y, x)      schedule(static)      aligned(points:64) if(points_count > 100) \n  for(size_t i = 0; i < points_count * 2; i += 2) \n  { \n    points[i] += x; \n    points[i + 1] += y; \n  } \n \n  return 1; \n} ", "pred": " \nint distort_backtransform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *const restrict points, \n                          size_t points_count) \n{ \n  dt_iop_rawprepare_data_t *d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n  if(d->x == 0 && d->y == 0) return 1; \n \n  const float scale = piece->buf_in.scale / piece->iscale; \n \n  const float x = (float)d->x * scale, y = (float)d->y * scale; \n \n#pragma omp parallel for simd default(none)      dt_omp_firstprivate(points_count, points, y, x)      schedule(static)      aligned(points:64) if(points_count > 100) \n  for(size_t i = 0; i < points_count * 2; i += 2) \n  { \n    points[i] += x; \n    points[i + 1] += y; \n  } \n \n  return 1; \n} "}
{"label": " \nMagickExport double GetImageTotalInkDensity(Image *image, \n  ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  double \n    total_ink_density; \n \n  MagickBooleanType \n    status; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\"); \n  assert(image->signature == MagickCoreSignature); \n  if (image->colorspace!= CMYKColorspace) \n    { \n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError, \n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename); \n      return(0.0); \n    } \n  status=MagickTrue; \n  total_ink_density=0.0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  #pragma omp parallel for schedule(static) shared(status)      magick_number_threads(image,image,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    double \n      density; \n \n    register const Quantum \n      *p; \n \n    register ssize_t \n      x; \n \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    if (p == (const Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      density=(double) GetPixelRed(image,p)+GetPixelGreen(image,p)+ \n        GetPixelBlue(image,p)+GetPixelBlack(image,p); \n      if (density > total_ink_density) \n        #pragma omp critical (MagickCore_GetImageTotalInkDensity) \n        { \n          if (density > total_ink_density) \n            total_ink_density=density; \n        } \n      p+=GetPixelChannels(image); \n    } \n  } \n  image_view=DestroyCacheView(image_view); \n  if (status == MagickFalse) \n    total_ink_density=0.0; \n  return(total_ink_density); \n} ", "pred": " \nMagickExport double GetImageTotalInkDensity(Image *image, \n  ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  double \n    total_ink_density; \n \n  MagickBooleanType \n    status; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\"); \n  assert(image->signature == MagickCoreSignature); \n  if (image->colorspace!= CMYKColorspace) \n    { \n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError, \n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename); \n      return(0.0); \n    } \n  status=MagickTrue; \n  total_ink_density=0.0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  #pragma omp parallel for schedule(static) shared(status)      magick_number_threads(image,image,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    double \n      density; \n \n    register const Quantum \n      *p; \n \n    register ssize_t \n      x; \n \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    if (p == (const Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      density=(double) GetPixelRed(image,p)+GetPixelGreen(image,p)+ \n        GetPixelBlue(image,p)+GetPixelBlack(image,p); \n{\"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\"}
{"label": "d dt_colorspaces_cygm_apply_coeffs_to_rgb(float *out, const float *in, int num, double RGB_to_CAM[4][3], double CAM_to_RGB[3][4], float coeffs[4]) \n{ \n   \n \n  double CAM_to_RGB_WB[3][4]; \n  for (int a=0; a<3; a++) \n    for (int b=0; b<4; b++) \n      CAM_to_RGB_WB[a][b] = CAM_to_RGB[a][b] * coeffs[b]; \n \n   \n \n  double RGB_to_RGB_WB[3][3]; \n  for (int a=0; a<3; a++) \n    for (int b=0; b<3; b++) { \n      RGB_to_RGB_WB[a][b] = 0.0f; \n      for (int c=0; c<4; c++) \n        RGB_to_RGB_WB[a][b] += CAM_to_RGB_WB[a][c] * RGB_to_CAM[c][b]; \n    } \n \n#pragma omp parallel for default(none) shared(in, out, num, RGB_to_RGB_WB) schedule(static) \n  for(int i = 0; i < num; i++) \n  { \n    const float *inpos = &in[i*4]; \n    float *outpos = &out[i*4]; \n    outpos[0]=outpos[1]=outpos[2] = 0.0f; \n    for (int a=0; a<3; a++) \n      for (int b=0; b<3; b++) \n        outpos[a] += RGB_to_RGB_WB[a][b] * inpos[b]; \n  } \n} \n \nvo ", "pred": "d dt_colorspaces_cygm_apply_coeffs_to_rgb(float *out, const float *in, int num, double RGB_to_CAM[4][3], double CAM_to_RGB[3][4], float coeffs[4]) \n{ \n   \n \n  double CAM_to_RGB_WB[3][4]; \n  for (int a=0; a<3; a++) \n    for (int b=0; b<4; b++) \n      CAM_to_RGB_WB[a][b] = CAM_to_RGB[a][b] * coeffs[b]; \n \n   \n \n  double RGB_to_RGB_WB[3][3]; \n  for (int a=0; a<3; a++) \n    for (int b=0; b<3; b++) { \n      RGB_to_RGB_WB[a][b] = 0.0f; \n      for (int c=0; c<4; c++) \n        RGB_to_RGB_WB[a][b] += CAM_to_RGB_WB[a][c] * RGB_to_CAM[c][b]; \n    } \n \n#pragma omp parallel for default(none) shared(in, out, num, RGB_to_RGB_WB) schedule(static) \n  for(int i = 0; i < num; i++) \n  { \n    const float *inpos = &in[i*4]; \n    float *outpos = &out[i*4]; \n    outpos[0]=outpos[1]=outpos[2] = 0.0f; \n    for (int a=0; a<3; a++) \n      for (int b=0; b<3; b++) \n        outpos[a] += RGB_to_RGB_WB[a][b] * inpos[b]; \n  } \n} \n \nvo "}
{"label": " \nvoid mzd_process_rows5(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, rci_t const *L2, \n\t\t       mzd_t const *T3, rci_t const *L3, mzd_t const *T4, rci_t const *L4) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n  int rem = k % 5; \n \n  int const ka = k / 5 + ((rem >= 4)? 1 : 0); \n  int const kb = k / 5 + ((rem >= 3)? 1 : 0); \n  int const kc = k / 5 + ((rem >= 2)? 1 : 0); \n  int const kd = k / 5 + ((rem >= 1)? 1 : 0); \n  int const ke = k / 5; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n  word const kc_bm = __M4RI_LEFT_BITMASK(kc); \n  word const kd_bm = __M4RI_LEFT_BITMASK(kd); \n  word const ke_bm = __M4RI_LEFT_BITMASK(ke); \n \n#pragma omp parallel for private(r) shared(startrow, stoprow) schedule(static,512)  \n \n  for(r = startrow; r < stoprow; ++r) { \n    word bits = mzd_read_bits(M, r, startcol, k); \n    rci_t const x0 = L0[ bits & ka_bm ]; bits>>=ka; \n    rci_t const x1 = L1[ bits & kb_bm ]; bits>>=kb; \n    rci_t const x2 = L2[ bits & kc_bm ]; bits>>=kc; \n    rci_t const x3 = L3[ bits & kd_bm ]; bits>>=kd; \n    rci_t const x4 = L4[ bits & ke_bm ]; \n \n    if(((x0 | x1 | x2) | (x3 | x4)) == 0)  \n \n      continue; \n \n    word *m0 = M->rows[r] + blocknum; \n    word const *t[5]; \n    t[0] = T0->rows[x0] + blocknum; \n    t[1] = T1->rows[x1] + blocknum; \n    t[2] = T2->rows[x2] + blocknum; \n    t[3] = T3->rows[x3] + blocknum; \n    t[4] = T4->rows[x4] + blocknum; \n \n    _mzd_combine_5( m0, t, wide); \n  } \n \n  __M4RI_DD_MZD(M); \n} ", "pred": " \nvoid mzd_process_rows5(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, rci_t const *L2, \n\t\t       mzd_t const *T3, rci_t const *L3, mzd_t const *T4, rci_t const *L4) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n  int rem = k % 5; \n \n  int const ka = k / 5 + ((rem >= 4)? 1 : 0); \n  int const kb = k / 5 + ((rem >= 3)? 1 : 0); \n  int const kc = k / 5 + ((rem >= 2)? 1 : 0); \n  int const kd = k / 5 + ((rem >= 1)? 1 : 0); \n  int const ke = k / 5; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n  word const kc_bm = __M4RI_LEFT_BITMASK(kc); \n  word const kd_bm = __M4RI_LEFT_BITMASK(kd); \n  word const ke_bm = __M4RI_LEFT_BITMASK(ke); \n \n#pragma omp parallel for private(r) shared(startrow, stoprow) schedule(static,512)  \n \n  for(r = startrow; r < stoprow; ++r) { \n    word bits = mzd_read_bits(M, r, startcol, k); \n    rci_t const x0 = L0[ bits & ka_bm ]; bits>>=ka; \n    rci_t const x1 = L1[ bits & kb_bm ]; bits>>=kb; \n                                                                                                                                                                                                                                                                                                                          "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 \n     && piece->dsc_in.datatype == TYPE_UINT16) \n  {  \n \n \n    const uint16_t *const in = (const uint16_t *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n#pragma omp parallel for SIMD() default(none)      dt_omp_firstprivate(csx, csy, d, in, out, roi_in, roi_out)      schedule(static)      collapse(2) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t pin = (size_t)(roi_in->width * (j + csy) + csx) + i; \n        const size_t pout = (size_t)j * roi_out->width + i; \n \n        const int id = BL(roi_out, d, j, i); \n        out[pout] = (in[pin] - d->sub[id]) / d->div[id]; \n      } \n    } \n \n    piece->pipe->dsc.filters = dt_rawspeed_crop_dcraw_filters(self->dev->image_storage.buf_dsc.filters, csx, csy); \n    adjust_xtrans_filters(piece->pipe, csx, csy); \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 \n          && piece->dsc_in.datatype == TYPE_FLOAT) \n  {  \n \n \n    const float *const in = (const float *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n#pragma omp parallel for SIMD() default(none)      dt_omp_firstprivate(csx, csy, d, in, out, roi_in, roi_out)      schedule(static)      collapse(2) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t pin = (size_t)(roi_in->width * (j + csy) + csx) + i; \n        const size_t pout = (size_t)j * roi_out->width + i; \n \n        const int id = BL(roi_out, d, j, i); \n        out[pout] = (in[pin] - d->sub[id]) / d->div[id]; \n      } \n    } \n \n    piece->pipe->dsc.filters = dt_rawspeed_crop_dcraw_filters(self->dev->image_storage.buf_dsc.filters, csx, csy); \n    adjust_xtrans_filters(piece->pipe, csx, csy); \n  } \n  else \n  {  \n \n \n    const float *const in = (const float *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n    const float sub = d->sub[0], div = d->div[0]; \n \n    const int ch = piece->colors; \n \n#pragma omp parallel for SIMD() default(none)      dt_omp_firstprivate(ch, csx, csy, div, in, out, roi_in, roi_out, sub)      schedule(static) collapse(3) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        for(int c = 0; c < ch; c++) \n        { \n          const size_t pin = (size_t)ch * (roi_in->width * (j + csy) + csx + i) + c; \n          const size_t pout = (size_t)ch * (j * roi_out->width + i) + c; \n \n          out[pout] = (in[pin] - sub) / div; \n        } \n      } \n    } \n  } \n \n  if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && d->apply_gainmaps) \n  { \n    const uint32_t map_w = d->gainmaps[0]->map_points_h; \n    const uint32_t map_h = d->gainmaps[0]->map_points_v; \n    const float im_to_rel_x = 1.0 / piece->buf_in.width; \n    const float im_to_rel_y = 1.0 / piece->buf_in.height; \n    const float rel_to_map_x = 1.0 / d->gainmaps[0]->map_spacing_h; \n    const float rel_to_map_y = 1.0 / d->gainmaps[0]->map_spacing_v; \n    const float map_origin_h = d->gainmaps[0]->map_origin_h; \n    const float map_origin_v = d->gainmaps[0]->map_origin_v; \n    float *const out = (float *const)ovoid; \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(csx, csy, roi_out, out, im_to_rel_x, im_to_rel_y, rel_to_map_x, rel_to_map_y,                          map_w, map_h, map_origin_h, map_origin_v)      dt_omp_sharedconst(d) schedule(static) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float y_map = CLAMP(((roi_out->y + csy + j) * im_to_rel_y - map_origin_v) * rel_to_map_y, 0, map_h); \n ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 \n     && piece->dsc_in.datatype == TYPE_UINT16) \n  {  \n \n \n    const uint16_t *const in = (const uint16_t *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n#pragma omp parallel for SIMD() default(none)      dt_omp_firstprivate(csx, csy, d, in, out, roi_in, roi_out)      schedule(static)      collapse(2) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t pin = (size_t)(roi_in->width * (j + csy) + csx) + i; \n        const size_t pout = (size_t)j * roi_out->width + i; \n \n        const int id = BL(roi_out, d, j, i); \n        out[pout] = (in[pin] - d->sub[id]) / d->div[id]; \n      } \n    } \n \n    piece->pipe->dsc.filters = dt_iop_rawprepare(piece, roi_in, d, in, out, roi_out, roi_out, roi_out);\\n      }\\n    }\\n  }\\n}\", \"func_defs\": \"\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *roi, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_t *const roi_in);\\n\\nstatic void dt_iop_draw_image(dt_iop_module_t *self, const dt_iop_image_t *img, const dt_iop_roi_t *const roi, const dt_iop_roi_"}
{"label": " \nint distort_transform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *const restrict points, size_t points_count) \n{ \n  dt_iop_rawprepare_data_t *d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n  if(d->x == 0 && d->y == 0) return 1; \n \n  const float scale = piece->buf_in.scale / piece->iscale; \n \n  const float x = (float)d->x * scale, y = (float)d->y * scale; \n \n#pragma omp parallel for simd default(none)      dt_omp_firstprivate(points_count, points, y, x)      schedule(static)      aligned(points:64) if(points_count > 100) \n  for(size_t i = 0; i < points_count * 2; i += 2) \n  { \n    points[i] -= x; \n    points[i + 1] -= y; \n  } \n \n  return 1; \n} ", "pred": " \nint distort_transform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *const restrict points, size_t points_count) \n{ \n  dt_iop_rawprepare_data_t *d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n  if(d->x == 0 && d->y == 0) return 1; \n \n  const float scale = piece->buf_in.scale / piece->iscale; \n \n  const float x = (float)d->x * scale, y = (float)d->y * scale; \n \n#pragma omp parallel for simd default(none)      dt_omp_firstprivate(points_count, points, y, x)      schedule(static)      aligned(points:64) if(points_count > 100) \n  for(size_t i = 0; i < points_count * 2; i += 2) \n  { \n    points[i] -= x; \n    points[i + 1] -= y; \n  } \n \n  return 1; \n} "}
{"label": " \nint voxelizeMesh(int num_threads, FILE *outFile, Vertex *vertices, unsigned int nVertices, Face **mesh, unsigned int nTriangles, Color *mc, int mid, Vertex *vSize, int co) { \n    Vertex rMin, rMax; \n    Voxel vMax; \n \n     \n \n    getRBoundingBox(vertices, nVertices, &rMin, &rMax); \n    rMin.x = floor(rMin.x); \n    rMin.y = floor(rMin.y); \n    rMin.z = floor(rMin.z); \n    printf(\"Min: \"); \n    printVertex(&rMin); \n    printf(\"\\nMax: \"); \n    printVertex(&rMax); \n    vMax.x = (unsigned int)ceil((rMax.x-rMin.x)/vSize->x); \n    vMax.y = (unsigned int)ceil((rMax.y-rMin.y)/vSize->y); \n    vMax.z = (unsigned int)ceil((rMax.z-rMin.z)/vSize->z); \n    printf(\"\\nVMax: \"); \n    printVoxel(&vMax); \n     \n \n    int x, y, z; \n    omp_set_num_threads(num_threads); \n    #pragma omp parallel for private(x, y, z) \n    for (x = 0; x <= vMax.x; ++x) { \n        for (y = 0; y <= vMax.y; ++y) { \n            for (z = 0; z <= vMax.z; ++z) { \n                Vertex voxelCenter; \n                centerOfVoxel_(x, y, z, &rMin, vSize, &voxelCenter); \n                printf(\"\\nVoxel: \"); \n                printVertex(&voxelCenter); \n \n                 \n \n                int inTarget = 1; \n                if (!isNear(num_threads, mesh, nTriangles, &voxelCenter, vSize)) inTarget = 0; \n \n                 \n \n                if (inTarget) { \n                    if (co == 26) { \n                        inTarget = intersectsMesh26(mesh, nTriangles, &voxelCenter, vSize); \n                    } else if (co == 6) { \n                        inTarget = intersectsMesh6(mesh, nTriangles, &voxelCenter, vSize); \n                    } else { \n                        printf(\"connectivity target undefined!\"); \n                        inTarget = 0; \n                    } \n                } \n \n                 \n \n                if (inTarget) { \n                     \n \n                    fprintf(outFile, \"%d,%f,%f,%f,%d,%d,%d\\n\", mid, voxelCenter.x, voxelCenter.y, voxelCenter.z, mc->r, mc->g, mc->b); \n                } \n            } \n        } \n    } \n \n    return 0; \n} ", "pred": " \nint voxelizeMesh(int num_threads, FILE *outFile, Vertex *vertices, unsigned int nVertices, Face **mesh, unsigned int nTriangles, Color *mc, int mid, Vertex *vSize, int co) { \n    Vertex rMin, rMax; \n    Voxel vMax; \n \n     \n \n    getRBoundingBox(vertices, nVertices, &rMin, &rMax); \n    rMin.x = floor(rMin.x); \n    rMin.y = floor(rMin.y); \n    rMin.z = floor(rMin.z); \n    printf(\"Min: \"); \n    printVertex(&rMin); \n    printf(\"\\nMax: \"); \n    printVertex(&rMax); \n    vMax.x = (unsigned int)ceil((rMax.x-rMin.x)/vSize->x); \n    vMax.y = (unsigned int)ceil((rMax.y-rMin.y)/vSize->y); \n    vMax.z = (unsigned int)ceil((rMax.z-rMin.z)/vSize->z); \n    printf(\"\\nVMax: \"); \n    printVoxel(&vMax); \n     \n \n    int x, y, z; \n    omp_set_num_threads(num_threads); \n    #pragma omp parallel for private(x, y, z) \n    for (x = 0; x <= vMax.x; ++x) { \n        for (y = 0; y <= vMax.y; ++y) { \n            for (z = 0; z <= vMax.z; ++z) { \n                Vertex voxelCenter; \n                centerOfVoxel_(x, y, z, &rMin, vSize, &voxelCenter); \n                printf(\"\\nVoxel: \"); \n                printVertex(&voxelCenter); \n{\"\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nint bs_thread(void *tid_ptr) { \n    int i, j, k; \n    fptype price[NCO]; \n    fptype priceDelta; \n    int tid = *(int *)tid_ptr; \n    int start = tid * (numOptions / nThreads); \n    int end = start + (numOptions / nThreads); \n \n    for (j=0; j<NUM_RUNS; j++) { \n#pragma omp parallel for private(i, price, priceDelta) \n        for (i=0; i<numOptions; i += NCO) { \n \n        for (i=start; i<end; i += NCO) { \n \n             \n \n             \n \n            BlkSchlsEqEuroNoDiv(price, NCO, &(sptprice[i]), &(strike[i]), \n                                &(rate[i]), &(volatility[i]), &(otime[i]), &(otype[i]), 0); \n            for (k=0; k<NCO; k++) { \n              prices[i+k] = price[k]; \n            }  \n            for (k=0; k<NCO; k++) { \n                priceDelta = data[i+k].DGrefval - price[k]; \n                if (fabs(priceDelta) >= 1e-4) { \n                    printf(\"Error on %d. Computed=%.5f, Ref=%.5f, Delta=%.5f\\n\", \n                           i + k, price[k], data[i+k].DGrefval, priceDelta); \n                    numError ++; \n                } \n            } \n        } \n    } \n \n    return 0; \n} ", "pred": " \nint bs_thread(void *tid_ptr) { \n    int i, j, k; \n    fptype price[NCO]; \n    fptype priceDelta; \n    int tid = *(int *)tid_ptr; \n    int start = tid * (numOptions / nThreads); \n    int end = start + (numOptions / nThreads); \n \n    for (j=0; j<NUM_RUNS; j++) { \n#pragma omp parallel for private(i, price, priceDelta) \n        for (i=0; i<numOptions; i += NCO) { \n \n        for (i=start; i<end; i += NCO) { \n \n             \n \n             \n \n            BlkSchlsEqEuroNoDiv(price, NCO, &(sptprice[i]), &(strike[i]), \n                                &(rate[i]), &(volatility[i]), &(otime[i]), &(otype[i]), 0); \n            for (k=0; k<NCO; k++) { \n              prices[i+k] = price[k]; \n            }  \n            for (k=0; k<NCO; k++) { \n                priceDelta = data[i+k].DGrefval - price[k]; \n                if (fabs(priceDelta) >= 1e-4) { \n                    printf(\"Error on %d. Computed=%.5f, Ref=%.5f, Delta=%.5f\\n\", \n                           i + k, price[k], data[i+k].DGrefval, priceDelta);                                                                                       "}
{"label": " \nint main(int argc, char** argv) { \n    int i, j, k; \n    int ni = NI; \n    int nj = NJ; \n    int nk = NK; \n     \n     \n \n    init_array(); \n     \n     \n#pragma omp parallel for private (j, k) schedule(static) check \n    for (i = 0; i < ni; i++) \n        for (j = 0; j < nj; j++) { \n            C[i][j] *= beta; \n            for (k = 0; k < nk; ++k) \n                C[i][j] += alpha * A[i][k] * B[k][j]; \n        } \n     \n     \n    double total = 0; \n    for(int y=0; y<ni; ++y){ \n        for(int x=0; x<nj; ++x) { \n            total+= C[y][x]; \n        } \n    } \n    printf(\"Total: %f\\n\",total); \n     \n    return 0; \n} ", "pred": " \nint main(int argc, char** argv) { \n    int i, j, k; \n    int ni = NI; \n    int nj = NJ; \n    int nk = NK; \n     \n     \n \n    init_array(); \n     \n     \n#pragma omp parallel for private (j, k) schedule(static) check \n    for (i = 0; i < ni; i++) \n        for (j = 0; j < nj; j++) { \n            C[i][j] *= beta; \n            for (k = 0; k < nk; ++k) \n                C[i][j] += alpha * A[i][k] * B[k][j]; \n        } \n     \n     \n    double total = 0; \n    for(int y=0; y<ni; ++y){ \n        for(int x=0; x<nj; ++x) { \n            total+= C[y][x]; \n        } \n    } \n    printf(\"Total: %f\\n\",total); \n     \n    return 0; \n} "}
{"label": " \nstatic PyObject *py_gibbs_ibm_discretize(PyObject *self, PyObject *args) { \n    PyObject *dists_arrays, *aaa; \n \n    if(!PyArg_ParseTuple(args, \"OO\", &dists_arrays, &aaa)) return NULL; \n \n    const size_t n_sents = PyTuple_Size(aaa); \n \n#pragma omp parallel for \n    for (size_t sent=0; sent<n_sents; sent++) { \n        PyArrayObject *aa_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(aaa, sent); \n        PyArrayObject *dists_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(dists_arrays, sent); \n        const size_t ff_len = \n            (size_t) PyArray_DIM(aa_array, 0); \n        if (ff_len == 0) continue; \n \n        const size_t ee_len = \n            ((size_t) PyArray_DIM(dists_array, 0) / ff_len) - 1; \n        if (ee_len == 0) continue; \n \n        LINK_t *aa = (LINK_t*) PyArray_GETPTR1(aa_array, 0); \n        COUNT_t *ps = (COUNT_t*) PyArray_GETPTR1(dists_array, 0); \n \n        for (size_t j=0; j<ff_len; j++) { \n            COUNT_t max_p = (COUNT_t) ps[0]; \n            size_t argmax_i = 0; \n            for (size_t i=1; i<ee_len+1; i++) { \n                if (ps[i] > max_p) { \n                    max_p = ps[i]; \n                    argmax_i = i; \n                } \n            } \n            aa[j] = (argmax_i == ee_len)? null_link : argmax_i; \n            ps += ee_len + 1; \n        } \n    } \n \n    Py_INCREF(Py_None); \n    return Py_None; \n} ", "pred": " \nstatic PyObject *py_gibbs_ibm_discretize(PyObject *self, PyObject *args) { \n    PyObject *dists_arrays, *aaa; \n \n    if(!PyArg_ParseTuple(args, \"OO\", &dists_arrays, &aaa)) return NULL; \n \n    const size_t n_sents = PyTuple_Size(aaa); \n \n#pragma omp parallel for \n    for (size_t sent=0; sent<n_sents; sent++) { \n        PyArrayObject *aa_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(aaa, sent); \n        PyArrayObject *dists_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(dists_arrays, sent); \n        const size_t ff_len = \n            (size_t) PyArray_DIM(aa_array, 0); \n        if (ff_len == 0) continue; \n \n        const size_t ee_len = \n            ((size_t) PyArray_DIM(dists_array, 0) / ff_len) - 1; \n        if (ee_len == 0) continue; \n \n        LINK_t *aa = (LINK_t*) PyArray_GETPTR1(aa_array, 0); \n        COUNT_t *ps = (COUNT_t*) PyArray_GETPTR1(dists_array, 0); \n \n        for (size_t j=0; j<ff_len; j++) { \n            COUNT_t max_p = (COUNT_t) ps[0]; \n            size_t argmax_i = 0; \n            for (size_t i=1; i<ee_len+1; i++) { \n                if (ps[i] == 0)                                                                                                                                                                                                       "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 8; \n  tile_size[3] = 32; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,4);t1++) { \n    lbp=max(ceild(t1,2),ceild(8*t1-Nt+3,8)); \n    ubp=min(floord(Nt+Nz-4,8),floord(4*t1+Nz+1,8)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-1,2)),ceild(8*t2-Nz-4,8));t3<=min(min(min(floord(Nt+Ny-4,8),floord(4*t1+Ny+5,8)),floord(8*t2+Ny+4,8)),floord(8*t1-8*t2+Nz+Ny+3,8));t3++) { \n        for (t4=max(max(max(0,ceild(t1-7,8)),ceild(8*t2-Nz-28,32)),ceild(8*t3-Ny-28,32));t4<=min(min(min(min(floord(Nt+Nx-4,32),floord(4*t1+Nx+5,32)),floord(8*t2+Nx+4,32)),floord(8*t3+Nx+4,32)),floord(8*t1-8*t2+Nz+Nx+3,32));t4++) { \n          for (t5=max(max(max(max(max(0,4*t1),8*t1-8*t2+1),8*t2-Nz+2),8*t3-Ny+2),32*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,4*t1+7),8*t2+6),8*t3+6),32*t4+30),8*t1-8*t2+Nz+5);t5++) { \n            for (t6=max(max(8*t2,t5+1),-8*t1+8*t2+2*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(8*t3,t5+1);t7<=min(8*t3+7,t5+N", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *) tile_size, sizeof(int)*Nz);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": " \nvoid test_three(int x) { \n#pragma omp for ordered(1) \n  for (int i = 0; i < x; i++) { \n#pragma omp ordered depend(source) \n  } \n} ", "pred": " \nvoid test_three(int x) { \n#pragma omp for ordered(1) \n  for (int i = 0; i < x; i++) { \n#pragma omp ordered depend(source) \n  } \n} "}
{"label": " \nvoid dt_bilateral_slice_to_output(const dt_bilateral_t *const b, const float *const in, float *out, \n                                  const float detail) \n{ \n   \n \n  const float norm = -detail * b->sigma_r * 0.04f; \n  const int ox = 1; \n  const int oy = b->size_x; \n  const int oz = b->size_y * b->size_x; \n \n  float *const buf = b->buf; \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(b, in, norm, oy, oz, ox, buf)      shared(out) collapse(2) \n  for(int j = 0; j < b->height; j++) \n  { \n    for(int i = 0; i < b->width; i++) \n    { \n      size_t index = 4 * (j * b->width + i); \n      float x, y, z; \n      const float L = in[index]; \n      image_to_grid(b, i, j, L, &x, &y, &z); \n       \n \n      const int xi = MIN((int)x, b->size_x - 2); \n      const int yi = MIN((int)y, b->size_y - 2); \n      const int zi = MIN((int)z, b->size_z - 2); \n      const float xf = x - xi; \n      const float yf = y - yi; \n      const float zf = z - zi; \n      const size_t gi = xi + b->size_x * (yi + b->size_y * zi); \n      const float Lout = norm * (buf[gi] * (1.0f - xf) * (1.0f - yf) * (1.0f - zf) \n                                 + buf[gi + ox] * (xf) * (1.0f - yf) * (1.0f - zf) \n                                 + buf[gi + oy] * (1.0f - xf) * (yf) * (1.0f - zf) \n                                 + buf[gi + ox + oy] * (xf) * (yf) * (1.0f - zf) \n                                 + buf[gi + oz] * (1.0f - xf) * (1.0f - yf) * (zf) \n                                 + buf[gi + ox + oz] * (xf) * (1.0f - yf) * (zf) \n                                 + buf[gi + oy + oz] * (1.0f - xf) * (yf) * (zf) \n                                 + buf[gi + ox + oy + oz] * (xf) * (yf) * (zf)); \n      out[index] = fmaxf(0.0f, out[index] + Lout); \n    } \n  } \n} ", "pred": " \nvoid dt_bilateral_slice_to_output(const dt_bilateral_t *const b, const float *const in, float *out, \n                                  const float detail) \n{ \n   \n \n  const float norm = -detail * b->sigma_r * 0.04f; \n  const int ox = 1; \n  const int oy = b->size_x; \n  const int oz = b->size_y * b->size_x; \n \n  float *const buf = b->buf; \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(b, in, norm, oy, oz, ox, buf)      shared(out) collapse(2) \n  for(int j = 0; j < b->height; j++) \n  { \n    for(int i = 0; i < b->width; i++) \n    { \n      size_t index = 4 * (j * b->width + i); \n      float x, y, z; \n      const float L = in[index]; \n      image_to_grid(b, i, j, L, &x, &y, &z); \n       \n \n      const int xi = MIN((int)x, b->size_x - 2); \n      const int yi = MIN((int)y, b->size_y - 2); \n      const int zi = MIN((int)z, b->size_z - 2); \n      const float xf = x - xi; \n      const float yf = y - yi; \n      const float zf = z - zi; \n      const size_t gi = xi + b->size_x * (yi + b->size_y * zi); \n      const float Lout = norm * (buf[gi] * (1.0f - xf) * (1.0f - yf) * (1.0f - zf) \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "}
{"label": " \nstatic void createNodeLocks(PreGraph *preGraph) \n{ \n\tIDnum nbNodes; \n\tIDnum nodeIndex; \n \n\tnbNodes = preNodeCount_pg(preGraph) + 1; \n\tif (nodeLocks) \n\t\tfree (nodeLocks); \n\tnodeLocks = mallocOrExit(nbNodes, omp_lock_t); \n \n #pragma omp parallel for \n\tfor (nodeIndex = 0; nodeIndex < nbNodes; nodeIndex++) \n\t\tomp_init_lock(nodeLocks + nodeIndex); \n} ", "pred": " \nstatic void createNodeLocks(PreGraph *preGraph) \n{ \n\tIDnum nbNodes; \n\tIDnum nodeIndex; \n \n\tnbNodes = preNodeCount_pg(preGraph) + 1; \n\tif (nodeLocks) \n\t\tfree (nodeLocks); \n\tnodeLocks = mallocOrExit(nbNodes, omp_lock_t); \n \n #pragma omp parallel for \n\tfor (nodeIndex = 0; nodeIndex < nbNodes; nodeIndex++) \n\t\tomp_init_lock(nodeLocks + nodeIndex); \n} "}
{"label": " \nvoid fwd_step_enkf_updateA(void * module_data, \n                           matrix_type * A, \n                           matrix_type * S, \n                           matrix_type * R, \n                           matrix_type * dObs, \n                           matrix_type * E, \n                           matrix_type * D, \n                           const module_info_type* module_info) { \n \n \n \n  fwd_step_enkf_data_type * fwd_step_data = fwd_step_enkf_data_safe_cast( module_data ); \n  fwd_step_log_open(fwd_step_data->fwd_step_log); \n  module_data_block_vector_type * data_block_vector = module_info_get_data_block_vector(module_info); \n  printf(\"Running Forward Stepwise regression:\\n\"); \n  { \n \n    int ens_size    = matrix_get_columns( S ); \n    int nx          = matrix_get_rows( A ); \n    int nd          = matrix_get_rows( S ); \n    int nfolds      = fwd_step_data->nfolds; \n    double r2_limit = fwd_step_data->r2_limit; \n    bool verbose    = fwd_step_data->verbose; \n    int num_kw     =  module_data_block_vector_get_size(data_block_vector); \n \n    #pragma omp parallel \n    #pragma omp master \n    if (fwd_step_data->num_threads == DEFAULT_NUM_THREADS) \n     fwd_step_data->num_threads = omp_get_num_threads(); \n    fwd_step_data->num_threads = 1; \n \n    if ( ens_size <= nfolds) \n      util_abort(\"%s: The number of ensembles must be larger than the CV fold - aborting\\n\", __func__); \n \n \n    { \n \n      matrix_type * St = matrix_alloc( ens_size, nd  ); \n      matrix_type * Et = matrix_alloc( ens_size, nd  ); \n \n       \n \n      matrix_subtract_row_mean( S );            \n \n      St   = matrix_alloc_transpose( S ); \n      Et   = matrix_alloc_transpose( E ); \n \n      matrix_type * di = matrix_alloc( 1, nd ); \n \n      if (verbose){ \n        char * ministep_name = module_info_get_ministep_name(module_info); \n        fwd_step_enkf_write_log_header(fwd_step_data, ministep_name, nx, nd, ens_size); \n      } \n \n      int kw,i; \n       \n       \n \n      int_vector_type * kw_list = int_vector_alloc(nx, -1); \n      int_vector_type * local_index_list = int_vector_alloc(nx, -1); \n      for (kw = 0; kw < num_kw; kw++) { \n        module_data_block_type * data_block = module_data_block_vector_iget_module_data_block(data_block_vector, kw); \n        int row_start = module_data_block_get_row_start(data_block); \n        int row_end   = module_data_block_get_row_end(data_block); \n        for (i = row_start; i < row_end; i++) { \n          int_vector_iset(kw_list, i, kw); \n          int_vector_iset(local_index_list, i, i - row_start); \n        } \n      } \n \n \n       \n \n      #pragma omp parallel for schedule(dynamic, 1) num_threads(fwd_step_data->num_threads) \n      for (i = 0; i < nx; i++) { \n        int kw_ind = int_vector_iget(kw_list, i); \n        module_data_block_type * data_block = module_data_block_vector_iget_module_data_block(data_block_vector, kw_ind); \n        const char * key = module_data_block_get_key(data_block); \n        const int* active_indices = module_data_block_get_active_indices(data_block); \n        int active_index = 0; \n        bool all_active = active_indices == NULL;  \n \n        stepwise_type * stepwise_data = stepwise_alloc1(ens_size, nd, fwd_step_data->rng, St, Et); \n \n         \n \n         \n \n        matrix_type * y = matrix_alloc( ens_size, 1 ); \n \n        for (int j = 0; j < ens_size; j++) { \n          matrix_iset(y, j, 0, matrix_iget( A, i, j ) ); \n        } \n \n        stepwise_set_Y0( stepwise_data, y ); \n \n          stepwise_estimate(stepwise_data, r2_limit, nfolds ); \n \n         \n \n        for (int j = 0; j < ens_size; j++) { \n          for (int k = 0; k < nd; k++) { \n            matrix_iset(di, 0, k, matrix_iget( D, k, j ) ); \n          } \n          double aij = matrix_iget( A, i, j ); \n          double xHat = stepwise_eval(stepwise_data, di ); \n          matrix_iset(A, i, j, aij + xHat); \n        } \n \n        if (verbose){ \n          int loc_ind = int_vector", "pred": " \nvoid fwd_step_enkf_updateA(void * module_data, \n                           matrix_type * A, \n                           matrix_type * S, \n                           matrix_type * R, \n                           matrix_type * dObs, \n                           matrix_type * E, \n                           matrix_type * D, \n                           const module_info_type* module_info) { \n \n \n \n  fwd_step_enkf_data_type * fwd_step_data = fwd_step_enkf_data_safe_cast( module_data ); \n  fwd_step_log_open(fwd_step_data->fwd_step_log); \n  module_data_block_vector_type * data_block_vector = module_info_get_data_block_vector(module_info); \n  printf(\"Running Forward Stepwise regression:\\n\"); \n  { \n \n    int ens_size    = matrix_get_columns( S ); \n    int nx          = matrix_get_rows( A ); \n    int nd          = matrix_get_rows( S ); \n    int nfolds      = fwd_step_data->nfolds; \n    double r2_limit = fwd_step_data->r2_limit; \n    bool verbose    = fwd_step_data->verbose; \n    int num_kw     =  module_data_block_vector_get_size(data_block_vector); \n \n    #pragma omp parallel \n    #pragma omp master \n{\"\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nvoid LLG_inplane_evolve(double *mag, double *mag_new, double dt) { \n    int i, j, n; \n#pragma omp parallel default(none) private(i,j,n) shared(Nx,Ny,bapp,mag,mag_new,dt,alpha,alpha2,jx,jy) \n\t{ \n#pragma omp for schedule(static)     \n\tfor(i=1;i<=Nx;i++) \n\t\tfor(j=1;j<=Ny;j++) { \n \n\t\t\tdouble beff[3] = {0., 0., bapp}; \n\t\t\tdouble magxbeff[3], magxmagxbeff[3], rhs[3]; \n\t\t\t \n\t\t\tadd_exchange(mag, i, j, beff); \n \n \n \n \n \n\t\t\tadd_anisotropy_z(mag, i, j, beff);\t\t\t \n\t\t\t \n\t\t\t \n \n\t\t\t \n \n\t\t\tadd_DMI_renorm_J0value(mag, i, j, beff); \n\t\t\t \n\t\t\tcross(&mag[ind(i,j)], beff, magxbeff); \n\t\t\tcross(&mag[ind(i,j)], magxbeff, magxmagxbeff); \n \n\t\t\tdouble tsst[3], magxtsst[3]; \n\t\t\tsst_torque_inplane(mag, i, j, jx, jy, tsst);\t\t\t \n\t\t\tcross(&mag[ind(i,j)],tsst,magxtsst); \n \n\t\t\tfor(n=0;n<3;n++) \n\t\t\t\trhs[n] = - magxbeff[n] - alpha*magxmagxbeff[n] + tsst[n] + alpha*magxtsst[n]; \n \n\t\t\tdouble mx = mag[ind(i,j)]; \n\t\t\tdouble my = mag[ind(i,j)+1];\t\t\t\t\t\t\t\t\t \n\t\t\tdouble mz = mag[ind(i,j)+2]; \n\t\t\tdouble Z = rhs[2]/(1.+alpha2*mz*mz); \n\t\t\trhs[0] += -alpha*my*Z - alpha2*mx*mz*Z; \n\t\t\trhs[1] += alpha*mx*Z - alpha2*my*mz*Z; \n\t\t\trhs[2] = (1.+alpha2)*Z; \n\t\t\t \n\t\t\tfor(n=0;n<3;n++) \n\t\t\t\tmag_new[ind(i,j)+n] = mag[ind(i,j)+n] + dt*rhs[n]; \n\t\t} \n    } \n} ", "pred": " \nvoid LLG_inplane_evolve(double *mag, double *mag_new, double dt) { \n    int i, j, n; \n#pragma omp parallel default(none) private(i,j,n) shared(Nx,Ny,bapp,mag,mag_new,dt,alpha,alpha2,jx,jy) \n\t{ \n#pragma omp for schedule(static)     \n\tfor(i=1;i<=Nx;i++) \n\t\tfor(j=1;j<=Ny;j++) { \n \n\t\t\tdouble beff[3] = {0., 0., bapp}; \n\t\t\tdouble magxbeff[3], magxmagxbeff[3], rhs[3]; \n\t\t\t \n\t\t\tadd_exchange(mag, i, j, beff); \n \n \n \n \n \n\t\t\tadd_anisotropy_z(mag, i, j, beff);\t\t\t \n\t\t\t \n\t\t\t \n \n\t\t\t \n \n\t\t\tadd_DMI_renorm_J0value(mag, i, j, beff); \n\t\t\t \n\t\t\tcross(&mag[ind(i,j)], beff, magxbeff); \n\t\t\tcross(&mag[ind(i,j)], magxbeff, magxmagxbeff); \n \n\t\t\tdouble tsst[3], magxtsst[3]; \n\t\t\tsst_torque_inplane(mag, i, j, jx, jy, tsst);\t\t\t \n\t\t\tcross(&mag[ind(i,j)],tsst,magxtsst); \n \n\t\t\tfor(n=0;n<3;n++) \n\t\t\t\trhs[n] = - magxbeff[n] - alpha*magxmagxbeff[n] + tsst[n] + alpha*magxtsst[n]; \n \n\t\t\tdouble mx = mag[ind(i,j)]; \n\t\t\tdouble my = mag[ind(i,j)+1];\t\t\t\t\t\t\t\t\t \n\t\t\tdouble mz = mag[ind(i,j)+2]; \n\t\t\tdouble Z = rhs[2]/(1.+alpha2*mz*mz); \n\t\t\trhs[z] = 0.0;\\n                                                                                                                                     "}
{"label": " \nvoid producer_consumer_parallel(int *buffer, int size, int *vec, int n, int nThreads ) \n{ \n\tint i, j; \n\tlong long unsigned int sum = 0; \n    double tstart, tend, duration; \n \n    tstart = omp_get_wtime(); \n \n     \n \n     \n \n     \n \n     \n \n#pragma omp parallel num_threads ( nThreads )      default(none) shared(buffer, vec, size, n) private(i, j)      reduction (+:sum)  \n \n\tfor(i=0;i<n;i++)  \n    { \n\t\tif(i % 2 == 0) \n        {\t \n \n \n             \n \n             \n \n             \n \n \n#pragma omp for schedule ( guided ) \n\t\t\tfor(j=0;j<size;j++) \n            { \n\t\t\t\tbuffer[j] = vec[i] + j*vec[i+1]; \n\t\t\t} \n\t\t} \n\t\telse \n        {\t \n \n \n \n#pragma omp for schedule ( guided ) \n\t\t\tfor(j=0;j<size;j++) \n            { \n\t\t\t\tsum += buffer[j]; \n\t\t\t} \n\t\t} \n\t} \n    tend = omp_get_wtime(); \n    duration = tend - tstart; \n \n\tprintf(\"%llu\\n%lf\\n\",sum,duration); \n} \n \nvoid pr ", "pred": " \nvoid producer_consumer_parallel(int *buffer, int size, int *vec, int n, int nThreads ) \n{ \n\tint i, j; \n\tlong long unsigned int sum = 0; \n    double tstart, tend, duration; \n \n    tstart = omp_get_wtime(); \n \n     \n \n     \n \n     \n \n     \n \n#pragma omp parallel num_threads ( nThreads )      default(none) shared(buffer, vec, size, n) private(i, j)      reduction (+:sum)  \n \n\tfor(i=0;i<n;i++)  \n    { \n\t\tif(i % 2 == 0) \n        {\t \n \n \n             \n \n             \n \n             \n \n \n#pragma omp for schedule ( guided ) \n\t\t\tfor(j=0;j<size;j++) \n            { \n\t\t\t\tbuffer[j] = vec[i] + j*vec[i+1]; \n\t\t\t} \n\t\t} \n\t\telse \n        {\t \n \n \n \n#pragma omp for schedule ( guided ) \n\t\t\tfor(j=0;j<size;j++) \n            { \n\t\t\t\tsum += buffer[j]; \n\t\t\t} \n\t\t} \n\t} \n    tend = omp_get_wtime(); \n    duration = tend - tstart; \n \n\tprintf(\"%llu\\n%lf\\n\",sum,duration); \n} \n \nvoid pr "}
{"label": " \nvoid dt_bilateral_slice(const dt_bilateral_t *const b, const float *const in, float *out, const float detail) \n{ \n   \n \n  const float norm = -detail * b->sigma_r * 0.04f; \n  const int ox = 1; \n  const int oy = b->size_x; \n  const int oz = b->size_y * b->size_x; \n \n  float *const buf = b->buf; \n  const int size_x = b->size_x; \n  const int size_y = b->size_y; \n  const int size_z = b->size_z; \n  const int width = b->width; \n  const int height = b->height; \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(b, in, norm, oy, oz, ox, size_x, size_y, size_z, height, width, buf)      shared(out) collapse(2) \n  for(int j = 0; j < height; j++) \n  { \n    for(int i = 0; i < width; i++) \n    { \n      size_t index = 4 * (j * width + i); \n      float x, y, z; \n      const float L = in[index]; \n      image_to_grid(b, i, j, L, &x, &y, &z); \n       \n \n      const int xi = MIN((int)x, size_x - 2); \n      const int yi = MIN((int)y, size_y - 2); \n      const int zi = MIN((int)z, size_z - 2); \n      const float xf = x - xi; \n      const float yf = y - yi; \n      const float zf = z - zi; \n      const size_t gi = xi + size_x * (yi + size_y * zi); \n      const float Lout = L \n                         + norm * (buf[gi] * (1.0f - xf) * (1.0f - yf) * (1.0f - zf) \n                                   + buf[gi + ox] * (xf) * (1.0f - yf) * (1.0f - zf) \n                                   + buf[gi + oy] * (1.0f - xf) * (yf) * (1.0f - zf) \n                                   + buf[gi + ox + oy] * (xf) * (yf) * (1.0f - zf) \n                                   + buf[gi + oz] * (1.0f - xf) * (1.0f - yf) * (zf) \n                                   + buf[gi + ox + oz] * (xf) * (1.0f - yf) * (zf) \n                                   + buf[gi + oy + oz] * (1.0f - xf) * (yf) * (zf) \n                                   + buf[gi + ox + oy + oz] * (xf) * (yf) * (zf)); \n      out[index] = Lout; \n       \n \n      out[index + 1] = in[index + 1]; \n      out[index + 2] = in[index + 2]; \n      out[index + 3] = in[index + 3]; \n    } \n  } \n} ", "pred": " \nvoid dt_bilateral_slice(const dt_bilateral_t *const b, const float *const in, float *out, const float detail) \n{ \n   \n \n  const float norm = -detail * b->sigma_r * 0.04f; \n  const int ox = 1; \n  const int oy = b->size_x; \n  const int oz = b->size_y * b->size_x; \n \n  float *const buf = b->buf; \n  const int size_x = b->size_x; \n  const int size_y = b->size_y; \n  const int size_z = b->size_z; \n  const int width = b->width; \n  const int height = b->height; \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(b, in, norm, oy, oz, ox, size_x, size_y, size_z, height, width, buf)      shared(out) collapse(2) \n  for(int j = 0; j < height; j++) \n  { \n    for(int i = 0; i < width; i++) \n    { \n      size_t index = 4 * (j * width + i); \n      float x, y, z; \n      const float L = in[index]; \n      image_to_grid(b, i, j, L, &x, &y, &z); \n       \n \n      const int xi = MIN((int)x, size_x - 2); \n      const int yi = MIN((int)y, size_y - 2); \n      const int zi = MIN((int)z, size_z - 2); \n      const float xf = x - xi; \n      const float yf = y - yi; \n      const float zf = z - zi; \n      const size_t gi = xi + size_x * (yi + size_y * zi); \n      const float Lout = L \n                         + norm * (buf[gi] * (1 + x * xi);\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "}
{"label": " \nstatic void createPreMarkers(RoadMapArray * rdmaps, PreGraph * preGraph, \n\t\t\t    IDnum * chains) \n{ \n\tIDnum sequenceIndex; \n\tIDnum referenceCount = rdmaps->referenceCount; \n\tAnnotation *annot = rdmaps->annotations; \n \n\tint threads = omp_get_max_threads(); \n\tif (threads > 8) \n\t\tthreads = 8; \n \n #pragma omp parallel for num_threads(threads) \n\tfor (sequenceIndex = 1; \n\t     sequenceIndex <= referenceCount; \n\t     sequenceIndex++) { \n\t\tAnnotation *annot = getAnnotationInArray(rdmaps->annotations, annotationOffset[sequenceIndex - 1]); \n\t\tRoadMap *rdmap; \n\t\tCoordinate currentPosition, currentInternalPosition; \n\t\tIDnum currentPreNodeID, nextInternalPreNodeID; \n\t\tIDnum annotIndex, lastAnnotIndex; \n\t\tPreMarker * previous; \n \n\t\tif (sequenceIndex % 1000000 == 0) \n\t\t\tvelvetLog(\"Connecting %li / %li\\n\", (long) sequenceIndex, \n\t\t\t       (long) sequenceCount_pg(preGraph)); \n \n\t\trdmap = getRoadMapInArray(rdmaps, sequenceIndex - 1); \n\t\tannotIndex = 0; \n\t\tlastAnnotIndex = getAnnotationCount(rdmap); \n\t\tnextInternalPreNodeID = chooseNextInternalPreNode \n\t\t    (chains[sequenceIndex] - 1, sequenceIndex, \n\t\t     preGraph, chains); \n \n\t\tprevious = NULL; \n\t\tcurrentPosition = 0; \n\t\tcurrentInternalPosition = 0; \n\t\tcurrentPreNodeID = 0; \n\t\t \n \n\t\twhile (annotIndex < lastAnnotIndex \n\t\t       || nextInternalPreNodeID!= 0) { \n\t\t\tif (annotIndex == lastAnnotIndex \n\t\t\t    || (nextInternalPreNodeID!= 0 \n\t\t\t\t&& currentInternalPosition < \n\t\t\t\tgetPosition(annot))) { \n\t\t\t\tlockNode(nextInternalPreNodeID); \n\t\t\t\tprevious = addPreMarker_pg(preGraph,  \n\t\t\t\t\t\tnextInternalPreNodeID, \n\t\t\t\t\t\tsequenceIndex, \n\t\t\t\t\t\t&currentPosition, \n\t\t\t\t\t\tprevious); \n\t\t\t\tunLockNode(nextInternalPreNodeID); \n\t\t\t\tcurrentPreNodeID = nextInternalPreNodeID; \n\t\t\t\tnextInternalPreNodeID = \n\t\t\t\t    chooseNextInternalPreNode \n\t\t\t\t    (currentPreNodeID, sequenceIndex, \n\t\t\t\t     preGraph, chains); \n\t\t\t\tcurrentInternalPosition += \n\t\t\t\t    getPreNodeLength_pg(currentPreNodeID, \n\t\t\t\t\t\t\tpreGraph); \n \n\t\t\t} else { \n\t\t\t\treConnectAnnotation(&currentPreNodeID, annot, \n\t\t\t\t\t\t  &currentPosition, \n\t\t\t\t\t\t  sequenceIndex,  \n\t\t\t\t\t\t  preGraph, \n\t\t\t\t\t\t  &previous); \n\t\t\t\tannot = getNextAnnotation(annot); \n\t\t\t\tannotIndex++; \n\t\t\t} \n\t\t} \n\t} \n} ", "pred": " \nstatic void createPreMarkers(RoadMapArray * rdmaps, PreGraph * preGraph, \n\t\t\t    IDnum * chains) \n{ \n\tIDnum sequenceIndex; \n\tIDnum referenceCount = rdmaps->referenceCount; \n\tAnnotation *annot = rdmaps->annotations; \n \n\tint threads = omp_get_max_threads(); \n\tif (threads > 8) \n\t\tthreads = 8; \n \n #pragma omp parallel for num_threads(threads) \n\tfor (sequenceIndex = 1; \n\t     sequenceIndex <= referenceCount; \n\t     sequenceIndex++) { \n\t\tAnnotation *annot = getAnnotationInArray(rdmaps->annotations, annotationOffset[sequenceIndex - 1]); \n\t\tRoadMap *rdmap; \n\t\tCoordinate currentPosition, currentInternalPosition; \n\t\tIDnum currentPreNodeID, nextInternalPreNodeID; \n\t\tIDnum annotIndex, lastAnnotIndex; \n\t\tPreMarker * previous; \n \n\t\tif (sequenceIndex % 1000000 == 0) \n\t\t\tvelvetLog(\"Connecting %li / %li\\n\", (long) sequenceIndex, \n\t\t\t       (long) sequenceCount_pg(preGraph)); \n \n\t\trdmap = getRoadMapInArray(rdmaps, sequenceIndex - 1); \n\t\tannotIndex = 0; \n\t\tlastAnnotIndex = getAnnotationCount(rdmap); \n\t\tnextInternalPreNodeID = chooseNextInternalPreNode \n\t\t    (chains[sequenceIndex] - 1, sequenceIndex, \n\t\t     preGraph, chains); \n \n\t\tprevious = NULL; \n\t\tcurrentPosition = 0; \n\t\tcurrentInternalPosition = 0; \n\t\tcurrentPreNodeID = 0; \n\t\t \n \n\t\twhile (annotIndex < lastAnnotIndex \n\t\t       || nextInternalPreNodeID!= 0) { \n\t\t\tif (annotIndex == lastAnnotIndex \n\t\t\t    || (nextInternalPreNodeID!= 0 \n\t\t\t\t&& currentInternalPosition < \n\t\t\t\tgetPosition(annot))) { \n\t\t\t\tlockNode(nextInternalPreNodeID); \n\t\t\t\tprevious = addPreMarker_pg(preGraph,  \n\t\t\t\t\t\tnextInternalPreNodeID,                                                                                                                                                                                                                                                                                                   "}
{"label": " \nvoid prefix_sums(attr_id_t *input, attr_id_t* result, attr_id_t* p, attr_id_t n) { \n \n    attr_id_t i, j, r, start, end, add_value; \n    int tid, nthreads; \n \n    tid = omp_get_thread_num(); \n    nthreads = omp_get_num_threads(); \n    r = n/nthreads; \n \n    result[0] = 0; \n \n#pragma omp for \n    for (i=1; i<n+1; i++) \n        result[i] = input[i-1]; \n \n    start =  tid*r + 1; \n    end   = (tid+1)*r; \n \n    if (tid == nthreads-1) \n        end = n+1; \n \n    for (j=start; j<end; j++) \n        result[j] = input[j-1] + result[j-1]; \n \n    p[tid] = result[end-1]; \n \n#pragma omp barrier \n \n    if (tid == 0) { \n        for (j=1; j<nthreads; j++) \n            p[j] += p[j-1]; \n    } \n \n#pragma omp barrier \n \n    if (tid>0) { \n        add_value=p[tid-1]; \n        for (j=start-1; j<end; j++) \n            result[j] += add_value; \n    } \n \n#pragma omp barrier \n \n    attr_id_t i; \n    result[0] = 0; \n    for (i=1; i<n+1; i++) { \n        result[i] = result[i-1] + input[i-1]; \n    } \n \n} ", "pred": " \nvoid prefix_sums(attr_id_t *input, attr_id_t* result, attr_id_t* p, attr_id_t n) { \n \n    attr_id_t i, j, r, start, end, add_value; \n    int tid, nthreads; \n \n    tid = omp_get_thread_num(); \n    nthreads = omp_get_num_threads(); \n    r = n/nthreads; \n \n    result[0] = 0; \n \n#pragma omp for \n    for (i=1; i<n+1; i++) \n        result[i] = input[i-1]; \n \n    start =  tid*r + 1; \n    end   = (tid+1)*r; \n \n    if (tid == nthreads-1) \n        end = n+1; \n \n    for (j=start; j<end; j++) \n        result[j] = input[j-1] + result[j-1]; \n \n    p[tid] = result[end-1]; \n \n#pragma omp barrier \n \n    if (tid == 0) { \n        for (j=1; j<nthreads; j++) \n            p[j] += p[j-1]; \n    } \n \n#pragma omp barrier \n \n    if (tid>0) { \n        add_value=p[tid-1]; \n        for (j=start-1; j<end; j++) \n            result[j] += add_value; \n    } \n \n#pragma omp barrier \n \n    attr_id_t i; \n    result[0] = 0; \n    for (i=1; i<n+1; i++) { \n        result[i] = result[i-1] + input[i-1]; \n    } \n \n} "}
{"label": " \nvoid test_two(int x) { \n#pragma omp for ordered \n  for (int i = 0; i < x; i++) \n    ; \n} ", "pred": " \nvoid test_two(int x) { \n#pragma omp for ordered \n  for (int i = 0; i < x; i++) \n    ; \n} "}
{"label": " \nstatic PyObject *py_gibbs_ibm_sample_parallel(PyObject *self, PyObject *args) { \n    PyObject *eee, *fff, *counts_idx_arrays, *dists_arrays, *params; \n    PyArrayObject *seed_array; \n    int model, n_iterations; \n    double null_prior; \n \n    if(!PyArg_ParseTuple(args, \"iiOOOOOdO\", \n        &n_iterations, &model, &eee, &fff, &dists_arrays, &counts_idx_arrays, \n        &params, &null_prior, &seed_array)) \n        return NULL; \n \n    const size_t n_sents = PyTuple_Size(eee); \n    const size_t n_samplers = PyTuple_Size(params); \n \n    PRNG_SEED_t *seed = (PRNG_SEED_t*) PyArray_GETPTR1(seed_array, 0); \n    PRNG_SEED_t local_seeds[n_samplers]; \n    for (size_t sampler=0; sampler<n_samplers; sampler++) \n        local_seeds[sampler] = prng_next(*seed + 1 + sampler); \n    *seed = prng_next(*seed); \n \n    for (size_t iteration=0; iteration<n_iterations; iteration++) { \n        fputc('.', stderr); \n        fflush(stderr); \n#pragma omp parallel for \n        for (size_t sampler=0; sampler<n_samplers; sampler++) { \n             \n \n            if (iteration > n_iterations-n_samplers+sampler) continue; \n \n             \n \n             \n \n             \n \n             \n \n            const int add_sample = (dists_arrays!= Py_None) && \n                                   ((iteration % n_samplers) == sampler); \n \n             \n \n             \n \n            PRNG_SEED_t seed_cache = local_seeds[sampler]; \n \n            PyObject *sampler_params = PyTuple_GET_ITEM(params, sampler); \n \n            PyObject *aaa = PyTuple_GET_ITEM(sampler_params, 0); \n            PyArrayObject *counts_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 1); \n            PyArrayObject *counts_sum_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 2); \n            PyArrayObject *jump_counts_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 3); \n            PyArrayObject *fert_counts_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 4); \n \n            COUNT_t *counts_sum = \n                 (COUNT_t*) PyArray_GETPTR1(counts_sum_array, 0); \n            COUNT_t *counts = (COUNT_t*) PyArray_GETPTR1(counts_array, 0); \n            COUNT_t *jump_counts = ((PyObject*)jump_counts_array == Py_None) \n               ? NULL \n                : PyArray_GETPTR1(jump_counts_array, 0); \n            COUNT_t *fert_counts = ((PyObject*)fert_counts_array == Py_None) \n               ? NULL \n                : PyArray_GETPTR1(fert_counts_array, 0); \n \n             \n \n             \n \n            if (fert_counts!= NULL) { \n                const size_t e_size = \n                      PyArray_SIZE(fert_counts_array) / FERT_ARRAY_LEN; \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n                for (size_t i=0; i<e_size*FERT_ARRAY_LEN; i++) \n                    fert_counts[i] = (COUNT_t) 1.0; \n \n                 \n \n                for (size_t sent=0; sent<n_sents; sent++) { \n                    PyArrayObject *ee_array = \n                        (PyArrayObject*) PyTuple_GET_ITEM(eee, sent); \n                    PyArrayObject *ff_array = \n                        (PyArrayObject*) PyTuple_GET_ITEM(fff, sent); \n                    const size_t ee_len = (size_t) PyArray_DIM(ee_array, 0); \n                    const size_t ff_len = (size_t) PyArray_DIM(ff_array, 0); \n \n                    if (ee_len == 0 || ff_len == 0) continue; \n \n                    PyArrayObject *aa_array = ", "pred": " \nstatic PyObject *py_gibbs_ibm_sample_parallel(PyObject *self, PyObject *args) { \n    PyObject *eee, *fff, *counts_idx_arrays, *dists_arrays, *params; \n    PyArrayObject *seed_array; \n    int model, n_iterations; \n    double null_prior; \n \n    if(!PyArg_ParseTuple(args, \"iiOOOOOdO\", \n        &n_iterations, &model, &eee, &fff, &dists_arrays, &counts_idx_arrays, \n        &params, &null_prior, &seed_array)) \n        return NULL; \n \n    const size_t n_sents = PyTuple_Size(eee); \n    const size_t n_samplers = PyTuple_Size(params); \n \n    PRNG_SEED_t *seed = (PRNG_SEED_t*) PyArray_GETPTR1(seed_array, 0); \n    PRNG_SEED_t local_seeds[n_samplers]; \n    for (size_t sampler=0; sampler<n_samplers; sampler++) \n        local_seeds[sampler] = prng_next(*seed + 1 + sampler); \n    *seed = prng_next(*seed); \n \n    for (size_t iteration=0; iteration<n_iterations; iteration++) { \n        fputc('.', stderr); \n        fflush(stderr); \n#pragma omp parallel for \n        for (size_t sampler=0; sampler<n_samplers; sampler++) { \n             \n \n            if (iteration > n_iterations-n_samplers+sampler) continue; \n \n             \n \n             \n \n             \n \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "}
{"label": " \nstatic void connectPreNodes(RoadMapArray * rdmaps, PreGraph * preGraph, \n\t\t\t    IDnum * chains) \n{ \n\tIDnum sequenceIndex; \n\tIDnum referenceCount = rdmaps->referenceCount; \n\tannotationOffset = mallocOrExit(rdmaps->length + 1, Coordinate); \n\tannotationOffset[0] = 0; \n\tfor (sequenceIndex = 1; sequenceIndex <= rdmaps->length; sequenceIndex++) \n\t\tannotationOffset[sequenceIndex] = annotationOffset[sequenceIndex - 1] + \n\t\t\t\t\t\t  getAnnotationCount(getRoadMapInArray(rdmaps, sequenceIndex - 1)); \n\tAnnotation *annot = rdmaps->annotations; \n \n\tif (rdmaps->referenceCount > 0)  \n\t\tallocatePreMarkerCountSpace_pg(preGraph); \n \n\tint threads = omp_get_max_threads(); \n\tif (threads > 8) \n\t\tthreads = 8; \n \n #pragma omp parallel for num_threads(threads) \n\tfor (sequenceIndex = 1; \n\t     sequenceIndex <= sequenceCount_pg(preGraph); \n\t     sequenceIndex++) { \n\t\tAnnotation *annot = getAnnotationInArray(rdmaps->annotations, annotationOffset[sequenceIndex - 1]); \n\t\tRoadMap *rdmap; \n\t\tCoordinate currentPosition, currentInternalPosition; \n\t\tIDnum currentPreNodeID, nextInternalPreNodeID; \n\t\tIDnum annotIndex, lastAnnotIndex; \n\t\tboolean isReference; \n \n\t\tif (sequenceIndex % 1000000 == 0) \n\t\t\tvelvetLog(\"Connecting %li / %li\\n\", (long) sequenceIndex, \n\t\t\t       (long) sequenceCount_pg(preGraph)); \n \n\t\trdmap = getRoadMapInArray(rdmaps, sequenceIndex - 1); \n\t\tannotIndex = 0; \n\t\tlastAnnotIndex = getAnnotationCount(rdmap); \n\t\tnextInternalPreNodeID = chooseNextInternalPreNode \n\t\t    (chains[sequenceIndex] - 1, sequenceIndex, \n\t\t     preGraph, chains); \n\t\tisReference = (sequenceIndex <= referenceCount); \n \n\t\tcurrentPosition = 0; \n\t\tcurrentInternalPosition = 0; \n\t\tcurrentPreNodeID = 0; \n\t\t \n \n\t\twhile (annotIndex < lastAnnotIndex \n\t\t       || nextInternalPreNodeID!= 0) { \n\t\t\tif (annotIndex == lastAnnotIndex \n\t\t\t    || (nextInternalPreNodeID!= 0 \n\t\t\t\t&& currentInternalPosition < \n\t\t\t\tgetPosition(annot))) { \n\t\t\t\tconnectPreNodeToTheNext(&currentPreNodeID, \n\t\t\t\t\t\t\tnextInternalPreNodeID, \n\t\t\t\t\t\t\t&currentPosition, \n\t\t\t\t\t\t\tsequenceIndex, \n\t\t\t\t\t\t\tisReference, \n\t\t\t\t\t\t\tpreGraph); \n\t\t\t\tnextInternalPreNodeID = \n\t\t\t\t    chooseNextInternalPreNode \n\t\t\t\t    (currentPreNodeID, sequenceIndex, \n\t\t\t\t     preGraph, chains); \n\t\t\t\tcurrentInternalPosition += \n\t\t\t\t    getPreNodeLength_pg(currentPreNodeID, \n\t\t\t\t\t\t\tpreGraph); \n \n\t\t\t} else { \n\t\t\t\tconnectAnnotation(&currentPreNodeID, annot, \n\t\t\t\t\t\t  &currentPosition, \n\t\t\t\t\t\t  sequenceIndex, isReference, \n\t\t\t\t\t\t  preGraph); \n\t\t\t\tannot = getNextAnnotation(annot); \n\t\t\t\tannotIndex++; \n\t\t\t} \n\t\t} \n\t} \n \n\tif (rdmaps->referenceCount > 0) { \n\t\tallocatePreMarkerSpace_pg(preGraph); \n\t\tcreatePreMarkers(rdmaps, preGraph, chains);\t \n\t} \n \n\tfree(annotationOffset); \n\tannotationOffset = NULL; \n} ", "pred": " \nstatic void connectPreNodes(RoadMapArray * rdmaps, PreGraph * preGraph, \n\t\t\t    IDnum * chains) \n{ \n\tIDnum sequenceIndex; \n\tIDnum referenceCount = rdmaps->referenceCount; \n\tannotationOffset = mallocOrExit(rdmaps->length + 1, Coordinate); \n\tannotationOffset[0] = 0; \n\tfor (sequenceIndex = 1; sequenceIndex <= rdmaps->length; sequenceIndex++) \n\t\tannotationOffset[sequenceIndex] = annotationOffset[sequenceIndex - 1] + \n\t\t\t\t\t\t  getAnnotationCount(getRoadMapInArray(rdmaps, sequenceIndex - 1)); \n\tAnnotation *annot = rdmaps->annotations; \n \n\tif (rdmaps->referenceCount > 0)  \n\t\tallocatePreMarkerCountSpace_pg(preGraph); \n \n\tint threads = omp_get_max_threads(); \n\tif (threads > 8) \n\t\tthreads = 8; \n \n #pragma omp parallel for num_threads(threads) \n\tfor (sequenceIndex = 1; \n\t     sequenceIndex <= sequenceCount_pg(preGraph); \n\t     sequenceIndex++) { \n\t\tAnnotation *annot = getAnnotationInArray(rdmaps->annotations, annotationOffset[sequenceIndex - 1]); \n\t\tRoadMap *rdmap; \n\t\tCoordinate currentPosition, currentInternalPosition; \n\t\tIDnum currentPreNodeID, nextInternalPreNodeID; \n\t\tIDnum annotIndex, lastAnnotIndex; \n\t\tboolean isReference; \n \n\t\tif (sequenceIndex % 1000000 == 0) \n\t\t\tvelvetLog(\"Connecting %li / %li\\n\", (long) sequenceIndex, \n\t\t\t       (long) sequenceCount_pg(preGraph)); \n \n\t\trdmap = getRoadMapInArray(rdmaps, sequenceIndex - 1); \n\t\tannotIndex = 0; \n\t\tlastAnnotIndex = getAnnotationCount(rdmap); \n\t\tnextInternalPreNodeID = chooseNextInternalPreNode \n\t\t    (chains[sequenceIndex] - 1, sequenceIndex, \n\t\t     preGraph, chains); \n\t\tisReference = (sequenceIndex <= referenceCount); \n \n\t\tcurrentPosition = 0; \n\t\tcurrentInternalPosition = 0; \n\t(preGraph, 0);\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": "void DeblockPicture(VideoParameters *p_Vid, StorablePicture *p) \n{ \n  int iheightMBs =(p_Vid->PicSizeInMbs/p_Vid->PicWidthInMbs); \n  unsigned int i, k = p->PicWidthInMbs + 2 * (iheightMBs - 1); \n   \n  for (i = 0; i < k; i++) \n  { \n    int nn;     \n    int n_last = imin(iheightMBs, (i >> 1) + 1); \n    int n_start = (i < p->PicWidthInMbs)? 0 : ((i - p->PicWidthInMbs) >> 1) + 1; \n \n    #pragma omp parallel for \n    for (nn = n_start; nn < n_last; nn += GROUP_SIZE) \n      DeblockParallel(p_Vid, p, i, nn, n_last); \n  } \n} \n ", "pred": "void DeblockPicture(VideoParameters *p_Vid, StorablePicture *p) \n{ \n  int iheightMBs =(p_Vid->PicSizeInMbs/p_Vid->PicWidthInMbs); \n  unsigned int i, k = p->PicWidthInMbs + 2 * (iheightMBs - 1); \n   \n  for (i = 0; i < k; i++) \n  { \n    int nn;     \n    int n_last = imin(iheightMBs, (i >> 1) + 1); \n    int n_start = (i < p->PicWidthInMbs)? 0 : ((i - p->PicWidthInMbs) >> 1) + 1; \n \n    #pragma omp parallel for \n    for (nn = n_start; nn < n_last; nn += GROUP_SIZE) \n      DeblockParallel(p_Vid, p, i, nn, n_last); \n  } \n} \n "}
{"label": " \nstatic void blur_line(float *buf, const int offset1, const int offset2, const int offset3, const int size1, \n                      const int size2, const int size3) \n{ \n  const float w0 = 6.f / 16.f; \n  const float w1 = 4.f / 16.f; \n  const float w2 = 1.f / 16.f; \n#pragma omp parallel for default(none)      dt_omp_firstprivate(size1, size2, size3, offset1, offset2, offset3, w0, w1, w2, buf)      collapse(2) \n  for(int k = 0; k < size1; k++) \n  { \n    for(int j = 0; j < size2; j++) \n    { \n      size_t index = (size_t)k * offset1 + j * offset2; \n      float tmp1 = buf[index]; \n      buf[index] = buf[index] * w0 + w1 * buf[index + offset3] + w2 * buf[index + 2 * offset3]; \n \n       \n \n \n      float tmp2 = buf[index + offset3]; \n      buf[index + offset3] = buf[index + offset3] * w0 + w1 * (buf[index + 2 * offset3] + tmp1) + w2 * buf[index + 3 * offset3]; \n \n       \n \n \n      for(int i = 2; i < size3 - 2; i++) \n      { \n        const float tmp3 = buf[index + i * offset3]; \n        buf[index + i * offset3] \n            = buf[index + i * offset3] * w0 + w1 * (buf[+ (i + 1) * offset3] + tmp2) + w2 * (buf[index + (i + 2) * offset3] + tmp1); \n        tmp1 = tmp2; \n        tmp2 = tmp3; \n      } \n      index += (size3 - 2) * offset3; \n      const float tmp3 = buf[index]; \n      buf[index] = buf[index] * w0 + w1 * (buf[index + offset3] + tmp2) + w2 * tmp1; \n      index += offset3; \n      buf[index] = buf[index] * w0 + w1 * tmp3 + w2 * tmp2; \n    } \n  } \n} ", "pred": " \nstatic void blur_line(float *buf, const int offset1, const int offset2, const int offset3, const int size1, \n                      const int size2, const int size3) \n{ \n  const float w0 = 6.f / 16.f; \n  const float w1 = 4.f / 16.f; \n  const float w2 = 1.f / 16.f; \n#pragma omp parallel for default(none)      dt_omp_firstprivate(size1, size2, size3, offset1, offset2, offset3, w0, w1, w2, buf)      collapse(2) \n  for(int k = 0; k < size1; k++) \n  { \n    for(int j = 0; j < size2; j++) \n    { \n      size_t index = (size_t)k * offset1 + j * offset2; \n      float tmp1 = buf[index]; \n      buf[index] = buf[index] * w0 + w1 * buf[index + offset3] + w2 * buf[index + 2 * offset3]; \n \n       \n \n \n      float tmp2 = buf[index + offset3]; \n      buf[index + offset3] = buf[index + offset3] * w0 + w1 * (buf[index + 2 * offset3] + tmp1) + w2 * buf[index + 3 * offset3]; \n \n       \n \n \n      for(int i = 2; i < size3 - 2; i++) \n      { \n        const float tmp3 = buf[index + i * offset3]; \n        buf[index + i * offset3] \n            = buf[index + i * offset3] * w0 + w1 * (buf[+ (i + 1) * offset3] + tmp2) + w2 * (buf[index + (i + 2) * offset3] + tmp1); \n        tmp1 = tmp2; \n        tmp2 = tmp3; \n      } \n                                                                                                                                     "}
{"label": " \nvoid dt_bilateral_splat(dt_bilateral_t *b, const float *const in) \n{ \n  const int ox = 1; \n  const int oy = b->size_x; \n  const int oz = b->size_y * b->size_x; \n \n  const float sigma_s = b->sigma_s * b->sigma_s; \n  float *const buf = b->buf; \n \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(in, oy, oz, ox, sigma_s, buf)    shared(b)    collapse(2) \n  for(int j = 0; j < b->height; j++) \n  { \n    for(int i = 0; i < b->width; i++) \n    { \n      size_t index = 4 * (j * b->width + i); \n      float x, y, z; \n      const float L = in[index]; \n      image_to_grid(b, i, j, L, &x, &y, &z); \n      const int xi = MIN((int)x, b->size_x - 2); \n      const int yi = MIN((int)y, b->size_y - 2); \n      const int zi = MIN((int)z, b->size_z - 2); \n      const float xf = x - xi; \n      const float yf = y - yi; \n      const float zf = z - zi; \n       \n \n      const size_t grid_index = xi + b->size_x * (yi + b->size_y * zi); \n       \n \n       \n \n       \n \n       \n \n#pragma omp simd aligned(buf:64) \n      for(int k = 0; k < 8; k++) \n      { \n        const size_t ii = grid_index + ((k & 1)? ox : 0) + ((k & 2)? oy : 0) + ((k & 4)? oz : 0); \n        const float contrib = ((k & 1)? xf : (1.0f - xf)) * ((k & 2)? yf : (1.0f - yf)) \n                              * ((k & 4)? zf : (1.0f - zf)) * 100.0f / (sigma_s); \n        buf[ii] += contrib; \n      } \n    } \n  } \n} ", "pred": " \nvoid dt_bilateral_splat(dt_bilateral_t *b, const float *const in) \n{ \n  const int ox = 1; \n  const int oy = b->size_x; \n  const int oz = b->size_y * b->size_x; \n \n  const float sigma_s = b->sigma_s * b->sigma_s; \n  float *const buf = b->buf; \n \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(in, oy, oz, ox, sigma_s, buf)    shared(b)    collapse(2) \n  for(int j = 0; j < b->height; j++) \n  { \n    for(int i = 0; i < b->width; i++) \n    { \n      size_t index = 4 * (j * b->width + i); \n      float x, y, z; \n      const float L = in[index]; \n      image_to_grid(b, i, j, L, &x, &y, &z); \n      const int xi = MIN((int)x, b->size_x - 2); \n      const int yi = MIN((int)y, b->size_y - 2); \n      const int zi = MIN((int)z, b->size_z - 2); \n      const float xf = x - xi; \n      const float yf = y - yi; \n      const float zf = z - zi; \n       \n \n      const size_t grid_index = xi + b->size_x * (yi + b->size_y * zi); \n       \n \n       \n \n       \n \n       \n \n#pragma omp simd aligned(buf:64) \n      for(int k = 0; k < 8; k++) \n      { \n        const size_t ii = grid_index + ((k & 1)? ox : 0) + ((k & 2)? oy : 0) + ((k & 2)? oz : 0);                                                                                                                                                        "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n     \n \n    double x[] = { 0, 1 }; \n    double y[] = { 0, 1 }; \n    double cfl = 0.99 / sqrt(2);         \n \n    double T = 0.3; \n    double c = 1; \n    long nx = 32; \n    long ny = 32; \n    struct py_field f; \n    char outfile[STR_SIZE] = \"yee_naive_omp.tsv\"; \n    int write = 1; \n    long threads = 4; \n    struct py_cell_partition *part; \n \n     \n \n    py_parse_cmdline(&nx, &threads, outfile, &write, argc, argv); \n    ny = nx;                     \n \n    omp_set_num_threads(threads); \n    printf(\"Domain: %li x %li\\n\", nx, ny); \n    printf(\"OpenMP threads: %li\\n\", threads); \n \n     \n \n    f = py_init_acoustic_field(nx, ny, x, y); \n    py_apply_func(&f.p, py_gauss2d);     \n \n    py_set_boundary(&f); \n \n     \n \n    f.dt = cfl * f.p.dx / c; \n    f.Nt = T / f.dt; \n \n     \n \n    part = py_partition_grid(threads, nx); \n \n     \n \n    double *p = f.p.value; \n    double *u = f.u.value; \n    double *v = f.v.value; \n \n     \n \n    long n, i, j; \n    double tic, toc; \n    tic = py_gettime(); \n \n    { \n         \n \n        double dt = f.dt; \n        double Nt = f.Nt; \n \n        for (n = 0; n < Nt; ++n) { \n \n             \n \n#pragma omp parallel for \n            for (i = 0; i < nx; ++i) { \n                for (j = 0; j < ny; ++j) { \n                    P(i, j) += \n                        dt / f.u.dx * (U(i + 1, j) - U(i, j)) + \n                        dt / f.v.dy * (V(i, j + 1) - V(i, j)); \n                } \n            } \n \n             \n \n#pragma omp parallel for \n            for (i = 1; i < nx; ++i) { \n                for (j = 0; j < ny; ++j) { \n                    U(i, j) += dt / f.p.dx * (P(i, j) - P(i - 1, j)); \n                } \n            } \n \n#pragma omp parallel for \n            for (i = 0; i < nx; ++i) \n                 \n \n                for (j = 1; j < ny; ++j) \n                    V(i, j) += dt / f.p.dy * (P(i, j) - P(i, j - 1)); \n        } \n    } \n \n    toc = py_gettime(); \n    printf(\"Elapsed: %f seconds\\n\", toc - tic); \n \n     \n \n    if (write) \n        py_write_to_disk(f.p, outfile); \n    free(part); \n    py_free_acoustic_field(f); \n \n    return EXIT_SUCCESS; \n} ", "pred": " \nint main(int argc, char *argv[]) \n{ \n     \n \n    double x[] = { 0, 1 }; \n    double y[] = { 0, 1 }; \n    double cfl = 0.99 / sqrt(2);         \n \n    double T = 0.3; \n    double c = 1; \n    long nx = 32; \n    long ny = 32; \n    struct py_field f; \n    char outfile[STR_SIZE] = \"yee_naive_omp.tsv\"; \n    int write = 1; \n    long threads = 4; \n    struct py_cell_partition *part; \n \n     \n \n    py_parse_cmdline(&nx, &threads, outfile, &write, argc, argv); \n    ny = nx;                     \n \n    omp_set_num_threads(threads); \n    printf(\"Domain: %li x %li\\n\", nx, ny); \n    printf(\"OpenMP threads: %li\\n\", threads); \n \n     \n \n    f = py_init_acoustic_field(nx, ny, x, y); \n    py_apply_func(&f.p, py_gauss2d);     \n \n    py_set_boundary(&f); \n \n     \n \n    f.dt = cfl * f.p.dx / c; \n    f.Nt = T / f.dt; \n \n     \n \n    part = py_partition_grid(threads, nx); \n \n     \n \n    double *p = f.p.value; \n    double *u = f.u.value; \n    double *v = f.v.value; \n \n     \n \n    long n, i, j; \n    double tic, toc; \n    tic = py_gettime(); \n \n    { \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \nstatic void \norderInsertionMarkers(InsertionMarker ** insMarkers, \n\t\t      IDnum * markerCounters, RoadMapArray * rdmaps) \n{ \n\tIDnum sequenceIndex; \n\tIDnum sequenceCounter = rdmaps->length; \n \n\tvelvetLog(\"Ordering insertion markers\\n\"); \n #pragma omp parallel for \n\tfor (sequenceIndex = 1; sequenceIndex <= sequenceCounter; \n\t     sequenceIndex++) { \n\t\tqsort(insMarkers[sequenceIndex], \n\t\t      markerCounters[sequenceIndex], \n\t\t      sizeof(InsertionMarker), compareInsertionMarkers); \n\t} \n} ", "pred": " \nstatic void \norderInsertionMarkers(InsertionMarker ** insMarkers, \n\t\t      IDnum * markerCounters, RoadMapArray * rdmaps) \n{ \n\tIDnum sequenceIndex; \n\tIDnum sequenceCounter = rdmaps->length; \n \n\tvelvetLog(\"Ordering insertion markers\\n\"); \n #pragma omp parallel for \n\tfor (sequenceIndex = 1; sequenceIndex <= sequenceCounter; \n\t     sequenceIndex++) { \n\t\tqsort(insMarkers[sequenceIndex], \n\t\t      markerCounters[sequenceIndex], \n\t\t      sizeof(InsertionMarker), compareInsertionMarkers); \n\t} \n} "}
{"label": " \nstatic PyObject *py_gibbs_ibm_initialize_parallel( \n        PyObject *self, PyObject *args) { \n \n    PyObject *eee, *fff, *counts_idx_arrays, *params; \n    PyArrayObject *seed_array; \n    unsigned long e_voc_size, f_voc_size; \n    double lexical_alpha, null_alpha; \n    int randomize; \n \n    if(!PyArg_ParseTuple(args, \"OOOOkkddOp\", \n                         &params, &eee, &fff, &counts_idx_arrays, \n                         &e_voc_size, &f_voc_size, \n                         &lexical_alpha, &null_alpha, \n                         &seed_array, &randomize)) \n        return NULL; \n \n    const size_t n_sents = PyTuple_Size(eee); \n    const size_t n_samplers = PyTuple_Size(params); \n \n    PRNG_SEED_t *seed = (PRNG_SEED_t*) PyArray_GETPTR1(seed_array, 0); \n    PRNG_SEED_t local_seeds[n_samplers]; \n    for (size_t sampler=0; sampler<n_samplers; sampler++) \n        local_seeds[sampler] = prng_next(*seed + 1 + sampler); \n    *seed = prng_next(*seed); \n \n#pragma omp parallel for \n    for (size_t sampler=0; sampler<n_samplers; sampler++) { \n        PRNG_SEED_t seed_cache = local_seeds[sampler]; \n \n        PyObject *sampler_params = PyTuple_GET_ITEM(params, sampler); \n \n        PyObject *aaa = PyTuple_GET_ITEM(sampler_params, 0); \n        PyArrayObject *counts_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 1); \n        PyArrayObject *counts_sum_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 2); \n        PyArrayObject *jump_counts_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 3); \n        PyArrayObject *fert_counts_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 4); \n \n        COUNT_t *counts = (COUNT_t*) PyArray_GETPTR1(counts_array, 0); \n        COUNT_t *counts_sum = (COUNT_t*) PyArray_GETPTR1(counts_sum_array, 0); \n        COUNT_t *jump_counts = ((PyObject*)jump_counts_array == Py_None) \n           ? NULL \n            : PyArray_GETPTR1(jump_counts_array, 0); \n        COUNT_t *fert_counts = ((PyObject*)fert_counts_array == Py_None) \n           ? NULL \n            : PyArray_GETPTR1(fert_counts_array, 0); \n \n        const size_t counts_size = PyArray_DIM(counts_array, 0); \n \n        for (size_t i=0; i<f_voc_size; i++) \n            counts[i] = null_alpha; \n        for (size_t i=f_voc_size; i<counts_size; i++) \n            counts[i] = lexical_alpha; \n \n        counts_sum[0] = null_alpha*(COUNT_t)f_voc_size; \n        for (size_t i=1; i<e_voc_size; i++) \n            counts_sum[i] = lexical_alpha*(COUNT_t)f_voc_size; \n \n        for (size_t sent=0; sent<n_sents; sent++) { \n            PyArrayObject *ee_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(eee, sent); \n            PyArrayObject *ff_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(fff, sent); \n            const size_t ee_len = (size_t) PyArray_DIM(ee_array, 0); \n            const size_t ff_len = (size_t) PyArray_DIM(ff_array, 0); \n \n            if (ee_len == 0 || ff_len == 0) continue; \n \n            PyArrayObject *aa_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(aaa, sent); \n            PyArrayObject *counts_idx_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(counts_idx_arrays, sent); \n \n            const TOKEN_t *ee = (const TOKEN_t*) PyArray_GETPTR1(ee_array, 0); \n            const TOKEN_t *ff = (const TOKEN_t*) PyArray_GETPTR1(ff_array, 0); \n            LINK_t *aa = (LINK_t*) PyArray_GETPTR1(aa_array, 0); \n            const INDEX_t *counts_idx = (const INDEX_t*) PyArray_GETPTR1( \n                counts_idx_array, 0); \n \n            int aa_jm1 = -1; \n            if (randomize) { \n                for (size_t j=0; j<ff_len; j++) { \n                    if (prng_next_count(&seed_cache) < 0.1) { \n                        a", "pred": " \nstatic PyObject *py_gibbs_ibm_initialize_parallel( \n        PyObject *self, PyObject *args) { \n \n    PyObject *eee, *fff, *counts_idx_arrays, *params; \n    PyArrayObject *seed_array; \n    unsigned long e_voc_size, f_voc_size; \n    double lexical_alpha, null_alpha; \n    int randomize; \n \n    if(!PyArg_ParseTuple(args, \"OOOOkkddOp\", \n                         &params, &eee, &fff, &counts_idx_arrays, \n                         &e_voc_size, &f_voc_size, \n                         &lexical_alpha, &null_alpha, \n                         &seed_array, &randomize)) \n        return NULL; \n \n    const size_t n_sents = PyTuple_Size(eee); \n    const size_t n_samplers = PyTuple_Size(params); \n \n    PRNG_SEED_t *seed = (PRNG_SEED_t*) PyArray_GETPTR1(seed_array, 0); \n    PRNG_SEED_t local_seeds[n_samplers]; \n    for (size_t sampler=0; sampler<n_samplers; sampler++) \n        local_seeds[sampler] = prng_next(*seed + 1 + sampler); \n    *seed = prng_next(*seed); \n \n#pragma omp parallel for \n    for (size_t sampler=0; sampler<n_samplers; sampler++) { \n        PRNG_SEED_t seed_cache = local_seeds[sampler]; \n \n        PyObject *sampler_params = PyTuple_GET_ITEM(seed, 0);\\n            PyArray_DUP(seed_array, sampler_params);\\n        }\\n        PyArray_DUP(seed_array, sampler_params);\\n      }\\n      PyArray_DUP(seed_array, sampler_params);\\n    }\\n    PyArray_DUP(seed_array, sampler_params);\\n  }\\n}\\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n  \\n\\n"}
{"label": " \nint main(int argc, char *argv[]) { \n\tstruct A sum[10]; \n\tfor (int32_t i = 0; i < 10; i++) { \n\t\tsum[i].x = 0; \n\t\tsum[i].y = 1; \n\t} \n #pragma omp parallel \n\t{ \n  #pragma omp for reduction(my_add : sum) \n\t\tfor (int32_t i = 0; i < 10; i++) sum[i].x += sum[i].y; \n\t} \n\tfor (int32_t i = 0; i < 10; i++) { \n\t\tassert(sum[i].x == 1); \n\t} \n} ", "pred": " \nint main(int argc, char *argv[]) { \n\tstruct A sum[10]; \n\tfor (int32_t i = 0; i < 10; i++) { \n\t\tsum[i].x = 0; \n\t\tsum[i].y = 1; \n\t} \n #pragma omp parallel \n\t{ \n  #pragma omp for reduction(my_add : sum) \n\t\tfor (int32_t i = 0; i < 10; i++) sum[i].x += sum[i].y; \n\t} \n\tfor (int32_t i = 0; i < 10; i++) { \n\t\tassert(sum[i].x == 1); \n\t} \n} "}
{"label": " \nvoid LLG_evolve(double *mag, double *mag_new, double dt) { \n    int i, j, n; \n#pragma omp parallel default(none) private(i,j,n) shared(Nx,Ny,bapp,mag,mag_new,dt,alpha,jx,jy) \n\t{ \n#pragma omp for schedule(static)     \n\tfor(i=1;i<=Nx;i++) \n\t\tfor(j=1;j<=Ny;j++) { \n \n\t\t\tdouble beff[3] = {0., 0., bapp}; \n\t\t\tdouble magxbeff[3], magxmagxbeff[3], rhs[3]; \n\t\t\t \n\t\t\tadd_exchange(mag, i, j, beff);\t\t \n \n \n \n \n \n \n \n\t\t\t \n\t\t\t \n \n\t\t\t \n \n\t\t\tadd_DMI_renorm_J0value(mag, i, j, beff); \n\t\t\t \n\t\t\tcross(&mag[ind(i,j)], beff, magxbeff); \n\t\t\tcross(&mag[ind(i,j)], magxbeff, magxmagxbeff); \n \n\t\t\tdouble tsst[3], magxtsst[3]; \n\t\t\t \n\t\t\tsst_torque(mag, i, j, jx, jy, tsst); \n \n \n \n \n\t\t\t \n\t\t\tcross(&mag[ind(i,j)],tsst,magxtsst); \n \n\t\t\tfor(n=0;n<3;n++) \n\t\t\t\trhs[n] = - magxbeff[n] - alpha*magxmagxbeff[n] + tsst[n] + alpha*magxtsst[n]; \n \n\t\t\tfor(n=0;n<3;n++) \n\t\t\t\tmag_new[ind(i,j)+n] = mag[ind(i,j)+n] + dt*rhs[n]; \n\t\t} \n    } \n} ", "pred": " \nvoid LLG_evolve(double *mag, double *mag_new, double dt) { \n    int i, j, n; \n#pragma omp parallel default(none) private(i,j,n) shared(Nx,Ny,bapp,mag,mag_new,dt,alpha,jx,jy) \n\t{ \n#pragma omp for schedule(static)     \n\tfor(i=1;i<=Nx;i++) \n\t\tfor(j=1;j<=Ny;j++) { \n \n\t\t\tdouble beff[3] = {0., 0., bapp}; \n\t\t\tdouble magxbeff[3], magxmagxbeff[3], rhs[3]; \n\t\t\t \n\t\t\tadd_exchange(mag, i, j, beff);\t\t \n \n \n \n \n \n \n \n\t\t\t \n\t\t\t \n \n\t\t\t \n \n\t\t\tadd_DMI_renorm_J0value(mag, i, j, beff); \n\t\t\t \n\t\t\tcross(&mag[ind(i,j)], beff, magxbeff); \n\t\t\tcross(&mag[ind(i,j)], magxbeff, magxmagxbeff); \n \n\t\t\tdouble tsst[3], magxtsst[3]; \n\t\t\t \n\t\t\tsst_torque(mag, i, j, jx, jy, tsst); \n \n \n \n \n\t\t\t \n\t\t\tcross(&mag[ind(i,j)],tsst,magxtsst); \n \n\t\t\tfor(n=0;n<3;n++) \n\t\t\t\trhs[n] = - magxbeff[n] - alpha*magxmagxbeff[n] + tsst[n] + alpha*magxtsst[n]; \n \n\t\t\tfor(n=0;n<3;n++) \n\t\t\t\tmag_new[ind(i,j)+n] = mag[ind(i,j)+n] + dt*rhs[n]; \n\t\t} \n    } \n} "}
{"label": " \nstatic void blur_line_z(float *buf, const int offset1, const int offset2, const int offset3, const int size1, \n                        const int size2, const int size3) \n{ \n  const float w1 = 4.f / 16.f; \n  const float w2 = 2.f / 16.f; \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(size1, size2, size3, offset1, offset2, offset3, w1, w2, buf)      collapse(2) \n  for(int k = 0; k < size1; k++) \n  { \n    for(int j = 0; j < size2; j++) \n    { \n      size_t index = (size_t)k * offset1 + j * offset2; \n      float tmp1 = buf[index]; \n      buf[index] = w1 * buf[index + offset3] + w2 * buf[index + 2 * offset3]; \n \n       \n \n \n      float tmp2 = buf[index + offset3]; \n      buf[index + offset3] = w1 * (buf[index + 2 * offset3] - tmp1) + w2 * buf[index + 3 * offset3]; \n \n       \n \n \n      for(int i = 2; i < size3 - 2; i++) \n      { \n        const float tmp3 = buf[index + i * offset3]; \n        buf[index + i * offset3] = +w1 * (buf[index + (i + 1) * offset3] - tmp2) + w2 * (buf[index + (i + 2) * offset3] - tmp1); \n        tmp1 = tmp2; \n        tmp2 = tmp3; \n      } \n \n      index += (size3 - 2) * offset3; \n      const float tmp3 = buf[index]; \n      buf[index] = w1 * (buf[index + offset3] - tmp2) - w2 * tmp1; \n      index += offset3; \n      buf[index] = -w1 * tmp3 - w2 * tmp2; \n    } \n  } \n} ", "pred": " \nstatic void blur_line_z(float *buf, const int offset1, const int offset2, const int offset3, const int size1, \n                        const int size2, const int size3) \n{ \n  const float w1 = 4.f / 16.f; \n  const float w2 = 2.f / 16.f; \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(size1, size2, size3, offset1, offset2, offset3, w1, w2, buf)      collapse(2) \n  for(int k = 0; k < size1; k++) \n  { \n    for(int j = 0; j < size2; j++) \n    { \n      size_t index = (size_t)k * offset1 + j * offset2; \n      float tmp1 = buf[index]; \n      buf[index] = w1 * buf[index + offset3] + w2 * buf[index + 2 * offset3]; \n \n       \n \n \n      float tmp2 = buf[index + offset3]; \n      buf[index + offset3] = w1 * (buf[index + 2 * offset3] - tmp1) + w2 * buf[index + 3 * offset3]; \n \n       \n \n \n      for(int i = 2; i < size3 - 2; i++) \n      { \n        const float tmp3 = buf[index + i * offset3]; \n        buf[index + i * offset3] = +w1 * (buf[index + (i + 1) * offset3] - tmp2) + w2 * (buf[index + (i + 2) * offset3] - tmp1); \n        tmp1 = tmp2; \n        tmp2 = tmp3; \n      } \n \n      index += (size3 - 2) * offset3; \n      const float tmp3 = buf[index]; \n      buf[index] = w1 * (buf[index + offset3] - tmp2);                                                          "}
{"label": " \nint main(int argc, char* argv[])  \n{ \n     \n \n    MPI_Init(&argc,&argv); \n    int size, rank; \n    int tstart,tstop; \n \n    MPI_Comm_rank(MPI_COMM_WORLD,&rank); \n    MPI_Comm_size(MPI_COMM_WORLD,&size); \n \n     \n \n    if(rank == 0) {   \n\ttstart = MPI_Wtime();     \n    } \n \n     \n \n    int niter, vstatus, order, count, count1, count2, count3; \n    double tolerance; \n    float **rr, **rd; \n    int *updown; \n    bool newton, debug, fwdxini; \n    velocity2 vn;  \n     \n \n \n    int nx, nt, ns, nh, nc, nxc, is, ih, ix, ic; \n    float **rfl, **rgd, **crv, **dip, *trace, *trace2; \n    float **time, **ampl, **delt, freq, theta, ava, amp, obl; \n    float slow, dx, x0, dt, t0, ds, s0, dh, h0, r0; \n    const char *type, *type2; \n    bool twod, verb, adj, lin, cmp, absoff; \n    surface inc, ref; \n    velocity vel, vel2; \n    ktable ts, tg, **tss, **tgs; \n    sf_file data, refl, curv, modl, vti; \n\t \n    sf_init(argc,argv); \n\t \n    if (!sf_getbool(\"newton\",&newton)) newton=true; \n     \n \n\t \n\t \n    if (!sf_getbool(\"lin\",&lin)) lin=false; \n     \n \n\t \n    if (lin) { \n\tif (!sf_getbool(\"adj\",&adj)) adj=false; \n\t \n \n\t\t \n\tif (adj) { \n\t    modl = sf_input(\"input\"); \n\t    data = sf_output(\"output\"); \n\t} else { \n\t    data = sf_input(\"input\"); \n\t    modl = sf_output(\"output\"); \n\t} \n\tcurv = sf_input(\"curv\"); \n    } else { \n\tadj = false; \n\tcurv = sf_input(\"input\"); \n\tmodl = sf_output(\"output\"); \n\tdata = NULL; \n    } \n     \n    if (SF_FLOAT!= sf_gettype(curv)) sf_error(\"Need float input\"); \n    if (!sf_histint  (curv,\"n1\",&nx)) sf_error(\"No n1= in input\"); \n    if (!sf_histfloat(curv,\"d1\",&dx)) sf_error(\"No d1= in input\"); \n    if (!sf_histfloat(curv,\"o1\",&x0)) sf_error(\"No o1= in input\"); \n    if (!sf_histint  (curv,\"n2\",&nc)) nc=1;  \n \n    nxc = nx*nc; \n     \n    if (!sf_getbool(\"absoff\",&absoff)) absoff=false; \n     \n \n\t \n     \n \n     \n    if (adj) { \n\tif (!sf_histint(modl,\"n1\",&nt)) sf_error(\"Need nt=\"); \n\tif (!sf_histfloat(modl,\"d1\",&dt)) dt=0.004; \n\tif (!sf_histfloat(modl,\"o1\",&t0)) t0=0.; \n\t\t \n\t\t \n\t \n \n\t\t \n\tif (!sf_histint(modl,\"n3\",&ns)) ns=nx; \n\tif (!sf_histfloat(modl,\"o3\",&s0)) s0=x0; \n\tif (!sf_histfloat(modl,\"d3\",&ds)) ds=dx; \n\t\t \n\t \n \n\t\t \n\tif (!sf_histint  (modl,\"n2\",&nh)) nh=nx; \n\tif (!sf_histfloat(modl,\"o2\",&h0)) h0=0.; \n\tif (!sf_histfloat(modl,\"d2\",&dh)) dh=dx; \n\t\t \n\t\t \n\tsf_putint(data,\"n1\",nx); \n\tsf_putfloat(data,\"d1\",dx); \n\tsf_putfloat(data,\"o1\",x0); \n\tsf_putint(data,\"n2\",nc); \n\tsf_putint(data,\"n3\",1); \n    } else { \n\tif (!sf_getint(\"nt\",&nt)) sf_error(\"Need nt=\"); \n\t \n \n\tif (!sf_getfloat(\"dt\",&dt)) dt=0.004; \n\t \n \n\tif (!sf_getfloat(\"t0\",&t0)) t0=0.; \n\t \n \n\t\t \n\tsf_putint  (modl,\"n1\",nt); \n\tsf_putfloat(modl,\"d1\",dt); \n\tsf_putfloat(modl,\"o1\",t0); \n\tsf_putstring(modl,\"label1\",\"Time\"); \n\tsf_putstring(modl,\"unit1\",\"s\"); \n\t\t \n\t \n \n\t\t \n\tif (!sf_getint(\"ns\",&ns)) ns=nx; \n\t \n \n\tif (!sf_getfloat(\"s0\",&s0)) s0=x0; \n\t \n \n\tif (!sf_getfloat(\"ds\",&ds)) ds=dx; \n\t \n \n\t\t \n\tsf_putfloat(modl,\"o3\",s0); \n\tsf_putfloat(modl,\"d3\",ds); \n\tsf_putint(modl,\"n3\",ns); \n\t\t \n\t \n \n\t\t \n\tif (!sf_getint  (\"nh\",&nh)) nh=nx; \n\t \n \n\tif (!sf_getfloat(\"h0\",&h0)) h0=0.; \n\t \n \n\tif (!sf_getfloat(\"dh\",&dh)) dh=dx; \n\t \n \n\t\t \n\tsf_putint  (modl,\"n2\",nh); \n\tsf_putfloat(modl,\"o2\",h0); \n\tsf_putfloat(modl,\"d2\",dh); \n    } \n\t \n    if (!sf_getbool(\"verb\",&verb)) verb=false; \n     \n \n\t \n    trace = sf_floatalloc(nt); \n    trace2 = sf_floatalloc(nt); \n\t \n     \n \n\t \n    crv = sf_floatalloc2(nx,nc); \n    rfl = sf_floatalloc2(nx,nc); \n    rgd = sf_floatalloc2(nx,nc); \n    dip = sf_floatalloc2(nx,nc); \n     \n    sf_floatread(crv[0],nxc,curv); \n     \n    if (!lin) { \n\t \n \n\t", "pred": " \nint main(int argc, char* argv[])  \n{ \n     \n \n    MPI_Init(&argc,&argv); \n    int size, rank; \n    int tstart,tstop; \n \n    MPI_Comm_rank(MPI_COMM_WORLD,&rank); \n    MPI_Comm_size(MPI_COMM_WORLD,&size); \n \n     \n \n    if(rank == 0) {   \n\ttstart = MPI_Wtime();     \n    } \n \n     \n \n    int niter, vstatus, order, count, count1, count2, count3; \n    double tolerance; \n    float **rr, **rd; \n    int *updown; \n    bool newton, debug, fwdxini; \n    velocity2 vn;  \n     \n \n \n    int nx, nt, ns, nh, nc, nxc, is, ih, ix, ic; \n    float **rfl, **rgd, **crv, **dip, *trace, *trace2; \n    float **time, **ampl, **delt, freq, theta, ava, amp, obl; \n    float slow, dx, x0, dt, t0, ds, s0, dh, h0, r0; \n    const char *type, *type2; \n    bool twod, verb, adj, lin, cmp, absoff; \n    surface inc, ref; \n    velocity vel, vel2; \n    ktable ts, tg, **tss, **tgs; \n    sf_file data, refl, curv, modl, vti; \n\t \n    sf_init(argc,argv); \n\t \n    if (!sf_getbool(\"newton\",&newton)) newton=true; \n     \n \n\t \n\t \n    if (!sf_getbool(\"lin\",&lin)) lin=false; \n     \n \n\t \n    if (lin) { \n\tif (!sf_getbool(argc,argv);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " \nstatic void CA_correct(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in2, \n                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int width = roi_in->width; \n  const int height = roi_in->height; \n  const uint32_t filters = piece->pipe->dsc.filters; \n  dt_iop_image_copy_by_size(out, in2, width, height, 1); \n  const float *const in = out; \n  const double cared = 0, cablue = 0; \n  const double caautostrength = 4; \n \n   \n \n  const int ts = 128; \n  const int tsh = ts / 2; \n   \n \n  const int v1 = ts, v2 = 2 * ts, v3 = 3 * ts, \n            v4 = 4 * ts;  \n \n \n   \n \n  for(int i = 0; i < 2; i++) \n    for(int j = 0; j < 2; j++) \n      if(FC(i, j, filters) == 3) \n      { \n        printf(\"CA correction supports only RGB Colour filter arrays\\n\"); \n        return; \n      } \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n  const gboolean autoCA = (cared == 0 && cablue == 0); \n   \n \n   \n \n   \n \n  float *Gtmp = (float(*))calloc((height) * (width), sizeof *Gtmp); \n \n   \n \n  float *RawDataTmp = (float *)malloc(sizeof(float) * height * width / 2 + 4); \n \n  float blockave[2][2] = { { 0, 0 }, { 0, 0 } }, blocksqave[2][2] = { { 0, 0 }, { 0, 0 } }, \n        blockdenom[2][2] = { { 0, 0 }, { 0, 0 } }, blockvar[2][2]; \n \n   \n \n  gboolean processpasstwo = TRUE; \n \n  const int border = 8; \n  const int border2 = 16; \n \n  const int vz1 = (height + border2) % (ts - border2) == 0? 1 : 0; \n  const int hz1 = (width + border2) % (ts - border2) == 0? 1 : 0; \n  const int vblsz = ceil((float)(height + border2) / (ts - border2) + 2 + vz1); \n  const int hblsz = ceil((float)(width + border2) / (ts - border2) + 2 + hz1); \n \n  char *buffer1 = (char *)calloc((size_t)vblsz * hblsz * (2 * 2 + 1), sizeof(float)); \n \n   \n \n  float *blockwt = (float *)buffer1; \n  float(*blockshifts)[2][2] = (float(*)[2][2])(buffer1 + (vblsz * hblsz * sizeof(float))); \n \n  double fitparams[2][2][16]; \n \n   \n \n  int polyord = 4, numpar = 16; \n \n  const float eps = 1e-5f, eps2 = 1e-10f;  \n \n \n#pragma omp parallel \n  { \n     \n \n \n     \n \n    int GRBdir[2][3]; \n \n    int shifthfloor[3], shiftvfloor[3], shifthceil[3], shiftvceil[3]; \n \n     \n \n    float coeff[2][3][2]; \n     \n \n    float CAshift[2][2]; \n     \n \n     \n \n    float shifthfrac[3], shiftvfrac[3]; \n     \n \n    float blockavethr[2][2] = { { 0, 0 }, { 0, 0 } }, blocksqavethr[2][2] = { { 0, 0 }, { 0, 0 } }, \n          blockdenomthr[2][2] = { { 0, 0 }, { 0, 0 } }; \n \n     \n \n    const size_t buffersize = sizeof(float) * 3 * ts * ts + 6 * sizeof(float) * ts * tsh + 8 * 64 + 63; \n    char *buffer = (char *)malloc(buffersize); \n    char *data = (char *)(((uintptr_t)buffer + (uintptr_t)63) / 64 * 64); \n \n     \n \n     \n \n \n     \n \n    float *rgb[3]; \n    rgb[0] = (float(*))data; \n    rgb[1] = (float(*))(data + 1 * sizeof(float) * ts * ts + 1 * 64); \n    rgb[2] = (float(*))(data + 2 * sizeof(float) * ts * ts + 2 * 64); \n \n     \n \n    float *rbhpfh = (float(*))(data + 3 * sizeof(float) * ts * ts + 3 * 64); \n     \n \n    float *rbhpfv = (float(*))(data + 3 * sizeof(float) * ts * ts + sizeof(float) * ts * tsh + 4 * 64); \n     \n \n    float *rblpfh = (float(*))(data + 4 * sizeof(float) * ts * ts + 5 * 64); \n     \n \n    float *rblpfv = (float(*))(data + 4 * sizeof(float) * ts * ts + sizeof(float) * ts * tsh + 6 * 64); \n     \n \n    float *grblpfh = (float(*))(data + 5 * sizeof(float) * ts * ts + 7 * 64); \n     \n \n    float *grblpfv = (float(*))(data + 5 * sizeof(float) * ts * ts + sizeof(float) * ts * tsh + 8 * 64); \n     \n \n    float *grbdiff = rbhpfh;  \n \n     \n \n    float *gshift = rbhpfv;  \n \n \n \n    if(autoCA) \n    { \n \n \n#pragma omp for collapse(2) schedule(static) nowait \n      for(int top = -border; top < height; top += ts - border2) \n        for(int left = -border; left < width; left += ts - border2) \n        { \n          memset(buffer, 0, buffersize); \n          const int vblock = ((top + border) / (ts - border2)) + 1; \n          const int hblock = ((left + border) / (ts - border2)) + 1; \n          const int bottom = MIN(top + ts, height + border); \n          const int right = MIN(left + ts, width + border); \n ", "pred": " \nstatic void CA_correct(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in2, \n                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int width = roi_in->width; \n  const int height = roi_in->height; \n  const uint32_t filters = piece->pipe->dsc.filters; \n  dt_iop_image_copy_by_size(out, in2, width, height, 1); \n  const float *const in = out; \n  const double cared = 0, cablue = 0; \n  const double caautostrength = 4; \n \n   \n \n  const int ts = 128; \n  const int tsh = ts / 2; \n   \n \n  const int v1 = ts, v2 = 2 * ts, v3 = 3 * ts, \n            v4 = 4 * ts;  \n \n \n   \n \n  for(int i = 0; i < 2; i++) \n    for(int j = 0; j < 2; j++) \n      if(FC(i, j, filters) == 3) \n      { \n        printf(\"CA correction supports only RGB Colour filter arrays\\n\"); \n        return; \n      } \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n  const gboolean autoCA = (cared == 0 && cablue == 0); \n   \n \n   \n \n   \n \n  float *Gtmp = (float(*))calloc((height) * (width), sizeof *Gtmp); \n \n   \n \n  float *RawDataTmp = (float *)malloc(sizeof(float) * height * width / 2 + 4); \n \n  float blockave[2][2] = { { 0, 0 }, { 0, 0 } }, blocksqave[2][2] = { { 0, 0 }, { 0, 0 } );\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "}
{"label": " \nvoid THNN_(unfolded_acc)( \n          THTensor *finput, \n          THTensor *input, \n          int kW, \n          int kH, \n          int dW, \n          int dH, \n          int padW, \n          int padH, \n          int nInputPlane, \n          int inputWidth, \n          int inputHeight, \n          int outputWidth, \n          int outputHeight) \n{ \n  LONG_PTR nip; \n  size_t nip; \n \n  real *input_data = THTensor_(data)(input); \n  real *finput_data = THTensor_(data)(finput); \n \n#pragma omp parallel for private(nip) \n  for(nip = 0; nip < nInputPlane; nip++) \n  { \n    size_t kw, kh, y, x; \n    long long ix = 0, iy = 0; \n    for(kh = 0; kh < kH; kh++) \n    { \n      for(kw = 0; kw < kW; kw++) \n      { \n        real *src = finput_data + nip*(kH*kW*outputHeight*outputWidth) + kh*(kW*outputHeight*outputWidth) + kw*(outputHeight*outputWidth); \n        real *dst = input_data + nip*(inputHeight*inputWidth); \n        if (padW > 0 || padH > 0) { \n          size_t lpad,rpad; \n          for(y = 0; y < outputHeight; y++) { \n            iy = (long long)(y*dH - padH + kh); \n            if (iy < 0 || iy >= inputHeight) { \n            } else { \n              if (dW==1){ \n                 ix = (long long)(0 - padW + kw); \n                 lpad = fmaxf(0,(int)(padW-kw)); \n                 rpad = fmaxf(0,(int)(padW-(kW-kw-1))); \n                 THVector_(add)(dst+(size_t)(iy*inputWidth+ix+lpad), src+(size_t)(y*outputWidth+lpad), 1, outputWidth - lpad - rpad);  \n \n              } \n              else{ \n                for (x=0; x<outputWidth; x++){ \n                   ix = (long long)(x*dW - padW + kw); \n                   if (ix < 0 || ix >= inputWidth){ \n                   }else \n                     THVector_(add)(dst+(size_t)(iy*inputWidth+ix), src+(size_t)(y*outputWidth+x), 1, 1); \n                } \n              } \n            } \n          } \n        } else { \n          for(y = 0; y < outputHeight; y++) { \n            iy = (long long)(y*dH + kh); \n            ix = (long long)(0 + kw); \n            if (dW == 1 ) \n               THVector_(add)(dst+(size_t)(iy*inputWidth+ix), src+(size_t)(y*outputWidth), 1, outputWidth);  \n \n            else{ \n              for(x = 0; x < outputWidth; x++) \n                THVector_(add)(dst+(size_t)(iy*inputWidth+ix+x*dW), src+(size_t)(y*outputWidth+x), 1, 1); \n            } \n          } \n        } \n      } \n    } \n  } \n} ", "pred": " \nvoid THNN_(unfolded_acc)( \n          THTensor *finput, \n          THTensor *input, \n          int kW, \n          int kH, \n          int dW, \n          int dH, \n          int padW, \n          int padH, \n          int nInputPlane, \n          int inputWidth, \n          int inputHeight, \n          int outputWidth, \n          int outputHeight) \n{ \n  LONG_PTR nip; \n  size_t nip; \n \n  real *input_data = THTensor_(data)(input); \n  real *finput_data = THTensor_(data)(finput); \n \n#pragma omp parallel for private(nip) \n  for(nip = 0; nip < nInputPlane; nip++) \n  { \n    size_t kw, kh, y, x; \n    long long ix = 0, iy = 0; \n    for(kh = 0; kh < kH; kh++) \n    { \n      for(kw = 0; kw < kW; kw++) \n      { \n        real *src = finput_data + nip*(kH*kW*outputHeight*outputWidth) + kh*(kW*outputHeight*outputWidth) + kw*(outputHeight*outputWidth); \n        real *dst = input_data + nip*(inputHeight*inputWidth); \n        if (padW > 0 || padH > 0) { \n          size_t lpad,rpad; \n          for(y = 0; y < outputHeight; y++) { \n            iy = (long long)(y*dH - padH + kh); \n            if (iy < 0) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "}
{"label": " \nstatic int \nf(double t, const double y[], double dydt[], void *vparams) { \n  fparams *p = (fparams *)vparams; \n  size_t i; \n  int status = GSL_SUCCESS; \n  int overall_status = GSL_SUCCESS; \n \n  memset(dydt, 0, body_size_to_vector_size(p->nbodies)*sizeof(double)); \n   \n#pragma omp parallel for \n  for (i = 0; i < p->nbodies; i++) { \n    size_t j; \n    body bi; \n    central_body bc; \n    double rhs[BODY_VECTOR_SIZE]; \n    double dsunomega[3]; \n \n    vector_to_body(y+i*BODY_VECTOR_SIZE+CENTRAL_BODY_VECTOR_SIZE, &bi); \n    vector_to_central_body(y, &bc); \n \n    for (j = 0; j < p->nbodies; j++) { \n      if (j!= i) { \n        body bj; \n        double rhs[BODY_VECTOR_SIZE]; \n        size_t k; \n        int status; \n \n        vector_to_body(y+j*BODY_VECTOR_SIZE + CENTRAL_BODY_VECTOR_SIZE, &bj); \n         \n        status = average_rhs(p->eps, &bi, &bj, p->epsquad, rhs); \n \n        if (status!= GSL_SUCCESS) { \n          overall_status = GSL_EBADFUNC; \n        } \n \n        for (k = 0; k < BODY_VECTOR_SIZE; k++) { \n          dydt[CENTRAL_BODY_VECTOR_SIZE + i*BODY_VECTOR_SIZE+k] += rhs[k]; \n        } \n      } \n    } \n \n     \n \n    memset(rhs, 0, BODY_VECTOR_SIZE*sizeof(double)); \n    memset(dsunomega, 0, 3*sizeof(double)); \n \n    tidal_rhs(&bi, &bc, rhs, dsunomega); \n \n    for (j = 0; j < BODY_VECTOR_SIZE; j++) { \n      if (isnan(rhs[j])) overall_status = GSL_EBADFUNC; \n    } \n \n    for (j = 0; j < 3; j++) { \n      if (isnan(dsunomega[j])) overall_status = GSL_EBADFUNC; \n    } \n \n    for (j = 0; j < 3; j++) { \n      dydt[CENTRAL_BODY_SPIN_INDEX + j] += dsunomega[j]; \n    } \n    for (j = 0; j < BODY_VECTOR_SIZE; j++) { \n      dydt[CENTRAL_BODY_VECTOR_SIZE + i*BODY_VECTOR_SIZE + j] += rhs[j]; \n    } \n  } \n \n  return overall_status; \n} ", "pred": " \nstatic int \nf(double t, const double y[], double dydt[], void *vparams) { \n  fparams *p = (fparams *)vparams; \n  size_t i; \n  int status = GSL_SUCCESS; \n  int overall_status = GSL_SUCCESS; \n \n  memset(dydt, 0, body_size_to_vector_size(p->nbodies)*sizeof(double)); \n   \n#pragma omp parallel for \n  for (i = 0; i < p->nbodies; i++) { \n    size_t j; \n    body bi; \n    central_body bc; \n    double rhs[BODY_VECTOR_SIZE]; \n    double dsunomega[3]; \n \n    vector_to_body(y+i*BODY_VECTOR_SIZE+CENTRAL_BODY_VECTOR_SIZE, &bi); \n    vector_to_central_body(y, &bc); \n \n    for (j = 0; j < p->nbodies; j++) { \n      if (j!= i) { \n        body bj; \n        double rhs[BODY_VECTOR_SIZE]; \n        size_t k; \n        int status; \n \n        vector_to_body(y+j*BODY_VECTOR_SIZE + CENTRAL_BODY_VECTOR_SIZE, &bj); \n         \n        status = average_rhs(p->eps, &bi, &bj, p->epsquad, rhs); \n \n        if (status!= GSL_SUCCESS) { \n          overall_status = GSL_EBADFUNC; \n        } \n \n        for (k = 0; k < BODY_VECTOR_SIZE; k++) { \n          dydt[CENTRAL_BODY_VECTOR_SIZE + i*BODY_VECTOR_SIZE+k] += rhs[k]; \n        } \n      }                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nstatic int nn_(SpatialConvolution_accGradParameters)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor *gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  real scale = luaL_optnumber(L, 4, 1); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n  int nOutputPlane = luaT_getfieldcheckint(L, 1, \"nOutputPlane\"); \n \n  THTensor *gradWeight = luaT_getfieldcheckudata(L, 1, \"gradWeight\", torch_Tensor); \n  THTensor *gradBias = luaT_getfieldcheckudata(L, 1, \"gradBias\", torch_Tensor); \n \n  int dimw = 2; \n  int dimh = 1; \n \n  real *gradBias_data; \n  real *gradOutput_data; \n  long noutSlice; \n \n  THArgCheck( nOutputPlane == gradOutput->size[input->nDimension == 4? 1 : 0], 1, \"Number of output features is not equal to nOutputPlane\" ); \n \n  if (input->nDimension == 4) \n  { \n    dimw++; \n    dimh++; \n  } \n \n   \n \n  gradBias_data = THTensor_(data)(gradBias); \n  gradOutput_data = THTensor_(data)(gradOutput); \n  noutSlice = gradOutput->size[dimh]*gradOutput->size[dimw]; \n   \n \n \n  if (input->nDimension == 3) \n  { \n    long k; \n#pragma omp parallel for private(k) \n    for(k = 0; k < nOutputPlane; k++) \n    { \n       \n \n      real *ptr_gradOutput = gradOutput_data + k*noutSlice; \n      long l; \n      for(l = 0; l < noutSlice; l++) \n        gradBias_data[k] += scale*ptr_gradOutput[l]; \n    } \n     \n     \n \n    THTensor_(conv2DRevger)(gradWeight, 1.0, scale, input, gradOutput, dH, dW); \n  } \n  else \n  { \n    long k; \n#pragma omp parallel for private(k) \n    for(k = 0; k < nOutputPlane; k++) \n    { \n      long p; \n      for(p = 0; p < input->size[0]; p++) \n      {  \n         \n \n        real *ptr_gradOutput = gradOutput_data + p*nOutputPlane*noutSlice + k*noutSlice; \n        long l; \n        for(l = 0; l < noutSlice; l++) \n          gradBias_data[k] += scale*ptr_gradOutput[l]; \n      } \n    } \n     \n \n    THTensor_(conv2DRevgerm)(gradWeight, 1.0, scale, input, gradOutput, dH, dW); \n  } \n  return 0; \n} ", "pred": " \nstatic int nn_(SpatialConvolution_accGradParameters)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor *gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  real scale = luaL_optnumber(L, 4, 1); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n  int nOutputPlane = luaT_getfieldcheckint(L, 1, \"nOutputPlane\"); \n \n  THTensor *gradWeight = luaT_getfieldcheckudata(L, 1, \"gradWeight\", torch_Tensor); \n  THTensor *gradBias = luaT_getfieldcheckudata(L, 1, \"gradBias\", torch_Tensor); \n \n  int dimw = 2; \n  int dimh = 1; \n \n  real *gradBias_data; \n  real *gradOutput_data; \n  long noutSlice; \n \n  THArgCheck( nOutputPlane == gradOutput->size[input->nDimension == 4? 1 : 0], 1, \"Number of output features is not equal to nOutputPlane\" ); \n \n  if (input->nDimension == 4) \n  { \n    dimw++; \n    dimh++; \n  } \n \n   \n \n  gradBias_data = THTensor_(data)(gradBias); \n  gradOutput_data = THTensor_(data)(gradOutput); \n  noutSlice = gradOutput->size[dimh]*gradOutput->size[dimw]; \n   \n \n \n  if (input->nDimension == 3) \n  { \n    long k; \n#pragma omp parallel for private(k) \n    for(k = 0; k < nOutputPlane; k++) \n    { \n       \n \n      real *ptr_gradOutput = gradOutput_data + k*noutSlice; \n      long l; \n      for(l = 0; l < noutSlice; l++) \n                                                                                                                                                                                                                                                                                                                                                                                   "}
{"label": " \nstatic int dt_circle_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                  dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start1 = dt_get_wtime(); \n  double start2 = start1; \n \n   \n \n  dt_masks_point_circle_t *circle = (dt_masks_point_circle_t *)(g_list_first(form->points)->data); \n  const int wi = piece->pipe->iwidth, hi = piece->pipe->iheight; \n  const float center[2] = { circle->center[0] * wi, circle->center[1] * hi }; \n  const float radius2 = circle->radius * MIN(wi, hi) * circle->radius * MIN(wi, hi); \n  const float total = (circle->radius + circle->border) * MIN(wi, hi); \n  const float total2 = total * total; \n \n   \n \n   \n \n  const int w = roi->width; \n  const int h = roi->height; \n  const int px = roi->x; \n  const int py = roi->y; \n  const float iscale = 1.0f / roi->scale; \n  const int grid = CLAMP((10.0f * roi->scale + 2.0f) / 3.0f, 1, 4);  \n \n  const int gw = (w + grid - 1) / grid + 1;   \n \n  const int gh = (h + grid - 1) / grid + 1;   \n \n \n   \n \n  memset(buffer, 0, (size_t)w * h * sizeof(float)); \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] circle init took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n   \n \n  const size_t circpts = dt_masks_roundup(MIN(360, 2 * M_PI * total2), 8); \n  float *circ = dt_alloc_align(64, circpts * 2 * sizeof(float)); \n  if(circ == NULL) return 0; \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(circpts, center, total)    shared(circ) \n#pragma omp parallel for shared(points) \n  for(int n = 0; n < circpts / 8; n++) \n  { \n    const float phi = (2.0f * M_PI * n) / circpts; \n    const float x = total * cos(phi); \n    const float y = total * sin(phi); \n    const float cx = center[0]; \n    const float cy = center[1]; \n    const int index_x = 2 * n * 8; \n    const int index_y = 2 * n * 8 + 1; \n     \n \n    circ[index_x] = cx + x; \n    circ[index_y] = cy + y; \n    circ[index_x + 2] = cx + x; \n    circ[index_y + 2] = cy - y; \n    circ[index_x + 4] = cx - x; \n    circ[index_y + 4] = cy + y; \n    circ[index_x + 6] = cx - x; \n    circ[index_y + 6] = cy - y; \n    circ[index_x + 8] = cx + y; \n    circ[index_y + 8] = cy + x; \n    circ[index_x + 10] = cx + y; \n    circ[index_y + 10] = cy - x; \n    circ[index_x + 12] = cx - y; \n    circ[index_y + 12] = cy + x; \n    circ[index_x + 14] = cx - y; \n    circ[index_y + 14] = cy - x; \n  } \n \n   \n \n  if(!dt_dev_distort_transform_plus(module->dev, piece->pipe, module->iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, circ, \n                                        circpts)) \n  { \n    dt_free_align(circ); \n    return 0; \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] circle outline took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n  float xmin = FLT_MAX, ymin = FLT_MAX, xmax = FLT_MIN, ymax = FLT_MIN; \n  for(int n = 0; n < circpts; n++) \n  { \n     \n \n    if(!(isnormal(circ[2 * n]) && isnormal(circ[2 * n + 1]))) continue; \n \n    xmin = MIN(xmin, circ[2 * n]); \n    xmax = MAX(xmax, circ[2 * n]); \n    ymin = MIN(ymin, circ[2 * n + 1]); \n    ymax = MAX(ymax, circ[2 * n + 1]); \n  } \n \n  printf(\"xmin %f, xmax %f, ymin %f, ymax %f\\n\", xmin, xmax, ymin, ymax); \n  printf(\"wi %d, hi %d, iscale %f\\n\", wi, hi, iscale); \n  printf(\"w %d, h %d, px %d, py %d\\n\", w, h, px, py); \n \n   \n \n  const int bbxm = CLAMP((int)floorf(xmin / iscale - px) / grid - 1, 0, gw - 1); \n  const int bbXM = CLAMP((int)ceilf(xmax / iscale - px) / grid + 2, 0, gw - 1); \n  const int bbym = CLAMP((int)floorf(ymin / iscale - py) / grid - 1, 0, gh - 1); \n  const int bbYM = CLAMP((int)ceilf(ymax / iscale - py) / grid + 2, 0, gh - 1); \n  const int bbw = bbXM - bbxm + 1; \n  const int bbh = bbYM - bbym + 1; \n \n  printf(\"bbxm %d, bbXM %d, bbym %d, bbYM %d\\n\", bbxm, bbXM, bbym, bbYM); \n  printf(\"gw %d, gh %d, bbw %d, bbh %d\\n\", gw, gh, bbw, bbh); \n \n  dt_free_align(circ); \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] circle bounding box took %0.04f sec\\n\", form->name, dt_get_w", "pred": " \nstatic int dt_circle_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                  dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start1 = dt_get_wtime(); \n  double start2 = start1; \n \n   \n \n  dt_masks_point_circle_t *circle = (dt_masks_point_circle_t *)(g_list_first(form->points)->data); \n  const int wi = piece->pipe->iwidth, hi = piece->pipe->iheight; \n  const float center[2] = { circle->center[0] * wi, circle->center[1] * hi }; \n  const float radius2 = circle->radius * MIN(wi, hi) * circle->radius * MIN(wi, hi); \n  const float total = (circle->radius + circle->border) * MIN(wi, hi); \n  const float total2 = total * total; \n \n   \n \n   \n \n  const int w = roi->width; \n  const int h = roi->height; \n  const int px = roi->x; \n  const int py = roi->y; \n  const float iscale = 1.0f / roi->scale; \n  const int grid = CLAMP((10.0f * roi->scale + 2.0f) / 3.0f, 1, 4);  \n \n  const int gw = (w + grid - 1) / grid + 1;   \n \n  const int gh = (h + grid - 1) / grid + 1;   \n \n \n   \n \n  memset(buffer, 0, (size_t)w * h * sizeof(float)); \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] circle init took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n   \n \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 32; \n  tile_size[1] = 32; \n  tile_size[2] = 16; \n  tile_size[3] = 2048; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,16);t1++) { \n    lbp=max(ceild(t1,2),ceild(32*t1-Nt+3,32)); \n    ubp=min(floord(Nt+Nz-4,32),floord(16*t1+Nz+13,32)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(32*t2-Nz-12,16)),t1);t3<=min(min(min(floord(Nt+Ny-4,16),floord(16*t1+Ny+29,16)),floord(32*t2+Ny+28,16)),floord(32*t1-32*t2+Nz+Ny+27,16));t3++) { \n        for (t4=max(max(max(0,ceild(t1-127,128)),ceild(32*t2-Nz-2044,2048)),ceild(16*t3-Ny-2044,2048));t4<=min(min(min(min(floord(Nt+Nx-4,2048),floord(16*t1+Nx+29,2048)),floord(32*t2+Nx+28,2048)),floord(16*t3+Nx+12,2048)),floord(32*t1-32*t2+Nz+Nx+27,2048));t4++) { \n          for (t5=max(max(max(max(max(0,16*t1),32*t1-32*t2+1),32*t2-Nz+2),16*t3-Ny+2),2048*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,16*t1+31),32*t2+30),16*t3+14),2048*t4+2046),32*t1-32*t2+Nz+29);t5++) { \n            for (t6=max(max(32*t2,t5+1),-32*t1+32*t2+2*t5-31);t6<=min(min(32*t2+31,-32*t1+32*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(16*t3,t5+1);t7<=min(16*t3+15", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *) tile_size, sizeof(int)*Nz);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": " \nvoid extractMatrix(float complex *matrix, float complex *packed) { \n\tint f; \n \n\textern int npol; \n\textern int nstation; \n\textern int nfrequency; \n \n     \n \n    omp_set_num_threads(4); \n    #pragma omp parallel private (f) \n    { \n    #pragma omp for \n\tfor (f = 0; f < nfrequency; f++) { \n        int i,j,pol1,pol2; \n\t\tfor (i = 0; i < nstation; i++) { \n\t\t\tfor (j = 0; j <= i; j++) { \n\t\t\t\tint k = f * (nstation + 1) * (nstation / 2) + i * (i + 1) / 2 + j; \n\t\t\t\tfor (pol1 = 0; pol1 < npol; pol1++) { \n\t\t\t\t\tfor (pol2 = 0; pol2 < npol; pol2++) { \n\t\t\t\t\t\tint index = (k * npol + pol1) * npol + pol2; \n\t\t\t\t\t\tmatrix[(((f * nstation + i) * nstation + j) * npol + pol1) * npol + pol2] = packed[index]; \n\t\t\t\t\t\tmatrix[(((f * nstation + j) * nstation + i) * npol + pol2) * npol + pol1] = conjf(packed[index]); \n\t\t\t\t\t \n \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t} \n    }    \n \n} ", "pred": " \nvoid extractMatrix(float complex *matrix, float complex *packed) { \n\tint f; \n \n\textern int npol; \n\textern int nstation; \n\textern int nfrequency; \n \n     \n \n    omp_set_num_threads(4); \n    #pragma omp parallel private (f) \n    { \n    #pragma omp for \n\tfor (f = 0; f < nfrequency; f++) { \n        int i,j,pol1,pol2; \n\t\tfor (i = 0; i < nstation; i++) { \n\t\t\tfor (j = 0; j <= i; j++) { \n\t\t\t\tint k = f * (nstation + 1) * (nstation / 2) + i * (i + 1) / 2 + j; \n\t\t\t\tfor (pol1 = 0; pol1 < npol; pol1++) { \n\t\t\t\t\tfor (pol2 = 0; pol2 < npol; pol2++) { \n\t\t\t\t\t\tint index = (k * npol + pol1) * npol + pol2; \n\t\t\t\t\t\tmatrix[(((f * nstation + i) * nstation + j) * npol + pol1) * npol + pol2] = packed[index]; \n\t\t\t\t\t\tmatrix[(((f * nstation + j) * nstation + i) * npol + pol2) * npol + pol1] = conjf(packed[index]); \n\t\t\t\t\t \n \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t} \n    }    \n \n} "}
{"label": " \nReal** cfd_baseline(const int numCell,const int numBox){ \n \n   \n \n  Real** old_boxes = malloc(sizeof(Real*)*numBox); \n  Real** new_boxes = malloc(sizeof(Real*)*numBox); \n \n   \n \n   \n \n   \n \n  int full_numCell = numCell+2*nGhost; \n  int full_numCell2 = full_numCell*full_numCell; \n  int full_numCell3 = full_numCell*full_numCell+full_numCell; \n  int totalCells = (numCell+2*nGhost)*(numCell+2*nGhost)*(numCell+2*nGhost); \n  int flux_totalSize = numCell*numCell*(numCell+1); \n   \n   \n \n  int idx; \n  for(idx=0;idx<numBox;idx++){ \n    old_boxes[idx] = malloc(sizeof(Real)*totalCells*numComp); \n    new_boxes[idx] = malloc(sizeof(Real)*totalCells*numComp); \n  } \n \n   \n \n \n#pragma omp parallel for default(shared)  private(idx)  \n  for(idx=0;idx < numBox;idx++){ \n    Real* old_box = old_boxes[idx]; \n    Real* new_box = new_boxes[idx]; \n    int ic,iz,iy,ix; \n \n    for(ic=0;ic<numComp;ic++){ \n      const Real phiOrigin = ic*compMultiplier; \n \n     \n \n     \n \n     \n \n     \n \n      for(iz=-nGhost;iz<(full_numCell-nGhost);iz++){ \n        for(iy=-nGhost;iy<(full_numCell-nGhost);iy++){ \n           \n \n          Real* oldp = GET_VAL_PTR(old_box,ic,iz,iy,-nGhost); \n          Real* newp = GET_VAL_PTR(new_box,ic,iz,iy,-nGhost); \n           \n \n          for(ix=-nGhost;ix<(full_numCell-nGhost);ix++){ \n            *oldp = phiOrigin + dx*((iz)+(iy)+(ix)); \n            *newp = phiOrigin + dx*((iz)+(iy)+(ix)); \n            oldp++; \n            newp++; \n            } \n          } \n      } \n    } \n  } \n \n   \n \n  double time_spent; \n  struct timeval  tv1, tv2; \n   \n   \n \n  int phi_comp_mult = ((numCell+2*nGhost)*(numCell+2*nGhost) \n                                   *(numCell+2*nGhost)); \n  const int phi_pencil_size = (numCell+2*nGhost); \n  const int flux_comp_mult = ((numCell)*(numCell)*(numCell+1)); \n \n   \n \n   \n \nprintf(\"Num Threads: %d\\n\",omp_get_max_threads()); \n  gettimeofday(&tv1, NULL); \n#pragma omp parallel for default(shared)  private(idx)  \n  for(idx=0;idx < numBox;idx++){ \n    Real* old_box = old_boxes[idx]; \n    Real* new_box = new_boxes[idx]; \n \n  int f_xu,f_yu,f_zu; \n  int flux_pencil_x; \n  int flux_pencil_y; \n    int iDir,ic,iz,iy,ix; \n    int phiOffset1,phiOffset2,fluxOffset1; \n     \n \n    Real* fluxCache = malloc(sizeof(Real)*numCell*numCell*(numCell+1)*numComp); \n     \n \n     \n \n    Real* velCache = malloc(sizeof(Real)*numCell*numCell*(numCell+1)); \n \n     \n \n    for(iDir=0;iDir<3;iDir++){ \n \n       \n \n      if(iDir == 0){ \n        f_zu = numCell; \n    f_yu = numCell; \n    f_xu = numCell+1; \n    flux_pencil_x = numCell+1; \n    flux_pencil_y = numCell; \n        phiOffset1 = 1; \n        phiOffset2 = 2; \n        fluxOffset1 = 1; \n      }else if(iDir == 1){ \n        f_zu = numCell; \n    f_yu = numCell+1; \n    f_xu = numCell; \n    flux_pencil_x = numCell; \n    flux_pencil_y = numCell+1; \n        phiOffset1 = phi_pencil_size; \n        phiOffset2 = phi_pencil_size*2; \n    fluxOffset1 = numCell; \n      }else if(iDir == 2){ \n        f_zu = numCell+1; \n    f_yu = numCell; \n    f_xu = numCell; \n    flux_pencil_x = numCell; \n    flux_pencil_y = numCell; \n        phiOffset1 = phi_pencil_size*phi_pencil_size; \n        phiOffset2 = phi_pencil_size*phi_pencil_size*2; \n    fluxOffset1 = numCell*numCell; \n      } \n \n \n       \n \n      for(ic=0;ic<numComp;ic++){ \n         \n \n        for(iz=0;iz<f_zu;iz++){ \n          for(iy=0;iy<f_yu;iy++){ \n            Real* phip = GET_VAL_PTR(old_box,ic,iz,iy,0);  \n            Real* fluxp = GET_FACE_VAL_PTR(iDir,fluxCache,ic,iz,iy,0); \n            for(ix=0;ix<f_xu;ix++){ \n              *fluxp = factor1* \n                       ((*(phip - phiOffset2)) + \n                 ", "pred": " \nReal** cfd_baseline(const int numCell,const int numBox){ \n \n   \n \n  Real** old_boxes = malloc(sizeof(Real*)*numBox); \n  Real** new_boxes = malloc(sizeof(Real*)*numBox); \n \n   \n \n   \n \n   \n \n  int full_numCell = numCell+2*nGhost; \n  int full_numCell2 = full_numCell*full_numCell; \n  int full_numCell3 = full_numCell*full_numCell+full_numCell; \n  int totalCells = (numCell+2*nGhost)*(numCell+2*nGhost)*(numCell+2*nGhost); \n  int flux_totalSize = numCell*numCell*(numCell+1); \n   \n   \n \n  int idx; \n  for(idx=0;idx<numBox;idx++){ \n    old_boxes[idx] = malloc(sizeof(Real)*totalCells*numComp); \n    new_boxes[idx] = malloc(sizeof(Real)*totalCells*numComp); \n  } \n \n   \n \n \n#pragma omp parallel for default(shared)  private(idx)  \n  for(idx=0;idx < numBox;idx++){ \n    Real* old_box = old_boxes[idx]; \n    Real* new_box = new_boxes[idx]; \n    int ic,iz,iy,ix; \n \n    for(ic=0;ic<numComp;ic++){ \n      const Real phiOrigin = ic*compMultiplier; \n \n     \n \n     \n \n     \n \n     \n \n      for(iz=-nGhost;iz<(full_numCell-nGhost);iz++){ \n        for(iy=-nGhost;iy<(full_numCell-nGhost);iy++){ \n           \n \n          Real* oldp = GET_VAL_PTR(old_box,ic,iz,iy,-nGhost); \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " \nstatic float one_iteration (const TestSequence * seqs, int num_seqs) \n{ \n  const int qp_base = 28; \n  const int qp_step = 4; \n  double bdr_values[num_seqs]; \n \n   \n \n \n \n \n   \n \n  for (int i = 0; i < num_seqs; i++) { \n    const TestSequence * seq = &seqs[i]; \n    double psnr [4]; \n    double bitrate [4]; \n \n#pragma omp parallel for schedule(dynamic, 1) \n    for (int j = 0; j < 4; j++) { \n \n       \n \n       \n \n       \n \n \n      FILE * file; \n      if (!(file = fopen(seq->path, \"rb\"))) { \n        fprintf(stderr, \"Could not open input file `%s'\\n\", seq->path); \n        exit (1); \n      } \n \n      int qp = qp_base + j * qp_step; \n      bool ok = encode (file, seq->width, seq->height, seq->frames, seq->fps, qp, \n                        &psnr[j], &bitrate[j]); \n      if (!ok) \n        fprintf (stderr, \"ERROR WHILE ENCODING!!!\\n\"); \n \n      fclose (file); \n    } \n    bdr_values[i] = bdr (seq->psnr_ref, psnr, seq->bitrate_ref, bitrate); \n     \n \n  } \n     \n  double sum = 0; \n  for (int i = 0; i < num_seqs; i++) \n    sum += bdr_values[i]; \n \n  return  sum / num_seqs; \n} ", "pred": " \nstatic float one_iteration (const TestSequence * seqs, int num_seqs) \n{ \n  const int qp_base = 28; \n  const int qp_step = 4; \n  double bdr_values[num_seqs]; \n \n   \n \n \n \n \n   \n \n  for (int i = 0; i < num_seqs; i++) { \n    const TestSequence * seq = &seqs[i]; \n    double psnr [4]; \n    double bitrate [4]; \n \n#pragma omp parallel for schedule(dynamic, 1) \n    for (int j = 0; j < 4; j++) { \n \n       \n \n       \n \n       \n \n \n      FILE * file; \n      if (!(file = fopen(seq->path, \"rb\"))) { \n        fprintf(stderr, \"Could not open input file `%s'\\n\", seq->path); \n        exit (1); \n      } \n \n      int qp = qp_base + j * qp_step; \n      bool ok = encode (file, seq->width, seq->height, seq->frames, seq->fps, qp, \n                        &psnr[j], &bitrate[j]); \n      if (!ok) \n        fprintf (stderr, \"ERROR WHILE ENCODING!!!\\n\"); \n \n      fclose (file); \n    } \n    bdr_values[i] = bdr (seq->psnr_ref, psnr, seq->bitrate_ref, bitrate); \n     \n \n  } \n     \n  double sum = 0; \n  for (int i = 0; i < num_seqs; i++) \n    sum += bdr_values[i]; \n \n  return  sum / num_seqs; \n} "}
{"label": " \nstatic void FFTW(task_callback)(void *(*work)(char *), char *jobdata, size_t elsize, int njobs, void *data){ \n\t(void)data; \n\t \n \n\t \n \n\tif(NTHREAD>1&&!omp_in_parallel()){ \n  #pragma omp parallel for default(shared)  \n\t\tfor(int i=0; i<njobs; ++i){ \n\t\t\twork(jobdata+elsize*i); \n\t\t} \n\t}else{ \n  #pragma omp taskloop default(shared) num_tasks(njobs) priority(1) \n\t\tfor(int i=0; i<njobs; ++i){ \n\t\t\twork(jobdata+elsize*i); \n\t\t} \n\t} \n\ttp_counter_t group={0}; \n\tfor(int i=0; i<njobs; ++i){ \n\t\tQUEUE(&group, work, jobdata+elsize*i, 1, 1); \n\t} \n\tWAIT(&group, 1); \n} ", "pred": " \nstatic void FFTW(task_callback)(void *(*work)(char *), char *jobdata, size_t elsize, int njobs, void *data){ \n\t(void)data; \n\t \n \n\t \n \n\tif(NTHREAD>1&&!omp_in_parallel()){ \n  #pragma omp parallel for default(shared)  \n\t\tfor(int i=0; i<njobs; ++i){ \n\t\t\twork(jobdata+elsize*i); \n\t\t} \n\t}else{ \n  #pragma omp taskloop default(shared) num_tasks(njobs) priority(1) \n\t\tfor(int i=0; i<njobs; ++i){ \n\t\t\twork(jobdata+elsize*i); \n\t\t} \n\t} \n\ttp_counter_t group={0}; \n\tfor(int i=0; i<njobs; ++i){ \n\t\tQUEUE(&group, work, jobdata+elsize*i, 1, 1); \n\t} \n\tWAIT(&group, 1); \n} "}
{"label": " \nstatic int nn_(SpatialConvolution_updateOutput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n \n  THTensor *weight = luaT_getfieldcheckudata(L, 1, \"weight\", torch_Tensor); \n  THTensor *bias = luaT_getfieldcheckudata(L, 1, \"bias\", torch_Tensor); \n  THTensor *output = luaT_getfieldcheckudata(L, 1, \"output\", torch_Tensor); \n \n  int dimw = 2; \n  int dimh = 1; \n \n  luaL_argcheck(L, input->nDimension == 3 || input->nDimension == 4, 2, \"3D or 4D(batch mode) tensor expected\"); \n \n  if (input->nDimension == 4) { \n    dimw++; \n    dimh++; \n  } \n \n  { \n    long nOutputPlane = weight->size[0]; \n    long kW           = weight->size[3]; \n    long kH           = weight->size[2]; \n    long inputWidth   = input->size[dimw]; \n    long inputHeight  = input->size[dimh]; \n    long outputWidth  = (inputWidth - kW) / dW + 1; \n    long outputHeight = (inputHeight - kH) / dH + 1; \n \n    if (input->nDimension == 3) \n    { \n      long i; \n      real* bias_data; \n      real* output_data; \n \n      THTensor_(resize3d)(output, nOutputPlane, outputHeight, outputWidth); \n       \n \n      bias_data = THTensor_(data)(bias); \n      output_data = THTensor_(data)(output); \n \n#pragma omp parallel for private(i) \n      for (i=0; i<bias->size[0]; i++) \n      { \n         \n \n         \n \n        real *ptr_output = output_data + i*outputWidth*outputHeight; \n        long j; \n        for(j = 0; j < outputWidth*outputHeight; j++) \n          ptr_output[j] = bias_data[i]; \n      } \n       \n \n       \n       \n \n      THTensor_(conv2Dmv)(output, 1.0, 1.0, input, weight, dH, dW, \"V\",\"X\"); \n    } \n    else \n    { \n      real* bias_data; \n      real* output_data;  \n      long p; \n \n      THTensor_(resize4d)(output, input->size[0], nOutputPlane, outputHeight, outputWidth); \n       \n      bias_data = THTensor_(data)(bias); \n      output_data = THTensor_(data)(output); \n       \n#pragma omp parallel for private(p) \n      for (p=0; p<input->size[0]; p++) \n      { \n         \n \n        long i; \n        for (i=0; i<bias->size[0]; i++) \n        { \n          real *ptr_output = output_data + p*nOutputPlane*outputWidth*outputHeight + i*outputWidth*outputHeight; \n          long j; \n          for(j = 0; j < outputWidth*outputHeight; j++) \n            ptr_output[j] = bias_data[i]; \n        } \n      } \n       \n       \n \n      THTensor_(conv2Dmm)(output, 1.0, 1.0, input, weight, dH, dW, \"V\",\"X\"); \n    } \n  } \n  return 1; \n} ", "pred": " \nstatic int nn_(SpatialConvolution_updateOutput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n \n  THTensor *weight = luaT_getfieldcheckudata(L, 1, \"weight\", torch_Tensor); \n  THTensor *bias = luaT_getfieldcheckudata(L, 1, \"bias\", torch_Tensor); \n  THTensor *output = luaT_getfieldcheckudata(L, 1, \"output\", torch_Tensor); \n \n  int dimw = 2; \n  int dimh = 1; \n \n  luaL_argcheck(L, input->nDimension == 3 || input->nDimension == 4, 2, \"3D or 4D(batch mode) tensor expected\"); \n \n  if (input->nDimension == 4) { \n    dimw++; \n    dimh++; \n  } \n \n  { \n    long nOutputPlane = weight->size[0]; \n    long kW           = weight->size[3]; \n    long kH           = weight->size[2]; \n    long inputWidth   = input->size[dimw]; \n    long inputHeight  = input->size[dimh]; \n    long outputWidth  = (inputWidth - kW) / dW + 1; \n    long outputHeight = (inputHeight - kH) / dH + 1; \n \n    if (input->nDimension == 3) \n    { \n      long i; \n      real* bias_data; \n      real* output_data; \n \n      THTensor_(resize3d)(output, nOutputPlane, outputHeight, outputWidth); \n       \n \n      bias_data = THTensor_(data)(bias); \n      output_data = THTensor_(data)(output); \n \n#pragma omp parallel for\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 16; \n  tile_size[1] = 16; \n  tile_size[2] = 16; \n  tile_size[3] = 1024; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=floord(Nt-1,2);t1++) { \n    lbp=max(ceild(t1,2),ceild(4*t1-Nt+2,4)); \n    ubp=min(floord(4*Nt+Nz-9,16),floord(8*t1+Nz+2,16)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-1,2)),ceild(16*t2-Nz-3,16));t3<=min(min(min(floord(4*Nt+Ny-9,16),floord(8*t1+Ny+7,16)),floord(16*t2+Ny+3,16)),floord(16*t1-16*t2+Nz+Ny+5,16));t3++) { \n        for (t4=max(max(max(0,ceild(t1-127,128)),ceild(16*t2-Nz-1011,1024)),ceild(16*t3-Ny-1011,1024));t4<=min(min(min(min(floord(4*Nt+Nx-9,1024),floord(8*t1+Nx+7,1024)),floord(16*t2+Nx+3,1024)),floord(16*t3+Nx+3,1024)),floord(16*t1-16*t2+Nz+Nx+5,1024));t4++) { \n          for (t5=max(max(max(max(max(0,ceild(16*t2-Nz+5,4)),ceild(16*t3-Ny+5,4)),ceild(1024*t4-Nx+5,4)),2*t1),4*t1-4*t2+1);t5<=min(min(min(min(min(floord(16*t1-16*t2+Nz+10,4),Nt-1),2*t1+3),4*t2+2),4*t3+2),256*t4+254);t5++) { \n            for (t6=max(max(16*t2,4*t5+4),-16*t1+16*t2+8*t5-15);t6<=min(min(16*t2+15,-16*t1+16*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(16*t3,4*t5+4);t7<=min(16*t3+15,4*t5+Ny-5);t7++) { \n                lbv=max(1024*t4,4*t5+4); \n                ubv=min", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 16; \n  tile_size[1] = 16; \n  tile_size[2] = 16; \n  tile_size[3] = 16;  tile_size[4] = 16;  tile_size[5] = 16;  tile_size[6] = 16;  tile_size[7] = 16;  tile_size[8] = 16;  tile_size[9] = 16;  tile_size[10] = 16;  tile_size[11] = 16;  tile_size[12] = 16;  tile_size[13] = 16;  tile_size[14] = 16;  tile_size[15] = 16;  tile_size[16] = 16;  tile_size[17] = 16;  tile_size[18] = 16;  tile_size[19] = 16;  tile_size[20] = 16;  tile_size[21] = 16;  tile_size[22] = 16;  tile_size[23] = 16;  tile_size[24] = 16;  tile_size[25] = 16;  tile_size[26] = 16;  tile_size[27] = 16;  tile_size[28] = 16;  tile_size[29] = 16;  tile_size[30] = 16;  tile_size[31] = 16;  tile_size[32] = 16;  tile_size[33] = 16;  tile_size[34] = 16;  tile_size[35] = 16;  tile_size[36] = 16;  tile_size[37] = 16;  tile_size[38] = 16;  tile_size[39] = 16;  tile_size[40] = 16;  tile_size[41] = 16;  tile_size[42] = 16;  tile_size[43] = 16;  tile_size[44] = 16;  tile_size[45] = 16;  tile_size[46] = 16;  tile_size[47] = 16;  tile_size[48] = 16;  tile_size[49] = 16;  tile_size[50] = 16;  tile_size[51] = 16;  tile_size[52] = 16;  tile_size[53] = 16;  tile_size[54] = 16;  tile_size[55] = 16;  tile_size[56] = 16;  tile_size[57] = 16;  tile_size[58] = 16;  tile_size[59] = 16;  tile_size[60] = 16;  tile_size[61] = 16;  tile_size[62] = 16;  tile_size[63] = 16;  tile_size[64] = 16;  tile_size[65] = 16;  tile_size[66] = 16;  tile_size[67] = 16;  tile_size[68] = 16;  tile_size[69] = 16;  tile_size[69] = 16;  tile_size[70] = 16;  tile_size[72] = 16;  tile_size[73] = 16;  tile_size[73] = 16;  tile_size[74] = 16;  tile_size[75] = 16;  tile_size[76] = 16;  tile_size[77] = 16;  tile_size[78] = 16;  tile_size[78] = 16;  tile_size[79] = 16;  tile_size[80] = 16;  tile_size[81] = 16;  tile_size[81] = 16;  tile_size[82] = 16;  tile_size[83] = 16;  tile_size[84] = 16;  tile_size[85] = 16;  tile_size[86] = 16;  tile_size[86] = 16;  tile_size[87] = 16;  tile_size[88] = 16;  tile_size[89] = 16;  tile_size[90] = 16;  tile_size[91] = 16;  tile_size[92] = 16;  tile_size[93] = 16;  tile_size[93] = 16;  tile_size[94] = 16;  tile_size[95] = 16;  tile_size[96] = 16;  tile_size[97] = 16;  tile_size[98] = 16;  tile_size[99] = 16;  tile_size[100] = 16;  tile_size[101] = 16;  tile_size[102] = 16;  tile_size[103] = 16;  tile_size[104] = 16;  tile_size[105] = 16;  tile_size[106] = 16;  tile_size[106] = 16;  tile_size[107] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109] = 16;  tile_size[109"}
{"label": " \nstatic void __pyx_f_6spatch_3knn_8balltree_8BallTree___query_many(struct __pyx_obj_6spatch_3knn_8balltree_BallTree *__pyx_v_self, __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_queryData, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_numQueries, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_numDimensions, __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_distances, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C *__pyx_v_idx_array) { \n  __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_query_ptr; \n  __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_dist_ptr; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C *__pyx_v_idx_ptr; \n  struct __pyx_t_6spatch_3knn_8balltree_stack *__pyx_v_node_stacks; \n  int __pyx_v_i; \n  int __pyx_t_1; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_t_2; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_t_3; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_t_4; \n \n   \n \n  { \n      #ifdef WITH_THREAD \n      PyThreadState *_save; \n      Py_UNBLOCK_THREADS \n      #endif \n       \n { \n        { \n            #if ((defined(__APPLE__) || defined(__OSX__)) && (defined(__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))))) \n                #undef likely \n                #undef unlikely \n                #define likely(x)   (x) \n                #define unlikely(x) (x) \n            #endif \n            #ifdef _OPENMP \n            #pragma omp parallel private(__pyx_v_node_stacks) private(__pyx_t_4, __pyx_t_1, __pyx_t_2, __pyx_t_3) \n            #endif  \n \n            { \n                 \n \n                __pyx_v_node_stacks = ((struct __pyx_t_6spatch_3knn_8balltree_stack *)1); \n \n                 \n \n                __pyx_v_node_stacks = ((struct __pyx_t_6spatch_3knn_8balltree_stack *)malloc(((sizeof(struct __pyx_t_6spatch_3knn_8balltree_stack)) * __pyx_v_numQueries))); \n \n                 \n \n                __pyx_t_1 = ((__pyx_v_k >= 5)!= 0); \n                if (__pyx_t_1) { \n \n                   \n \n                  __pyx_t_2 = __pyx_v_numQueries; \n                  if (1 == 0) abort(); \n                  { \n                      __pyx_t_4 = (__pyx_t_2 - 0) / 1; \n                      if (__pyx_t_4 > 0) \n                      { \n                          #ifdef _OPENMP \n                          #pragma omp for lastprivate(__pyx_v_idx_ptr) lastprivate(__pyx_v_dist_ptr) firstprivate(__pyx_v_i) lastprivate(__pyx_v_i) lastprivate(__pyx_v_query_ptr) \n                          #endif  \n \n                          for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_4; __pyx_t_3++){ \n                              { \n                                  __pyx_v_i = 0 + 1 * __pyx_t_3; \n                                   \n \n                                  __pyx_v_idx_ptr = ((__pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C *)1); \n                                  __pyx_v_dist_ptr = ((__pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *)1); \n                                  __pyx_v_query_ptr = ((__pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *)1); \n \n                                   \n \n                           ", "pred": " \nstatic void __pyx_f_6spatch_3knn_8balltree_8BallTree___query_many(struct __pyx_obj_6spatch_3knn_8balltree_BallTree *__pyx_v_self, __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_queryData, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_numQueries, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_numDimensions, __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_distances, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C *__pyx_v_idx_array) { \n  __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_query_ptr; \n  __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_dist_ptr; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C *__pyx_v_idx_ptr; \n  struct __pyx_t_6spatch_3knn_8balltree_stack *__pyx_v_node_stacks; \n  int __pyx_v_i; \n  int __pyx_t_1; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_t_2; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_t_3; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_t_4; \n \n   \n \n  { \n      #ifdef WITH_THREAD \n      PyThreadState *_save; \n      Py_UNBLOCK_THREADS \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "}
{"label": " \nMagickExport MagickBooleanType ProfileImage(Image *image,const char *name, \n  const void *datum,const size_t length,ExceptionInfo *exception) \n{ \n#define ProfileImageTag  \"Profile/Image\" \n#define ThrowProfileException(severity,tag,context)  {    if (source_profile!= (cmsHPROFILE) NULL)      (void) cmsCloseProfile(source_profile);    if (target_profile!= (cmsHPROFILE) NULL)      (void) cmsCloseProfile(target_profile);    ThrowBinaryException(severity,tag,context);  } \n \n  MagickBooleanType \n    status; \n \n  StringInfo \n    *profile; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(name!= (const char *) NULL); \n  if ((datum == (const void *) NULL) || (length == 0)) \n    { \n      char \n        **arguments, \n        *names; \n \n      int \n        number_arguments; \n \n      register ssize_t \n        i; \n \n       \n \n      names=ConstantString(name); \n      (void) SubstituteString(&names,\",\",\" \"); \n      arguments=StringToArgv(names,&number_arguments); \n      names=DestroyString(names); \n      if (arguments == (char **) NULL) \n        return(MagickTrue); \n      ResetImageProfileIterator(image); \n      for (name=GetNextImageProfile(image); name!= (const char *) NULL; ) \n      { \n        for (i=1; i < (ssize_t) number_arguments; i++) \n        { \n          if ((*arguments[i] == '!') && \n              (LocaleCompare(name,arguments[i]+1) == 0)) \n            break; \n          if (GlobExpression(name,arguments[i],MagickTrue)!= MagickFalse) \n            { \n              (void) DeleteImageProfile(image,name); \n              break; \n            } \n        } \n        name=GetNextImageProfile(image); \n      } \n      for (i=0; i < (ssize_t) number_arguments; i++) \n        arguments[i]=DestroyString(arguments[i]); \n      arguments=(char **) RelinquishMagickMemory(arguments); \n      return(MagickTrue); \n    } \n   \n \n  status=MagickTrue; \n  profile=AcquireStringInfo((size_t) length); \n  SetStringInfoDatum(profile,(unsigned char *) datum); \n  if ((LocaleCompare(name,\"icc\")!= 0) && (LocaleCompare(name,\"icm\")!= 0)) \n    status=SetImageProfile(image,name,profile,exception); \n  else \n    { \n      const StringInfo \n        *icc_profile; \n \n      icc_profile=GetImageProfile(image,\"icc\"); \n      if ((icc_profile!= (const StringInfo *) NULL) && \n          (CompareStringInfo(icc_profile,profile) == 0)) \n        { \n          const char \n            *value; \n \n          value=GetImageProperty(image,\"exif:ColorSpace\",exception); \n          (void) value; \n           \n \n          icc_profile=GetImageProfile(image,\"icc\"); \n        } \n      if ((icc_profile!= (const StringInfo *) NULL) && \n          (CompareStringInfo(icc_profile,profile) == 0)) \n        { \n          profile=DestroyStringInfo(profile); \n          return(MagickTrue); \n        } \n      (void) ThrowMagickException(exception,GetMagickModule(), \n        MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\", \n        \"'%s' (LCMS)\",image->filename); \n      { \n        cmsHPROFILE \n          source_profile; \n \n        CMSExceptionInfo \n          cms_exception; \n \n         \n \n        cmsSetLogErrorHandler(CMSExceptionHandler); \n        cms_exception.image=image; \n        cms_exception.exception=exception; \n        (void) cms_exception; \n        source_profile=cmsOpenProfileFromMemTHR(&cms_exception, \n          GetStringInfoDatum(profile),(cmsUInt32Number) \n          GetStringInfoLength(profile)); \n        if (source_profile == (cmsHPROFILE) NULL) \n          ThrowBinaryException(ResourceLimitError, \n            \"ColorspaceColorProfileMismatch\",name); \n        if ((cmsGetDeviceClass(source_profile)!= cmsSigLinkClass) && \n            (icc_profile == (StringInfo *) NULL)) \n          status=SetImageProfile(image,name,profile,exception); \n        else \n          { \n            CacheView \n              *image_view; \n \n            ColorspaceType \n              source_colorspace, \n              target_colorspace; \n \n            cmsColorSpaceSignature \n              signature; \n \n            cmsHPROFILE \n              target_profile; \n \n            cmsHTRANSFORM \n              *restrict transform; \n \n            cmsUInt32Number \n              flags, \n", "pred": " \nMagickExport MagickBooleanType ProfileImage(Image *image,const char *name, \n  const void *datum,const size_t length,ExceptionInfo *exception) \n{ \n#define ProfileImageTag  \"Profile/Image\" \n#define ThrowProfileException(severity,tag,context)  {    if (source_profile!= (cmsHPROFILE) NULL)      (void) cmsCloseProfile(source_profile);    if (target_profile!= (cmsHPROFILE) NULL)      (void) cmsCloseProfile(target_profile);    ThrowBinaryException(severity,tag,context);  } \n \n  MagickBooleanType \n    status; \n \n  StringInfo \n    *profile; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(name!= (const char *) NULL); \n  if ((datum == (const void *) NULL) || (length == 0)) \n    { \n      char \n        **arguments, \n        *names; \n \n      int \n        number_arguments; \n \n      register ssize_t \n        i; \n \n       \n \n      names=ConstantString(name); \n      (void) SubstituteString(&names,\",\",\" \"); \n      arguments=StringToArgv(names,&number_arguments); \n      names=DestroyString(names); \n      if (arguments == (char **) NULL) \n        return(MagickTrue); \n      ResetImageProfileIterator(image); \n      for (name=GetNextImageProfile(image); name!= (const char *) NULL; ) \n      { \n        for (i=1; i < (ssize_t) number_arguments; i++) \n        { \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "}
{"label": " \nvoid vec_mult(float *p, int n) \n{ \n  float *v1, *v2; \n  int i; \n \n  #pragma omp task shared(v1, v2) depend(out: v1, v2) \n    #pragma omp target map(v1, v2) \n      { \n\tif (omp_is_initial_device ()) \n\t  abort (); \n \n\tv1 = (float *) malloc (n * sizeof (float)); \n\tv2 = (float *) malloc (n * sizeof (float)); \n \n\tinit (v1, v2, n); \n      } \n \n  #pragma omp task shared(v1, v2) depend(in: v1, v2) \n    #pragma omp target map(to: v1, v2) map(from: p[0:n]) \n      { \n\tif (omp_is_initial_device ()) \n\t  abort (); \n \n #pragma omp parallel for \n\t  for (i = 0; i < n; i++) \n\t    p[i] = v1[i] * v2[i]; \n \n\t  free (v1); \n\t  free (v2); \n      } \n \n  #pragma omp taskwait \n} ", "pred": " \nvoid vec_mult(float *p, int n) \n{ \n  float *v1, *v2; \n  int i; \n \n  #pragma omp task shared(v1, v2) depend(out: v1, v2) \n    #pragma omp target map(v1, v2) \n      { \n\tif (omp_is_initial_device ()) \n\t  abort (); \n \n\tv1 = (float *) malloc (n * sizeof (float)); \n\tv2 = (float *) malloc (n * sizeof (float)); \n \n\tinit (v1, v2, n); \n      } \n \n  #pragma omp task shared(v1, v2) depend(in: v1, v2) \n    #pragma omp target map(to: v1, v2) map(from: p[0:n]) \n      { \n\tif (omp_is_initial_device ()) \n\t  abort (); \n \n #pragma omp parallel for \n\t  for (i = 0; i < n; i++) \n\t    p[i] = v1[i] * v2[i]; \n \n\t  free (v1); \n\t  free (v2); \n      } \n \n  #pragma omp taskwait \n} "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 4; \n  tile_size[3] = 1024; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,12);t1++) { \n    lbp=max(ceild(t1,2),ceild(24*t1-Nt+3,24)); \n    ubp=min(floord(Nt+Nz-4,24),floord(12*t1+Nz+9,24)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(24*t2-Nz,4)),3*t1);t3<=min(min(min(floord(Nt+Ny-4,4),floord(12*t1+Ny+21,4)),floord(24*t2+Ny+20,4)),floord(24*t1-24*t2+Nz+Ny+19,4));t3++) { \n        for (t4=max(max(max(0,ceild(3*t1-255,256)),ceild(24*t2-Nz-1020,1024)),ceild(4*t3-Ny-1020,1024));t4<=min(min(min(min(floord(4*t3+Nx,1024),floord(Nt+Nx-4,1024)),floord(12*t1+Nx+21,1024)),floord(24*t2+Nx+20,1024)),floord(24*t1-24*t2+Nz+Nx+19,1024));t4++) { \n          for (t5=max(max(max(max(max(0,12*t1),24*t1-24*t2+1),24*t2-Nz+2),4*t3-Ny+2),1024*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,12*t1+23),24*t2+22),4*t3+2),1024*t4+1022),24*t1-24*t2+Nz+21);t5++) { \n            for (t6=max(max(24*t2,t5+1),-24*t1+24*t2+2*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(4*t3,t5+1);t7<=min(4*t3+3,t5+Ny-2);", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *) tile_size, sizeof(int)*Nz);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": " \nint main (int argc, char **argv){ \n    int i,j,k,MatrixDim; \n    FP_NUMBER sum, *L, *U, *A; \n    FILE *fl,*fu,*fa; \n \n    if ( argc < 2) { \n        printf(\"./gen_input [Matrix_Dimension_size]\\n\"); \n        return 1; \n    } \n \n    MatrixDim = atoi(argv[1]); \n    L = (FP_NUMBER *) malloc(sizeof(FP_NUMBER*)*MatrixDim*MatrixDim); \n    U = (FP_NUMBER *) malloc(sizeof(FP_NUMBER*)*MatrixDim*MatrixDim); \n    A = (FP_NUMBER *) malloc(sizeof(FP_NUMBER*)*MatrixDim*MatrixDim); \n \n    if (!L ||!U ||!A){ \n        printf(\"Can not allocate memory\\n\"); \n        if (L) free(L); \n        if (U) free(U); \n        if (A) free(A); \n        return 1; \n    } \n \n    srand(time(NULL)); \n \n    sprintf(L_FNAME, \"l-%d.dat\", MatrixDim); \n    fl = fopen(L_FNAME, \"wb\"); \n    if (fl == NULL) { \n        printf(\"Cannot open file %s\\n\", L_FNAME); \n        return 1; \n    } \n \n    sprintf(U_FNAME, \"u-%d.dat\", MatrixDim); \n    fu = fopen(U_FNAME, \"wb\"); \n    if (fu == NULL) { \n        printf(\"Cannot open file %s\\n\", U_FNAME); \n        return 1; \n    } \n \n    sprintf(A_FNAME, \"%d.dat\", MatrixDim); \n    fa = fopen(A_FNAME, \"wb\"); \n    if (!fa) { \n        printf(\"Cannot open file %s\\n\", A_FNAME); \n        return 1; \n    } \n \n#pragma omp parallel for default(none)     private(i,j) shared(L,U,MatrixDim) \n    for (i=0; i < MatrixDim; i ++){ \n        for (j=0; j < MatrixDim; j++){ \n            if ( i == j) { \n                L[i * MatrixDim + j] = 1.0; \n                U[i * MatrixDim + j] = GET_RAND_FP; \n            } else if (i < j){ \n                L[i * MatrixDim + j] = 0; \n                U[i * MatrixDim + j] = GET_RAND_FP; \n            } else {  \n \n                L[i * MatrixDim + j] = GET_RAND_FP; \n                U[i * MatrixDim + j] = 0; \n            } \n        } \n    } \n \n#pragma omp parallel for default(none)      private(i,j,k,sum) shared(L,U,A,MatrixDim) \n    for (i=0; i < MatrixDim; i++ ) { \n        for (j=0; j < MatrixDim; j++){ \n            sum = 0; \n            for(k=0; k < MatrixDim; k++) \n                sum += L[i * MatrixDim + k]*U[k * MatrixDim + j]; \n            A[i * MatrixDim + j] = sum; \n        } \n    } \n \n    for (i=0; i < MatrixDim; i ++) { \n        for (j=0; j < MatrixDim; j++) \n            fprintf(fl, \"%f \", L[i * MatrixDim + j]); \n        fprintf(fl, \"\\n\"); \n    } \n    fclose(fl); \n \n    for (i=0; i < MatrixDim; i ++) { \n        for (j=0; j < MatrixDim; j++) \n            fprintf(fu, \"%f \", U[i * MatrixDim + j]); \n        fprintf(fu, \"\\n\"); \n    } \n    fclose(fu); \n \n    fprintf(fa, \"%d\\n\", MatrixDim); \n    for (i=0; i < MatrixDim; i ++) { \n        for (j=0; j < MatrixDim; j++) \n            fprintf(fa, \"%f \", A[i * MatrixDim + j]); \n        fprintf(fa, \"\\n\"); \n    } \n    fclose(fa); \n \n    free(L); \n    free(U); \n    free(A); \n \n    return 0; \n} ", "pred": " \nint main (int argc, char **argv){ \n    int i,j,k,MatrixDim; \n    FP_NUMBER sum, *L, *U, *A; \n    FILE *fl,*fu,*fa; \n \n    if ( argc < 2) { \n        printf(\"./gen_input [Matrix_Dimension_size]\\n\"); \n        return 1; \n    } \n \n    MatrixDim = atoi(argv[1]); \n    L = (FP_NUMBER *) malloc(sizeof(FP_NUMBER*)*MatrixDim*MatrixDim); \n    U = (FP_NUMBER *) malloc(sizeof(FP_NUMBER*)*MatrixDim*MatrixDim); \n    A = (FP_NUMBER *) malloc(sizeof(FP_NUMBER*)*MatrixDim*MatrixDim); \n \n    if (!L ||!U ||!A){ \n        printf(\"Can not allocate memory\\n\"); \n        if (L) free(L); \n        if (U) free(U); \n        if (A) free(A); \n        return 1; \n    } \n \n    srand(time(NULL)); \n \n    sprintf(L_FNAME, \"l-%d.dat\", MatrixDim); \n    fl = fopen(L_FNAME, \"wb\"); \n    if (fl == NULL) { \n        printf(\"Cannot open file %s\\n\", L_FNAME); \n        return 1; \n    } \n \n    sprintf(U_FNAME, \"u-%d.dat\", MatrixDim); \n    fu = fopen(U_FNAME, \"wb\"); \n    if (fu == NULL) { \n        printf(\"Cannot open file %s\\n\", U_FNAME); \n        return 1; \n    } \n \n    sprintf(A_FNAME, \"%d.dat\", MatrixDim); \n    fa = fopen(A_FNAME, \"wb\"); \n    if (!fa) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "}
{"label": " \nvoid _PSWITCH(D_psi)(_PTSWITCH(spinor) * const P, _PTSWITCH(spinor) * const Q){ \n  if(P==Q){ \n    printf(\"Error in D_psi (operator.c):\\n\"); \n    printf(\"Arguments must be different spinor fields\\n\"); \n    printf(\"Program aborted\\n\"); \n    exit(1); \n  } \n   \n \n  _C_TYPE ALIGN32 phase_0l = (_C_TYPE) phase_0; \n  _C_TYPE ALIGN32 phase_1l = (_C_TYPE) phase_1; \n  _C_TYPE ALIGN32 phase_2l = (_C_TYPE) phase_2; \n  _C_TYPE ALIGN32 phase_3l = (_C_TYPE) phase_3;   \n \n  if(_PSWITCH(g_update_gauge_copy)) { \n    _PSWITCH(update_backward_gauge)(_PSWITCH(g_gauge_field)); \n  } \n# if defined TM_USE_MPI \n  _PTSWITCH(xchange_lexicfield)(Q); \n# endif \n \n#pragma omp parallel \n  { \n \n  int ix,iy; \n  _PSWITCH(su3) * restrict up,* restrict um; \n  _PTSWITCH(spinor) * restrict rr;  \n  _PTSWITCH(spinor) const * restrict s; \n  _PTSWITCH(spinor) const * restrict sp; \n  _PTSWITCH(spinor) const * restrict sm; \n  _C_TYPE rho1, rho2; \n  _PTSWITCH(spinor) tmpr; \n \n  rho1 = (_F_TYPE)1. + (_F_TYPE) g_mu * I; \n  rho2 = conj(rho1); \n \n   \n \n \n#pragma omp for \n  for (ix = 0; ix < VOLUME; ix++) { \n    rr  = (_PTSWITCH(spinor) *) P +ix; \n    s  = (_PTSWITCH(spinor) *) Q +ix; \n \n    if(g_c_sw > 0) { \n      _PSWITCH(assign_mul_one_sw_pm_imu_site_lexic)(ix, &tmpr, s, (_F_TYPE) g_mu); \n    } \n    else { \n      _complex_times_vector(tmpr.s0, rho1, s->s0); \n      _complex_times_vector(tmpr.s1, rho1, s->s1); \n      _complex_times_vector(tmpr.s2, rho2, s->s2); \n      _complex_times_vector(tmpr.s3, rho2, s->s3); \n    } \n \n     \n \n    iy=g_iup[ix][0]; \n    sp = (_PTSWITCH(spinor) *) Q +iy; \n    up=&_PSWITCH(g_gauge_field)[ix][0]; \n    _PTSWITCH(p0add)(&tmpr, sp, up, phase_0l); \n \n     \n \n    iy=g_idn[ix][0]; \n    sm  = (_PTSWITCH(spinor) *) Q +iy; \n    um=&_PSWITCH(g_gauge_field)[iy][0]; \n    _PTSWITCH(m0add)(&tmpr, sm, um, phase_0l); \n \n     \n \n    iy=g_iup[ix][1]; \n    sp = (_PTSWITCH(spinor) *) Q +iy; \n    up=&_PSWITCH(g_gauge_field)[ix][1]; \n    _PTSWITCH(p1add)(&tmpr, sp, up, phase_1l); \n \n     \n \n    iy=g_idn[ix][1]; \n    sm = (_PTSWITCH(spinor) *) Q +iy; \n    um=&_PSWITCH(g_gauge_field)[iy][1]; \n    _PTSWITCH(m1add)(&tmpr, sm, um, phase_1l); \n \n     \n \n    iy=g_iup[ix][2]; \n    sp = (_PTSWITCH(spinor) *) Q +iy; \n    up=&_PSWITCH(g_gauge_field)[ix][2]; \n    _PTSWITCH(p2add)(&tmpr, sp, up, phase_2l); \n \n     \n \n    iy=g_idn[ix][2]; \n    sm = (_PTSWITCH(spinor) *) Q +iy; \n    um=&_PSWITCH(g_gauge_field)[iy][2]; \n    _PTSWITCH(m2add)(&tmpr, sm, um, phase_2l); \n \n     \n \n    iy=g_iup[ix][3]; \n    sp = (_PTSWITCH(spinor) *) Q +iy; \n    up=&_PSWITCH(g_gauge_field)[ix][3]; \n    _PTSWITCH(p3add)(&tmpr, sp, up, phase_3l); \n \n     \n \n    iy=g_idn[ix][3]; \n    sm = (_PTSWITCH(spinor) *) Q +iy; \n    um=&_PSWITCH(g_gauge_field)[iy][3]; \n    _PTSWITCH(m3addandstore)(rr, sm, um, phase_3l, &tmpr); \n  } \n  }  \n \n} ", "pred": " \nvoid _PSWITCH(D_psi)(_PTSWITCH(spinor) * const P, _PTSWITCH(spinor) * const Q){ \n  if(P==Q){ \n    printf(\"Error in D_psi (operator.c):\\n\"); \n    printf(\"Arguments must be different spinor fields\\n\"); \n    printf(\"Program aborted\\n\"); \n    exit(1); \n  } \n   \n \n  _C_TYPE ALIGN32 phase_0l = (_C_TYPE) phase_0; \n  _C_TYPE ALIGN32 phase_1l = (_C_TYPE) phase_1; \n  _C_TYPE ALIGN32 phase_2l = (_C_TYPE) phase_2; \n  _C_TYPE ALIGN32 phase_3l = (_C_TYPE) phase_3;   \n \n  if(_PSWITCH(g_update_gauge_copy)) { \n    _PSWITCH(update_backward_gauge)(_PSWITCH(g_gauge_field)); \n  } \n# if defined TM_USE_MPI \n  _PTSWITCH(xchange_lexicfield)(Q); \n# endif \n \n#pragma omp parallel \n  { \n \n  int ix,iy; \n  _PSWITCH(su3) * restrict up,* restrict um; \n  _PTSWITCH(spinor) * restrict rr;  \n  _PTSWITCH(spinor) const * restrict s; \n  _PTSWITCH(spinor) const * restrict sp; \n  _PTSWITCH(spinor) const * restrict sm; \n  _C_TYPE rho1, rho2; \n  _PTSWITCH(spinor) tmpr; \n \n  rho1 = (_F_TYPE)1. + (_F_TYPE) g_mu * I; \n  rho2 = conj(rho1); \n \n   \n \n \n#pragma omp for \n  for (ix = 0; ix < VOLUME; ix++) { \n    rr  = (_PTSWITCH(spinor) *) P +ix; \n    s  = (_PTSWITCH(spinor) *) Q +ix; \n \n    if(g_c_sw > 0) { \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 32; \n  tile_size[3] = 2048; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0765; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,4);t1++) { \n    lbp=max(ceild(t1,2),ceild(8*t1-Nt+3,8)); \n    ubp=min(floord(Nt+Nz-4,8),floord(4*t1+Nz+1,8)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-7,8)),ceild(8*t2-Nz-28,32));t3<=min(min(min(floord(Nt+Ny-4,32),floord(4*t1+Ny+5,32)),floord(8*t2+Ny+4,32)),floord(8*t1-8*t2+Nz+Ny+3,32));t3++) { \n        for (t4=max(max(max(0,ceild(t1-511,512)),ceild(8*t2-Nz-2044,2048)),ceild(32*t3-Ny-2044,2048));t4<=min(min(min(min(floord(Nt+Nx-4,2048),floord(4*t1+Nx+5,2048)),floord(8*t2+Nx+4,2048)),floord(32*t3+Nx+28,2048)),floord(8*t1-8*t2+Nz+Nx+3,2048));t4++) { \n          for (t5=max(max(max(max(max(0,4*t1),8*t1-8*t2+1),8*t2-Nz+2),32*t3-Ny+2),2048*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,4*t1+7),8*t2+6),32*t3+30),2048*t4+2046),8*t1-8*t2+Nz+5);t5++) { \n            for (t6=max(max(8*t2,t5+1),-8*t1+8*t2+2*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(32*t3,t5+1);t7<=min(32*t3+31,t5+Ny-2);t7++) { \n                lbv=max(2048*t4,t5+1); \n                ubv=min(2048*t4+2047,t5+Nx-2); \n#pragma ivdep \n#pragma vector always \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = ((alpha * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (beta * (((((A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)] + A[ t5 % 2][ (-t5+t6)][ (-", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 32; \n  tile_size[3] = 2048; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0876;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 24; \n  tile_size[3] = 256; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0765; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,12);t1++) { \n    lbp=max(ceild(t1,2),ceild(24*t1-Nt+3,24)); \n    ubp=min(floord(Nt+Nz-4,24),floord(12*t1+Nz+9,24)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-1,2)),ceild(24*t2-Nz-20,24));t3<=min(min(min(floord(Nt+Ny-4,24),floord(12*t1+Ny+21,24)),floord(24*t2+Ny+20,24)),floord(24*t1-24*t2+Nz+Ny+19,24));t3++) { \n        for (t4=max(max(max(0,ceild(3*t1-63,64)),ceild(24*t2-Nz-252,256)),ceild(24*t3-Ny-252,256));t4<=min(min(min(min(floord(Nt+Nx-4,256),floord(12*t1+Nx+21,256)),floord(24*t2+Nx+20,256)),floord(24*t3+Nx+20,256)),floord(24*t1-24*t2+Nz+Nx+19,256));t4++) { \n          for (t5=max(max(max(max(max(0,12*t1),24*t1-24*t2+1),24*t2-Nz+2),24*t3-Ny+2),256*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,12*t1+23),24*t2+22),24*t3+22),256*t4+254),24*t1-24*t2+Nz+21);t5++) { \n            for (t6=max(max(24*t2,t5+1),-24*t1+24*t2+2*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(24*t3,t5+1);t7<=min(24*t3+23,t5+Ny-2);t7++) { \n                lbv=max(256*t4,t5+1); \n                ubv=min(256*t4+255,t5+Nx-2); \n#pragma ivdep \n#pragma vector always \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = ((alpha * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (beta * (((((A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)] + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) - 1][ (-t5+", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 24; \n  tile_size[3] = 256; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0876;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "}
{"label": " \nvoid traj(struct s_X **J_p_X, struct s_best *p_best, double t0, double t_end, double t_transiant, struct s_par **J_p_par, struct s_data *p_data, struct s_calc **calc, plom_f_pred_t f_pred, void *sender, void *receiver, void *controller, const enum plom_print print_opt) \n{ \n    int k, j; \n    int thread_id; \n    int nt, the_nt; \n \n    FILE *p_file_X = NULL; \n    if (print_opt & PLOM_PRINT_X) { \n        p_file_X = plom_fopen(SFR_PATH, GENERAL_ID, \"X\", \"w\", header_X, p_data); \n    } \n    FILE *p_file_hat = plom_fopen(SFR_PATH, GENERAL_ID, \"hat\", \"w\", header_hat, p_data); \n \n    struct s_hat *p_hat = build_hat(p_data); \n \n \n     \n \n    if ( (p_data->implementation == PLOM_ODE) && (t_transiant > 0.0) ) { \n        replicate_J_p_X_0(J_p_X, p_data); \n    } \n \n \n     \n \n    for(j=0;j<J;j++) { \n\treset_inc(J_p_X[j], p_data); \n\tproj2obs(J_p_X[j], p_data); \n    }\t \n \n    compute_hat_nn(J_p_X, J_p_par, p_data, calc, p_hat, 0, (int) t0-1, t0); \n    print_p_hat(p_file_hat, NULL, p_hat, p_data, t0); \n \n    if ((print_opt & PLOM_PRINT_X) && FLAG_JSON==0) { \n\tprint_X(p_file_X, J_p_par, J_p_X, p_data, calc[0], 0, 0, 0, (int) t0-1, t0); \n    } \n \n \n    for (k= (int) t0 ; k< (int) t_end ; k++) { \n \n \n        if (print_opt & PLOM_PRINT_X) { \n            if(k % 10 == 0){ \n                block(); \n            } \n        } \n \n \n#pragma omp parallel for private(thread_id) \n        for(j=0;j<J;j++) { \n\t    thread_id = omp_get_thread_num(); \n \n            reset_inc(J_p_X[j], p_data); \n            f_pred(J_p_X[j], k, k+1, J_p_par[j], p_data, calc[thread_id]); \n            proj2obs(J_p_X[j], p_data); \n        } \n \n \n\t \n \n\tfor (nt=0; nt<calc[0]->n_threads; nt++) { \n\t    zmq_send(sender, &nt, sizeof (int), ZMQ_SNDMORE); \n\t    zmq_send(sender, &k, sizeof (int), 0); \n\t} \n \n\t \n \n\tfor (nt=0; nt<calc[0]->n_threads; nt++) { \n\t    zmq_recv(receiver, &the_nt, sizeof (int), 0);\t        \n\t} \n \n \n        compute_hat_nn(J_p_X, J_p_par, p_data, calc, p_hat, 0, k, k+1); \n        print_p_hat(p_file_hat, NULL, p_hat, p_data, k+1); \n \n        if ((print_opt & PLOM_PRINT_X) && FLAG_JSON==0) { \n            print_X(p_file_X, J_p_par, J_p_X, p_data, calc[0], 0, 0, 0, k, k+1); \n        } \n    } \n \n     \n    plom_plug_hat(p_best, p_hat, p_data); \n \n \n    clean_hat(p_hat, p_data); \n    if (print_opt & PLOM_PRINT_X) { \n        plom_fclose(p_file_X); \n    } \n    plom_fclose(p_file_hat); \n} ", "pred": " \nvoid traj(struct s_X **J_p_X, struct s_best *p_best, double t0, double t_end, double t_transiant, struct s_par **J_p_par, struct s_data *p_data, struct s_calc **calc, plom_f_pred_t f_pred, void *sender, void *receiver, void *controller, const enum plom_print print_opt) \n{ \n    int k, j; \n    int thread_id; \n    int nt, the_nt; \n \n    FILE *p_file_X = NULL; \n    if (print_opt & PLOM_PRINT_X) { \n        p_file_X = plom_fopen(SFR_PATH, GENERAL_ID, \"X\", \"w\", header_X, p_data); \n    } \n    FILE *p_file_hat = plom_fopen(SFR_PATH, GENERAL_ID, \"hat\", \"w\", header_hat, p_data); \n \n    struct s_hat *p_hat = build_hat(p_data); \n \n \n     \n \n    if ( (p_data->implementation == PLOM_ODE) && (t_transiant > 0.0) ) { \n        replicate_J_p_X_0(J_p_X, p_data); \n    } \n \n \n     \n \n    for(j=0;j<J;j++) { \n\treset_inc(J_p_X[j], p_data); \n\tproj2obs(J_p_X[j], p_data); \n    }\t \n \n    compute_hat_nn(J_p_X, J_p_par, p_data, calc, p_hat, 0, (int) t0-1, t0); \n    print_p_hat(p_file_hat, NULL, p_hat, p_data, t0); \n \n    if ((print_opt & PLOM_PRINT_X) && FLAG_JSON==0) { \n\tprint_X(p_file_X, J_p_par, J_p_X, p_data, calc[0], 0, 0, 0, (int) t0);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nint main( int argc, char *argv[] ) \n{ \n\tif( argc < 4 ) { \n\t\tusage(); \n\t\treturn 1; \n\t} \n\tchar\t*inB2\t= argv[1];  \n \n\tchar\t*inB3 \t= argv[2];  \n \n\tchar\t*laiF \t= argv[3];  \n \n\tfloat offset=Null, scale=Null; \n\tif(argv[4]!= NULL && argv[5]!= NULL){ \n\t\toffset \t= atof(argv[4]);  \n \n\t\tscale \t= atof(argv[5]);  \n \n\t} \n\tGDALAllRegister(); \n\tGDALDatasetH hD2 = GDALOpen(inB2,GA_ReadOnly); \n \n\tGDALDatasetH hD3 = GDALOpen(inB3,GA_ReadOnly); \n \n\tif(hD2==NULL||hD3==NULL){ \n\t\tprintf(\"One or more input files \"); \n\t\tprintf(\"could not be loaded\\n\"); \n\t\texit(1); \n\t} \n\tGDALDriverH hDr2 = GDALGetDatasetDriver(hD2); \n\tchar **options = NULL; \n\t \n \n\t \n \n\t \n \n\tGDALDatasetH hDOut = GDALCreateCopy(hDr2,laiF,hD2,FALSE,options,NULL,NULL); \n\tGDALRasterBandH hBOut = GDALGetRasterBand(hDOut,1); \n\tGDALSetRasterNoDataValue(hBOut, NODATA); \n\tGDALRasterBandH hB2 = GDALGetRasterBand(hD2,1); \n \n\tGDALRasterBandH hB3 = GDALGetRasterBand(hD3,1); \n \n \n\tint nX = GDALGetRasterBandXSize(hB2); \n\tint nY = GDALGetRasterBandYSize(hB2); \n\tint N=nX*nY; \n \n\tfloat *l2 = (float *) malloc(sizeof(float)*N); \n\tfloat *l3 = (float *) malloc(sizeof(float)*N); \n\tfloat *lOut = (float *) malloc(sizeof(float)*N); \n\tint rc, qa; \n \n\t \n \n\tint err = 0;  \n\terr=GDALRasterIO(hB2,GF_Read,0,0,nX,nY,l2,nX,nY,GDT_Float32,0,0); \n\t \n \n\terr=GDALRasterIO(hB3,GF_Read,0,0,nX,nY,l3,nX,nY,GDT_Float32,0,0); \n #pragma omp parallel for default(none)    private (rc, qa) shared (N, l2, l3, lOut, offset, scale) \n\tfor(rc=0;rc<N;rc++){ \n\t\tqa=mcd15A3a(l3[rc]); \n\t\tif( qa!= 0) lOut[rc] = NODATA; \n\t\tif(offset!=Null && scale!=Null){ \n\t\t\tlOut[rc] = offset + l2[rc] * scale; \n\t\t} \n\t\telse lOut[rc] = l2[rc]; \n\t} \n #pragma omp barrier \n\terr=GDALRasterIO(hBOut,GF_Write,0,0,nX,nY,lOut,nX,nY,GDT_Float32,0,0); \n\terr=err+1; \n\tif( l2!= NULL ) free( l2 ); \n\tif( l3!= NULL ) free( l3 ); \n\tGDALClose(hD2); \n\tGDALClose(hD3); \n\tGDALClose(hDOut); \n\treturn(EXIT_SUCCESS); \n} ", "pred": " \nint main( int argc, char *argv[] ) \n{ \n\tif( argc < 4 ) { \n\t\tusage(); \n\t\treturn 1; \n\t} \n\tchar\t*inB2\t= argv[1];  \n \n\tchar\t*inB3 \t= argv[2];  \n \n\tchar\t*laiF \t= argv[3];  \n \n\tfloat offset=Null, scale=Null; \n\tif(argv[4]!= NULL && argv[5]!= NULL){ \n\t\toffset \t= atof(argv[4]);  \n \n\t\tscale \t= atof(argv[5]);  \n \n\t} \n\tGDALAllRegister(); \n\tGDALDatasetH hD2 = GDALOpen(inB2,GA_ReadOnly); \n \n\tGDALDatasetH hD3 = GDALOpen(inB3,GA_ReadOnly); \n \n\tif(hD2==NULL||hD3==NULL){ \n\t\tprintf(\"One or more input files \"); \n\t\tprintf(\"could not be loaded\\n\"); \n\t\texit(1); \n\t} \n\tGDALDriverH hDr2 = GDALGetDatasetDriver(hD2); \n\tchar **options = NULL; \n\t \n \n\t \n \n\t \n \n\tGDALDatasetH hDOut = GDALCreateCopy(hDr2,laiF,hD2,FALSE,options,NULL,NULL); \n\tGDALRasterBandH hBOut = GDALGetRasterBand(hDOut,1); \n\tGDALSetRasterNoDataValue(hBOut, NODATA); \n\tGDALRasterBandH hB2 = GDALGetRasterBand(hD2,1); \n \n\tGDALRasterBandH hB3 = GDALGetRasterBand(hD3,1); \n \n \n\tint nX = GDALGetRasterBandXSize(hB2); \n\tint nY = GDALGetRasterBandYSize(hB2); \n\tint N=nX*nY; \n \n\tfloat *l2 = (float *) malloc(sizeof(float)*N); \n\tfloat *l3 = (float *) malloc(sizeof(float)*N); \n\tfloat *lOut = (float *) malloc(sizeof(float)*N);\\n                                                                                                                                                                                                                                                                                                                                                                                                                                           "}
{"label": " \nvoid THNN_(HardTanh_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput, \n          real min_val, \n          real max_val) \n{ \n  THTensor_(resizeAs)(gradInput, input); \n \n  if (input->nDimension == 1 || \n   !THTensor_(isContiguous)(input) || \n   !THTensor_(isContiguous)(gradOutput) || \n   !THTensor_(isContiguous)(gradInput)) \n  { \n    TH_TENSOR_APPLY3(real, gradInput, real, gradOutput, real, input, \n      if (*input_data < min_val || *input_data > max_val) \n        *gradInput_data = 0; \n      else \n        *gradInput_data = *gradOutput_data; \n    ); \n  } \n  else \n  { \n    real* ptr_gradOutput = THTensor_(data)(gradOutput); \n    real* ptr_gradInput  = THTensor_(data)(gradInput); \n    real* ptr_input      = THTensor_(data)(input); \n    long i; \n \n#pragma omp parallel for private(i) \n    for (i = 0; i < THTensor_(nElement)(input); i++) \n    { \n      if (ptr_input[i] < min_val || ptr_input[i] > max_val) \n        ptr_gradInput[i] = 0; \n      else \n        ptr_gradInput[i] = ptr_gradOutput[i]; \n    } \n  } \n} ", "pred": " \nvoid THNN_(HardTanh_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput, \n          real min_val, \n          real max_val) \n{ \n  THTensor_(resizeAs)(gradInput, input); \n \n  if (input->nDimension == 1 || \n   !THTensor_(isContiguous)(input) || \n   !THTensor_(isContiguous)(gradOutput) || \n   !THTensor_(isContiguous)(gradInput)) \n  { \n    TH_TENSOR_APPLY3(real, gradInput, real, gradOutput, real, input, \n      if (*input_data < min_val || *input_data > max_val) \n        *gradInput_data = 0; \n      else \n        *gradInput_data = *gradOutput_data; \n    ); \n  } \n  else \n  { \n    real* ptr_gradOutput = THTensor_(data)(gradOutput); \n    real* ptr_gradInput  = THTensor_(data)(gradInput); \n    real* ptr_input      = THTensor_(data)(input); \n    long i; \n \n#pragma omp parallel for private(i) \n    for (i = 0; i < THTensor_(nElement)(input); i++) \n    { \n      if (ptr_input[i] < min_val || ptr_input[i] > max_val) \n        ptr_gradInput[i] = 0; \n      else \n        ptr_gradInput[i] = ptr_gradOutput[i]; \n    } \n  } \n} "}
{"label": " \nvoid kappa_get_beam_properties(ParamCoLoRe *par) \n{ \n  HealpixShells *kmap=par->kmap; \n \n#pragma omp parallel default(none)     shared(par,kmap) \n \n  { \n    double idx=par->n_grid/par->l_box; \n \n     \n \n    int i_r,nr; \n    double idr,dr; \n    get_radial_params(par->r_max,par->n_grid,&nr,&dr); \n    idr=1./dr; \n \n     \n \n    int *i_r_max_arr=my_malloc(kmap->nr*sizeof(int)); \n    int *i_r_min_arr=my_malloc(kmap->nr*sizeof(int)); \n    double *inv_r_max=my_malloc(kmap->nr*sizeof(double)); \n    for(i_r=0;i_r<kmap->nr;i_r++) { \n      int i_r_here=(int)(kmap->rf[i_r]*idr+0.5); \n      inv_r_max[i_r]=1./(i_r_here*dr); \n      i_r_max_arr[i_r]=MIN(i_r_here,nr-1); \n    } \n    i_r_min_arr[0]=0; \n    for(i_r=1;i_r<kmap->nr;i_r++) \n      i_r_min_arr[i_r]=i_r_max_arr[i_r-1]+1; \n \n     \n \n    double *fac_r_1=my_malloc(nr*sizeof(double)); \n    double *fac_r_2=my_malloc(nr*sizeof(double)); \n    for(i_r=0;i_r<nr;i_r++) { \n      double rm=(i_r+0.5)*dr; \n      double pg=get_bg(par,rm,BG_D1,0)*(1+get_bg(par,rm,BG_Z,0)); \n      fac_r_1[i_r]=rm*pg*dr; \n      fac_r_2[i_r]=rm*rm*pg*dr; \n    } \n \n    long ip; \n#pragma omp for \n \n    for(ip=0;ip<kmap->num_pix;ip++) { \n      int ax,added; \n      flouble t[6]; \n      double rot[6],xn[3]; \n      double kappa_1=0,kappa_2=0; \n      double *u=&(kmap->pos[3*ip]); \n      double prefac=idx*idx; \n      double cth_h=1,sth_h=0,cph_h=1,sph_h=0; \n \n      cth_h=u[2]; \n      if(cth_h>=1) cth_h=1; \n      if(cth_h<=-1) cth_h=-1; \n      sth_h=sqrt((1-cth_h)*(1+cth_h)); \n      if(sth_h!=0) { \n\tcph_h=u[0]/sth_h; \n\tsph_h=u[1]/sth_h; \n      } \n \n      rot[0]=(cth_h*cth_h*cph_h*cph_h+sph_h*sph_h)*prefac; \n      rot[1]=(2*cph_h*sph_h*(cth_h*cth_h-1))*prefac; \n      rot[2]=(-2*cth_h*sth_h*cph_h)*prefac; \n      rot[3]=(cth_h*cth_h*sph_h*sph_h+cph_h*cph_h)*prefac; \n      rot[4]=(-2*cth_h*sth_h*sph_h)*prefac; \n      rot[5]=(sth_h*sth_h)*prefac; \n      for(i_r=0;i_r<kmap->nr;i_r++) { \n\tint irr; \n\tint irmin=i_r_min_arr[i_r]; \n\tint irmax=i_r_max_arr[i_r]; \n\tfor(irr=irmin;irr<=irmax;irr++) { \n\t  double rm=(irr+0.5)*dr; \n\t  for(ax=0;ax<3;ax++) \n\t    xn[ax]=(rm*u[ax]+par->pos_obs[ax])*idx; \n\t  added=interpolate_from_grid(par,xn,NULL,NULL,t,NULL,NULL,RETURN_TID,INTERP_TYPE_LENSING); \n\t  if(added) { \n\t    double dotp=0; \n\t    for(ax=0;ax<6;ax++) \n\t      dotp+=rot[ax]*t[ax]; \n\t    kappa_1+=dotp*fac_r_1[irr]; \n\t    kappa_2+=dotp*fac_r_2[irr]; \n\t  } \n\t} \n\tkmap->data[i_r*kmap->num_pix+ip]+=(kappa_1-inv_r_max[i_r]*kappa_2); \n      } \n    }  \n \n \n    free(fac_r_1); \n    free(fac_r_2); \n    free(i_r_max_arr); \n    free(i_r_min_arr); \n    free(inv_r_max); \n  }  \n \n \n  return; \n} ", "pred": " \nvoid kappa_get_beam_properties(ParamCoLoRe *par) \n{ \n  HealpixShells *kmap=par->kmap; \n \n#pragma omp parallel default(none)     shared(par,kmap) \n \n  { \n    double idx=par->n_grid/par->l_box; \n \n     \n \n    int i_r,nr; \n    double idr,dr; \n    get_radial_params(par->r_max,par->n_grid,&nr,&dr); \n    idr=1./dr; \n \n     \n \n    int *i_r_max_arr=my_malloc(kmap->nr*sizeof(int)); \n    int *i_r_min_arr=my_malloc(kmap->nr*sizeof(int)); \n    double *inv_r_max=my_malloc(kmap->nr*sizeof(double)); \n    for(i_r=0;i_r<kmap->nr;i_r++) { \n      int i_r_here=(int)(kmap->rf[i_r]*idr+0.5); \n      inv_r_max[i_r]=1./(i_r_here*dr); \n      i_r_max_arr[i_r]=MIN(i_r_here,nr-1); \n    } \n    i_r_min_arr[0]=0; \n    for(i_r=1;i_r<kmap->nr;i_r++) \n      i_r_min_arr[i_r]=i_r_max_arr[i_r-1]+1; \n \n     \n \n    double *fac_r_1=my_malloc(nr*sizeof(double)); \n    double *fac_r_2=my_malloc(nr*sizeof(double)); \n    for(i_r=0;i_r<nr;i_r++) { \n      double rm=(i_r+0.5)*dr; \n      double pg=get_bg(par,rm,BG_D1,0)*(1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 24; \n  tile_size[3] = 2048; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,12);t1++) { \n    lbp=max(ceild(t1,2),ceild(24*t1-Nt+3,24)); \n    ubp=min(floord(Nt+Nz-4,24),floord(12*t1+Nz+9,24)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-1,2)),ceild(24*t2-Nz-20,24));t3<=min(min(min(floord(Nt+Ny-4,24),floord(12*t1+Ny+21,24)),floord(24*t2+Ny+20,24)),floord(24*t1-24*t2+Nz+Ny+19,24));t3++) { \n        for (t4=max(max(max(0,ceild(3*t1-511,512)),ceild(24*t2-Nz-2044,2048)),ceild(24*t3-Ny-2044,2048));t4<=min(min(min(min(floord(Nt+Nx-4,2048),floord(12*t1+Nx+21,2048)),floord(24*t2+Nx+20,2048)),floord(24*t3+Nx+20,2048)),floord(24*t1-24*t2+Nz+Nx+19,2048));t4++) { \n          for (t5=max(max(max(max(max(0,12*t1),24*t1-24*t2+1),24*t2-Nz+2),24*t3-Ny+2),2048*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,12*t1+23),24*t2+22),24*t3+22),2048*t4+2046),24*t1-24*t2+Nz+21);t5++) { \n            for (t6=max(max(24*t2,t5+1),-24*t1+24*t2+2*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(24*t3,t5+1);t7<", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *) tile_size, sizeof(int)*Nz);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": " \nvoid fastsum_trafo(fastsum_plan *ths) \n{ \n  int j, k, t; \n  ticks t0, t1; \n \n  ths->MEASURE_TIME_t[4] = K(0.0); \n  ths->MEASURE_TIME_t[5] = K(0.0); \n  ths->MEASURE_TIME_t[6] = K(0.0); \n  ths->MEASURE_TIME_t[7] = K(0.0); \n \n  t0 = getticks(); \n   \n \n  NFFT(adjoint)(&(ths->mv1)); \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[4] += NFFT(elapsed_seconds)(t1,t0); \n \n  t0 = getticks(); \n   \n \n  #pragma omp parallel for default(shared) private(k) \n  for (k = 0; k < ths->mv2.N_total; k++) \n    ths->mv2.f_hat[k] = ths->b[k] * ths->mv1.f_hat[k]; \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[5] += nfft_elapsed_seconds(t1,t0); \n \n  t0 = getticks(); \n   \n \n  NFFT(trafo)(&(ths->mv2)); \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[6] += nfft_elapsed_seconds(t1,t0); \n \n  t0 = getticks(); \n \n   \n \n  #pragma omp parallel for default(shared) private(j) \n  for (j = 0; j < ths->M_total; j++) \n    ths->f[j] = ths->mv2.f[j]; \n \n  if (ths->eps_I > 0.0) \n  { \n     \n \n  #ifdef _OPENMP \n    #pragma omp parallel for default(shared) private(j,k,t) \n  #endif \n    for (j = 0; j < ths->M_total; j++) \n    { \n      R ymin[ths->d], ymax[ths->d];  \n \n \n      if (ths->flags & NEARFIELD_BOXES) \n        ths->f[j] += SearchBox(ths->y + ths->d * j, ths); \n      else \n      { \n        for (t = 0; t < ths->d; t++) \n        { \n          ymin[t] = ths->y[ths->d * j + t] - ths->eps_I; \n          ymax[t] = ths->y[ths->d * j + t] + ths->eps_I; \n        } \n        ths->f[j] \n         += SearchTree(ths->d, 0, ths->x, ths->alpha, ymin, ymax, ths->N_total, \n             ths->k, ths->kernel_param, ths->Ad, ths->Add, ths->p, ths->flags); \n      } \n    } \n  } \n \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[7] += NFFT(elapsed_seconds)(t1,t0); \n} ", "pred": " \nvoid fastsum_trafo(fastsum_plan *ths) \n{ \n  int j, k, t; \n  ticks t0, t1; \n \n  ths->MEASURE_TIME_t[4] = K(0.0); \n  ths->MEASURE_TIME_t[5] = K(0.0); \n  ths->MEASURE_TIME_t[6] = K(0.0); \n  ths->MEASURE_TIME_t[7] = K(0.0); \n \n  t0 = getticks(); \n   \n \n  NFFT(adjoint)(&(ths->mv1)); \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[4] += NFFT(elapsed_seconds)(t1,t0); \n \n  t0 = getticks(); \n   \n \n  #pragma omp parallel for default(shared) private(k) \n  for (k = 0; k < ths->mv2.N_total; k++) \n    ths->mv2.f_hat[k] = ths->b[k] * ths->mv1.f_hat[k]; \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[5] += nfft_elapsed_seconds(t1,t0); \n \n  t0 = getticks(); \n   \n \n  NFFT(trafo)(&(ths->mv2)); \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[6] += nfft_elapsed_seconds(t1,t0); \n \n  t0 = getticks(); \n \n   \n \n  #pragma omp parallel for default(shared) private(j) \n  for (j = 0; j < ths->M_total; j++) \n    ths->f[j] = ths->mv2.f[j]; \n \n  if (ths->eps_I > 0.0) \n  { \n     \n \n  #ifdef _OPENMP \n    #pragma omp parallel for default(shared) private(j,k,t) \n  #endif \n    for (j = 0; j < ths->M_total; j++)                                                                                                                                                                                                                                                                                                                                                                                                          "}
{"label": " \nstatic void nn_(SpatialMaxPooling_updateOutput_frame)(real *input_p, real *output_p, \n                                                      real *ind_p, \n                                                      long nslices, \n                                                      long iwidth, long iheight, \n                                                      long owidth, long oheight, \n                                                      int kW, int kH, int dW, int dH, \n                                                      int padW, int padH) \n{ \n  long k; \n#pragma omp parallel for private(k) \n  for (k = 0; k < nslices; k++) \n  { \n     \n \n    long i, j; \n    real *ip = input_p   + k*iwidth*iheight; \n    for(i = 0; i < oheight; i++) \n    { \n      for(j = 0; j < owidth; j++) \n      { \n        long hstart = i * dH - padH; \n        long wstart = j * dW - padW; \n        long hend = fminf(hstart + kH, iheight); \n        long wend = fminf(wstart + kW, iwidth); \n        hstart = fmaxf(hstart, 0); \n        wstart = fmaxf(wstart, 0); \n \n         \n \n        real *op = output_p  + k*owidth*oheight + i*owidth + j; \n        real *indp = ind_p   + k*owidth*oheight + i*owidth + j; \n \n         \n \n        long maxindex = -1; \n        real maxval = -THInf; \n        long tcntr = 0; \n        long x,y; \n        for(y = hstart; y < hend; y++) \n        { \n          for(x = wstart; x < wend; x++) \n          { \n            tcntr = y*iwidth + x; \n            real val = *(ip + tcntr); \n            if (val > maxval) \n            { \n              maxval = val; \n              maxindex = tcntr; \n            } \n          } \n        } \n \n         \n \n        *op = maxval; \n \n         \n \n        *indp = maxindex + 1; \n      } \n    } \n  } \n} ", "pred": " \nstatic void nn_(SpatialMaxPooling_updateOutput_frame)(real *input_p, real *output_p, \n                                                      real *ind_p, \n                                                      long nslices, \n                                                      long iwidth, long iheight, \n                                                      long owidth, long oheight, \n                                                      int kW, int kH, int dW, int dH, \n                                                      int padW, int padH) \n{ \n  long k; \n#pragma omp parallel for private(k) \n  for (k = 0; k < nslices; k++) \n  { \n     \n \n    long i, j; \n    real *ip = input_p   + k*iwidth*iheight; \n    for(i = 0; i < oheight; i++) \n    { \n      for(j = 0; j < owidth; j++) \n      { \n        long hstart = i * dH - padH; \n        long wstart = j * dW - padW; \n        long hext = 0;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": "uct perturbs * ppt, \n    struct transfers * ptr, \n    struct primordial * ppm, \n    struct spectra * psp \n) { \n \n     \n \n \n     \n \n \n    int index_md; \n    int index_ic1,index_ic2,index_ic1_ic2; \n    int index_l; \n    int index_ct; \n    int cl_integrand_num_columns; \n \n    double * cl_integrand;  \n \n    double * transfer_ic1;  \n \n    double * transfer_ic2;  \n \n    double * primordial_pk;   \n \n \n     \n \n    int abort; \n \n     \n \n    double tstart, tstop; \n \n     \n \n \n    class_alloc(psp->l_size,sizeof(int)*psp->md_size,psp->error_message); \n    class_alloc(psp->cl,sizeof(double *)*psp->md_size,psp->error_message); \n    class_alloc(psp->ddcl,sizeof(double *)*psp->md_size,psp->error_message); \n \n    psp->l_size_max = ptr->l_size_max; \n    class_alloc(psp->l,sizeof(double)*psp->l_size_max,psp->error_message); \n \n     \n \n    for (index_l=0; index_l < psp->l_size_max; index_l++) { \n        psp->l[index_l] = (double)ptr->l[index_l]; \n    } \n \n     \n \n \n    for (index_md = 0; index_md < psp->md_size; index_md++) { \n \n         \n \n \n        psp->l_size[index_md] = ptr->l_size[index_md]; \n \n         \n \n \n        class_alloc(psp->cl[index_md],sizeof(double)*psp->l_size[index_md]*psp->ct_size*psp->ic_ic_size[index_md],psp->error_message); \n        class_alloc(psp->ddcl[index_md],sizeof(double)*psp->l_size[index_md]*psp->ct_size*psp->ic_ic_size[index_md],psp->error_message); \n        cl_integrand_num_columns = 1+psp->ct_size*2;  \n \n \n         \n \n \n        for (index_ic1 = 0; index_ic1 < psp->ic_size[index_md]; index_ic1++) { \n            for (index_ic2 = index_ic1; index_ic2 < psp->ic_size[index_md]; index_ic2++) { \n                index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,psp->ic_size[index_md]); \n \n                 \n \n                if (psp->is_non_zero[index_md][index_ic1_ic2] == _TRUE_) { \n \n                     \n \n                    abort = _FALSE_; \n \n                     \n \n \n                    #pragma omp parallel                                                                         shared(ptr,ppm,index_md,psp,ppt,cl_integrand_num_columns,index_ic1,index_ic2,abort)                      private(tstart,cl_integrand,primordial_pk,transfer_ic1,transfer_ic2,index_l,tstop) \n \n                    { \n \n                        tstart = omp_get_wtime(); \n \n                        class_alloc_parallel(cl_integrand, \n                                             ptr->q_size*cl_integrand_num_columns*sizeof(double), \n                                             psp->error_message); \n \n                        class_alloc_parallel(primordial_pk, \n                                             psp->ic_ic_size[index_md]*sizeof(double), \n                                             psp->error_message); \n \n                        class_alloc_parallel(transfer_ic1, \n                                             ptr->tt_size[index_md]*sizeof(double), \n                                             psp->error_message); \n \n                        class_alloc_parallel(transfer_ic2, \n                                             ptr->tt_size[index_md]*sizeof(double), \n                                             psp->error_message); \n \n                        #pragma omp for schedule (dynamic) \n \n                         \n \n \n                       ", "pred": "uct perturbs * ppt, \n    struct transfers * ptr, \n    struct primordial * ppm, \n    struct spectra * psp \n) { \n \n     \n \n \n     \n \n \n    int index_md; \n    int index_ic1,index_ic2,index_ic1_ic2; \n    int index_l; \n    int index_ct; \n    int cl_integrand_num_columns; \n \n    double * cl_integrand;  \n \n    double * transfer_ic1;  \n \n    double * transfer_ic2;  \n \n    double * primordial_pk;   \n \n \n     \n \n    int abort; \n \n     \n \n    double tstart, tstop; \n \n     \n \n \n    class_alloc(psp->l_size,sizeof(int)*psp->md_size,psp->error_message); \n    class_alloc(psp->cl,sizeof(double *)*psp->md_size,psp->error_message); \n    class_alloc(psp->ddcl,sizeof(double *)*psp->md_size,psp->error_message); \n \n    psp->l_size_max = ptr->l_size_max; \n    class_alloc(psp->l,sizeof(double)*psp->l_size_max,psp->error_message); \n \n     \n \n    for (index_l=0; index_l < psp->l_size_max; index_l++) { \n        psp->l[index_l] = (double)ptr->l[index_l]; \n    } \n \n     \n \n \n    for (index_md = 0; index_md < psp->md_size; index_md++) { \n \n         \n \n \n        psp->l_size[index_md] = ptr->l_size[index_md]; \n \n         \n \n \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "}
{"label": " \nstatic void fastsum_precompute_kernel(fastsum_plan *ths) \n{ \n  int j, k, t; \n  INT N[ths->d]; \n  int n_total; \n  ticks t0, t1; \n \n  ths->MEASURE_TIME_t[0] = K(0.0); \n \n  t0 = getticks(); \n   \n \n  if (ths->eps_I > 0.0 &&!(ths->flags & EXACT_NEARFIELD)) \n  { \n    if (ths->d == 1) \n      #pragma omp parallel for default(shared) private(k) \n      for (k = -ths->Ad / 2 - 2; k <= ths->Ad / 2 + 2; k++) \n        ths->Add[k + ths->Ad / 2 + 2] = regkern1(ths->k, \n            ths->eps_I * (R) k / (R)(ths->Ad) * K(2.0), ths->p, ths->kernel_param, \n            ths->eps_I, ths->eps_B); \n    else \n      #pragma omp parallel for default(shared) private(k) \n      for (k = 0; k <= ths->Ad + 2; k++) \n        ths->Add[k] = regkern3(ths->k, ths->eps_I * (R) k / (R)(ths->Ad), ths->p, \n            ths->kernel_param, ths->eps_I, ths->eps_B); \n  } \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[0] += NFFT(elapsed_seconds)(t1,t0); \n \n  t0 = getticks(); \n   \n \n  n_total = 1; \n  for (t = 0; t < ths->d; t++) \n    n_total *= ths->n; \n \n  #pragma omp parallel for default(shared) private(j,k,t) \n  for (j = 0; j < n_total; j++) \n  { \n    if (ths->d == 1) \n      ths->b[j] = regkern1(ths->k, (R) - (j / (R)(ths->n) - K(0.5)), ths->p, \n          ths->kernel_param, ths->eps_I, ths->eps_B) / (R)(n_total); \n    else \n    { \n      k = j; \n      ths->b[j] = K(0.0); \n      for (t = 0; t < ths->d; t++) \n      { \n        ths->b[j] += ((R) (k % (ths->n)) / (R)(ths->n) - K(0.5)) \n            * ((R) (k % (ths->n)) / (R)(ths->n) - K(0.5)); \n        k = k / (ths->n); \n      } \n      ths->b[j] = regkern3(ths->k, SQRT(CREAL(ths->b[j])), ths->p, ths->kernel_param, \n          ths->eps_I, ths->eps_B) / (R)(n_total); \n    } \n  } \n \n  for (t = 0; t < ths->d; t++) \n    N[t] = ths->n; \n \n  NFFT(fftshift_complex)(ths->b, (int)(ths->d), N); \n  FFTW(execute)(ths->fft_plan); \n  NFFT(fftshift_complex)(ths->b, (int)(ths->d), N); \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[0] += nfft_elapsed_seconds(t1,t0); \n} ", "pred": " \nstatic void fastsum_precompute_kernel(fastsum_plan *ths) \n{ \n  int j, k, t; \n  INT N[ths->d]; \n  int n_total; \n  ticks t0, t1; \n \n  ths->MEASURE_TIME_t[0] = K(0.0); \n \n  t0 = getticks(); \n   \n \n  if (ths->eps_I > 0.0 &&!(ths->flags & EXACT_NEARFIELD)) \n  { \n    if (ths->d == 1) \n      #pragma omp parallel for default(shared) private(k) \n      for (k = -ths->Ad / 2 - 2; k <= ths->Ad / 2 + 2; k++) \n        ths->Add[k + ths->Ad / 2 + 2] = regkern1(ths->k, \n            ths->eps_I * (R) k / (R)(ths->Ad) * K(2.0), ths->p, ths->kernel_param, \n            ths->eps_I, ths->eps_B); \n    else \n      #pragma omp parallel for default(shared) private(k) \n      for (k = 0; k <= ths->Ad + 2; k++) \n        ths->Add[k] = regkern3(ths->k, ths->eps_I * (R) k / (R)(ths->Ad), ths->p, \n            ths->kernel_param, ths->eps_I, ths->eps_B); \n  } \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[0] += NFFT(elapsed_seconds)(t1,t0); \n \n  t0 = getticks(); \n   \n \n  n_total = 1; \n  for (t = 0; t < ths->d; t++) \n    n_total *= ths->n; \n \n  #pragma omp parallel for default(shared) private(j,k,t) \n  for (j = 0; j < n_total; j++)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 4; \n  tile_size[1] = 4; \n  tile_size[2] = 8; \n  tile_size[3] = 256; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0765; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,2);t1++) { \n    lbp=max(ceild(t1,2),ceild(4*t1-Nt+3,4)); \n    ubp=min(floord(Nt+Nz-4,4),floord(2*t1+Nz-1,4)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-3,4)),ceild(4*t2-Nz-4,8));t3<=min(min(min(floord(4*t2+Ny,8),floord(Nt+Ny-4,8)),floord(2*t1+Ny+1,8)),floord(4*t1-4*t2+Nz+Ny-1,8));t3++) { \n        for (t4=max(max(max(0,ceild(t1-127,128)),ceild(4*t2-Nz-252,256)),ceild(8*t3-Ny-252,256));t4<=min(min(min(min(floord(4*t2+Nx,256),floord(Nt+Nx-4,256)),floord(2*t1+Nx+1,256)),floord(8*t3+Nx+4,256)),floord(4*t1-4*t2+Nz+Nx-1,256));t4++) { \n          for (t5=max(max(max(max(max(0,2*t1),4*t1-4*t2+1),4*t2-Nz+2),8*t3-Ny+2),256*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,2*t1+3),4*t2+2),8*t3+6),256*t4+254),4*t1-4*t2+Nz+1);t5++) { \n            for (t6=max(max(4*t2,t5+1),-4*t1+4*t2+2*t5-3);t6<=min(min(4*t2+3,-4*t1+4*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(8*t3,t5+1);t7<=min(8*t3+7,t5+Ny-2);t7++) { \n                lbv=max(256*t4,t5+1); \n                ubv=min(256*t4+255,t5+Nx-2); \n#pragma ivdep \n#pragma vector always \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = ((alpha * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (beta * (((((A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)] + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) - 1][ (-t5+t8)]) + A", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 4; \n  tile_size[1] = 4; \n  tile_size[2] = 8; \n  tile_size[3] = 256; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0876;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "}
{"label": " \nvoid kappa_beams_preproc(ParamCoLoRe *par) \n{ \n   \n \n  int ir; \n  flouble *r0_i=my_malloc(par->kmap->nr*sizeof(flouble)); \n  flouble *rf_i=my_malloc(par->kmap->nr*sizeof(flouble)); \n \n  memcpy(r0_i,par->kmap->r0,par->kmap->nr*sizeof(flouble)); \n  memcpy(rf_i,par->kmap->rf,par->kmap->nr*sizeof(flouble)); \n \n  int *i_sorted=ind_sort(par->kmap->nr,par->kmap->r0); \n  for(ir=0;ir<par->kmap->nr;ir++) { \n    par->kmap->r0[ir]=r0_i[i_sorted[ir]]; \n    par->kmap->rf[ir]=rf_i[i_sorted[ir]]; \n  } \n  free(r0_i); \n  free(rf_i); \n  free(i_sorted); \n \n   \n \n#pragma omp parallel default(none)     shared(par) \n \n  { \n    long ipp; \n \n#pragma omp for \n \n    for(ipp=0;ipp<par->kmap->num_pix*par->kmap->nr;ipp++) { \n      par->kmap->data[ipp]=0; \n      par->kmap->nadd[ipp]=1; \n    }  \n \n  }  \n \n \n  return; \n} ", "pred": " \nvoid kappa_beams_preproc(ParamCoLoRe *par) \n{ \n   \n \n  int ir; \n  flouble *r0_i=my_malloc(par->kmap->nr*sizeof(flouble)); \n  flouble *rf_i=my_malloc(par->kmap->nr*sizeof(flouble)); \n \n  memcpy(r0_i,par->kmap->r0,par->kmap->nr*sizeof(flouble)); \n  memcpy(rf_i,par->kmap->rf,par->kmap->nr*sizeof(flouble)); \n \n  int *i_sorted=ind_sort(par->kmap->nr,par->kmap->r0); \n  for(ir=0;ir<par->kmap->nr;ir++) { \n    par->kmap->r0[ir]=r0_i[i_sorted[ir]]; \n    par->kmap->rf[ir]=rf_i[i_sorted[ir]]; \n  } \n  free(r0_i); \n  free(rf_i); \n  free(i_sorted); \n \n   \n \n#pragma omp parallel default(none)     shared(par) \n \n  { \n    long ipp; \n \n#pragma omp for \n \n    for(ipp=0;ipp<par->kmap->num_pix*par->kmap->nr;ipp++) { \n      par->kmap->data[ipp]=0; \n      par->kmap->nadd[ipp]=1; \n    }  \n \n  }  \n \n \n  return; \n} "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n  const dt_iop_temperature_data_t *const d = (dt_iop_temperature_data_t *)piece->data; \n \n  const float *const in = (const float *const)ivoid; \n  float *const out = (float *const)ovoid; \n \n  if(filters == 9u) \n  {  \n \n#pragma omp parallel for SIMD() default(none)      dt_omp_firstprivate(d, in, out, roi_out, xtrans)      schedule(static)      collapse(2) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t p = (size_t)j * roi_out->width + i; \n        out[p] = in[p] * d->coeffs[FCxtrans(j, i, roi_out, xtrans)]; \n      } \n    } \n  } \n  else if(filters) \n  {  \n \n#pragma omp parallel for SIMD() default(none)      dt_omp_firstprivate(d, filters, in, out, roi_out)      schedule(static)      collapse(2) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t p = (size_t)j * roi_out->width + i; \n        out[p] = in[p] * d->coeffs[FC(j + roi_out->y, i + roi_out->x, filters)]; \n      } \n    } \n  } \n  else \n  {  \n \n    const int ch = piece->colors; \n \n#pragma omp parallel for SIMD() default(none)      dt_omp_firstprivate(ch, d, in, out, roi_out)      schedule(static)      collapse(2) \n    for(size_t k = 0; k < (size_t)ch * roi_out->width * roi_out->height; k += ch) \n    { \n      for(int c = 0; c < 3; c++) \n      { \n        const size_t p = (size_t)k + c; \n        out[p] = in[p] * d->coeffs[c]; \n      } \n    } \n \n    if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out->width, roi_out->height); \n  } \n \n  piece->pipe->dsc.temperature.enabled = 1; \n  for(int k = 0; k < 4; k++) \n  { \n    piece->pipe->dsc.temperature.coeffs[k] = d->coeffs[k]; \n    piece->pipe->dsc.processed_maximum[k] = d->coeffs[k] * piece->pipe->dsc.processed_maximum[k]; \n  } \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n  const dt_iop_temperature_data_t *const d = (dt_iop_temperature_data_t *)piece->data; \n \n  const float *const in = (const float *const)ivoid; \n  float *const out = (float *const)ovoid; \n \n  if(filters == 9u) \n  {  \n \n#pragma omp parallel for SIMD() default(none)      dt_omp_firstprivate(d, in, out, roi_out, xtrans)      schedule(static)      collapse(2) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t p = (size_t)j * roi_out->width + i; \n        out[p] = in[p] * d->coeffs[FCxtrans(j, i, roi_out, xtrans)]; \n      } \n    } \n  } \n  else if(filters) \n  {  \n \n#pragma omp parallel for SIMD() default(none)      dt_omp_firstprivate(d, filters, in, out, roi_out)      schedule(static)      collapse(2) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "}
{"label": " \nvoid fastsum_exact(fastsum_plan *ths) \n{ \n  int j, k; \n  int t; \n  R r; \n \n  #pragma omp parallel for default(shared) private(j,k,t,r) \n  for (j = 0; j < ths->M_total; j++) \n  { \n    ths->f[j] = K(0.0); \n    for (k = 0; k < ths->N_total; k++) \n    { \n      if (ths->d == 1) \n        r = ths->y[j] - ths->x[k]; \n      else \n      { \n        r = K(0.0); \n        for (t = 0; t < ths->d; t++) \n          r += (ths->y[j * ths->d + t] - ths->x[k * ths->d + t]) \n              * (ths->y[j * ths->d + t] - ths->x[k * ths->d + t]); \n        r = SQRT(r); \n      } \n      ths->f[j] += ths->alpha[k] * ths->k(r, 0, ths->kernel_param); \n    } \n  } \n} ", "pred": " \nvoid fastsum_exact(fastsum_plan *ths) \n{ \n  int j, k; \n  int t; \n  R r; \n \n  #pragma omp parallel for default(shared) private(j,k,t,r) \n  for (j = 0; j < ths->M_total; j++) \n  { \n    ths->f[j] = K(0.0); \n    for (k = 0; k < ths->N_total; k++) \n    { \n      if (ths->d == 1) \n        r = ths->y[j] - ths->x[k]; \n      else \n      { \n        r = K(0.0); \n        for (t = 0; t < ths->d; t++) \n          r += (ths->y[j * ths->d + t] - ths->x[k * ths->d + t]) \n              * (ths->y[j * ths->d + t] - ths->x[k * ths->d + t]); \n        r = SQRT(r); \n      } \n      ths->f[j] += ths->alpha[k] * ths->k(r, 0, ths->kernel_param); \n    } \n  } \n} "}
{"label": " \nvoid TrainBatch(LeNet5 *lenet, image *inputs, uint8 *labels, int batchSize) \n{ \n\tdouble buffer[GETCOUNT(LeNet5)] = { 0 }; \n\tint i = 0; \n#pragma omp parallel for \n\tfor (i = 0; i < batchSize; ++i) \n\t{ \n\t\tFeature features = { 0 }; \n\t\tFeature errors = { 0 }; \n\t\tLeNet5\tdeltas = { 0 }; \n\t\tload_input(&features, inputs[i]); \n\t\tforward(lenet, &features, relu); \n\t\tload_target(&features, &errors, labels[i]); \n\t\tbackward(lenet, &deltas, &errors, &features, relugrad); \n  #pragma omp critical \n\t\t{ \n\t\t\tFOREACH(j, GETCOUNT(LeNet5)) \n\t\t\t\tbuffer[j] += ((double *)&deltas)[j]; \n\t\t} \n\t} \n\tdouble k = ALPHA / batchSize; \n\tFOREACH(i, GETCOUNT(LeNet5)) \n\t\t((double *)lenet)[i] += k * buffer[i]; \n} ", "pred": " \nvoid TrainBatch(LeNet5 *lenet, image *inputs, uint8 *labels, int batchSize) \n{ \n\tdouble buffer[GETCOUNT(LeNet5)] = { 0 }; \n\tint i = 0; \n#pragma omp parallel for \n\tfor (i = 0; i < batchSize; ++i) \n\t{ \n\t\tFeature features = { 0 }; \n\t\tFeature errors = { 0 }; \n\t\tLeNet5\tdeltas = { 0 }; \n\t\tload_input(&features, inputs[i]); \n\t\tforward(lenet, &features, relu); \n\t\tload_target(&features, &errors, labels[i]); \n\t\tbackward(lenet, &deltas, &errors, &features, relugrad); \n  #pragma omp critical \n\t\t{ \n\t\t\tFOREACH(j, GETCOUNT(LeNet5)) \n\t\t\t\tbuffer[j] += ((double *)&deltas)[j]; \n\t\t} \n\t} \n\tdouble k = ALPHA / batchSize; \n\tFOREACH(i, GETCOUNT(LeNet5)) \n\t\t((double *)lenet)[i] += k * buffer[i]; \n} "}
{"label": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n  dt_iop_temperature_data_t *d = (dt_iop_temperature_data_t *)piece->data; \n  if(filters == 9u) \n  {  \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(ivoid, ovoid, roi_out, xtrans)      shared(d)      schedule(static) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)j * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)j * roi_out->width; \n \n      int i = 0; \n      const int alignment = ((4 - (j * roi_out->width & (4 - 1))) & (4 - 1)); \n \n       \n \n      for(; i < alignment && i < roi_out->width; i++, out++, in++) \n        *out = *in * d->coeffs[FCxtrans(j, i, roi_out, xtrans)]; \n \n      const __m128 coeffs[3] = { \n        _mm_set_ps(d->coeffs[FCxtrans(j, i + 3, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 2, roi_out, xtrans)], \n                   d->coeffs[FCxtrans(j, i + 1, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 0, roi_out, xtrans)]), \n        _mm_set_ps(d->coeffs[FCxtrans(j, i + 7, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 6, roi_out, xtrans)], \n                   d->coeffs[FCxtrans(j, i + 5, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 4, roi_out, xtrans)]), \n        _mm_set_ps(d->coeffs[FCxtrans(j, i + 11, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 10, roi_out, xtrans)], \n                   d->coeffs[FCxtrans(j, i + 9, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 8, roi_out, xtrans)]) \n      }; \n \n       \n \n      for(int c = 0; c < 3 && i < roi_out->width - (4 - 1); c++, i += 4, in += 4, out += 4) \n      { \n        __m128 v; \n \n        v = _mm_load_ps(in); \n        v = _mm_mul_ps(v, coeffs[c]); \n        _mm_stream_ps(out, v); \n      } \n \n       \n \n      for(; i < roi_out->width; i++, out++, in++) *out = *in * d->coeffs[FCxtrans(j, i, roi_out, xtrans)]; \n    } \n    _mm_sfence(); \n  } \n  else if(filters) \n  {  \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(filters, ivoid, ovoid, roi_out)      shared(d)      schedule(static) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)j * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)j * roi_out->width; \n \n      int i = 0; \n      const int alignment = ((4 - (j * roi_out->width & (4 - 1))) & (4 - 1)); \n \n       \n \n      for(; i < alignment && i < roi_out->width; i++, out++, in++) \n        *out = *in * d->coeffs[FC(j + roi_out->y, i + roi_out->x, filters)]; \n \n      const __m128 coeffs = _mm_set_ps(d->coeffs[FC(j + roi_out->y, roi_out->x + i + 3, filters)], \n                                       d->coeffs[FC(j + roi_out->y, roi_out->x + i + 2, filters)], \n                                       d->coeffs[FC(j + roi_out->y, roi_out->x + i + 1, filters)], \n                                       d->coeffs[FC(j + roi_out->y, roi_out->x + i, filters)]); \n \n       \n \n      for(; i < roi_out->width - (4 - 1); i += 4, in += 4, out += 4) \n      { \n        const __m128 input = _mm_load_ps(in); \n \n        const __m128 multiplied = _mm_mul_ps(input, coeffs); \n \n        _mm_stream_ps(out, multiplied); \n      } \n \n       \n \n      for(; i < roi_out->width; i++, out++, in++) \n        *out = *in * d->coeffs[FC(j + roi_out->y, i + roi_out->x, filters)]; \n    } \n    _mm_sfence(); \n  } \n  else \n  {  \n \n    const int ch = piece->colors; \n \n    const __m128 co", "pred": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n  dt_iop_temperature_data_t *d = (dt_iop_temperature_data_t *)piece->data; \n  if(filters == 9u) \n  {  \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(ivoid, ovoid, roi_out, xtrans)      shared(d)      schedule(static) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)j * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)j * roi_out->width; \n \n      int i = 0; \n      const int alignment = ((4 - (j * roi_out->width & (4 - 1))) & (4 - 1)); \n \n       \n \n      for(; i < alignment && i < roi_out->width; i++, out++, in++) \n        *out = *in * d->coeffs[FCxtrans(j, i, roi_out, xtrans)]; \n \n      const __m128 coeffs[3] = { \n        _mm_set_ps(d->coeffs[FCxtrans(j, i + 3, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 2, roi_out, xtrans)], \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   "}
{"label": "nt loadAncAll_mp(struct ind_map *matmap, long int col, FILE *i_a, int nt) \n{ \n \n \n \n \nchar *buf; \nchar *buf_split, *spf; \nlong int line=0,tot=0; \nlong int i; \nlong int size_buf=200; \n \nchar tmp[200]; \nchar al; \nchar rs[200]; \n \nint iCPU = omp_get_num_procs(); \n \nif (nt>iCPU){nt=iCPU;} \nomp_set_num_threads(nt); \n \n \nbuf=malloc(size_buf*sizeof(char)); \nprintf(\"\\nStart reading ancestral allele state file...\\n\"); \nwhile (fgets(buf,size_buf,i_a)!=NULL){ \n\tline++; \n\tprintf(\"\\nAnc all line %ld\",line); \n\tif (strchr(buf,' ')==NULL & strchr(buf,'\\t')==NULL ){printf(\"ERROR: loadAncAll: wrong separator character in line %ld. Please use only TAB or SPACE.\\n\",line);return 1;} \n\tchoppy(buf); \n\tbuf_split=strtok_r(buf,\" \\t\",&spf); \n\tstrcpy(rs,buf_split); \n\tbuf_split=strtok_r(NULL,\" \\t\",&spf); \n\tal=*buf_split; \n #pragma omp parallel for private(i,tmp,rs,al,line) reduction(+:tot) \n\tfor (i=0;i<col;i++){ \n\t\t \n \n\t\tstrncpy(tmp,\"rs\",3); \n\t\tstrcat(tmp, rs); \n\t\tif (strcmp(matmap[i].rs,tmp)==0){ \n\t\t\t \n \n\t\t\tmatmap[i].anc=al; \n\t\t\ttot++; \n\t\t\tprintf(\"\\nLine %ld - Found match! rs:%s Tot match1\",line,rs); \n\t\t\t \n \n\t\t} \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t} \n\t \n \nif (line==10000){ \nprintf(\"\\ntot %ld\",tot); \nbreak;} \n} \nif (tot!=col){printf(\"WARNING: loadAncAll: some SNPs have no ancestral allele information. (%ld SNPs with allele information - %ld SNPs in total).\\n\",tot,col);} \nelse{printf(\"\\nAncestral state loaded for %ld/%ld SNPs\",tot,col);} \nreturn 0; \nprintf(\"\\nStart reading ancestral allele state file...done!\"); \nfree(buf); \n} \n \n ", "pred": "nt loadAncAll_mp(struct ind_map *matmap, long int col, FILE *i_a, int nt) \n{ \n \n \n \n \nchar *buf; \nchar *buf_split, *spf; \nlong int line=0,tot=0; \nlong int i; \nlong int size_buf=200; \n \nchar tmp[200]; \nchar al; \nchar rs[200]; \n \nint iCPU = omp_get_num_procs(); \n \nif (nt>iCPU){nt=iCPU;} \nomp_set_num_threads(nt); \n \n \nbuf=malloc(size_buf*sizeof(char)); \nprintf(\"\\nStart reading ancestral allele state file...\\n\"); \nwhile (fgets(buf,size_buf,i_a)!=NULL){ \n\tline++; \n\tprintf(\"\\nAnc all line %ld\",line); \n\tif (strchr(buf,' ')==NULL & strchr(buf,'\\t')==NULL ){printf(\"ERROR: loadAncAll: wrong separator character in line %ld. Please use only TAB or SPACE.\\n\",line);return 1;} \n\tchoppy(buf); \n\tbuf_split=strtok_r(buf,\" \\t\",&spf); \n\tstrcpy(rs,buf_split); \n\tbuf_split=strtok_r(NULL,\" \\t\",&spf); \n\tal=*buf_split; \n #pragma omp parallel for private(i,tmp,rs,al,line) reduction(+:tot) \n\tfor (i=0;i<col;i++){ \n\t\t \n \n\t\tstrncpy(tmp,\"rs\",3); \n\t\tstrcat(tmp, rs); \n\t\tif (strcmp(matmap[i].rs,tmp)==0){ \n\t\t\t \n \n\t\t\tmatmap[i].anc=al; \n\t\t\ttot++; \n\t\t\tprintf(\"\\nLine %ld - Found match! rs:%s Tot match1\",line,rs); \n\t\t\t \n \n\t\t} \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t} \n\t \n \nif (line==10000){ \nprintf(\"\\ntot %ld\",tot); \nbreak;} \n} \n{\"username(\\\"test_c/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test"}
{"label": " \nstatic void nn_(SpatialMaxPooling_updateGradInput_frame)(real *gradInput_p, real *gradOutput_p, \n                                                         real *ind_p, \n                                                         long nslices, \n                                                         long iwidth, long iheight, \n                                                         long owidth, long oheight, \n                                                         int dW, int dH) \n{ \n  long k; \n#pragma omp parallel for private(k) \n  for (k = 0; k < nslices; k++) \n  { \n    real *gradInput_p_k = gradInput_p + k*iwidth*iheight; \n    real *gradOutput_p_k = gradOutput_p + k*owidth*oheight; \n    real *ind_p_k = ind_p + k*owidth*oheight; \n \n     \n \n    long i, j; \n    for(i = 0; i < oheight; i++) \n    { \n      for(j = 0; j < owidth; j++) \n      { \n         \n \n        long maxp = ind_p_k[i*owidth + j] - 1; \n         \n \n        gradInput_p_k[maxp] += gradOutput_p_k[i*owidth + j]; \n      } \n    } \n  } \n} ", "pred": " \nstatic void nn_(SpatialMaxPooling_updateGradInput_frame)(real *gradInput_p, real *gradOutput_p, \n                                                         real *ind_p, \n                                                         long nslices, \n                                                         long iwidth, long iheight, \n                                                         long owidth, long oheight, \n                                                         int dW, int dH) \n{ \n  long k; \n#pragma omp parallel for private(k) \n  for (k = 0; k < nslices; k++) \n  { \n    real *gradInput_p_k = gradInput_p + k*iwidth*iheight; \n    real *gradOutput_p_k = gradOutput_p + k*owidth*oheight; \n    real *ind_p_k = ind_p + k*owidth*oheight; \n \n     \n \n    long i, j; \n    for(i = 0; i < oheight; i++) \n    { \n      for(j = 0; j < owidth; j++) \n      { \n         \n \n        long maxp = ind_p_k[i*owidth + j] - 1; \n                                                                  "}
{"label": " \nvoid \nfoo (int a, int b, int c) \n{ \n  int i; \n  #pragma omp parallel \n  #pragma omp for reduction (task, *: j) schedule (nonmonotonic: runtime) \n  for (i = a; i < b; i += c) \n    { \n      j++; \n      bar (&j); \n    } \n} ", "pred": " \nvoid \nfoo (int a, int b, int c) \n{ \n  int i; \n  #pragma omp parallel \n  #pragma omp for reduction (task, *: j) schedule (nonmonotonic: runtime) \n  for (i = a; i < b; i += c) \n    { \n      j++; \n      bar (&j); \n    } \n} "}
{"label": " \nstatic int nn_(SpatialMaxPooling_updateOutput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  int kW = luaT_getfieldcheckint(L, 1, \"kW\"); \n  int kH = luaT_getfieldcheckint(L, 1, \"kH\"); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n  int padW = luaT_getfieldcheckint(L, 1, \"padW\"); \n  int padH = luaT_getfieldcheckint(L, 1, \"padH\"); \n  int ceil_mode = luaT_getfieldcheckboolean(L,1,\"ceil_mode\"); \n  THTensor *indices = luaT_getfieldcheckudata(L, 1, \"indices\", torch_Tensor); \n  THTensor *output = luaT_getfieldcheckudata(L, 1, \"output\", torch_Tensor); \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  long nslices; \n  long iheight; \n  long iwidth; \n  long oheight; \n  long owidth; \n  real *input_data; \n  real *output_data; \n  real *indices_data; \n \n \n  luaL_argcheck(L, input->nDimension == 3 || input->nDimension == 4, 2, \"3D or 4D (batch mode) tensor expected\"); \n \n  if (input->nDimension == 4)  \n  { \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n  luaL_argcheck(L, input->size[dimw] >= kW - padW && input->size[dimh] >= kH - padH, 2, \"input image smaller than kernel size\"); \n \n  luaL_argcheck(L, kW/2 >= padW && kH/2 >= padH, 2, \"pad should be smaller than half of kernel size\"); \n \n   \n \n  nslices = input->size[dimh-1]; \n  iheight = input->size[dimh]; \n  iwidth = input->size[dimw]; \n  if (ceil_mode) \n  { \n    oheight = (long)(ceil((float)(iheight - kH + 2*padH) / dH)) + 1; \n    owidth  = (long)(ceil((float)(iwidth  - kW + 2*padW) / dW)) + 1; \n  } \n  else \n  { \n    oheight = (long)(floor((float)(iheight - kH + 2*padH) / dH)) + 1; \n    owidth  = (long)(floor((float)(iwidth  - kW + 2*padW) / dW)) + 1; \n  } \n \n  if (padW || padH) \n  { \n     \n \n    if ((oheight - 1)*dH >= iheight + padH) \n      --oheight; \n    if ((owidth  - 1)*dW >= iwidth  + padW) \n      --owidth; \n  } \n \n   \n \n  input = THTensor_(newContiguous)(input); \n \n   \n \n  if (input->nDimension == 3) \n  { \n    THTensor_(resize3d)(output, nslices, oheight, owidth); \n     \n \n    THTensor_(resize3d)(indices,  nslices, oheight, owidth); \n \n    input_data = THTensor_(data)(input); \n    output_data = THTensor_(data)(output); \n    indices_data = THTensor_(data)(indices); \n \n    nn_(SpatialMaxPooling_updateOutput_frame)(input_data, output_data, \n                                              indices_data, \n                                              nslices, \n                                              iwidth, iheight, \n                                              owidth, oheight, \n                                              kW, kH, dW, dH, \n                                              padW, padH); \n  } \n  else \n  { \n    long p; \n \n    THTensor_(resize4d)(output, nbatch, nslices, oheight, owidth); \n     \n \n    THTensor_(resize4d)(indices, nbatch, nslices, oheight, owidth); \n \n    input_data = THTensor_(data)(input); \n    output_data = THTensor_(data)(output); \n    indices_data = THTensor_(data)(indices); \n \n#pragma omp parallel for private(p) \n    for (p = 0; p < nbatch; p++) \n    { \n      nn_(SpatialMaxPooling_updateOutput_frame)(input_data+p*nslices*iwidth*iheight, output_data+p*nslices*owidth*oheight, \n                                                indices_data+p*nslices*owidth*oheight, \n                                                nslices, \n                                                iwidth, iheight, \n                                                owidth, oheight, \n                                                kW, kH, dW, dH, \n                                                padW, padH); \n    } \n  } \n \n   \n \n  THTensor_(free)(input); \n  return 1; \n} ", "pred": " \nstatic int nn_(SpatialMaxPooling_updateOutput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  int kW = luaT_getfieldcheckint(L, 1, \"kW\"); \n  int kH = luaT_getfieldcheckint(L, 1, \"kH\"); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n  int padW = luaT_getfieldcheckint(L, 1, \"padW\"); \n  int padH = luaT_getfieldcheckint(L, 1, \"padH\"); \n  int ceil_mode = luaT_getfieldcheckboolean(L,1,\"ceil_mode\"); \n  THTensor *indices = luaT_getfieldcheckudata(L, 1, \"indices\", torch_Tensor); \n  THTensor *output = luaT_getfieldcheckudata(L, 1, \"output\", torch_Tensor); \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  long nslices; \n  long iheight; \n  long iwidth; \n  long oheight; \n  long owidth; \n  real *input_data; \n  real *output_data; \n  real *indices_data; \n \n \n  luaL_argcheck(L, input->nDimension == 3 || input->nDimension == 4, 2, \"3D or 4D (batch mode) tensor expected\"); \n \n  if (input->nDimension == 4)  \n  { \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n  luaL_argcheck(L, input->size[dimw] >= kW - padW && input->size[dimh] >= kH - padH, 2, \"input image smaller than kernel size\"); \n \n  luaL_argcheck(L, kW/2 >= padW && kH/2 >= padH, 2, \"pad should be smaller than half of kernel size\"); \n \n   \n \n  nslices = input->size[dimh-1]; \n  iheight = input->size[dimh-1];                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "}
{"label": " \nstatic int nn_(SpatialMaxPooling_updateGradInput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor *gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n  THTensor *indices = luaT_getfieldcheckudata(L, 1, \"indices\", torch_Tensor); \n  THTensor *gradInput = luaT_getfieldcheckudata(L, 1, \"gradInput\", torch_Tensor); \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  int nslices; \n  int iheight; \n  int iwidth; \n  int oheight; \n  int owidth; \n  real *gradInput_data; \n  real *gradOutput_data; \n  real *indices_data; \n \n   \n \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n \n   \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(zero)(gradInput); \n \n  if (input->nDimension == 4) { \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n   \n \n  nslices = input->size[dimh-1]; \n  iheight = input->size[dimh]; \n  iwidth = input->size[dimw]; \n  oheight = gradOutput->size[dimh]; \n  owidth = gradOutput->size[dimw]; \n \n   \n \n  gradInput_data = THTensor_(data)(gradInput); \n  gradOutput_data = THTensor_(data)(gradOutput); \n  indices_data = THTensor_(data)(indices); \n \n   \n \n  if (input->nDimension == 3) \n  { \n    nn_(SpatialMaxPooling_updateGradInput_frame)(gradInput_data, gradOutput_data, \n                                                 indices_data, \n                                                 nslices, \n                                                 iwidth, iheight, \n                                                 owidth, oheight, \n                                                 dW, dH); \n  } \n  else \n  { \n    long p; \n#pragma omp parallel for private(p) \n    for (p = 0; p < nbatch; p++) \n    { \n      nn_(SpatialMaxPooling_updateGradInput_frame)(gradInput_data+p*nslices*iwidth*iheight, gradOutput_data+p*nslices*owidth*oheight, \n                                                   indices_data+p*nslices*owidth*oheight, \n                                                   nslices, \n                                                   iwidth, iheight, \n                                                   owidth, oheight, \n                                                   dW, dH); \n    } \n  } \n \n   \n \n  THTensor_(free)(gradOutput); \n \n  return 1; \n} ", "pred": " \nstatic int nn_(SpatialMaxPooling_updateGradInput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor *gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n  THTensor *indices = luaT_getfieldcheckudata(L, 1, \"indices\", torch_Tensor); \n  THTensor *gradInput = luaT_getfieldcheckudata(L, 1, \"gradInput\", torch_Tensor); \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  int nslices; \n  int iheight; \n  int iwidth; \n  int oheight; \n  int owidth; \n  real *gradInput_data; \n  real *gradOutput_data; \n  real *indices_data; \n \n   \n \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n \n   \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(zero)(gradInput); \n \n  if (input->nDimension == 4) { \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n   \n \n  nslices = input->size[dimh-1]; \n  iheight = input->size[dimh]; \n  iwidth = input->size[dimw]; \n  oheight = gradOutput->size[dimh]; \n  owidth = gradOutput->size[dimw]; \n \n   \n \n  gradInput_data = THTensor_(data)(gradInput); \n  gradOutput_data = THTensor_(data)(gradOutput); \n  indices_data = THTensor_(data)(indices); \n \n   \n \n  if (input->nDimension == 3) \n  { \n    nn_(SpatialMaxPooling_updateGradInput_frame)(gradInput_data, gradOutput_data, \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \nvoid THNN_(HardTanh_updateOutput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *output, \n          real min_val, \n          real max_val) \n{ \n  THTensor_(resizeAs)(output, input); \n   \n  if (input->nDimension == 1 ||!THTensor_(isContiguous)(input) ||!THTensor_(isContiguous)(output)) \n  { \n    TH_TENSOR_APPLY2(real, output, real, input, \n      if (*input_data < min_val) \n        *output_data = min_val; \n      else if (*input_data <= max_val) \n        *output_data = *input_data; \n      else \n        *output_data = max_val; \n    ); \n  } \n  else \n  { \n    real* ptr_output = THTensor_(data)(output); \n    real* ptr_input  = THTensor_(data)(input); \n    long i; \n \n#pragma omp parallel for private(i) \n    for (i = 0; i < THTensor_(nElement)(input); i++) \n    { \n      if (ptr_input[i] < min_val) \n        ptr_output[i] = min_val; \n      else if (ptr_input[i] <= max_val) \n        ptr_output[i] = ptr_input[i]; \n      else \n        ptr_output[i] = max_val; \n    } \n  } \n} ", "pred": " \nvoid THNN_(HardTanh_updateOutput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *output, \n          real min_val, \n          real max_val) \n{ \n  THTensor_(resizeAs)(output, input); \n   \n  if (input->nDimension == 1 ||!THTensor_(isContiguous)(input) ||!THTensor_(isContiguous)(output)) \n  { \n    TH_TENSOR_APPLY2(real, output, real, input, \n      if (*input_data < min_val) \n        *output_data = min_val; \n      else if (*input_data <= max_val) \n        *output_data = *input_data; \n      else \n        *output_data = max_val; \n    ); \n  } \n  else \n  { \n    real* ptr_output = THTensor_(data)(output); \n    real* ptr_input  = THTensor_(data)(input); \n    long i; \n \n#pragma omp parallel for private(i) \n    for (i = 0; i < THTensor_(nElement)(input); i++) \n    { \n      if (ptr_input[i] < min_val) \n        ptr_output[i] = min_val; \n      else if (ptr_input[i] <= max_val) \n        ptr_output[i] = ptr_input[i]; \n      else \n        ptr_output[i] = max_val; \n    } \n  } \n} "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 16; \n  tile_size[3] = 512; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0765; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,4);t1++) { \n    lbp=max(ceild(t1,2),ceild(8*t1-Nt+3,8)); \n    ubp=min(floord(Nt+Nz-4,8),floord(4*t1+Nz+1,8)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-3,4)),ceild(8*t2-Nz-12,16));t3<=min(min(min(floord(Nt+Ny-4,16),floord(4*t1+Ny+5,16)),floord(8*t2+Ny+4,16)),floord(8*t1-8*t2+Nz+Ny+3,16));t3++) { \n        for (t4=max(max(max(0,ceild(t1-127,128)),ceild(8*t2-Nz-508,512)),ceild(16*t3-Ny-508,512));t4<=min(min(min(min(floord(Nt+Nx-4,512),floord(4*t1+Nx+5,512)),floord(8*t2+Nx+4,512)),floord(16*t3+Nx+12,512)),floord(8*t1-8*t2+Nz+Nx+3,512));t4++) { \n          for (t5=max(max(max(max(max(0,4*t1),8*t1-8*t2+1),8*t2-Nz+2),16*t3-Ny+2),512*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,4*t1+7),8*t2+6),16*t3+14),512*t4+510),8*t1-8*t2+Nz+5);t5++) { \n            for (t6=max(max(8*t2,t5+1),-8*t1+8*t2+2*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(16*t3,t5+1);t7<=min(16*t3+15,t5+Ny-2);t7++) { \n                lbv=max(512*t4,t5+1); \n                ubv=min(512*t4+511,t5+Nx-2); \n#pragma ivdep \n#pragma vector always \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = ((alpha * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (beta * (((((A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)] + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) - 1][ (-t5+t8", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 16; \n  tile_size[3] = 512; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0876;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "}
{"label": " \nstatic void process_nlmeans(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                            const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in, \n                            const dt_iop_roi_t *const roi_out) \n{ \n   \n \n   \n \n  const dt_iop_denoiseprofile_params_t *const d = (const dt_iop_denoiseprofile_params_t *const)piece->data; \n \n  const int ch = piece->colors; \n \n   \n \n   \n \n  const float scale = fmin(roi_in->scale, 2.0f) / fmax(piece->iscale, 1.0f); \n  const int P = ceilf(d->radius * scale);  \n \n  const int K = ceilf(7 * scale);          \n \n \n   \n \n \n  float *Sa = dt_alloc_align(64, (size_t)sizeof(float) * roi_out->width * dt_get_num_threads()); \n   \n \n  memset(ovoid, 0x0, (size_t)sizeof(float) * roi_out->width * roi_out->height * 4); \n  float *in = dt_alloc_align(64, (size_t)4 * sizeof(float) * roi_in->width * roi_in->height); \n \n  const float wb[3] = { piece->pipe->dsc.processed_maximum[0] * d->strength * (scale * scale), \n                        piece->pipe->dsc.processed_maximum[1] * d->strength * (scale * scale), \n                        piece->pipe->dsc.processed_maximum[2] * d->strength * (scale * scale) }; \n  const float aa[3] = { d->a[1] * wb[0], d->a[1] * wb[1], d->a[1] * wb[2] }; \n  const float bb[3] = { d->b[1] * wb[0], d->b[1] * wb[1], d->b[1] * wb[2] }; \n  precondition((float *)ivoid, in, roi_in->width, roi_in->height, aa, bb); \n \n   \n \n  for(int kj = -K; kj <= K; kj++) \n  { \n    for(int ki = -K; ki <= K; ki++) \n    { \n       \n \n       \n \n \n      int inited_slide = 0; \n \n \n \n \n \n \n \n \n#pragma omp parallel for schedule(static) default(none) firstprivate(inited_slide) shared(kj, ki, in, Sa) \n      for(int j = 0; j < roi_out->height; j++) \n      { \n        if(j + kj < 0 || j + kj >= roi_out->height) continue; \n        float *S = Sa + dt_get_thread_num() * roi_out->width; \n        const float *ins = in + 4l * ((size_t)roi_in->width * (j + kj) + ki); \n        float *out = ((float *)ovoid) + (size_t)4 * roi_out->width * j; \n \n        const int Pm = MIN(MIN(P, j + kj), j); \n        const int PM = MIN(MIN(P, roi_out->height - 1 - j - kj), roi_out->height - 1 - j); \n         \n \n         \n \n        if(!inited_slide) \n        { \n           \n \n          memset(S, 0x0, sizeof(float) * roi_out->width); \n          for(int jj = -Pm; jj <= PM; jj++) \n          { \n            int i = MAX(0, -ki); \n            float *s = S + i; \n            const float *inp = in + 4 * i + (size_t)4 * roi_in->width * (j + jj); \n            const float *inps = in + 4 * i + 4l * ((size_t)roi_in->width * (j + jj + kj) + ki); \n            const int last = roi_out->width + MIN(0, -ki); \n            for(; i < last; i++, inp += 4, inps += 4, s++) \n            { \n              for(int k = 0; k < 3; k++) s[0] += (inp[k] - inps[k]) * (inp[k] - inps[k]); \n            } \n          } \n           \n \n          if(Pm == P && PM == P) inited_slide = 1; \n        } \n \n         \n \n        float *s = S; \n        float slide = 0.0f; \n         \n \n        for(int i = 0; i < 2 * P + 1; i++) slide += s[i]; \n        for(int i = 0; i < roi_out->width; i++, s++, ins += 4, out += 4) \n        { \n           \n \n           \n \n          if(i - P > 0 && i + P < roi_out->width) slide += s[P] - s[-P - 1]; \n          if(i + ki >= 0 && i + ki < roi_out->width) \n          { \n             \n \n             \n \n            const float norm =.015f / (2 * P + 1); \n            const float iv[4] = { ins[0], ins[1], ins[2], 1.0f }; \n#pragma omp SIMD() \n            for(size_t c = 0; c < 4; c++) \n            { \n              out[c] += iv[c] * fast_mexp2", "pred": " \nstatic void process_nlmeans(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                            const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in, \n                            const dt_iop_roi_t *const roi_out) \n{ \n   \n \n   \n \n  const dt_iop_denoiseprofile_params_t *const d = (const dt_iop_denoiseprofile_params_t *const)piece->data; \n \n  const int ch = piece->colors; \n \n   \n \n   \n \n  const float scale = fmin(roi_in->scale, 2.0f) / fmax(piece->iscale, 1.0f); \n  const int P = ceilf(d->radius * scale);  \n \n  const int K = ceilf(7 * scale);          \n \n \n   \n \n \n  float *Sa = dt_alloc_align(64, (size_t)sizeof(float) * roi_out->width * dt_get_num_threads()); \n   \n \n  memset(ovoid, 0x0, (size_t)sizeof(float) * roi_out->width * roi_out->height * 4); \n  float *in = dt_alloc_align(64, (size_t)4 * sizeof(float) * roi_in->width * roi_in->height); \n \n  const float wb[3] = { piece->pipe->dsc.processed_maximum[0] * d->strength * (scale * scale), \n                        piece->pipe->dsc.processed_maximum[1] * d->strength * (scale * scale), \n                        piece->pipe->dsc.processed_maximum[2] * d->strength * (scale * scale) }; \n  const float aa[3] = { piece->pipe->dsc.processed_maximum[3] * d->strength * (scale * scale),                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "}
{"label": "nt Data_plot_print_data  \n( Data_plot_t *D, int (*F) (const gsl_vector *x, gsl_vector *fx ),  \n  const char *fmt ) \n{ \n    const size_t Nvar = D->Nvar ;  \n    const size_t Nfunc = D->Nfunc ; \n   \n    if ( D->b_parallel_print_data &&  \n         D->b_print_data_stop_if_too_much_nan ) \n    { \n        WARNING ( stdout, \"%s\", \"le fait d'arreter la routine lorsque\" \n                  \" la fonction renvoie trop de failure n'est pas \\n\" \n                  \"compatible avec le multithreading je pense. \" \n                  \"A faire. En attendant, on ne parall\u00e9lise pas. \" );  \n \n        D->b_parallel_print_data = false ;  \n    } \n \n \n    if ( D->b_parallel_print_data ) \n    { \n       \n        WARNING ( stdout, \"%s\", \"A cause des changements faits, la\" \n                  \" routine de parall\u00e9lisation ne peut pas marcher : \" \n                  \"d'une part, chaque thread partage la meme fonction\" \n                  \" partageant a priori des variables communes. Donc \" \n                  \"c'est la merde. Ensuite, la routine source pour \" \n                  \"printer les data a besoin d'un objet data_plot, et\" \n                  \" qu'un seul est cr\u00e9e pour tous les threads : donc \" \n                  \"c'est la merde aussi. -> pas de parall\u00e9lisation \" \n                  \"possible pour le moement\" );  \n \n        return GSL_FAILURE ;  \n \n         \n \n       \n        const size_t nthread = 4 ;  \n        const size_t idecomp = 0 ; \n \n        TVector ** B  \n                = Data_plot_src_print_data_para_bounds (D, idecomp, nthread );  \n \n        gsl_vector_uint ** N \n                = Data_plot_src_print_data_para_npts ( D, B, idecomp, nthread );  \n       \n        TFlux * T = TFlux_alloc ( nthread );  \n       \n        for ( size_t i = 0 ; i < nthread ; i++ ) \n\t{ \n            TFlux_set_mode ( T, i, \"w\" );  \n            TFlux_set_path ( T, i, \"%s\", D->Fdata->path->s );  \n            TFlux_set_basename ( T, i, \"%s_omp_data%zu.dat\",  \n                                 D->basename->s, i );  \n            TFlux_open ( T, i );  \n\t} \n       \n         \n \n \n#pragma omp parallel for num_threads(nthread) \n        for ( size_t i = 0 ; i < nthread ; i++ ) \n\t{ \n            Data_plot_src_print_data \n                    ( D, T->files[i]->file, F, B[i], N[i],  \n                      fmt, Nfunc, D->b_print_failure );  \n\t} \n         \n \n \n         \n \n \n        __DEBUG ( true, \"%s\", \"Il reste encore \u00e0 merger les fichiers\" \n                  \" cr\u00e9e en un seul qui a le meme nom que celui \" \n                  \"cr\u00e9e si on n'avait pas parall\u00e9lis\u00e9.\" );  \n \n         \n \n \n        for ( size_t i= 0 ; i < nthread ; i++ ) \n\t{ \n            gsl_vector_uint_free ( N[i] );  \n            TVector_free ( B[i] );  \n\t} \n        free ( B ) ;  \n        free ( N );  \n \n \n        WARNING ( stdout, \"%s\", \"A faire : merger les fichiers du \" \n                  \"tableau de flux\" );  \n \n \n        TFlux_free ( T );  \n \n    }  \n \n    else \n    {     \n        FILE * file = D->Fdata->file ;  \n        gsl_vector_uint * npts = gsl_vector_uint_alloc ( Nvar );  \n   \n        for ( size_t i = 0 ; i < Nvar ; i++ ) \n            gsl_vector_uint_set  \n                    ( npts, i, Vector_uint_get ( D->npts_var, i ) ) ;  \n \n \n        int status = Data_plot_src_print_data \n                ( D, file, F, D->bounds_var, npts, fmt, Nfunc,  \n                  D->b_print_failure);    \n \n        if ( status )  \n\t{ \n            WARNING ( stdout, \"%s\", \"Probleme print data\" );  \n\t} \n \n        gsl_vector_uint_free ( npts );  \n \n        return status ;  \n    }  \n \n} \n \n \n \n/********* ", "pred": "nt Data_plot_print_data  \n( Data_plot_t *D, int (*F) (const gsl_vector *x, gsl_vector *fx ),  \n  const char *fmt ) \n{ \n    const size_t Nvar = D->Nvar ;  \n    const size_t Nfunc = D->Nfunc ; \n   \n    if ( D->b_parallel_print_data &&  \n         D->b_print_data_stop_if_too_much_nan ) \n    { \n        WARNING ( stdout, \"%s\", \"le fait d'arreter la routine lorsque\" \n                  \" la fonction renvoie trop de failure n'est pas \\n\" \n                  \"compatible avec le multithreading je pense. \" \n                  \"A faire. En attendant, on ne parall\u00e9lise pas. \" );  \n \n        D->b_parallel_print_data = false ;  \n    } \n \n \n    if ( D->b_parallel_print_data ) \n    { \n       \n        WARNING ( stdout, \"%s\", \"A cause des changements faits, la\" \n                  \" routine de parall\u00e9lisation ne peut pas marcher : \" \n                  \"d'une part, chaque thread partage la meme fonction\" \n                  \" partageant a priori des variables communes. Donc \" \n                  \"c'est la merde. Ensuite, la routine source pour \" \n                  \"printer les data a besoin d'un objet data_plot, et\" \n                  \" qu'un seul est cr\u00e9e pour tous les threads : donc \" \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " \nstatic void process_nlmeans_sse(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in, \n                                const dt_iop_roi_t *const roi_out) \n{ \n   \n \n   \n \n  dt_iop_denoiseprofile_params_t *d = (dt_iop_denoiseprofile_params_t *)piece->data; \n \n   \n \n   \n \n  const float scale = fmin(roi_in->scale, 2.0f) / fmax(piece->iscale, 1.0f); \n  const int P = ceilf(d->radius * scale);  \n \n  const int K = ceilf(7 * scale);          \n \n \n   \n \n \n  float *Sa = dt_alloc_align(64, (size_t)sizeof(float) * roi_out->width * dt_get_num_threads()); \n   \n \n  memset(ovoid, 0x0, (size_t)sizeof(float) * roi_out->width * roi_out->height * 4); \n  float *in = dt_alloc_align(64, (size_t)4 * sizeof(float) * roi_in->width * roi_in->height); \n \n  const float wb[3] = { piece->pipe->dsc.processed_maximum[0] * d->strength * (scale * scale), \n                        piece->pipe->dsc.processed_maximum[1] * d->strength * (scale * scale), \n                        piece->pipe->dsc.processed_maximum[2] * d->strength * (scale * scale) }; \n  const float aa[3] = { d->a[1] * wb[0], d->a[1] * wb[1], d->a[1] * wb[2] }; \n  const float bb[3] = { d->b[1] * wb[0], d->b[1] * wb[1], d->b[1] * wb[2] }; \n  precondition((float *)ivoid, in, roi_in->width, roi_in->height, aa, bb); \n \n   \n \n  for(int kj = -K; kj <= K; kj++) \n  { \n    for(int ki = -K; ki <= K; ki++) \n    { \n       \n \n       \n \n \n      int inited_slide = 0; \n \n \n \n \n \n \n \n \n#pragma omp parallel for schedule(static) default(none) firstprivate(inited_slide) shared(kj, ki, in, Sa) \n      for(int j = 0; j < roi_out->height; j++) \n      { \n        if(j + kj < 0 || j + kj >= roi_out->height) continue; \n        float *S = Sa + dt_get_thread_num() * roi_out->width; \n        const float *ins = in + 4l * ((size_t)roi_in->width * (j + kj) + ki); \n        float *out = ((float *)ovoid) + (size_t)4 * roi_out->width * j; \n \n        const int Pm = MIN(MIN(P, j + kj), j); \n        const int PM = MIN(MIN(P, roi_out->height - 1 - j - kj), roi_out->height - 1 - j); \n         \n \n         \n \n        if(!inited_slide) \n        { \n           \n \n          memset(S, 0x0, sizeof(float) * roi_out->width); \n          for(int jj = -Pm; jj <= PM; jj++) \n          { \n            int i = MAX(0, -ki); \n            float *s = S + i; \n            const float *inp = in + 4 * i + (size_t)4 * roi_in->width * (j + jj); \n            const float *inps = in + 4 * i + 4l * ((size_t)roi_in->width * (j + jj + kj) + ki); \n            const int last = roi_out->width + MIN(0, -ki); \n            for(; i < last; i++, inp += 4, inps += 4, s++) \n            { \n              for(int k = 0; k < 3; k++) s[0] += (inp[k] - inps[k]) * (inp[k] - inps[k]); \n            } \n          } \n           \n \n          if(Pm == P && PM == P) inited_slide = 1; \n        } \n \n         \n \n        float *s = S; \n        float slide = 0.0f; \n         \n \n        for(int i = 0; i < 2 * P + 1; i++) slide += s[i]; \n        for(int i = 0; i < roi_out->width; i++) \n        { \n           \n \n           \n \n          if(i - P > 0 && i + P < roi_out->width) slide += s[P] - s[-P - 1]; \n          if(i + ki >= 0 && i + ki < roi_out->width) \n          { \n             \n \n             \n \n            const float norm =.015f / (2 * P + 1); \n            const __m128 iv = { ins[0], ins[1], ins[2], 1.0f }; \n            _mm_store_ps(out, \n                         _mm_load_ps(out) + iv * _mm_set1_ps(fast_mexp2f(fmaxf(0.0f, slide * norm - 2.0f)))); \n         ", "pred": " \nstatic void process_nlmeans_sse(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in, \n                                const dt_iop_roi_t *const roi_out) \n{ \n   \n \n   \n \n  dt_iop_denoiseprofile_params_t *d = (dt_iop_denoiseprofile_params_t *)piece->data; \n \n   \n \n   \n \n  const float scale = fmin(roi_in->scale, 2.0f) / fmax(piece->iscale, 1.0f); \n  const int P = ceilf(d->radius * scale);  \n \n  const int K = ceilf(7 * scale);          \n \n \n   \n \n \n  float *Sa = dt_alloc_align(64, (size_t)sizeof(float) * roi_out->width * dt_get_num_threads()); \n   \n \n  memset(ovoid, 0x0, (size_t)sizeof(float) * roi_out->width * roi_out->height * 4); \n  float *in = dt_alloc_align(64, (size_t)4 * sizeof(float) * roi_in->width * roi_in->height); \n \n  const float wb[3] = { piece->pipe->dsc.processed_maximum[0] * d->strength * (scale * scale), \n                        piece->pipe->dsc.processed_maximum[1] * d->strength * (scale * scale), \n                        piece->pipe->dsc.processed_maximum[2] * d->strength * (scale * scale) }; \n  const float aa[3] = { d->a[1] * d->a[0];\\n    const float bb[3] = { aa[0] * d->a[1];\\n    const float cb[3] = { aa[1] * d->a[2];\\n    const float cc[3] = { aa[2] * d->a[3];\\n    const float cb[3] = { aa[3] * d->a[4];\\n    const float cc[4] = { aa[4] * d->a[5];\\n    const float cb[4] = { aa[5] * d->a[6];\\n    const float cc[5] = { aa[5] * d->a[7];\\n    const float cb[5] = { aa[7] * d->a[8];\\n    const float cc[6] = { aa[7] * d->a[9];\\n    const float cb[6] = { aa[7] * d->a[10];\\n    const float cc[7] = { aa[7] * d->a[11];\\n    const float cb[7] = { aa[7] * d->a[12];\\n    const float cc[7] = { aa[7] * d->a[13];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7] = { aa[7] * d->a[14];\\n    const float cc[7] = { aa[7] * d->a[14];\\n    const float cb[7]"}
{"label": " \nvoid THNN_(SpatialConvolutionLocal_updateGradInput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *gradOutput, \n    THTensor *gradInput, \n    THTensor *weight, \n    THTensor *finput, \n    THTensor *fgradInput, \n    int kW, int kH, \n    int dW, int dH, \n    int padW, int padH, \n    int64_t inputWidth, int64_t inputHeight, \n    int64_t outputWidth, int64_t outputHeight) \n{ \n  weight = THNN_(view_weight_local)(weight); \n \n  THNN_(SpatialConvolutionLocal_shapeCheck) \n    (input, gradOutput, weight, NULL, kH, kW, dH, dW, padH, padW, \n     inputHeight, inputWidth, outputHeight, outputWidth); \n \n  input = THTensor_(newContiguous)(input); \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n  int64_t nInputPlane = THTensor_(size)(weight,2)/(kW*kH); \n  int64_t nOutputPlane = THTensor_(size)(weight,1); \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(resizeAs)(fgradInput, finput); \n \n  THTensor *tweight = THTensor_(new)(); \n  THTensor_(transpose)(tweight, weight, 1, 2); \n \n  if(input->nDimension == 3) \n  { \n    THNN_(SpatialConvolutionLocal_updateGradInput_frame) \n      (gradInput, gradOutput, tweight, \n       fgradInput, kW, kH, dW, dH, padW, padH, \n       nInputPlane, inputWidth, inputHeight, \n       nOutputPlane, outputWidth, outputHeight); \n  } \n  else \n  { \n    int64_t T = input->size[0]; \n    int64_t t; \n \n#pragma omp parallel for private(t) \n    for(t = 0; t < T; t++) \n    { \n      THTensor *gradInput_t = THTensor_(newSelect)(gradInput, 0, t); \n      THTensor *gradOutput_t = THTensor_(newSelect)(gradOutput, 0, t); \n      THTensor *fgradInput_t = THTensor_(newSelect)(fgradInput, 0, t); \n \n      THNN_(SpatialConvolutionLocal_updateGradInput_frame) \n    (gradInput_t, gradOutput_t, tweight, fgradInput_t, \n     kW, kH, dW, dH, padW, padH, \n     nInputPlane, inputWidth, inputHeight, \n     nOutputPlane, outputWidth, outputHeight); \n \n      THTensor_(free)(gradInput_t); \n      THTensor_(free)(gradOutput_t); \n      THTensor_(free)(fgradInput_t); \n    } \n  } \n \n  THTensor_(free)(tweight); \n  THTensor_(free)(input); \n  THTensor_(free)(gradOutput); \n  THTensor_(free)(weight); \n} ", "pred": " \nvoid THNN_(SpatialConvolutionLocal_updateGradInput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *gradOutput, \n    THTensor *gradInput, \n    THTensor *weight, \n    THTensor *finput, \n    THTensor *fgradInput, \n    int kW, int kH, \n    int dW, int dH, \n    int padW, int padH, \n    int64_t inputWidth, int64_t inputHeight, \n    int64_t outputWidth, int64_t outputHeight) \n{ \n  weight = THNN_(view_weight_local)(weight); \n \n  THNN_(SpatialConvolutionLocal_shapeCheck) \n    (input, gradOutput, weight, NULL, kH, kW, dH, dW, padH, padW, \n     inputHeight, inputWidth, outputHeight, outputWidth); \n \n  input = THTensor_(newContiguous)(input); \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n  int64_t nInputPlane = THTensor_(size)(weight,2)/(kW*kH); \n  int64_t nOutputPlane = THTensor_(size)(weight,1); \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(resizeAs)(fgradInput, finput); \n \n  THTensor *tweight = THTensor_(new)(); \n  THTensor_(transpose)(tweight, weight, 1, 2); \n \n  if(input->nDimension == 3) \n  { \n    THNN_(SpatialConvolutionLocal_updateGradInput_frame) \n      (gradInput, gradOutput, tweight, \n       fgradInput, kW, kH, dW, dH, padW, padH, \n       nInputPlane, inputWidth, inputHeight, \n       nOutputPlane, outputWidth, outputHeight); \n  } \n  else \n  { \n    int64_t T = input->size[0]; \n    int64_t t; \n \n#pragma omp parallel for private(t, nInputPlane, nInputPlane, nOutputPlane, nOutputPlane, nInputPlane, nInputPlane, nInputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, nOutputPlane, n"}
{"label": " \nvoid reb_integrator_leapfrog_part2(struct reb_simulation* r){ \n\tconst int N = r->N; \n\tstruct reb_particle* restrict const particles = r->particles; \n\tconst double dt = r->dt; \n#pragma omp parallel for schedule(guided) \n\tfor (int i=0;i<N;i++){ \n\t\tparticles[i].vx += dt * particles[i].ax; \n\t\tparticles[i].vy += dt * particles[i].ay; \n\t\tparticles[i].vz += dt * particles[i].az; \n\t\tparticles[i].x  += 0.5* dt * particles[i].vx; \n\t\tparticles[i].y  += 0.5* dt * particles[i].vy; \n\t\tparticles[i].z  += 0.5* dt * particles[i].vz; \n\t} \n\tr->t+=dt/2.; \n} ", "pred": " \nvoid reb_integrator_leapfrog_part2(struct reb_simulation* r){ \n\tconst int N = r->N; \n\tstruct reb_particle* restrict const particles = r->particles; \n\tconst double dt = r->dt; \n#pragma omp parallel for schedule(guided) \n\tfor (int i=0;i<N;i++){ \n\t\tparticles[i].vx += dt * particles[i].ax; \n\t\tparticles[i].vy += dt * particles[i].ay; \n\t\tparticles[i].vz += dt * particles[i].az; \n\t\tparticles[i].x  += 0.5* dt * particles[i].vx; \n\t\tparticles[i].y  += 0.5* dt * particles[i].vy; \n\t\tparticles[i].z  += 0.5* dt * particles[i].vz; \n\t} \n\tr->t+=dt/2.; \n} "}
{"label": " \nvoid VMatrixECM(gsl_matrix_float *X,float *ev,int type,int maxiter,VImage map) \n{ \n  size_t i,j; \n  size_t nvox = X->size1; \n  size_t nt = X->size2; \n \n   \n   \n \n  size_t m = (nvox*(nvox+1))/2; \n  float *A = (float *) calloc(m,sizeof(float)); \n  if (!A) VError(\" err allocating correlation matrix (too big)\"); \n  memset(A,0,m*sizeof(float)); \n  size_t progress=0; \n   \n \n#pragma omp parallel for shared(progress) private(j) schedule(guided) firstprivate(X,A) \n  for (i=0; i<nvox; i++) { \n    if (i%1000 == 0) fprintf(stderr,\" %d000  of  %lu\\r\",(int)(++progress),nvox); \n \n    const float *arr1 = gsl_matrix_float_const_ptr(X,i,0); \n    for (j=0; j<=i; j++) { \n      if (i == j) continue; \n      const float *arr2 = gsl_matrix_float_const_ptr(X,j,0); \n       \n      const double v = ECMcorrelation(arr1,arr2,nt,type); \n      const size_t k=j+i*(i+1)/2; \n      A[k] = v; \n    } \n  } \n  fprintf(stderr,\"\\n\"); \n \n   \n   \n \n   \n \n     \n   \n \n  MatrixPowerIteration(A,ev,nvox,maxiter); \n  VFree(A); \n} ", "pred": " \nvoid VMatrixECM(gsl_matrix_float *X,float *ev,int type,int maxiter,VImage map) \n{ \n  size_t i,j; \n  size_t nvox = X->size1; \n  size_t nt = X->size2; \n \n   \n   \n \n  size_t m = (nvox*(nvox+1))/2; \n  float *A = (float *) calloc(m,sizeof(float)); \n  if (!A) VError(\" err allocating correlation matrix (too big)\"); \n  memset(A,0,m*sizeof(float)); \n  size_t progress=0; \n   \n \n#pragma omp parallel for shared(progress) private(j) schedule(guided) firstprivate(X,A) \n  for (i=0; i<nvox; i++) { \n    if (i%1000 == 0) fprintf(stderr,\" %d000  of  %lu\\r\",(int)(++progress),nvox); \n \n    const float *arr1 = gsl_matrix_float_const_ptr(X,i,0); \n    for (j=0; j<=i; j++) { \n      if (i == j) continue; \n      const float *arr2 = gsl_matrix_float_const_ptr(X,j,0); \n       \n      const double v = ECMcorrelation(arr1,arr2,nt,type); \n      const size_t k=j+i*(i+1)/2; \n      A[k] = v; \n    } \n  } \n  fprintf(stderr,\"\\n\"); \n \n   \n   \n \n   \n \n     \n   \n \n  MatrixPowerIteration(A,ev,nvox,maxiter); \n  VFree(A); \n} "}
{"label": " \nvoid assign_mul_add_mul_add_mul_r(spinor * const R, spinor * const S, spinor * const U, \n\t\t\t\t  const double c1,const double c2,const double c3, \n\t\t\t\t  const int N) \n{ \n#pragma omp parallel \n  { \n \n  spinor *r,*s,*u; \n \n#pragma omp for \n  for (int ix = 0; ix < N; ++ix) \n  { \n    r=(spinor *) R + ix; \n    s=(spinor *) S + ix; \n    u=(spinor *) U + ix; \n     \n    r->s0.c0 = c1 * r->s0.c0 + c2 * s->s0.c0 + c3 * u->s0.c0; \n    r->s0.c1 = c1 * r->s0.c1 + c2 * s->s0.c1 + c3 * u->s0.c1; \n    r->s0.c2 = c1 * r->s0.c2 + c2 * s->s0.c2 + c3 * u->s0.c2; \n     \n    r->s1.c0 = c1 * r->s1.c0 + c2 * s->s1.c0 + c3 * u->s1.c0; \n    r->s1.c1 = c1 * r->s1.c1 + c2 * s->s1.c1 + c3 * u->s1.c1; \n    r->s1.c2 = c1 * r->s1.c2 + c2 * s->s1.c2 + c3 * u->s1.c2; \n \n    r->s2.c0 = c1 * r->s2.c0 + c2 * s->s2.c0 + c3 * u->s2.c0; \n    r->s2.c1 = c1 * r->s2.c1 + c2 * s->s2.c1 + c3 * u->s2.c1; \n    r->s2.c2 = c1 * r->s2.c2 + c2 * s->s2.c2 + c3 * u->s2.c2; \n     \n    r->s3.c0 = c1 * r->s3.c0 + c2 * s->s3.c0 + c3 * u->s3.c0; \n    r->s3.c1 = c1 * r->s3.c1 + c2 * s->s3.c1 + c3 * u->s3.c1; \n    r->s3.c2 = c1 * r->s3.c2 + c2 * s->s3.c2 + c3 * u->s3.c2; \n  } \n \n  }  \n \n} ", "pred": " \nvoid assign_mul_add_mul_add_mul_r(spinor * const R, spinor * const S, spinor * const U, \n\t\t\t\t  const double c1,const double c2,const double c3, \n\t\t\t\t  const int N) \n{ \n#pragma omp parallel \n  { \n \n  spinor *r,*s,*u; \n \n#pragma omp for \n  for (int ix = 0; ix < N; ++ix) \n  { \n    r=(spinor *) R + ix; \n    s=(spinor *) S + ix; \n    u=(spinor *) U + ix; \n     \n    r->s0.c0 = c1 * r->s0.c0 + c2 * s->s0.c0 + c3 * u->s0.c0; \n    r->s0.c1 = c1 * r->s0.c1 + c2 * s->s0.c1 + c3 * u->s0.c1; \n    r->s0.c2 = c1 * r->s0.c2 + c2 * s->s0.c2 + c3 * u->s0.c2; \n     \n    r->s1.c0 = c1 * r->s1.c0 + c2 * s->s1.c0 + c3 * u->s1.c0; \n    r->s1.c1 = c1 * r->s1.c1 + c2 * s->s1.c1 + c3 * u->s1.c1; \n    r->s1.c2 = c1 * r->s1.c2 + c2 * s->s1.c2 + c3 * u->s1.c2; \n \n    r->s2.c0 = c1 * r->s2.c0 + c2 * s->s2.c0 + c3 * u->s2.c0; \n    r->s2.c1 = c1 * r->s2.c1 + c2 * s->s2.c1 + c3 * u->s2.c1; \n    r->s2.c2 = c1 * r->s2.c2 + c2 * s->s2.c2 + c3 * u->s2.c2;                                                                                                                                                                 "}
{"label": " \nvoid \ntest16 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (guided) ordered \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n#pragma omp ordered \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest16 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (guided) ordered \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n#pragma omp ordered \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ngrad_imp_LCU( struct halfspinor *der, \n\t      const struct halfspinor *S, \n\t      const struct field *Fmunu, \n\t      const double U_0, \n\t      const size_t t, \n\t      const size_t mu ) \n{ \n  size_t i ; \n#pragma omp for private(i) \n  for( i = 0 ; i < LCU ; i++ ) { \n \n     \n \n    double complex A[ NCNC ] __attribute__((aligned(ALIGNMENT))) ; \n    double complex B[ NCNC ] __attribute__((aligned(ALIGNMENT))) ; \n     \n    const size_t Uidx = i + t*LCU ;     \n    const size_t Ubck = lat[ Uidx ].back[mu] ; \n     \n    const size_t Sfwd = lat[ i ].neighbor[mu] ; \n    const size_t Sfwd2 = lat[ Sfwd ].neighbor[mu] ; \n     \n    const size_t Sbck = lat[ i ].back[mu] ; \n    const size_t Sbck2 = lat[ Sbck ].back[mu] ; \n     \n    size_t d ; \n    for( d = 0 ; d < NS ; d++ ) { \n       \n \n      multab( (void*)der[ i ].D[d], \n\t      (void*)lat[ Uidx ].O[mu], \n\t      (void*)S[ Sfwd ].D[d] ) ; \n       \n \n      multabdag( (void*)A, \n\t\t (void*)lat[ Ubck ].O[mu], \n\t\t (void*)S[ Sbck ].D[d] ) ; \n       \n \n      #ifdef LEGACY_NRQCD_COMPARE \n      colormatrix_Sa_xmy( der[i].D[d], A, (7+1/(U_0*U_0))/12. ) ; \n      #else \n      colormatrix_Sa_xmy( der[i].D[d], A, 2./3. ) ; \n      #endif \n       \n       \n \n      multab( (void*)A, \n\t      (void*)Fmunu[i].O[6+2*mu], \n\t      (void*)S[ Sfwd2 ].D[d] ) ; \n       \n \n      multabdag( (void*)B, \n\t\t (void*)Fmunu[i].O[7+2*mu], \n\t\t (void*)S[ Sbck2 ].D[d] ) ; \n      colormatrix_Sa_xmy( A, B, -1./12. ) ; \n \n      add_mat( (void*)der[i].D[d], (void*)A ) ; \n    } \n  } \n  return ; \n} ", "pred": " \nvoid \ngrad_imp_LCU( struct halfspinor *der, \n\t      const struct halfspinor *S, \n\t      const struct field *Fmunu, \n\t      const double U_0, \n\t      const size_t t, \n\t      const size_t mu ) \n{ \n  size_t i ; \n#pragma omp for private(i) \n  for( i = 0 ; i < LCU ; i++ ) { \n \n     \n \n    double complex A[ NCNC ] __attribute__((aligned(ALIGNMENT))) ; \n    double complex B[ NCNC ] __attribute__((aligned(ALIGNMENT))) ; \n     \n    const size_t Uidx = i + t*LCU ;     \n    const size_t Ubck = lat[ Uidx ].back[mu] ; \n     \n    const size_t Sfwd = lat[ i ].neighbor[mu] ; \n    const size_t Sfwd2 = lat[ Sfwd ].neighbor[mu] ; \n     \n    const size_t Sbck = lat[ i ].back[mu] ; \n    const size_t Sbck2 = lat[ Sbck ].back[mu] ; \n     \n    size_t d ; \n    for( d = 0 ; d < NS ; d++ ) { \n       \n \n      multab( (void*)der[ i ].D[d], \n\t      (void*)lat[ Uidx ].O[mu], \n\t      (void*)S[ Sfwd ].D[d] ) ; \n       \n \n      multabdag( (void*)A, \n\t\t (void*)lat[ Ubck ].O[mu], \n\t\t (void*)S[ Sbck ].D[d] ) ; \n       \n \n      #ifdef LEGACY_NRQCD_COMPARE \n      colormatrix_Sa_xmy( der[i].D[d], A, (7+1/(U_0*U_0)) ) {                                                                                                                                                                                                                                                                                            "}
{"label": " \nvoid reb_integrator_leapfrog_part1(struct reb_simulation* r){ \n\tconst int N = r->N; \n\tstruct reb_particle* restrict const particles = r->particles; \n\tconst double dt = r->dt; \n#pragma omp parallel for schedule(guided) \n\tfor (int i=0;i<N;i++){ \n\t\tparticles[i].x  += 0.5* dt * particles[i].vx; \n\t\tparticles[i].y  += 0.5* dt * particles[i].vy; \n\t\tparticles[i].z  += 0.5* dt * particles[i].vz; \n\t} \n\tr->t+=dt/2.; \n} ", "pred": " \nvoid reb_integrator_leapfrog_part1(struct reb_simulation* r){ \n\tconst int N = r->N; \n\tstruct reb_particle* restrict const particles = r->particles; \n\tconst double dt = r->dt; \n#pragma omp parallel for schedule(guided) \n\tfor (int i=0;i<N;i++){ \n\t\tparticles[i].x  += 0.5* dt * particles[i].vx; \n\t\tparticles[i].y  += 0.5* dt * particles[i].vy; \n\t\tparticles[i].z  += 0.5* dt * particles[i].vz; \n\t} \n\tr->t+=dt/2.; \n} "}
{"label": " \nvoid \ntest15 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (guided) ordered \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n#pragma omp ordered \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest15 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (guided) ordered \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n#pragma omp ordered \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ntest3 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (guided) \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest3 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (guided) \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 16; \n  tile_size[3] = 512; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,4);t1++) { \n    lbp=max(ceild(t1,2),ceild(8*t1-Nt+3,8)); \n    ubp=min(floord(Nt+Nz-4,8),floord(4*t1+Nz+1,8)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-3,4)),ceild(8*t2-Nz-12,16));t3<=min(min(min(floord(Nt+Ny-4,16),floord(4*t1+Ny+5,16)),floord(8*t2+Ny+4,16)),floord(8*t1-8*t2+Nz+Ny+3,16));t3++) { \n        for (t4=max(max(max(0,ceild(t1-127,128)),ceild(8*t2-Nz-508,512)),ceild(16*t3-Ny-508,512));t4<=min(min(min(min(floord(Nt+Nx-4,512),floord(4*t1+Nx+5,512)),floord(8*t2+Nx+4,512)),floord(16*t3+Nx+12,512)),floord(8*t1-8*t2+Nz+Nx+3,512));t4++) { \n          for (t5=max(max(max(max(max(0,4*t1),8*t1-8*t2+1),8*t2-Nz+2),16*t3-Ny+2),512*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,4*t1+7),8*t2+6),16*t3+14),512*t4+510),8*t1-8*t2+Nz+5);t5++) { \n            for (t6=max(max(8*t2,t5+1),-8*t1+8*t2+2*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(16*t3,t5+1);t7<=min(16*t3+15,t5+N", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *) tile_size, sizeof(int)*Nz);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": " \nvoid ctrsm(CBlasSide side, CBlasUplo uplo, CBlasTranspose transA, CBlasDiag diag, \n           size_t m, size_t n, \n           float complex alpha, const float complex * restrict A, size_t lda, \n           float complex * restrict B, size_t ldb) { \n  const size_t nRowA = (side == CBlasLeft)? m : n; \n \n  int info = 0; \n  if (lda < nRowA) \n    info = 9; \n  else if (ldb < m) \n    info = 11; \n  if (info!= 0) { \n    XERBLA(info); \n    return; \n  } \n \n  if (m == 0 || n == 0) \n    return; \n \n  if (alpha == zero) { \n#pragma omp parallel for \n    for (size_t j = 0; j < n; j++) { \n      for (size_t i = 0; i < m; i++) \n        B[j * ldb + i] = zero; \n    } \n    return; \n  } \n \n  if (side == CBlasLeft) { \n    if (transA == CBlasNoTrans) { \n      if (uplo == CBlasUpper) { \n#pragma omp parallel for \n        for (size_t j = 0; j < n; j++) { \n          if (alpha!= one) { \n            for (size_t i = 0; i < m; i++) \n              B[j * ldb + i] *= alpha; \n          } \n          size_t k = m - 1; \n          do { \n            if (B[j * ldb + k]!= zero) { \n              if (diag == CBlasNonUnit) B[j * ldb + k] /= A[k * lda + k]; \n              register float complex temp = B[j * ldb + k]; \n              for (size_t i = 0; i < k; i++) \n                B[j * ldb + i] -= temp * A[k * lda + i]; \n            } \n          } while (k-- > 0); \n        } \n      } \n      else { \n#pragma omp parallel for \n        for (size_t j = 0; j < n; j++) { \n          if (alpha!= one) { \n            for (size_t i = 0; i < m; i++) \n              B[j * ldb + i] *= alpha; \n          } \n          for (size_t k = 0; k < m; k++) { \n            if (B[j * ldb + k]!= zero) { \n              if (diag == CBlasNonUnit) B[j * ldb + k] /= A[k * lda + k]; \n              register float complex temp = B[j * ldb + k]; \n              for (size_t i = k + 1; i < m; i++) \n                B[j * ldb + i] -= temp * A[k * lda + i]; \n            } \n          } \n        } \n      } \n    } \n    else { \n      if (uplo == CBlasUpper) { \n#pragma omp parallel for \n        for (size_t j = 0; j < n; j++) { \n          for (size_t i = 0; i < m; i++) { \n            register float complex temp = alpha * B[j * ldb + i]; \n            if (transA == CBlasTrans) { \n              for (size_t k = 0; k < i; k++) \n                temp -= A[i * lda + k] * B[j * ldb + k]; \n              if (diag == CBlasNonUnit) temp /= A[i * lda + i]; \n            } \n            else { \n              for (size_t k = 0; k < i; k++) \n                temp -= conjf(A[i * lda + k]) * B[j * ldb + k]; \n              if (diag == CBlasNonUnit) temp /= conjf(A[i * lda + i]); \n            } \n            B[j * ldb + i] = temp; \n          } \n        } \n      } \n      else { \n#pragma omp parallel for \n        for (size_t j = 0; j < n; j++) { \n          size_t i = m - 1; \n          do { \n            register float complex temp = alpha * B[j * ldb + i]; \n            if (transA == CBlasTrans) { \n              for (size_t k = i + 1; k < m; k++) \n                temp -= A[i * lda + k] * B[j * ldb + k]; \n              if (diag == CBlasNonUnit) temp /= A[i * lda + i]; \n            } \n            else { \n              for (size_t k = i + 1; k < m; k++) \n                temp -= conjf(A[i * lda + k]) * B[j * ldb + k]; \n              if (diag == CBlasNonUnit) temp /= conjf(A[i * lda + i]); \n            } \n            B[j * ldb + i] = temp; \n          } while (i--", "pred": " \nvoid ctrsm(CBlasSide side, CBlasUplo uplo, CBlasTranspose transA, CBlasDiag diag, \n           size_t m, size_t n, \n           float complex alpha, const float complex * restrict A, size_t lda, \n           float complex * restrict B, size_t ldb) { \n  const size_t nRowA = (side == CBlasLeft)? m : n; \n \n  int info = 0; \n  if (lda < nRowA) \n    info = 9; \n  else if (ldb < m) \n    info = 11; \n  if (info!= 0) { \n    XERBLA(info); \n    return; \n  } \n \n  if (m == 0 || n == 0) \n    return; \n \n  if (alpha == zero) { \n#pragma omp parallel for \n    for (size_t j = 0; j < n; j++) { \n      for (size_t i = 0; i < m; i++) \n        B[j * ldb + i] = zero; \n    } \n    return; \n  } \n \n  if (side == CBlasLeft) { \n    if (transA == CBlasNoTrans) { \n      if (uplo == CBlasUpper) { \n#pragma omp parallel for \n        for (size_t j = 0; j < n; j++) { \n          if (alpha!= one) { \n            for (size_t i = 0; i < m; i++) \n              B[j * ldb + i] *= alpha; \n          } \n          size_t k = m - 1; \n          do { \n            if (B[j * ldb + k]!= zero) { \n              if (diag == CBlasUpper) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " \nvoid \ntest13 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (dynamic) ordered \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n#pragma omp ordered \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest13 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (dynamic) ordered \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n#pragma omp ordered \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ntest12 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (guided) \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest12 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (guided) \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ntest7 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (guided) ordered \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n#pragma omp ordered \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest7 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (guided) ordered \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n#pragma omp ordered \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ntest10 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (dynamic) \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest10 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (dynamic) \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid direct_conv(float * D0, float * F, float * O, const int N, const int K, const int P, const int Q, const int C, const int R, const int S) { \n    const int P_pad = P + 2;  \n    const int Q_pad = Q + 2;  \n    int n, k, p, q, c, r, s;  \n    float sum;  \n    for (n = 0; n < N; n++) { \n#pragma omp parallel for \n        for (k = 0; k < K; k++) { \n            for (p = 1; p < P_pad-1; p++) { \n                for (q = 1; q < P_pad-1; q++) { \n                    sum = 0;  \n#pragma unroll \n                    for (c = 0; c < C; c++) { \n#pragma unroll \n                        for (r = 0; r < R; r++) { \n#pragma unroll \n                            for (s = 0; s < S; s++) { \n                                sum += F[k*C*R*S + c*R*S + r*S + s]*D0[n*C*P_pad*Q_pad + c*P_pad*Q_pad + (p+r-1)*Q_pad + (q+s-1)];  \n                            } \n                        } \n                    } \n                    O[n*K*P*Q+ k*P*Q+ (p-1)*Q+ (q-1)] = sum;  \n                } \n            } \n        } \n    } \n} ", "pred": " \nvoid direct_conv(float * D0, float * F, float * O, const int N, const int K, const int P, const int Q, const int C, const int R, const int S) { \n    const int P_pad = P + 2;  \n    const int Q_pad = Q + 2;  \n    int n, k, p, q, c, r, s;  \n    float sum;  \n    for (n = 0; n < N; n++) { \n#pragma omp parallel for \n        for (k = 0; k < K; k++) { \n            for (p = 1; p < P_pad-1; p++) { \n                for (q = 1; q < P_pad-1; q++) { \n                    sum = 0;  \n#pragma unroll \n                    for (c = 0; c < C; c++) { \n#pragma unroll \n                        for (r = 0; r < R; r++) { \n#pragma unroll \n                            for (s = 0; s < S; s++) { \n                                sum += F[k*C*R*S + c*R*S + r*S + s]*D0[n*C*P_pad*Q_pad + c*P_pad*Q_pad + (p+r-1)*Q_pad + (q+s-1)];  \n                            } \n                        } \n                    } \n                    O[n*K*P*Q_pad + P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*P*"}
{"label": "void process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n  dt_iop_temperature_data_t *d = (dt_iop_temperature_data_t *)piece->data; \n  if(filters == 9u) \n  {  \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(ivoid, ovoid, roi_out, xtrans)      shared(d)      schedule(static) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)j * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)j * roi_out->width; \n \n      int i = 0; \n      const int alignment = ((4 - (j * roi_out->width & (4 - 1))) & (4 - 1)); \n \n       \n \n      for(; i < alignment && i < roi_out->width; i++, out++, in++) \n        *out = *in * d->coeffs[FCxtrans(j, i, roi_out, xtrans)]; \n \n      const __m128 coeffs[3] = { \n        _mm_set_ps(d->coeffs[FCxtrans(j, i + 3, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 2, roi_out, xtrans)], \n                   d->coeffs[FCxtrans(j, i + 1, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 0, roi_out, xtrans)]), \n        _mm_set_ps(d->coeffs[FCxtrans(j, i + 7, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 6, roi_out, xtrans)], \n                   d->coeffs[FCxtrans(j, i + 5, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 4, roi_out, xtrans)]), \n        _mm_set_ps(d->coeffs[FCxtrans(j, i + 11, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 10, roi_out, xtrans)], \n                   d->coeffs[FCxtrans(j, i + 9, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 8, roi_out, xtrans)]) \n      }; \n \n       \n \n      for(int c = 0; c < 3 && i < roi_out->width - (4 - 1); c++, i += 4, in += 4, out += 4) \n      { \n        __m128 v; \n \n        v = _mm_load_ps(in); \n        v = _mm_mul_ps(v, coeffs[c]); \n        _mm_stream_ps(out, v); \n      } \n \n       \n \n      for(; i < roi_out->width; i++, out++, in++) *out = *in * d->coeffs[FCxtrans(j, i, roi_out, xtrans)]; \n    } \n    _mm_sfence(); \n  } \n  else if(filters) \n  {  \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(filters, ivoid, ovoid, roi_out)      shared(d)      schedule(static) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)j * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)j * roi_out->width; \n \n      int i = 0; \n      const int alignment = ((4 - (j * roi_out->width & (4 - 1))) & (4 - 1)); \n \n       \n \n      for(; i < alignment && i < roi_out->width; i++, out++, in++) \n        *out = *in * d->coeffs[FC(j + roi_out->y, i + roi_out->x, filters)]; \n \n      const __m128 coeffs = _mm_set_ps(d->coeffs[FC(j + roi_out->y, roi_out->x + i + 3, filters)], \n                                       d->coeffs[FC(j + roi_out->y, roi_out->x + i + 2, filters)], \n                                       d->coeffs[FC(j + roi_out->y, roi_out->x + i + 1, filters)], \n                                       d->coeffs[FC(j + roi_out->y, roi_out->x + i, filters)]); \n \n       \n \n      for(; i < roi_out->width - (4 - 1); i += 4, in += 4, out += 4) \n      { \n        const __m128 input = _mm_load_ps(in); \n \n        const __m128 multiplied = _mm_mul_ps(input, coeffs); \n \n        _mm_stream_ps(out, multiplied); \n      } \n \n       \n \n      for(; i < roi_out->width; i++, out++, in++) \n        *out = *in * d->coeffs[FC(j + roi_out->y, i + roi_out->x, filters)]; \n    } \n    _mm_sfence(); \n  } \n  else \n  {  \n \n    const int ch = piece->colors; \n \n    const __m128 coeffs", "pred": "void process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n  dt_iop_temperature_data_t *d = (dt_iop_temperature_data_t *)piece->data; \n  if(filters == 9u) \n  {  \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(ivoid, ovoid, roi_out, xtrans)      shared(d)      schedule(static) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)j * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)j * roi_out->width; \n \n      int i = 0; \n      const int alignment = ((4 - (j * roi_out->width & (4 - 1))) & (4 - 1)); \n \n       \n \n      for(; i < alignment && i < roi_out->width; i++, out++, in++) \n        *out = *in * d->coeffs[FCxtrans(j, i, roi_out, xtrans)]; \n \n      const __m128 coeffs[3] = { \n        _mm_set_ps(d->coeffs[FCxtrans(j, i + 3, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 2, roi_out, xtrans)], \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nstatic void compute_centroids(void) \n{ \n\tint i, j;        \n \n\tint population;  \n \n \n\tstart = timer_get(); \n\t \n\tmemcpy(lcentroids, CENTROID(rank*(ncentroids/nprocs)), lncentroids[rank]*dimension*sizeof(float)); \n\tmemset(&has_changed[rank*NUM_THREADS], 0, NUM_THREADS*sizeof(int)); \n\tmemset(centroids, 0, (ncentroids + DELTA*nprocs)*dimension*sizeof(float)); \n\tmemset(ppopulation, 0, (ncentroids + nprocs*DELTA)*sizeof(int)); \n \n\t \n \n #pragma omp parallel for schedule(static) default(shared) private(i, j) \n\tfor (i = 0; i < lnpoints; i++) \n\t{ \n\t\tj = map[i]%NUM_THREADS; \n\t\t \n\t\tomp_set_lock(&lock[j]); \n\t\t \n\t\tvector_add(CENTROID(map[i]), POINT(i)); \n\t\t\t \n\t\tppopulation[map[i]]++; \n\t\t \n\t\tomp_unset_lock(&lock[j]); \n\t} \n\t \n\tend = timer_get(); \n\ttotal += timer_diff(start, end); \n\t \n\tsync_pcentroids(); \n \n\tsync_ppopulation(); \n\t \n\tstart = timer_get(); \n \n\t \n \n #pragma omp parallel for schedule(static) default(shared) private(i, j, population) \n\tfor (j = 0; j < lncentroids[rank]; j++) \n\t{ \n\t\tpopulation = 0; \n\t\t \n\t\tfor (i = 0; i < nprocs; i++) \n\t\t{ \n\t\t\tif (*POPULATION(i, j) == 0) \n\t\t\t\tcontinue; \n\t\t\t \n\t\t\tpopulation += *POPULATION(i, j); \n\t\t\t \n\t\t\tif (i == rank) \n\t\t\t\tcontinue; \n\t\t\t \n\t\t\tvector_add(PCENTROID(rank, j), PCENTROID(i, j)); \n\t\t} \n\t\t \n\t\tif (population > 1) \n\t\t\tvector_mult(PCENTROID(rank, j), 1.0/population); \n\t\t \n\t\t \n \n\t\tif (!vector_equal(PCENTROID(rank, j), LCENTROID(j))) \n\t\t{ \n\t\t\thas_changed[rank*NUM_THREADS + omp_get_thread_num()] = 1; \n\t\t\tvector_assign(LCENTROID(j), PCENTROID(rank, j)); \n\t\t} \n\t} \n\t \n\tend = timer_get(); \n\ttotal += timer_diff(start, end); \n\t\t \n\tsync_centroids(); \n\t\t \n\tsync_status(); \n} ", "pred": " \nstatic void compute_centroids(void) \n{ \n\tint i, j;        \n \n\tint population;  \n \n \n\tstart = timer_get(); \n\t \n\tmemcpy(lcentroids, CENTROID(rank*(ncentroids/nprocs)), lncentroids[rank]*dimension*sizeof(float)); \n\tmemset(&has_changed[rank*NUM_THREADS], 0, NUM_THREADS*sizeof(int)); \n\tmemset(centroids, 0, (ncentroids + DELTA*nprocs)*dimension*sizeof(float)); \n\tmemset(ppopulation, 0, (ncentroids + nprocs*DELTA)*sizeof(int)); \n \n\t \n \n #pragma omp parallel for schedule(static) default(shared) private(i, j) \n\tfor (i = 0; i < lnpoints; i++) \n\t{ \n\t\tj = map[i]%NUM_THREADS; \n\t\t \n\t\tomp_set_lock(&lock[j]); \n\t\t \n\t\tvector_add(CENTROID(map[i]), POINT(i)); \n\t\t\t \n\t\tppopulation[map[i]]++; \n\t\t \n\t\tomp_unset_lock(&lock[j]); \n\t} \n\t \n\tend = timer_get(); \n\ttotal += timer_diff(start, end); \n\t \n\tsync_pcentroids(); \n \n\tsync_ppopulation(); \n\t \n\tstart = timer_get(); \n \n\t \n \n #pragma omp parallel for schedule(static) default(shared) private(i, j, population) \n\tfor (j = 0; j < lncentroids[rank]; j++) \n\t{ \n\t\tpopulation = 0; \n\t\t \n\t\tfor (i = 0; i < nprocs; i++) \n\t\t{ \n\t\t\tif (*POPULATION(i, j) == 0) \n\t\t\t\tcontinue; \n\t\t\t \n\t\t\tpopulation += *POPULATION(i, j); \n\t\t\t \n\t\t\tif (i == rank) \n\t\t\t\tcontinue; \n\t\t\t \n\t\t\tvector_add(PCENTROID(rank, j), PCENTROID(rank, j), p, nprocs);\\n                                                                                                                                                                                                  "}
{"label": " \nvoid \ntest9 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (dynamic) \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest9 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (dynamic) \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ntest11 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (guided) \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest11 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (guided) \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nint findNodeDepths(double dt) \n{ \n    int i; \n    int converged;       \n \n    double yOld;         \n \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++ ) link_setOutfallDepth(i); \n \n     \n \n     \n \n    converged = TRUE; \n#pragma omp parallel num_threads(NumThreads)                                    \n \n{ \n    #pragma omp for private(yOld)                                               \n \n    for ( i = 0; i < Nobjects[NODE]; i++ ) \n    { \n        if ( Node[i].type == OUTFALL ) continue; \n        yOld = Node[i].newDepth; \n        setNodeDepth(i, dt); \n        Xnode[i].converged = TRUE; \n        if ( fabs(yOld - Node[i].newDepth) > HeadTol ) \n        { \n            converged = FALSE; \n            Xnode[i].converged = FALSE; \n        } \n    } \n}                                                                               \n \n    return converged; \n} ", "pred": " \nint findNodeDepths(double dt) \n{ \n    int i; \n    int converged;       \n \n    double yOld;         \n \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++ ) link_setOutfallDepth(i); \n \n     \n \n     \n \n    converged = TRUE; \n#pragma omp parallel num_threads(NumThreads)                                    \n \n{ \n    #pragma omp for private(yOld)                                               \n \n    for ( i = 0; i < Nobjects[NODE]; i++ ) \n    { \n        if ( Node[i].type == OUTFALL ) continue; \n        yOld = Node[i].newDepth; \n        setNodeDepth(i, dt); \n        Xnode[i].converged = TRUE; \n        if ( fabs(yOld - Node[i].newDepth) > HeadTol ) \n        { \n            converged = FALSE; \n            Xnode[i].converged = FALSE; \n        } \n    } \n}                                                                               \n \n    return converged; \n} "}
{"label": " \nvoid findLinkFlows(double dt) \n{ \n    int i; \n \n     \n \n#pragma omp parallel num_threads(NumThreads)                                    \n \n{ \n    #pragma omp for                                                             \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n        if ( isTrueConduit(i) &&!Link[i].bypassed ) \n            dwflow_findConduitFlow(i, Steps, Omega, dt); \n    } \n} \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n\t    if ( isTrueConduit(i) ) updateNodeFlows(i); \n    } \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n        if (!isTrueConduit(i) ) \n        {\t \n            if (!Link[i].bypassed ) findNonConduitFlow(i, dt); \n            updateNodeFlows(i); \n        } \n    } \n} ", "pred": " \nvoid findLinkFlows(double dt) \n{ \n    int i; \n \n     \n \n#pragma omp parallel num_threads(NumThreads)                                    \n \n{ \n    #pragma omp for                                                             \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n        if ( isTrueConduit(i) &&!Link[i].bypassed ) \n            dwflow_findConduitFlow(i, Steps, Omega, dt); \n    } \n} \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n\t    if ( isTrueConduit(i) ) updateNodeFlows(i); \n    } \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n        if (!isTrueConduit(i) ) \n        {\t \n            if (!Link[i].bypassed ) findNonConduitFlow(i, dt); \n            updateNodeFlows(i); \n        } \n    } \n} "}
{"label": " \nstatic void populate(void) \n{ \n\tint i, j;         \n \n\tfloat tmp;       \n \n\tfloat distance;  \n \n \n\tstart = timer_get(); \n\tmemset(&too_far[rank*NUM_THREADS], 0, NUM_THREADS*sizeof(int));  \n\t \n\t \n \n #pragma omp parallel for schedule(static) default(shared) private(i, j, tmp, distance) \n\tfor (i = 0; i < lnpoints; i++) \n\t{ \n\t\tdistance = vector_distance(CENTROID(map[i]), POINT(i)); \n\t\t \n\t\t \n \n\t\tfor (j = 0; j < ncentroids; j++) \n\t\t{ \n\t\t\t \n \n\t\t\tif (j == map[i]) \n\t\t\t\tcontinue; \n\t\t\t\t \n\t\t\ttmp = vector_distance(CENTROID(j), POINT(i)); \n\t\t\t \n\t\t\t \n \n\t\t\tif (tmp < distance) \n\t\t\t{ \n\t\t\t\tmap[i] = j; \n\t\t\t\tdistance = tmp; \n\t\t\t} \n\t\t} \n\t\t \n\t\t \n \n\t\tif (distance > mindistance) \n\t\t\ttoo_far[rank*NUM_THREADS + omp_get_thread_num()] = 1; \n\t} \n\tend = timer_get(); \n\ttotal += timer_diff(start, end); \n\t \n} ", "pred": " \nstatic void populate(void) \n{ \n\tint i, j;         \n \n\tfloat tmp;       \n \n\tfloat distance;  \n \n \n\tstart = timer_get(); \n\tmemset(&too_far[rank*NUM_THREADS], 0, NUM_THREADS*sizeof(int));  \n\t \n\t \n \n #pragma omp parallel for schedule(static) default(shared) private(i, j, tmp, distance) \n\tfor (i = 0; i < lnpoints; i++) \n\t{ \n\t\tdistance = vector_distance(CENTROID(map[i]), POINT(i)); \n\t\t \n\t\t \n \n\t\tfor (j = 0; j < ncentroids; j++) \n\t\t{ \n\t\t\t \n \n\t\t\tif (j == map[i]) \n\t\t\t\tcontinue; \n\t\t\t\t \n\t\t\ttmp = vector_distance(CENTROID(j), POINT(i)); \n\t\t\t \n\t\t\t \n \n\t\t\tif (tmp < distance) \n\t\t\t{ \n\t\t\t\tmap[i] = j; \n\t\t\t\tdistance = tmp; \n\t\t\t} \n\t\t} \n\t\t \n\t\t \n \n\t\tif (distance > mindistance) \n\t\t\ttoo_far[rank*NUM_THREADS + omp_get_thread_num()] = 1; \n\t} \n\tend = timer_get(); \n\ttotal += timer_diff(start, end); \n\t \n} "}
{"label": " \nvoid \ntest14 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (dynamic) ordered \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n#pragma omp ordered \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest14 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel for reduction (+:e,c) schedule (dynamic) ordered \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n#pragma omp ordered \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nstatic int crypt_all(int *pcount, struct db_salt *salt) \n{ \n\tint count = *pcount; \n\tint i; \n \n#pragma omp parallel for default(none) private(i) shared(ctx_salt, count, saved_key, saved_key_length, crypt_out) \n#pragma omp parallel for default(none) private(i) shared(saved_salt, count, saved_key, saved_key_length, crypt_out) \n\tfor (i = 0; i < count; i++) { \n\t\tSHA512_CTX ctx; \n \n\t\tmemcpy(&ctx, &ctx_salt, sizeof(ctx)); \n\t\tSHA512_Init(&ctx); \n\t\tSHA512_Update(&ctx, &saved_salt, SALT_SIZE); \n \n\t\tSHA512_Update(&ctx, saved_key[i], saved_key_length[i]); \n\t\tSHA512_Final((unsigned char *)(crypt_out[i]), &ctx); \n\t} \n\treturn count; \n} ", "pred": " \nstatic int crypt_all(int *pcount, struct db_salt *salt) \n{ \n\tint count = *pcount; \n\tint i; \n \n#pragma omp parallel for default(none) private(i) shared(ctx_salt, count, saved_key, saved_key_length, crypt_out) \n#pragma omp parallel for default(none) private(i) shared(saved_salt, count, saved_key, saved_key_length, crypt_out) \n\tfor (i = 0; i < count; i++) { \n\t\tSHA512_CTX ctx; \n \n\t\tmemcpy(&ctx, &ctx_salt, sizeof(ctx)); \n\t\tSHA512_Init(&ctx); \n\t\tSHA512_Update(&ctx, &saved_salt, SALT_SIZE); \n \n\t\tSHA512_Update(&ctx, saved_key[i], saved_key_length[i]); \n\t\tSHA512_Final((unsigned char *)(crypt_out[i]), &ctx); \n\t} \n\treturn count; \n} "}
{"label": " \nvoid \ntest6 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (dynamic) ordered \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n#pragma omp ordered \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest6 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (dynamic) ordered \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n#pragma omp ordered \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ntest1 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (dynamic) \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest1 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (dynamic) \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 16; \n  tile_size[3] = 32; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,12);t1++) { \n    lbp=max(ceild(t1,2),ceild(24*t1-Nt+3,24)); \n    ubp=min(floord(Nt+Nz-4,24),floord(12*t1+Nz+9,24)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(3*t1-3,4)),ceild(24*t2-Nz-12,16));t3<=min(min(min(floord(Nt+Ny-4,16),floord(12*t1+Ny+21,16)),floord(24*t2+Ny+20,16)),floord(24*t1-24*t2+Nz+Ny+19,16));t3++) { \n        for (t4=max(max(max(0,ceild(3*t1-7,8)),ceild(24*t2-Nz-28,32)),ceild(16*t3-Ny-28,32));t4<=min(min(min(min(floord(Nt+Nx-4,32),floord(12*t1+Nx+21,32)),floord(24*t2+Nx+20,32)),floord(16*t3+Nx+12,32)),floord(24*t1-24*t2+Nz+Nx+19,32));t4++) { \n          for (t5=max(max(max(max(max(0,12*t1),24*t1-24*t2+1),24*t2-Nz+2),16*t3-Ny+2),32*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,12*t1+23),24*t2+22),16*t3+14),32*t4+30),24*t1-24*t2+Nz+21);t5++) { \n            for (t6=max(max(24*t2,t5+1),-24*t1+24*t2+2*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(16*t3,t5+1);t7<=min(16*t3+15,", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *) tile_size, sizeof(int)*Nz);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": " \nvoid mul_add_mul_r(spinor * const R, spinor * const S, spinor * const U, \n\t\t   const double c1,const double c2, const int N) { \n#pragma omp parallel \n  { \n \n  int ix; \n  spinor *r,*s,*u; \n   \n#pragma omp for \n  for (ix=0; ix < N; ix++){ \n    r=(spinor *) R + ix; \n    s=(spinor *) S + ix; \n    u=(spinor *) U + ix; \n     \n    r->s0.c0 = c1 * s->s0.c0 + c2 * u->s0.c0; \n    r->s0.c1 = c1 * s->s0.c1 + c2 * u->s0.c1; \n    r->s0.c2 = c1 * s->s0.c2 + c2 * u->s0.c2; \n     \n    r->s1.c0 = c1 * s->s1.c0 + c2 * u->s1.c0; \n    r->s1.c1 = c1 * s->s1.c1 + c2 * u->s1.c1; \n    r->s1.c2 = c1 * s->s1.c2 + c2 * u->s1.c2; \n \n    r->s2.c0 = c1 * s->s2.c0 + c2 * u->s2.c0; \n    r->s2.c1 = c1 * s->s2.c1 + c2 * u->s2.c1; \n    r->s2.c2 = c1 * s->s2.c2 + c2 * u->s2.c2; \n \n    r->s3.c0 = c1 * s->s3.c0 + c2 * u->s3.c0; \n    r->s3.c1 = c1 * s->s3.c1 + c2 * u->s3.c1; \n    r->s3.c2 = c1 * s->s3.c2 + c2 * u->s3.c2; \n  } \n  }  \n \n} ", "pred": " \nvoid mul_add_mul_r(spinor * const R, spinor * const S, spinor * const U, \n\t\t   const double c1,const double c2, const int N) { \n#pragma omp parallel \n  { \n \n  int ix; \n  spinor *r,*s,*u; \n   \n#pragma omp for \n  for (ix=0; ix < N; ix++){ \n    r=(spinor *) R + ix; \n    s=(spinor *) S + ix; \n    u=(spinor *) U + ix; \n     \n    r->s0.c0 = c1 * s->s0.c0 + c2 * u->s0.c0; \n    r->s0.c1 = c1 * s->s0.c1 + c2 * u->s0.c1; \n    r->s0.c2 = c1 * s->s0.c2 + c2 * u->s0.c2; \n     \n    r->s1.c0 = c1 * s->s1.c0 + c2 * u->s1.c0; \n    r->s1.c1 = c1 * s->s1.c1 + c2 * u->s1.c1; \n    r->s1.c2 = c1 * s->s1.c2 + c2 * u->s1.c2; \n \n    r->s2.c0 = c1 * s->s2.c0 + c2 * u->s2.c0; \n    r->s2.c1 = c1 * s->s2.c1 + c2 * u->s2.c1; \n    r->s2.c2 = c1 * s->s2.c2 + c2 * u->s2.c2; \n \n    r->s3.c0 = c1 * s->s3.c0 + c2 * u->s3.c0; \n    r->s3.c1 = c1 * s->s3.c1 + c2 * u->s3.c1; \n    r->s3.c2 = c1 * s->s3.c2 + c2 * u->s3.c2;    r->s3.c3 = c1 * s"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 4; \n  tile_size[3] = 64; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,4);t1++) { \n    lbp=max(ceild(t1,2),ceild(8*t1-Nt+3,8)); \n    ubp=min(floord(Nt+Nz-4,8),floord(4*t1+Nz+1,8)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(8*t2-Nz,4)),t1);t3<=min(min(min(floord(Nt+Ny-4,4),floord(4*t1+Ny+5,4)),floord(8*t2+Ny+4,4)),floord(8*t1-8*t2+Nz+Ny+3,4));t3++) { \n        for (t4=max(max(max(0,ceild(t1-15,16)),ceild(8*t2-Nz-60,64)),ceild(4*t3-Ny-60,64));t4<=min(min(min(min(floord(4*t3+Nx,64),floord(Nt+Nx-4,64)),floord(4*t1+Nx+5,64)),floord(8*t2+Nx+4,64)),floord(8*t1-8*t2+Nz+Nx+3,64));t4++) { \n          for (t5=max(max(max(max(max(0,4*t1),8*t1-8*t2+1),8*t2-Nz+2),4*t3-Ny+2),64*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,4*t1+7),8*t2+6),4*t3+2),64*t4+62),8*t1-8*t2+Nz+5);t5++) { \n            for (t6=max(max(8*t2,t5+1),-8*t1+8*t2+2*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(4*t3,t5+1);t7<=min(4*t3+3,t5+Ny-2);t7++) { \n ", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *) tile_size, sizeof(int)*Nz);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": " \nvoid winograd_conv(const int M, int irows, int C, int K, const int batch, long* total_flops, double* total_time, const int mod, const int verify){ \n    \n    long i, j, n;  \n    const int outHeight = irows-2;  \n    const int outWidth = irows-2;  \n    const int sizeI = irows*irows;  \n    const int sizeF = 3*3;  \n    const int sizeO = outHeight*outWidth;  \n    const int tiles = (outHeight)*0.5*(outWidth)*0.5;  \n \n    int ret;  \n \n    float* image;  \n     \n \n    ret = hbw_posix_memalign((void*)&image, 64, batch*C*sizeI*sizeof(float));  \n    assert(image!= NULL);  \n \n    float* filter;  \n     \n \n    ret = hbw_posix_memalign((void*)&filter, 64, K*C*sizeF*sizeof(float));  \n    assert(filter!= NULL);  \n \n \n    float* out;  \n     \n \n    ret = hbw_posix_memalign((void*)&out, 64, batch*K*sizeO*sizeof(float));  \n    assert(out!= NULL);  \n     \n     \n \n    #pragma omp parallel for private(i) \n    for(i = 0; i < batch*C*sizeI; i++) \n        image[i] = (float)(i%mod);  \n     \n     \n \n    #pragma omp parallel for private(i) \n    for(i = 0; i < K*C*sizeF; i++) \n        filter[i] = (float)(i%mod);  \n     \n \n    double timer;  \n    double timer_acc = 0.0f;  \n \n     \n \n    for(i = 0; i < 5; i++){ \n         \n \n        if (i>0) timer= omp_get_wtime();  \n        fal_conv(M, image, irows, C, filter, K, batch, out);  \n        if(i>0) timer_acc += omp_get_wtime()-timer;  \n    } \n \n    timer = timer_acc/4.0f;  \n    long nflops = batch*K*C*(irows-2)*(irows-2)*3*3*2;  \n    double gflops = (double) nflops*1.0e-9/timer;  \n    *total_flops += nflops;  \n    *total_time += timer;  \n \n    if(verify){ \n        printf(\"Verifying WINOGRAD CONV I = %d Batch = %d C = %d K = %d \\n\", irows, batch, C, K);  \n \n        float* vout;  \n         \n \n        ret = hbw_posix_memalign((void*)&vout, 64, batch*K*sizeO*sizeof(float));  \n        assert(vout!= NULL);  \n        direct_conv(image, filter, vout, batch, K, outHeight, outWidth, C, 3, 3);  \n        for(n = 0; n < batch*sizeO*K; n++){ \n            if(out[n]!= vout[n]){ \n                printf(\"Output Error: out[%d] = %f and vout[%d] = %f \\n\", n, out[n], n, vout[n]);  \n                break;  \n            } \n        } \n        hbw_free(vout);  \n    }else  \n        printf(\"WINOGRAD CONV:\\tEFFECTIVE GFLOPS is %.2f \\tGFlops \\tand timing is \\t%f  seconds \\n\", gflops, timer);  \n \n    hbw_free(image);  \n    hbw_free(filter);  \n    hbw_free(out);  \n \n} ", "pred": " \nvoid winograd_conv(const int M, int irows, int C, int K, const int batch, long* total_flops, double* total_time, const int mod, const int verify){ \n    \n    long i, j, n;  \n    const int outHeight = irows-2;  \n    const int outWidth = irows-2;  \n    const int sizeI = irows*irows;  \n    const int sizeF = 3*3;  \n    const int sizeO = outHeight*outWidth;  \n    const int tiles = (outHeight)*0.5*(outWidth)*0.5;  \n \n    int ret;  \n \n    float* image;  \n     \n \n    ret = hbw_posix_memalign((void*)&image, 64, batch*C*sizeI*sizeof(float));  \n    assert(image!= NULL);  \n \n    float* filter;  \n     \n \n    ret = hbw_posix_memalign((void*)&filter, 64, K*C*sizeF*sizeof(float));  \n    assert(filter!= NULL);  \n \n \n    float* out;  \n     \n \n    ret = hbw_posix_memalign((void*)&out, 64, batch*K*sizeO*sizeof(float));  \n    assert(out!= NULL);  \n     \n     \n \n    #pragma omp parallel for private(i) \n    for(i = 0; i < batch*C*sizeI; i++) \n        image[i] = (float)(i%mod);  \n     \n     \n \n    #pragma omp parallel for private(i) \n    for(i = 0; i < K*C*sizeF; i++) \n        filter[i] = (float)(i%mod);  \n     \n \n    double timer;  \n    double timer_acc = 0.0f;  \n \n     \n \n    for(i = 0; i < 5; i++)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "}
{"label": " \nvoid \ntest5 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (dynamic) ordered \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n#pragma omp ordered \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest5 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (dynamic) ordered \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n#pragma omp ordered \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid THNN_(SpatialConvolutionLocal_updateOutput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *output, \n    THTensor *weight, \n    THTensor *bias, \n    THTensor *finput, \n    THTensor *fgradInput, \n    int kW, int kH, \n    int dW, int dH, \n    int padW, int padH, \n    int64_t inputWidth, int64_t inputHeight, \n    int64_t outputWidth, int64_t outputHeight) \n{ \n  weight = THNN_(view_weight_local)(weight); \n \n  THNN_(SpatialConvolutionLocal_shapeCheck) \n    (input, NULL, weight, bias, kH, kW, dH, dW, padH, padW, \n     inputHeight, inputWidth, outputHeight, outputWidth); \n \n  input = THTensor_(newContiguous)(input); \n \n  int64_t nInputPlane = THTensor_(size)(weight, 2)/ (kW * kH); \n  int64_t nOutputPlane = THTensor_(size)(weight, 1); \n \n  if(input->nDimension == 3) \n  { \n    THTensor_(resize2d)(finput, kW*kH*nInputPlane, outputHeight*outputWidth); \n    THTensor_(resize3d)(output, nOutputPlane, outputHeight, outputWidth); \n \n    THNN_(SpatialConvolutionLocal_updateOutput_frame) \n      (input, output, weight, bias, finput, \n       kW, kH, dW, dH, padW, padH, \n       nInputPlane, inputWidth, inputHeight, \n       nOutputPlane, outputWidth, outputHeight); \n  } \n  else \n  { \n    int64_t T = input->size[0]; \n    int64_t t; \n \n    THTensor_(resize3d)(finput, T, kW*kH*nInputPlane, outputHeight*outputWidth); \n    THTensor_(resize4d)(output, T, nOutputPlane, outputHeight, outputWidth); \n \n#pragma omp parallel for private(t) \n    for(t = 0; t < T; t++) \n    { \n      THTensor *input_t = THTensor_(newSelect)(input, 0, t); \n      THTensor *output_t = THTensor_(newSelect)(output, 0, t); \n      THTensor *finput_t = THTensor_(newSelect)(finput, 0, t); \n \n      THNN_(SpatialConvolutionLocal_updateOutput_frame) \n    (input_t, output_t, weight, bias, finput_t, \n     kW, kH, dW, dH, padW, padH, \n     nInputPlane, inputWidth, inputHeight, \n     nOutputPlane, outputWidth, outputHeight); \n \n      THTensor_(free)(input_t); \n      THTensor_(free)(output_t); \n      THTensor_(free)(finput_t); \n    } \n  } \n \n  THTensor_(free)(input); \n  THTensor_(free)(weight); \n} ", "pred": " \nvoid THNN_(SpatialConvolutionLocal_updateOutput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *output, \n    THTensor *weight, \n    THTensor *bias, \n    THTensor *finput, \n    THTensor *fgradInput, \n    int kW, int kH, \n    int dW, int dH, \n    int padW, int padH, \n    int64_t inputWidth, int64_t inputHeight, \n    int64_t outputWidth, int64_t outputHeight) \n{ \n  weight = THNN_(view_weight_local)(weight); \n \n  THNN_(SpatialConvolutionLocal_shapeCheck) \n    (input, NULL, weight, bias, kH, kW, dH, dW, padH, padW, \n     inputHeight, inputWidth, outputHeight, outputWidth); \n \n  input = THTensor_(newContiguous)(input); \n \n  int64_t nInputPlane = THTensor_(size)(weight, 2)/ (kW * kH); \n  int64_t nOutputPlane = THTensor_(size)(weight, 1); \n \n  if(input->nDimension == 3) \n  { \n    THTensor_(resize2d)(finput, kW*kH*nInputPlane, outputHeight*outputWidth); \n    THTensor_(resize3d)(output, nOutputPlane, outputHeight, outputWidth); \n \n    THNN_(SpatialConvolutionLocal_updateOutput_frame) \n      (input, output, weight, bias, finput, \n       kW, kH, dW, dH, padW, padH, \n       nInputPlane, inputWidth, inputHeight, \n       nOutputPlane, outputWidth, outputHeight); \n  } \n  else \n  { \n    int64_t T = input->size[0]; \n    int64_t t; \n \n    THTensor_(resize3d)(finput, T, kW*kH*nInputPlane, outputHeight*outputWidth); \n    THTensor_(resize4d)(finput, T, chi*kH*nInputPlane, outputHeight*outputWidth);                                                                                                                                                                                                                                                                                                                           "}
{"label": " \nvoid \ntest8 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (guided) ordered \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n#pragma omp ordered \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest8 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (guided) ordered \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n#pragma omp ordered \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \nmontecarlo_main_loop(storage_model_t * storage, int64_t virtual_packet_flag, int nthreads, unsigned long seed) \n{ \n  int64_t packet_index; \n  storage->virt_packet_nus = (double *)malloc(sizeof(double) * storage->no_of_packets); \n  storage->virt_packet_energies = (double *)malloc(sizeof(double) * storage->no_of_packets); \n  storage->virt_packet_count = 0; \n  storage->virt_array_size = storage->no_of_packets; \n  fprintf(stderr, \"Running with OpenMP - %d threads\", nthreads); \n  omp_set_dynamic(0); \n  omp_set_num_threads(nthreads); \n#pragma omp parallel \n  { \n    initialize_random_kit(seed + omp_get_thread_num()); \n#pragma omp for \n  fprintf(stderr, \"Running without OpenMP\"); \n  initialize_random_kit(seed); \n  for (packet_index = 0; packet_index < storage->no_of_packets; packet_index++) \n    { \n      int reabsorbed = 0; \n      rpacket_t packet; \n      rpacket_set_id(&packet, packet_index); \n      rpacket_init(&packet, storage, packet_index, virtual_packet_flag); \n      if (virtual_packet_flag > 0) \n\t{ \n\t  reabsorbed = montecarlo_one_packet(storage, &packet, -1); \n\t} \n      reabsorbed = montecarlo_one_packet(storage, &packet, 0); \n      storage->output_nus[packet_index] = rpacket_get_nu(&packet); \n      if (reabsorbed == 1) \n\t{ \n\t  storage->output_energies[packet_index] = -rpacket_get_energy(&packet); \n\t} \n      else \n\t{ \n\t  storage->output_energies[packet_index] = rpacket_get_energy(&packet); \n\t} \n    } \n  } \n} ", "pred": " \nvoid \nmontecarlo_main_loop(storage_model_t * storage, int64_t virtual_packet_flag, int nthreads, unsigned long seed) \n{ \n  int64_t packet_index; \n  storage->virt_packet_nus = (double *)malloc(sizeof(double) * storage->no_of_packets); \n  storage->virt_packet_energies = (double *)malloc(sizeof(double) * storage->no_of_packets); \n  storage->virt_packet_count = 0; \n  storage->virt_array_size = storage->no_of_packets; \n  fprintf(stderr, \"Running with OpenMP - %d threads\", nthreads); \n  omp_set_dynamic(0); \n  omp_set_num_threads(nthreads); \n#pragma omp parallel \n  { \n    initialize_random_kit(seed + omp_get_thread_num()); \n#pragma omp for \n  fprintf(stderr, \"Running without OpenMP\"); \n  initialize_random_kit(seed); \n  for (packet_index = 0; packet_index < storage->no_of_packets; packet_index++) \n    { \n      int reabsorbed = 0; \n      rpacket_t packet; \n      rpacket_set_id(&packet, packet_index); \n      rpacket_init(&packet, storage, packet_index, virtual_packet_flag); \n      if (virtual_packet_flag > 0) \n\t{ \n\t  reabsorbed = montecarlo_one_packet(storage, &packet, -1); \n\t} \n      reabsorbed = montecarlo_one_packet(storage, &packet, 0); \n      storage->output_nus[packet_index] = rpacket_get_nu(&packet); \n      if (reabsorbed == 1) \n\t{ \n\t  storage->output_energies[packet_index] = -rpacket_get_energy(&packet); \n\t} \n      else \n\t{ \n\t  storage->output_energies[packet_index] = rpacket_get_energy(&packet);                  "}
{"label": " \nvoid \ntest2 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (dynamic) \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest2 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (dynamic) \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ntest4 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (guided) \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest4 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n#pragma omp parallel reduction (+:e,c) \n  { \n#pragma omp for schedule (guided) \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n#pragma omp atomic \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid  \nupdate_rho(double *rho,  \n           double *t) \n{ \n     \n \n \n    int i, j; \n \n    double ref_rho = 100.; \n    double ref_temp = 500.; \n    double thermal_expansivity = 0.001; \n \n    #pragma omp parallel for \n    for ( j = 0; j < NY; j++ ){ \n       for ( i = 0; i < NX; i++ ){ \n           rho[NX*j + i] = ref_rho * (1. - (thermal_expansivity * (t[NX*j + i] - ref_temp))); \n       } \n    } \n} ", "pred": " \nvoid  \nupdate_rho(double *rho,  \n           double *t) \n{ \n     \n \n \n    int i, j; \n \n    double ref_rho = 100.; \n    double ref_temp = 500.; \n    double thermal_expansivity = 0.001; \n \n    #pragma omp parallel for \n    for ( j = 0; j < NY; j++ ){ \n       for ( i = 0; i < NX; i++ ){ \n           rho[NX*j + i] = ref_rho * (1. - (thermal_expansivity * (t[NX*j + i] - ref_temp))); \n       } \n    } \n} "}
{"label": "lar_t k_arborescence_genf2(index_t         n, \n                              index_t         m, \n                              index_t         k, \n                              index_t         g, \n                              index_t         *d_pos, \n                              index_t         *d_adj,  \n                              ffprng_scalar_t y_seed, \n                              line_array_t    *d_x)  \n{ \n \n    assert(g == SCALARS_IN_LINE);    \n    assert(k >= 1); \n \n    line_array_t *d_s0  = (line_array_t *) MALLOC(LINE_ARRAY_SIZE(n*g)); \n    line_array_t *d_s1  = (line_array_t *) MALLOC(LINE_ARRAY_SIZE(n*g)); \n \n    scalar_t sum; \n    SCALAR_SET_ZERO(sum); \n \n     \n \n     \n \n     \n \n     \n \n    index_t deg = 1UL << (k-1); \n    for(index_t d = 0; d <= deg; d++) { \n        scalar_t zd = d+1;  \n         \n         \n \n#pragma omp parallel for \n        for(index_t u = 0; u < n; u++) { \n            line_t xu; \n            LINE_LOAD(xu, d_x, u);        \n \n            line_t xuzd; \n            LINE_MUL_SCALAR(xuzd, xu, zd);   \n \n            LINE_STORE(d_s0, u, xuzd);    \n \n        } \n \n         \n \n        srand(y_seed); \n        for(index_t l = 2; l <= k; l++) { \n            ffprng_scalar_t yl_seed = irand();  \n                 \n \n                 \n \n            k_arborescence_genf2_round(n,m,k,g,l,d_pos,d_adj,yl_seed,d_s0,d_s1); \n            line_array_t *tmp = d_s0; \n            d_s0 = d_s1; \n            d_s1 = tmp; \n        } \n         \n \n \n         \n \n        scalar_t zdsum = line_sum(n, g, d_s0); \n        scalar_t ldk = lagrange_coeff(deg, d, k); \n        scalar_t pk; \n        SCALAR_MUL(pk, ldk, zdsum); \n        SCALAR_ADD(sum, sum, pk);  \n    } \n \n    FREE(d_s0); \n    FREE(d_s1); \n \n    trans_bytes += (deg+1)*2*n*g*sizeof(scalar_t); \n    num_muls    += (deg+1)*n*g; \n \n    return sum; \n} \n \n \n \n ", "pred": "lar_t k_arborescence_genf2(index_t         n, \n                              index_t         m, \n                              index_t         k, \n                              index_t         g, \n                              index_t         *d_pos, \n                              index_t         *d_adj,  \n                              ffprng_scalar_t y_seed, \n                              line_array_t    *d_x)  \n{ \n \n    assert(g == SCALARS_IN_LINE);    \n    assert(k >= 1); \n \n    line_array_t *d_s0  = (line_array_t *) MALLOC(LINE_ARRAY_SIZE(n*g)); \n    line_array_t *d_s1  = (line_array_t *) MALLOC(LINE_ARRAY_SIZE(n*g)); \n \n    scalar_t sum; \n    SCALAR_SET_ZERO(sum); \n \n     \n \n     \n \n     \n \n     \n \n    index_t deg = 1UL << (k-1); \n    for(index_t d = 0; d <= deg; d++) { \n        scalar_t zd = d+1;  \n         \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "}
{"label": " \nvoid  \napply_thermal_boundary_conditions(double *t) \n{ \n    int i, j; \n    \n    #pragma omp parallel for \n    for ( j = 0; j < NY; j++ ){ \n         \n \n        t[NX*j + 0] = t[NX*j + 1]; \n         \n         \n \n        t[NX*j + (NX-1)] = t[NX*j + (NX-2)]; \n    } \n     \n \n    #pragma omp parallel for \n    for ( i = 0; i < NX; i++ ){ \n         \n \n        t[0 + i] = 1000.; \n \n         \n \n        t[NX*(NY-1) + i] = 0.; \n    } \n} ", "pred": " \nvoid  \napply_thermal_boundary_conditions(double *t) \n{ \n    int i, j; \n    \n    #pragma omp parallel for \n    for ( j = 0; j < NY; j++ ){ \n         \n \n        t[NX*j + 0] = t[NX*j + 1]; \n         \n         \n \n        t[NX*j + (NX-1)] = t[NX*j + (NX-2)]; \n    } \n     \n \n    #pragma omp parallel for \n    for ( i = 0; i < NX; i++ ){ \n         \n \n        t[0 + i] = 1000.; \n \n         \n \n        t[NX*(NY-1) + i] = 0.; \n    } \n} "}
{"label": " \nstatic IDnum *computeReadToNodeCounts(Coordinate *totalCount) \n{ \n\tIDnum nodeIndex; \n\tIDnum maxNodeIndex = 2 * nodeCount(graph) + 1; \n\tIDnum maxReadIndex = sequenceCount(graph) + 1; \n\tIDnum *readNodeCounts = callocOrExit(maxReadIndex, IDnum); \n\tunsigned char *readMarker = callocOrExit(1 + maxReadIndex / 8, unsigned char); \n\tCoordinate total = 0; \n \n\tvelvetLog(\"Computing read to node mapping array sizes\\n\"); \n \n #pragma omp parallel for reduction(+:total) \n\tfor (nodeIndex = 0; nodeIndex < maxNodeIndex; nodeIndex++) { \n\t\tNode *node; \n\t\tShortReadMarker *nodeArray; \n\t\tIDnum nodeReadCount; \n\t\tIDnum readIndex; \n \n\t\tnode = getNodeInGraph(graph, nodeIndex - nodeCount(graph)); \n\t\tif (node == NULL) \n\t\t\tcontinue; \n\t\tnodeArray = getNodeReads(node, graph); \n\t\tnodeReadCount = getNodeReadCount(node, graph); \n \n\t\t \n \n\t\tfor (readIndex = 0; readIndex < nodeReadCount; readIndex++) { \n\t\t\tShortReadMarker *shortMarker; \n\t\t\tIDnum readID; \n \n\t\t\tshortMarker = getShortReadMarkerAtIndex(nodeArray, \n\t\t\t\t\t\t\t\treadIndex); \n\t\t\treadID = getShortReadMarkerID(shortMarker); \n   #pragma omp atomic \n\t\t\treadNodeCounts[readID]++; \n\t\t\ttotal++; \n\t\t} \n\t} \n \n\tfor (nodeIndex = 0; nodeIndex < maxNodeIndex; nodeIndex++) { \n\t\tNode *node; \n\t\tPassageMarkerI marker; \n \n\t\tnode = getNodeInGraph(graph, nodeIndex - nodeCount(graph)); \n\t\tif (node == NULL) \n\t\t\tcontinue; \n\t\t \n \n\t\tfor (marker = getMarker(node); marker!= NULL_IDX; \n\t\t     marker = getNextInNode(marker)) { \n\t\t\tIDnum readIndex = getPassageMarkerSequenceID(marker);; \n \n\t\t\tif (readIndex < 0) \n\t\t\t\tcontinue; \n \n\t\t\tconst unsigned int idx = readIndex / 8; \n\t\t\tconst unsigned int mask = 1 << (readIndex & 7); \n\t\t\tif (readMarker[idx] & mask) \n\t\t\t\tcontinue; \n \n\t\t\treadNodeCounts[readIndex]++; \n\t\t\ttotal++; \n\t\t\treadMarker[idx] |= mask; \n\t\t} \n \n\t\t \n \n\t\tfor (marker = getMarker(node); marker!= NULL_IDX; \n\t\t     marker = getNextInNode(marker)) { \n\t\t\tIDnum readIndex = getPassageMarkerSequenceID(marker); \n\t\t\tif (readIndex > 0) \n\t\t\t\t \n \n\t\t\t\treadMarker[readIndex / 8] = 0; \n\t\t} \n\t} \n \n\t*totalCount = total; \n\tfree(readMarker); \n\treturn readNodeCounts; \n} ", "pred": " \nstatic IDnum *computeReadToNodeCounts(Coordinate *totalCount) \n{ \n\tIDnum nodeIndex; \n\tIDnum maxNodeIndex = 2 * nodeCount(graph) + 1; \n\tIDnum maxReadIndex = sequenceCount(graph) + 1; \n\tIDnum *readNodeCounts = callocOrExit(maxReadIndex, IDnum); \n\tunsigned char *readMarker = callocOrExit(1 + maxReadIndex / 8, unsigned char); \n\tCoordinate total = 0; \n \n\tvelvetLog(\"Computing read to node mapping array sizes\\n\"); \n \n #pragma omp parallel for reduction(+:total) \n\tfor (nodeIndex = 0; nodeIndex < maxNodeIndex; nodeIndex++) { \n\t\tNode *node; \n\t\tShortReadMarker *nodeArray; \n\t\tIDnum nodeReadCount; \n\t\tIDnum readIndex; \n \n\t\tnode = getNodeInGraph(graph, nodeIndex - nodeCount(graph)); \n\t\tif (node == NULL) \n\t\t\tcontinue; \n\t\tnodeArray = getNodeReads(node, graph); \n\t\tnodeReadCount = getNodeReadCount(node, graph); \n \n\t\t \n \n\t\tfor (readIndex = 0; readIndex < nodeReadCount; readIndex++) { \n\t\t\tShortReadMarker *shortMarker; \n\t\t\tIDnum readID; \n \n\t\t\tshortMarker = getShortReadMarkerAtIndex(nodeArray, \n\t\t\t\t\t\t\t\treadIndex); \n\t\t\treadID = getShortReadMarkerID(shortMarker); \n   #pragma omp atomic \n\t\t\treadNodeCounts[readID]++; \n\t\t\ttotal++; \n\t\t} \n\t} \n \n\tfor (nodeIndex = 0; nodeIndex < maxNodeIndex; nodeIndex++) { \n\t\tNode *node; \n\t\tPassageMarkerI marker; \n \n\t\tnode = getNodeInGraph(graph, nodeIndex - nodeCount(graph)); \n\t\tif (node == NULL) \n\t\t\tcontinue; \n\t\t \n \n\t\tfor (marker = getMarker(node); marker!= NULL_IDX; \n\t\t     marker = getNextInNode(marker)) { \n\t\t\tIDnum readIndex = getPassageMarkerSequenceID(marker);; \n                                                                                                                                                                                                                                                                                    "}
{"label": "d randinits_scalar(scalar_t *a, index_t s, ffprng_scalar_t seed)  \n{ \n    ffprng_t base; \n    FFPRNG_INIT(base, seed); \n    index_t nt = num_threads(); \n    index_t block_size = s/nt; \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        ffprng_t gen; \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? s-1 : (start+block_size-1); \n        FFPRNG_FWD(gen, start, base); \n        for(index_t i = start; i <= stop; i++) { \n            ffprng_scalar_t rnd; \n            FFPRNG_RAND(rnd, gen); \n            scalar_t rs = (scalar_t) rnd;            \n            a[i] = rs; \n        } \n    } \n} \n \n/* ", "pred": "d randinits_scalar(scalar_t *a, index_t s, ffprng_scalar_t seed)  \n{ \n    ffprng_t base; \n    FFPRNG_INIT(base, seed); \n    index_t nt = num_threads(); \n    index_t block_size = s/nt; \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        ffprng_t gen; \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? s-1 : (start+block_size-1); \n        FFPRNG_FWD(gen, start, base); \n        for(index_t i = start; i <= stop; i++) { \n            ffprng_scalar_t rnd; \n            FFPRNG_RAND(rnd, gen); \n            scalar_t rs = (scalar_t) rnd;            \n            a[i] = rs; \n        } \n    } \n} \n \n/* "}
{"label": " \nvoid  \nsolve_advection_diffusion(double *t,  \n                          double *u,  \n                          double *v, \n                          double dx,  \n                          double dy, \n                          double *rho,  \n                          double dt, \n                          double cp,  \n                          double *k, \n                          double H) \n{ \n    int i,j;  \n    double tn[NY*NX]; \n    double kx; \n    double ky; \n \n     \n \n    double dx2 = dx * dx; \n    double dy2 = dy * dy; \n    double twodx = 2. * dx; \n    double twody = 2. * dy; \n \n    #pragma omp parallel for \n    for ( j = 0; j < NY; j++ ){ \n       for ( i = 0; i < NX; i++ ){ \n           tn[NX*j + i] = t[NX*j + i]; \n       } \n    } \n    \n  \n    unsigned int n = 0; \n    unsigned int s = 0; \n    unsigned int m = 0; \n    unsigned int e = 0; \n    unsigned int w = 0; \n \n    #pragma omp parallel for \n    for ( j = 1; j < NY-1; j++ ){ \n        #pragma omp simd safelen(3) \n        for ( i = 1; i < NX-1; i++){ \n            m = NX*j + i; \n            n = NX*(j-1) + i; \n            s = NX*(j+1) + i; \n            e = NX*j + (i+1); \n            w = NX*j + (i-1); \n \n            kx = k[m] * (tn[e] - 2.*tn[m] + tn[w]) / dx2; \n            ky = k[m] * (tn[s] - 2.*tn[m] + tn[n]) / dy2; \n \n            t[m] = tn[m] + dt * ((H + kx + ky)/(rho[m] * cp)                       - (u[m] * ( (tn[e] - tn[w]) / twodx ))                       - (v[m] * ( (tn[s] - tn[n]) / twody )) ); \n       } \n    } \n \n    apply_thermal_boundary_conditions(t); \n} ", "pred": " \nvoid  \nsolve_advection_diffusion(double *t,  \n                          double *u,  \n                          double *v, \n                          double dx,  \n                          double dy, \n                          double *rho,  \n                          double dt, \n                          double cp,  \n                          double *k, \n                          double H) \n{ \n    int i,j;  \n    double tn[NY*NX]; \n    double kx; \n    double ky; \n \n     \n \n    double dx2 = dx * dx; \n    double dy2 = dy * dy; \n    double twodx = 2. * dx; \n    double twody = 2. * dy; \n \n    #pragma omp parallel for \n    for ( j = 0; j < NY; j++ ){ \n       for ( i = 0; i < NX; i++ ){ \n           tn[NX*j + i] = t[NX*j + i]; \n       } \n    } \n    \n  \n    unsigned int n = 0; \n    unsigned int s = 0; \n    unsigned int m = 0; \n    unsigned int e = 0; \n    unsigned int w = 0; \n \n    #pragma omp parallel for \n    for ( j = 0; j < NX; j++ ){                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " \nvoid scale(double *A, int rows, int cols, double alpha) { \n\tint N,i; \n\t \n  \n\t  \n\tN = rows * cols; \n\t \n #pragma omp parallel for \n\tfor (i = 0; i < N;++i) { \n\t\tA[i] = alpha * A[i]; \n\t} \n} ", "pred": " \nvoid scale(double *A, int rows, int cols, double alpha) { \n\tint N,i; \n\t \n  \n\t  \n\tN = rows * cols; \n\t \n #pragma omp parallel for \n\tfor (i = 0; i < N;++i) { \n\t\tA[i] = alpha * A[i]; \n\t} \n} "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 4; \n  tile_size[1] = 4; \n  tile_size[2] = 8; \n  tile_size[3] = 1024; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=2*Nt-2;t1++) { \n    lbp=ceild(t1+2,2); \n    ubp=min(floord(4*Nt+Nz-9,4),floord(2*t1+Nz-4,4)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(ceild(t1,4),ceild(4*t2-Nz+5,8));t3<=min(min(floord(4*Nt+Ny-9,8),floord(2*t1+Ny-3,8)),floord(4*t2+Ny-9,8));t3++) { \n        for (t4=max(max(ceild(t1-508,512),ceild(4*t2-Nz-1011,1024)),ceild(8*t3-Ny-1011,1024));t4<=min(min(min(floord(4*Nt+Nx-9,1024),floord(2*t1+Nx-3,1024)),floord(4*t2+Nx-9,1024)),floord(8*t3+Nx-5,1024));t4++) { \n          for (t5=max(max(max(ceild(t1,2),ceild(4*t2-Nz+5,4)),ceild(8*t3-Ny+5,4)),ceild(1024*t4-Nx+5,4));t5<=floord(t1+1,2);t5++) { \n            for (t6=max(4*t2,-4*t1+4*t2+8*t5-3);t6<=min(min(4*t2+3,-4*t1+4*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(8*t3,4*t5+4);t7<=min(8*t3+7,4*t5+Ny-5);t7++) { \n                lbv=max(1024*t4,4*t5+4); \n                ubv=min(1024*t4+1023,4*t5+Nx-5); \n#pragma ivdep \n#pragma vector always \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((2.0 * A[ t5 % 2][ (-4*t5+t6)][ (-4", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 4; \n  tile_size[1] = 4; \n  tile_size[2] = 8; \n  tile_size[3] = 8;   tile_size[4] = 8;   tile_size[5] = 8;   tile_size[6] = 8;   tile_size[7] = 8;   tile_size[8] = 8;   tile_size[9] = 8;   tile_size[10] = 8;   tile_size[11] = 8;   tile_size[12] = 8;   tile_size[13] = 8;   tile_size[14] = 8;   tile_size[15] = 8;   tile_size[16] = 8;   tile_size[17] = 8;   tile_size[18] = 8;   tile_size[19] = 8;   tile_size[20] = 8;   tile_size[21] = 8;   tile_size[22] = 8;   tile_size[23] = 8;   tile_size[24] = 8;   tile_size[25] = 8;   tile_size[26] = 8;   tile_size[27] = 8;   tile_size[28] = 8;   tile_size[29] = 8;   tile_size[30] = 8;   tile_size[31] = 8;   tile_size[32] = 8;   tile_size[33] = 8;   tile_size[34] = 8;   tile_size[35] = 8;   tile_size[36] = 8;   tile_size[37] = 8;   tile_size[38] = 8;   tile_size[39] = 8;   tile_size[40] = 8;   tile_size[41] = 8;   tile_size[42] = 8;   tile_size[43] = 8;   tile_size[44] = 8;   tile_size[45] = 8;   tile_size[46] = 8;   tile_size[47] = 8;   tile_size[48] = 8;   tile_size[49] = 8;   tile_size[50] = 8;   tile_size[51] = 8;   tile_size[52] = 8;   tile_size[53] = 8;   tile_size[54] = 8;   tile_size[55] = 8;   tile_size[56] = 8;   tile_size[57] = 8;   tile_size[58] = 8;   tile_size[59] = 8;   tile_size[60] = 8;   tile_size[61] = 8;   tile_size[62] = 8;   tile_size[63] = 8;   tile_size[64] = 8;   tile_size[65] = 8;   tile_size[66] = 8;   tile_size[67] = 8;   tile_size[68] = 8;   tile_size[69] = 8;   tile_size[70] = 8;   tile_size[72] = 8;   tile_size[73] = 8;   tile_size[73] = 8;   tile_size[74] = 8;   tile_size[75] = 8;   tile_size[76] = 8;   tile_size[77] = 8;   tile_size[78] = 8;   tile_size[79] = 8;   tile_size[80] = 8;   tile_size[81] = 8;   tile_size[81] = 8;   tile_size[82] = 8;   tile_size[83] = 8;   tile_size[84] = 8;   tile_size[85] = 8;   tile_size[86] = 8;   tile_size[86] = 8;   tile_size[87] = 8;   tile_size[88] = 8;   tile_size[89] = 8;   tile_size[90] = 8;   tile_size[91] = 8;   tile_size[92] = 8;   tile_size[93] = 8;   tile_size[93] = 8;   tile_size[94] = 8;   tile_size[95] = 8;   tile_size[96] = 8;   tile_size[97] = 8;   tile_size[98] = 8;   tile_size[99] = 8;   tile_size[100] = 8;   tile_size[101] = 8;   tile_size[102] = 8;   tile_size[103] = 8;   tile_size[104] = 8;   tile_size[105] = 8;   tile_size[106] = 8;   tile_size[106] = 8;   tile_size[107] = 8;   tile_size[109] = 8;   tile_size[109] = 8;   tile_size[111] = 8;   tile_size[111] = 8;   tile_size[112] = 8;   tile_size[113] = 8;   tile_size[114] = 8;   tile_size[114] = 8;   tile_size[115] = 8;   tile_size[116] = 8;   tile_size[117] = 8;   tile_size[118] = 8;   tile_size[118] = 8;   tile_size[119] = 8;   tile_size[120] = 8;   tile_size[121] = 8;   tile_size[122] = 8;   tile_size[122] = 8;   tile_size[123] = 8;   tile_size[124] = 8;   tile_size[124] = 8;   tile_size[125] = 8;   tile_size[126] = 8;   tile_size"}
{"label": "d k_arborescence_genf2_round(index_t         n, \n                                index_t         m, \n                                index_t         k, \n                                index_t         g, \n                                index_t         l, \n                                index_t         *d_pos, \n                                index_t         *d_adj, \n                                ffprng_scalar_t yl_seed, \n                                line_array_t    *d_in, \n                                line_array_t    *d_out) \n{ \n    assert(g == SCALARS_IN_LINE);    \n \n    index_t nt = num_threads(); \n    index_t length = n; \n    index_t block_size = length/nt; \n \n    ffprng_t y_base; \n    FFPRNG_INIT(y_base, yl_seed); \n \n \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? length-1 : (start+block_size-1); \n        ffprng_t y_gen; \n        index_t y_pos = d_pos[start]-start; \n        FFPRNG_FWD(y_gen, y_pos, y_base); \n        for(index_t u = start; u <= stop; u++) { \n            index_t pu  = d_pos[u];                 \n \n            index_t deg = d_adj[pu];                \n \n            index_t poff = 4; \n            index_t vvp = d_adj[pu+0+poff];       \n \n            LINE_PREFETCH(d_in, vvp);             \n \n            line_t pyvsum; \n            LINE_SET_ONE(pyvsum); \n            for(index_t j = 1; j <= deg; j++) { \n                index_t v = d_adj[pu+j];            \n \n                line_t pvin; \n                LINE_LOAD(pvin, d_in, v);      \n \n                index_t vp = d_adj[pu+j+poff];    \n \n                LINE_PREFETCH(d_in, vp);          \n \n                ffprng_scalar_t rnd;                \n                FFPRNG_RAND(rnd, y_gen); \n                scalar_t y_luv = (scalar_t) rnd; \n                line_t yuvpvin; \n                LINE_MUL_SCALAR(yuvpvin, pvin, y_luv);    \n \n                LINE_ADD(pyvsum, pyvsum, yuvpvin); \n            } \n            line_t puin; \n            LINE_LOAD(puin, d_in, u);               \n \n            line_t puout; \n            LINE_MUL(puout, puin, pyvsum);                \n \n            LINE_STORE(d_out, u, puout);            \n \n        } \n    } \n \n    trans_bytes += (2*n+m)*sizeof(index_t) + (m+2*n)*g*sizeof(scalar_t); \n    num_muls    += (m+n)*g; \n} \n \nsc ", "pred": "d k_arborescence_genf2_round(index_t         n, \n                                index_t         m, \n                                index_t         k, \n                                index_t         g, \n                                index_t         l, \n                                index_t         *d_pos, \n                                index_t         *d_adj, \n                                ffprng_scalar_t yl_seed, \n                                line_array_t    *d_in, \n                                line_array_t    *d_out) \n{ \n    assert(g == SCALARS_IN_LINE);    \n \n    index_t nt = num_threads(); \n    index_t length = n; \n    index_t block_size = length/nt; \n \n    ffprng_t y_base; \n    FFPRNG_INIT(y_base, yl_seed); \n \n \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        index_t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": "atic pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose) \n{ \n    png_structp  png_ptr = NULL; \n    png_infop    info_ptr = NULL; \n    png_size_t   rowbytes; \n    int          color_type, bit_depth; \n \n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr, \n      rwpng_error_handler, verbose? rwpng_warning_stderr_handler : rwpng_warning_silent_handler); \n    if (!png_ptr) { \n        return PNG_OUT_OF_MEMORY_ERROR;    \n \n    } \n \n    info_ptr = png_create_info_struct(png_ptr); \n    if (!info_ptr) { \n        png_destroy_read_struct(&png_ptr, NULL, NULL); \n        return PNG_OUT_OF_MEMORY_ERROR;    \n \n    } \n \n     \n \n \n    if (setjmp(mainprog_ptr->jmpbuf)) { \n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL); \n        return LIBPNG_FATAL_ERROR;    \n \n    } \n \n     \n \n    png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_const_bytep)\"pHYs\\0iTXt\\0tEXt\\0zTXt\", 4); \n    png_set_read_user_chunk_fn(png_ptr, &mainprog_ptr->chunks, read_chunk_callback); \n \n    struct rwpng_read_data read_data = {infile, 0}; \n    png_set_read_fn(png_ptr, &read_data, user_read_data); \n \n    png_read_info(png_ptr, info_ptr);   \n \n \n     \n \n \n    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height, \n                 &bit_depth, &color_type, NULL, NULL, NULL); \n \n     \n \n    if (mainprog_ptr->width > INT_MAX/mainprog_ptr->height) { \n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL); \n        return PNG_OUT_OF_MEMORY_ERROR;   \n \n    } \n \n     \n \n \n     \n \n \n    if (!(color_type & PNG_COLOR_MASK_ALPHA)) { \n        png_set_expand(png_ptr); \n        png_set_filler(png_ptr, 65535L, PNG_FILLER_AFTER); \n        fprintf(stderr, \"pngquant readpng:  image is neither RGBA nor GA\\n\"); \n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL); \n        mainprog_ptr->retval = WRONG_INPUT_COLOR_TYPE; \n        return mainprog_ptr->retval; \n    } \n \n    if (bit_depth == 16) { \n        png_set_strip_16(png_ptr); \n    } \n \n    if (!(color_type & PNG_COLOR_MASK_COLOR)) { \n        png_set_gray_to_rgb(png_ptr); \n    } \n \n \n     \n \n    double gamma = 0.45455; \n    if (!png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB)) { \n        png_get_gAMA(png_ptr, info_ptr, &gamma); \n        if (gamma < 0 || gamma > 1.0) { \n            fprintf(stderr, \"pngquant readpng:  ignored out-of-range gamma %f\\n\", gamma); \n            gamma = 0.45455; \n        } \n    } \n    mainprog_ptr->gamma = gamma; \n \n    png_set_interlace_handling(png_ptr); \n \n     \n \n \n    png_read_update_info(png_ptr, info_ptr); \n \n    rowbytes = png_get_rowbytes(png_ptr, info_ptr); \n \n    if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) { \n        fprintf(stderr, \"pngquant readpng:  unable to allocate image data\\n\"); \n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL); \n        return PNG_OUT_OF_MEMORY_ERROR; \n    } \n \n    png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0); \n \n     \n \n \n    png_read_image(png_ptr, row_pointers); \n \n     \n \n \n    png_read_end(png_ptr, NULL); \n \n    png_charp ProfileData; \n    png_bytep ProfileData; \n    png_uint_32 ProfileLen; \n \n    cmsHPROFILE hInProfile = NULL; \n \n     \n \n    int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR; \n \n    mainprog_ptr->lcms_status = NONE; \n \n     \n \n    if (png_get_iCCP(png_ptr, info_ptr, &(png_charp){0}, &(int){0}, &ProfileData, &ProfileLen)) { \n \n        hInProfile = cmsOpenProfileFromMem(ProfileData, ProfileLen); \n        cmsColorSpaceSignature colorspace = cmsGetColorSpace(hInProfile); \n \n         \n \n        if (colorspace == cmsSigRgbData && COLOR_PNG) { \n            mainprog_ptr->lcms_status = ICCP; \n        } else { \n            if (colorspace == cmsSigGrayData &&!COLOR_PNG) { \n                mainprog_ptr->lcms_status = ICCP_WARN_GRAY; \n           ", "pred": "atic pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose) \n{ \n    png_structp  png_ptr = NULL; \n    png_infop    info_ptr = NULL; \n    png_size_t   rowbytes; \n    int          color_type, bit_depth; \n \n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr, \n      rwpng_error_handler, verbose? rwpng_warning_stderr_handler : rwpng_warning_silent_handler); \n    if (!png_ptr) { \n        return PNG_OUT_OF_MEMORY_ERROR;    \n \n    } \n \n    info_ptr = png_create_info_struct(png_ptr); \n    if (!info_ptr) { \n        png_destroy_read_struct(&png_ptr, NULL, NULL); \n        return PNG_OUT_OF_MEMORY_ERROR;    \n \n    } \n \n     \n \n \n    if (setjmp(mainprog_ptr->jmpbuf)) { \n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL); \n        return LIBPNG_FATAL_ERROR;    \n \n    } \n \n     \n \n    png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_const_bytep)\"pHYs\\0iTXt\\0tEXt\\0zTXt\", 4); \n    png_set_read_user_chunk_fn(png_ptr, &mainprog_ptr->chunks, read_chunk_callback); \n \n    struct rwpng_read_data read_data = {infile, 0}; \n    png_set_read_fn(png_ptr, &read_data, user_read_fn);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": "d k_arborescence_genf1_round(index_t         n, \n                                index_t         m, \n                                index_t         k, \n                                index_t         g, \n                                index_t         l, \n                                index_t         *d_pos, \n                                index_t         *d_adj, \n                                ffprng_scalar_t yl_seed, \n                                line_array_t    *d_s)  \n{ \n    assert(g == SCALARS_IN_LINE);    \n \n    index_t nt = num_threads(); \n    index_t length = n; \n    index_t block_size = length/nt; \n \n    ffprng_t y_base; \n    FFPRNG_INIT(y_base, yl_seed); \n \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? length-1 : (start+block_size-1); \n        ffprng_t y_gen; \n        index_t y_pos = d_pos[start]-start; \n        FFPRNG_FWD(y_gen, y_pos, y_base); \n        for(index_t u = start; u <= stop; u++) { \n            index_t pu  = d_pos[u];                 \n \n            index_t deg = d_adj[pu];                \n \n            line_t pul; \n            LINE_SET_ZERO(pul); \n            for(index_t j = 1; j <= deg; j++) { \n                index_t v = d_adj[pu+j];            \n \n                index_t nv = d_adj[pu+j+(j < deg? 1 : 2)]; \n                     \n \n                line_t s; \n                LINE_SET_ZERO(s); \n                for(index_t l1 = 1; l1 < l; l1++) { \n                    line_t pul1, pvl2; \n                    index_t l2 = l-l1;  \n \n                    index_t i_v_l2 = ARB_LINE_IDX(b, k, l2, v);  \n \n                    LINE_LOAD(pvl2, d_s, i_v_l2);   \n                                               \n \n                    index_t i_u_l1 = ARB_LINE_IDX(b, k, l1, u);  \n \n                    LINE_LOAD(pul1, d_s, i_u_l1);   \n                                               \n \n                    index_t i_nv_l2 = ARB_LINE_IDX(b, k, l2, nv); \n                    LINE_PREFETCH(d_s, i_nv_l2);   \n \n                    line_t p; \n                    LINE_MUL(p, pul1, pvl2);        \n \n                    LINE_ADD(s, s, p); \n                } \n                ffprng_scalar_t rnd;                \n                FFPRNG_RAND(rnd, y_gen); \n                scalar_t y_luv = (scalar_t) rnd; \n                line_t sy; \n                LINE_MUL_SCALAR(sy, s, y_luv);      \n \n                LINE_ADD(pul, pul, sy); \n            } \n            index_t i_u_l = ARB_LINE_IDX(b, k, l, u); \n            LINE_STORE(d_s, i_u_l, pul);       \n \n        } \n    } \n \n    trans_bytes += (2*n+m)*sizeof(index_t) + (2*(l-1)*m+n)*g*sizeof(scalar_t); \n    num_muls    += ((l-1)*m+n)*g; \n} \n \nsc ", "pred": "d k_arborescence_genf1_round(index_t         n, \n                                index_t         m, \n                                index_t         k, \n                                index_t         g, \n                                index_t         l, \n                                index_t         *d_pos, \n                                index_t         *d_adj, \n                                ffprng_scalar_t yl_seed, \n                                line_array_t    *d_s)  \n{ \n    assert(g == SCALARS_IN_LINE);    \n \n    index_t nt = num_threads(); \n    index_t length = n; \n    index_t block_size = length/nt; \n \n    ffprng_t y_base; \n    FFPRNG_INIT(y_base, yl_seed); \n \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? length-1 : (start+block_size-1); \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 4; \n  tile_size[1] = 4; \n  tile_size[2] = 4; \n  tile_size[3] = 2048; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=2*Nt-2;t1++) { \n    lbp=ceild(t1+2,2); \n    ubp=min(floord(4*Nt+Nz-9,4),floord(2*t1+Nz-4,4)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(ceild(t1+2,2),ceild(4*t2-Nz+9,4));t3<=min(min(floord(4*Nt+Ny-9,4),floord(2*t1+Ny-3,4)),floord(4*t2+Ny-9,4));t3++) { \n        for (t4=max(max(ceild(t1-1020,1024),ceild(4*t2-Nz-2035,2048)),ceild(4*t3-Ny-2035,2048));t4<=min(min(min(floord(4*Nt+Nx-9,2048),floord(2*t1+Nx-3,2048)),floord(4*t2+Nx-9,2048)),floord(4*t3+Nx-9,2048));t4++) { \n          for (t5=max(max(max(ceild(t1,2),ceild(4*t2-Nz+5,4)),ceild(4*t3-Ny+5,4)),ceild(2048*t4-Nx+5,4));t5<=floord(t1+1,2);t5++) { \n            for (t6=max(4*t2,-4*t1+4*t2+8*t5-3);t6<=min(min(4*t2+3,-4*t1+4*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=4*t3;t7<=min(4*t3+3,4*t5+Ny-5);t7++) { \n                lbv=max(2048*t4,4*t5+4); \n                ubv=min(2048*t4+2047,4*t5+Nx-5); \n#pragma ivdep \n#pragma vector always \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((2.0 * A[ t5 % 2][ (-4*t5+t6)", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 4; \n  tile_size[1] = 4; \n  tile_size[2] = 4; \n  tile_size[3] = 4;  tile_size[4] = 4;  tile_size[5] = 4;  tile_size[6] = 4;  tile_size[7] = 4;  tile_size[8] = 4;  tile_size[9] = 4;  tile_size[10] = 4;  tile_size[11] = 4;  tile_size[12] = 4;  tile_size[13] = 4;  tile_size[14] = 4;  tile_size[15] = 4;  tile_size[16] = 4;  tile_size[17] = 4;  tile_size[18] = 4;  tile_size[19] = 4;  tile_size[20] = 4;  tile_size[21] = 4;  tile_size[22] = 4;  tile_size[23] = 4;  tile_size[24] = 4;  tile_size[25] = 4;  tile_size[26] = 4;  tile_size[27] = 4;  tile_size[28] = 4;  tile_size[29] = 4;  tile_size[30] = 4;  tile_size[31] = 4;  tile_size[32] = 4;  tile_size[33] = 4;  tile_size[34] = 4;  tile_size[35] = 4;  tile_size[36] = 4;  tile_size[37] = 4;  tile_size[38] = 4;  tile_size[39] = 4;  tile_size[40] = 4;  tile_size[41] = 4;  tile_size[42] = 4;  tile_size[43] = 4;  tile_size[44] = 4;  tile_size[45] = 4;  tile_size[46] = 4;  tile_size[47] = 4;  tile_size[48] = 4;  tile_size[49] = 4;  tile_size[50] = 4;  tile_size[51] = 4;  tile_size[52] = 4;  tile_size[53] = 4;  tile_size[54] = 4;  tile_size[55] = 4;  tile_size[56] = 4;  tile_size[57] = 4;  tile_size[58] = 4;  tile_size[59] = 4;  tile_size[60] = 4;  tile_size[61] = 4;  tile_size[62] = 4;  tile_size[63] = 4;  tile_size[64] = 4;  tile_size[65] = 4;  tile_size[66] = 4;  tile_size[67] = 4;  tile_size[68] = 4;  tile_size[69] = 4;  tile_size[70] = 4;  tile_size[71] = 4;  tile_size[72] = 4;  tile_size[73] = 4;  tile_size[73] = 4;  tile_size[74] = 4;  tile_size[75] = 4;  tile_size[76] = 4;  tile_size[77] = 4;  tile_size[78] = 4;  tile_size[81] = 4;  tile_size[81] = 4;  tile_size[82] = 4;  tile_size[83] = 4;  tile_size[84] = 4;  tile_size[85] = 4;  tile_size[86] = 4;  tile_size[86] = 4;  tile_size[87] = 4;  tile_size[88] = 4;  tile_size[89] = 4;  tile_size[90] = 4;  tile_size[91] = 4;  tile_size[92] = 4;  tile_size[93] = 4;  tile_size[93] = 4;  tile_size[94] = 4;  tile_size[95] = 4;  tile_size[96] = 4;  tile_size[97] = 4;  tile_size[98] = 4;  tile_size[99] = 4;  tile_size[100] = 4;  tile_size[100] = 4;  tile_size[101] = 4;  tile_size[102] = 4;  tile_size[103] = 4;  tile_size[104] = 4;  tile_size[105] = 4;  tile_size[106] = 4;  tile_size[106] = 4;  tile_size[107] = 4;  tile_size[109] = 4;  tile_size[109] = 4;  tile_size[111] = 4;  tile_size[111] = 4;  tile_size[112] = 4;  tile_size[112] = 4;  tile_size[113] = 4;  tile_size[114] = 4;  tile_size[114] = 4;  tile_size[115] = 4;  tile_size[116] = 4;  tile_size[117] = 4;  tile_size[118] = 4;  tile_size[118] = 4;  tile_size[119] = 4;  tile_size[120] = 4;  tile_size[121] = 4;  tile_size[122] = 4;  tile_size[122] = 4;  tile_size[123] = 4;  tile_size[124] = 4;  tile_size[124] = 4;  tile_size[125] = 4;  tile_size[126] = 4;  tile_size[127] = 4;  tile_size[127] = 4;  tile_size[128] = 4;  tile_size[129] = 4;  tile_size[130] = 4;  tile_size[131] = 4;  tile_size[132] = 4;  tile_size[133] = 4;  tile_size[133] = 4;  tile_size[133] = 4;  tile_size[133] = 4;  tile_size[133] = 4;  tile_size[133"}
{"label": "lar_t k_arborescence_genf1(index_t         n, \n                              index_t         m, \n                              index_t         k, \n                              index_t         g, \n                              index_t         *d_pos, \n                              index_t         *d_adj,  \n                              ffprng_scalar_t y_seed, \n                              line_array_t    *d_x)  \n{ \n \n    assert(g == SCALARS_IN_LINE);    \n    assert(k >= 1); \n \n    line_array_t *d_s  = (line_array_t *) MALLOC(LINE_ARRAY_SIZE(k*n*g)); \n \n     \n \n \n#pragma omp parallel for \n    for(index_t u = 0; u < n; u++) { \n        line_t xu; \n        LINE_LOAD(xu, d_x, u);               \n \n        index_t i_u_1 = ARB_LINE_IDX(b, k, 1, u); \n        LINE_STORE(d_s, i_u_1, xu);          \n \n    } \n \n     \n \n    srand(y_seed); \n    for(index_t l = 2; l <= k; l++) { \n        ffprng_scalar_t yl_seed = irand();  \n \n        k_arborescence_genf1_round(n,m,k,g,l,d_pos,d_adj,yl_seed,d_s); \n    } \n \n     \n \n \n    scalar_t sum = line_sum_stride(n, g, k,  \n                                          ((line_array_t *)(((line_t *) d_s) + k - 1))); \n \n    FREE(d_s); \n \n    trans_bytes += 2*n*g*sizeof(scalar_t); \n    num_muls    += 0; \n \n    return sum; \n} \n \n \n \n ", "pred": "lar_t k_arborescence_genf1(index_t         n, \n                              index_t         m, \n                              index_t         k, \n                              index_t         g, \n                              index_t         *d_pos, \n                              index_t         *d_adj,  \n                              ffprng_scalar_t y_seed, \n                              line_array_t    *d_x)  \n{ \n \n    assert(g == SCALARS_IN_LINE);    \n    assert(k >= 1); \n \n    line_array_t *d_s  = (line_array_t *) MALLOC(LINE_ARRAY_SIZE(k*n*g)); \n \n     \n \n \n#pragma omp parallel for \n    for(index_t u = 0; u < n; u++) { \n        line_t xu; \n        LINE_LOAD(xu, d_x, u);               \n \n        index_t i_u_1 = ARB_LINE_IDX(b, k, 1, u); \n        LINE_STORE(d_s, i_u_1, xu);          \n \n    } \n \n                                                                                                                                                                                                                                                                                                           "}
{"label": " \nvoid  \nupdate_nu(double *nu,  \n          double *t) \n{ \n     \n \n \n    int i, j; \n \n    double ref_nu = 1.; \n    double ref_temp = 500.; \n    double theta = 1.5; \n \n    #pragma omp parallel for \n    for ( j = 0; j < NY; j++ ){ \n       for ( i = 0; i < NX; i++ ){ \n           nu[NX*j + i] = ref_nu * exp(-theta * ((t[NX*j + i] - ref_temp)/ref_temp)); \n       } \n    } \n} ", "pred": " \nvoid  \nupdate_nu(double *nu,  \n          double *t) \n{ \n     \n \n \n    int i, j; \n \n    double ref_nu = 1.; \n    double ref_temp = 500.; \n    double theta = 1.5; \n \n    #pragma omp parallel for \n    for ( j = 0; j < NY; j++ ){ \n       for ( i = 0; i < NX; i++ ){ \n           nu[NX*j + i] = ref_nu * exp(-theta * ((t[NX*j + i] - ref_temp)/ref_temp)); \n       } \n    } \n} "}
{"label": "eduction (int loop) \n{ \n  int\ti; \n \n  #pragma omp for reduction(&&:rdct_and,rdct_and2,rdct_and3,rdct_and4) \n  for (i=1; i<loop; i++) { \n    rdct_and  = rdct_and && i; \n    rdct_and2 = i && rdct_and2; \n    rdct_and3 = rdct_and3 && false; \n    rdct_and4 = false && rdct_and4; \n  } \n} \n \n \nvoid \nchec ", "pred": "eduction (int loop) \n{ \n  int\ti; \n \n  #pragma omp for reduction(&&:rdct_and,rdct_and2,rdct_and3,rdct_and4) \n  for (i=1; i<loop; i++) { \n    rdct_and  = rdct_and && i; \n    rdct_and2 = i && rdct_and2; \n    rdct_and3 = rdct_and3 && false; \n    rdct_and4 = false && rdct_and4; \n  } \n} \n \n \nvoid \nchec "}
{"label": " \nvoid msub(double* A, double* B, double* C,int rows,int cols) { \n\tint N,i; \n\t \n  \n\t  \n\tN = rows * cols; \n\t \n #pragma omp parallel for \n\tfor (i = 0; i < N; ++i) { \n\t\tC[i] = A[i] - B[i]; \n\t} \n} ", "pred": " \nvoid msub(double* A, double* B, double* C,int rows,int cols) { \n\tint N,i; \n\t \n  \n\t  \n\tN = rows * cols; \n\t \n #pragma omp parallel for \n\tfor (i = 0; i < N; ++i) { \n\t\tC[i] = A[i] - B[i]; \n\t} \n} "}
{"label": "ifq_t *motifq_project(motifq_t *q,  \n                         index_t nproj, index_t *proj, index_t *embed, \n                         index_t nl, index_t *l) \n{ \n    index_t n = q->n; \n    index_t *pos = q->pos; \n    index_t *adj = q->adj;     \n  \n    index_t *posproj = alloc_idxtab(nproj); \n    index_t bproj = get_posproj(n, pos, adj, nproj, proj, embed, posproj); \n    index_t *adjproj = alloc_idxtab(bproj); \n \n#pragma omp parallel for \n    for(index_t v = 0; v < nproj; v++) { \n        index_t pv = posproj[v]; \n        index_t u = embed[v]; \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        index_t degproj = 0; \n        for(index_t i = 0; i < deg; i++) { \n            index_t w = proj[adj[pu + 1 + i]]; \n            if(w!= PROJ_UNDEF) \n                adjproj[pv + 1 + degproj++] = w; \n        } \n        adjproj[pv] = degproj; \n    } \n \n    motifq_t *qq = (motifq_t *) MALLOC(sizeof(motifq_t)); \n    qq->is_stub = 0; \n    qq->n = nproj; \n    qq->k = q->k; \n    qq->pos = posproj; \n    qq->adj = adjproj; \n \n     \n \n \n    assert(q->nl == 0);  \n \n    qq->nl = nl; \n    qq->l = (index_t *) MALLOC(sizeof(index_t)*nl); \n    for(index_t i = 0; i < nl; i++) { \n        index_t u = proj[l[i]]; \n        assert(u!= PROJ_UNDEF);  \n \n        qq->l[i] = u; \n    } \n \n     \n \n \n    qq->ns = q->ns; \n    qq->shade = (shade_map_t *) MALLOC(sizeof(shade_map_t)*nproj); \n \n#pragma omp parallel for \n    for(index_t u = 0; u < n; u++) { \n        index_t v = proj[u]; \n        if(v!= PROJ_UNDEF) \n            qq->shade[v] = q->shade[u]; \n    } \n \n     \n \n     \n \n \n     \n \n    index_t *l_shade = (index_t *) MALLOC(sizeof(index_t)*nl); \n    shade_map_t reserved_shades = 0; \n    for(index_t i = 0; i < nl; i++) { \n        index_t v = qq->l[i]; \n        index_t j = 0; \n        for(; j < qq->ns; j++) \n            if(((qq->shade[v] >> j)&1) == 1 &&  \n               ((reserved_shades >> j)&1) == 0) \n                break; \n        assert(j < qq->ns); \n        reserved_shades |= 1UL << j; \n        l_shade[i] = j; \n    } \n     \n \n \n#pragma omp parallel for \n    for(index_t v = 0; v < nproj; v++) \n        qq->shade[v] &= ~reserved_shades; \n \n     \n \n    for(index_t i = 0; i < nl; i++) { \n        index_t v = qq->l[i]; \n        qq->shade[v] = 1UL << l_shade[i]; \n    } \n    FREE(l_shade); \n \n    return qq; \n} \n \n/* ", "pred": "ifq_t *motifq_project(motifq_t *q,  \n                         index_t nproj, index_t *proj, index_t *embed, \n                         index_t nl, index_t *l) \n{ \n    index_t n = q->n; \n    index_t *pos = q->pos; \n    index_t *adj = q->adj;     \n  \n    index_t *posproj = alloc_idxtab(nproj); \n    index_t bproj = get_posproj(n, pos, adj, nproj, proj, embed, posproj); \n    index_t *adjproj = alloc_idxtab(bproj); \n \n#pragma omp parallel for \n    for(index_t v = 0; v < nproj; v++) { \n        index_t pv = posproj[v]; \n        index_t u = embed[v]; \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        index_t degproj = 0; \n        for(index_t i = 0; i < deg; i++) { \n            index_t w = proj[adj[pu + 1 + i]]; \n            if(w!= PROJ_UNDEF) \n                adjproj[pv + 1 + degproj++] = w; \n        } \n        adjproj[pv] = degproj; \n    } \n \n    motifq_t *qq = (motifq_t *) MALLOC(sizeof(motifq_t)); \n    qq->is_stub = 0; \n    qq->n = nproj; \n    qq->k = q->k; \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": "ex_t prefixsum(index_t n, index_t *a, index_t k) \n{ \n \n    index_t s[MAX_THREADS]; \n    index_t nt = num_threads(); \n    assert(nt < MAX_THREADS); \n \n    index_t length = n; \n    index_t block_size = length/nt; \n \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? length-1 : (start+block_size-1); \n        index_t tsum = (stop-start+1)*k; \n        for(index_t u = start; u <= stop; u++) \n            tsum += a[u]; \n        s[t] = tsum; \n    } \n \n    index_t run = 0; \n    for(index_t t = 1; t <= nt; t++) { \n        index_t v = s[t-1]; \n        s[t-1] = run; \n        run += v; \n    } \n    s[nt] = run; \n \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? length-1 : (start+block_size-1); \n        index_t trun = s[t]; \n        for(index_t u = start; u <= stop; u++) { \n            index_t tv = a[u]; \n            a[u] = trun; \n            trun += tv + k; \n        } \n        assert(trun == s[t+1]);     \n    } \n \n \n    index_t run = 0; \n    for(index_t u = 0; u < n; u++) { \n        index_t tv = a[u]; \n        a[u] = run; \n        run += tv + k; \n    } \n \n \n    return run;  \n} \n \n \n/ ", "pred": "ex_t prefixsum(index_t n, index_t *a, index_t k) \n{ \n \n    index_t s[MAX_THREADS]; \n    index_t nt = num_threads(); \n    assert(nt < MAX_THREADS); \n \n    index_t length = n; \n    index_t block_size = length/nt; \n \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? length-1 : (start+block_size-1); \n        index_t tsum = (stop-start+1)*k; \n        for(index_t u = start; u <= stop; u++) \n            tsum += a[u]; \n        s[t] = tsum; \n    } \n \n    index_t run = 0; \n    for(index_t t = 1; t <= nt; t++) { \n        index_t v = s[t-1]; \n        s[t-1] = run; \n        run += v; \n    } \n    s[nt] = run; \n \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? length-1 : (start+block_size-1); \n        index_t trun = s[t]; \n        for(index_t u = start; u <= stop; u++) { \n            index_t tv = a[u]; \n            a[u] = trun; \n            trun += tv + k; \n        } \n                                                                                                                                                "}
{"label": " \nvoid madd(double* A, double* B, double* C,int rows,int cols) { \n\tint N,i; \n\t \n  \n\t  \n\tN = rows * cols; \n\t \n #pragma omp parallel for \n\tfor (i = 0; i < N; ++i) { \n\t\tC[i] = A[i] + B[i]; \n\t} \n} ", "pred": " \nvoid madd(double* A, double* B, double* C,int rows,int cols) { \n\tint N,i; \n\t \n  \n\t  \n\tN = rows * cols; \n\t \n #pragma omp parallel for \n\tfor (i = 0; i < N; ++i) { \n\t\tC[i] = A[i] + B[i]; \n\t} \n} "}
{"label": " \nint main(int argc, char** argv) { \n    struct pb_TimerSet timers; \n    struct pb_Parameters *parameters; \n \n \n \n \n \n    printf(\"CPU-based sparse matrix vector multiplication****\\n\"); \n    printf(\"Original version by Li-Wen Chang <lchang20@illinois.edu> and Shengzhao Wu<wu14@illinois.edu>\\n\"); \n    printf(\"This version maintained by Chris Rodrigues  ***********\\n\"); \n    parameters = pb_ReadParameters(&argc, argv); \n    if ((parameters->inpFiles[0] == NULL) || (parameters->inpFiles[1] == NULL)) \n    { \n        fprintf(stderr, \"Expecting two input filenames\\n\"); \n        exit(-1); \n    } \n \n    pb_InitializeTimerSet(&timers); \n    pb_SwitchToTimer(&timers, pb_TimerID_COMPUTE); \n \n     \n \n    int len; \n    int depth; \n    int dim; \n    int pad=1; \n    int nzcnt_len; \n \n     \n \n     \n \n    float *h_data; \n    int *h_indices; \n    int *h_ptr; \n    int *h_perm; \n    int *h_nzcnt; \n     \n \n    float *h_Ax_vector; \n    float *h_x_vector; \n \n \n     \n \n    pb_SwitchToTimer(&timers, pb_TimerID_IO); \n     \n \n     \n \n     \n \n    int col_count; \n    coo_to_jds( \n            parameters->inpFiles[0],  \n \n            1,  \n \n            pad,  \n \n            1,  \n \n            1,  \n \n            0,  \n \n            1,  \n \n            &h_data, &h_ptr, &h_nzcnt, &h_indices, &h_perm, \n            &col_count, &dim, &len, &nzcnt_len, &depth \n            );\t\t \n \n \n    h_Ax_vector=(float*)malloc(sizeof(float)*dim); \n    h_x_vector=(float*)malloc(sizeof(float)*dim); \n    input_vec( parameters->inpFiles[1], h_x_vector,dim); \n \n    pb_SwitchToTimer(&timers, pb_TimerID_COMPUTE); \n \n \n \n    int p, i, k; \n     \n \n    for(p=0;p<50;p++) \n    { \n#pragma omp parallel for \n        for (i = 0; i < dim; i++) { \n            float sum = 0.0f; \n             \n \n            int  bound = h_nzcnt[i]; \n            for(k=0;k<bound;k++ ) { \n                int j = h_ptr[k] + i; \n                int in = h_indices[j]; \n \n                float d = h_data[j]; \n                float t = h_x_vector[in]; \n \n                sum += d*t; \n            } \n            h_Ax_vector[h_perm[i]] = sum; \n        } \n    }\t \n \n    if (parameters->outFile) { \n        pb_SwitchToTimer(&timers, pb_TimerID_IO); \n        outputData(parameters->outFile,h_Ax_vector,dim); \n \n    } \n    pb_SwitchToTimer(&timers, pb_TimerID_COMPUTE); \n \n    free (h_data); \n    free (h_indices); \n    free (h_ptr); \n    free (h_perm); \n    free (h_nzcnt); \n    free (h_Ax_vector); \n    free (h_x_vector); \n    pb_SwitchToTimer(&timers, pb_TimerID_NONE); \n \n    pb_PrintTimerSet(&timers); \n    pb_FreeParameters(parameters); \n \n    return 0; \n \n} ", "pred": " \nint main(int argc, char** argv) { \n    struct pb_TimerSet timers; \n    struct pb_Parameters *parameters; \n \n \n \n \n \n    printf(\"CPU-based sparse matrix vector multiplication****\\n\"); \n    printf(\"Original version by Li-Wen Chang <lchang20@illinois.edu> and Shengzhao Wu<wu14@illinois.edu>\\n\"); \n    printf(\"This version maintained by Chris Rodrigues  ***********\\n\"); \n    parameters = pb_ReadParameters(&argc, argv); \n    if ((parameters->inpFiles[0] == NULL) || (parameters->inpFiles[1] == NULL)) \n    { \n        fprintf(stderr, \"Expecting two input filenames\\n\"); \n        exit(-1); \n    } \n \n    pb_InitializeTimerSet(&timers); \n    pb_SwitchToTimer(&timers, pb_TimerID_COMPUTE); \n \n     \n \n    int len; \n    int depth; \n    int dim; \n    int pad=1; \n    int nzcnt_len; \n \n     \n \n     \n \n    float *h_data; \n    int *h_indices; \n    int *h_ptr; \n    int *h_perm; \n    int *h_nzcnt; \n     \n \n    float *h_Ax_vector; \n    float *h_x_vector; \n \n \n     \n \n    pb_SwitchToTimer(&timers, pb_TimerID_IO); \n     \n \n     \n \n     \n \n    int col_count; \n    coo_to_jds( \n            parameters->inpFiles[0],  \n \n            1,  \n \n            pad,  \n \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": "d adjsort(index_t n, index_t *pos, index_t *adj) \n{ \n#pragma omp parallel for \n    for(index_t u = 0; u < n; u++) { \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        heapsort_indext(deg, adj + pu + 1); \n    } \n} \n \nvo ", "pred": "d adjsort(index_t n, index_t *pos, index_t *adj) \n{ \n#pragma omp parallel for \n    for(index_t u = 0; u < n; u++) { \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        heapsort_indext(deg, adj + pu + 1); \n    } \n} \n \nvo "}
{"label": " \nvoid stranspose(double *sig, int rows, int cols,double *col) { \n\tint t,u; \n\tregister int i,j; \n #pragma omp parallel for private(i,j,t,u) \n\tfor (i=0; i < rows; i++) { \n\t\tt = i * cols; \n\t\tu = 0; \n\t\tfor (j=0; j < cols; j++) { \n\t\t\tcol[u+i] = sig[j+t]; \n\t\t\tu+=rows; \n\t\t} \n\t} \n\t \n} ", "pred": " \nvoid stranspose(double *sig, int rows, int cols,double *col) { \n\tint t,u; \n\tregister int i,j; \n #pragma omp parallel for private(i,j,t,u) \n\tfor (i=0; i < rows; i++) { \n\t\tt = i * cols; \n\t\tu = 0; \n\t\tfor (j=0; j < cols; j++) { \n\t\t\tcol[u+i] = sig[j+t]; \n\t\t\tu+=rows; \n\t\t} \n\t} \n\t \n} "}
{"label": "ex_t get_poscut(index_t n, index_t *pos, index_t *adj,  \n                   index_t lo_v, index_t hi_v, \n                   index_t *poscut) \n{ \n     \n \n    assert(lo_v <= hi_v); \n \n#pragma omp parallel for \n    for(index_t u = 0; u < lo_v; u++) { \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        index_t cs, ce; \n        index_t l = get_interval(deg, adj + pu + 1, \n                                 lo_v, hi_v, \n                                 &cs, &ce); \n        poscut[u] = deg - l; \n    } \n \n#pragma omp parallel for \n    for(index_t u = hi_v+1; u < n; u++) { \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        index_t cs, ce; \n        index_t l = get_interval(deg, adj + pu + 1, \n                                 lo_v, hi_v, \n                                 &cs, &ce); \n        poscut[u-hi_v-1+lo_v] = deg - l; \n    } \n \n    index_t ncut = n - (hi_v-lo_v+1); \n    index_t run = prefixsum(ncut, poscut, 1); \n    return run; \n} \n \nmo ", "pred": "ex_t get_poscut(index_t n, index_t *pos, index_t *adj,  \n                   index_t lo_v, index_t hi_v, \n                   index_t *poscut) \n{ \n     \n \n    assert(lo_v <= hi_v); \n \n#pragma omp parallel for \n    for(index_t u = 0; u < lo_v; u++) { \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        index_t cs, ce; \n        index_t l = get_interval(deg, adj + pu + 1, \n                                 lo_v, hi_v, \n                                 &cs, &ce); \n        poscut[u] = deg - l; \n    } \n \n#pragma omp parallel for \n    for(index_t u = hi_v+1; u < n; u++) { \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        index_t cs, ce; \n        index_t l = get_interval(deg, adj + pu + 1, \n                                 lo_v, hi_v, \n                                 &cs, &ce); \n        poscut[u-hi_v-1+lo_v] = deg - l; \n    } \n \n    index_t ncut = n - (hi_v-lo_v+1); \n    index_t ncut = n;                         "}
{"label": "lar_t line_sum_stride(index_t      l,  \n                         index_t      g, \n                         index_t      stride, \n                         line_array_t *d_s) \n{ \n \n    index_t nt = num_threads(); \n    index_t block_size = l/nt; \n    assert(nt < MAX_THREADS); \n    scalar_t ts[MAX_THREADS]; \n     \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        SCALAR_SET_ZERO(ts[t]); \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? l-1 : (start+block_size-1); \n        line_t ln; \n        line_t acc; \n        LINE_SET_ZERO(acc); \n        for(index_t i = start; i <= stop; i++) {     \n            index_t ii = i*stride; \n            LINE_LOAD(ln, d_s, ii);     \n \n            LINE_ADD(acc, acc, ln); \n        } \n        scalar_t lsum; \n        LINE_SUM(lsum, acc); \n        ts[t] = lsum; \n    } \n    scalar_t sum; \n    SCALAR_SET_ZERO(sum); \n    for(index_t t = 0; t < nt; t++) { \n        SCALAR_ADD(sum, sum, ts[t]); \n    } \n \n    trans_bytes += sizeof(scalar_t)*l*g; \n \n    return sum; \n} \n \n \n/ ", "pred": "lar_t line_sum_stride(index_t      l,  \n                         index_t      g, \n                         index_t      stride, \n                         line_array_t *d_s) \n{ \n \n    index_t nt = num_threads(); \n    index_t block_size = l/nt; \n    assert(nt < MAX_THREADS); \n    scalar_t ts[MAX_THREADS]; \n     \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        SCALAR_SET_ZERO(ts[t]); \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? l-1 : (start+block_size-1); \n        line_t ln; \n        line_t acc; \n        LINE_SET_ZERO(acc); \n        for(index_t i = start; i <= stop; i++) {     \n            index_t ii = i*stride; \n            LINE_LOAD(ln, d_s, ii);     \n \n            LINE_ADD(acc, acc, ln); \n        } \n        scalar_t lsum; \n        LINE_SUM(lsum, acc); \n        ts[t] = lsum; \n    } \n    scalar_t sum; \n    SCALAR_SET_ZERO(sum); \n    for(index_t t = 0; t < nt; t++) { \n        SCALAR_ADD(t, t, l, l, l);                                                "}
{"label": " \nstatic Connection **computeNodeToNodeMappings(ReadOccurence ** readNodes, \n\t\t\t\t\t      IDnum * readNodeCounts, \n\t\t\t\t\t      IDnum * readPairs, \n\t\t\t\t\t      Category * cats, \n\t\t\t\t\t      boolean * dubious, \n\t\t\t\t\t      boolean * shadows, \n\t\t\t\t\t      ShortLength * lengths) \n{ \n\tIDnum nodeID; \n\tIDnum nodes = nodeCount(graph); \n\tstruct timeval start, end, diff; \n\tCategory cat; \n\tboolean hasShadow; \n \n\tscaffold = callocOrExit(2 * nodes + 1, Connection *); \n \n\tvelvetLog(\"Computing direct node to node mappings\\n\"); \n \n\tgettimeofday(&start, NULL); \n\tcreateNodeLocks(graph); \n \n\tint threads = omp_get_max_threads(); \n\tif (threads > 32) \n\t\tthreads = 32; \n \n #pragma omp parallel for num_threads(threads) \n\tfor (nodeID = -nodes; nodeID <= nodes; nodeID++) \n\t{ \n\t\tif (nodeID % 10000 == 0) \n\t\t\tvelvetLog(\"Scaffolding node %li\\n\", (long) nodeID); \n \n\t\tprojectFromNode(nodeID, readNodes, readNodeCounts, \n\t\t\t\treadPairs, cats, dubious, lengths, shadows, false, 0); \n\t} \n \n\tinitConnectionStackMemory(); \n \n\thasShadow = false; \n\tfor (cat = 0; cat < CATEGORIES; cat++) \n\t\tif (shadows[cat]) \n\t\t{ \n\t\t\thasShadow = true; \n\t\t\tbreak; \n\t\t} \n \n\tif (hasShadow) \n\t{ \n\t\tfor (cat = 0; cat < CATEGORIES; cat++) \n\t\t{ \n\t\t\tsetAllConnectionsClean(); \n\t\t\tif (!shadows[cat]) \n\t\t\t\tcontinue; \n\t\t\tvelvetLog(\"Scaffolding MP library %i\\n\", cat); \n   #pragma omp parallel for \n\t\t\tfor (nodeID = -nodes; nodeID <= nodes; nodeID++) \n\t\t\t\tprojectFromNode(nodeID, readNodes, readNodeCounts, \n\t\t\t\t\t\treadPairs, cats, dubious, lengths, \n\t\t\t\t\t\tshadows, true, cat); \n\t\t} \n\t} \n #pragma omp parallel for \n\tfor (nodeID = 2 * nodes; nodeID >= 0; nodeID--) \n\t\tsplayToList(scaffold + nodeID); \n \n\tdestroyConnectionStackMemory(); \n \n\tfree(nodeLocks); \n\tnodeLocks = NULL; \n\tgettimeofday(&end, NULL); \n\ttimersub(&end, &start, &diff); \n\tvelvetLog(\" === Nodes Scaffolded in %ld.%06ld s\\n\", (long) diff.tv_sec, (long) diff.tv_usec); \n \n\tPEBBLE_ROUND_NUM++; \n \n\treturn scaffold; \n} ", "pred": " \nstatic Connection **computeNodeToNodeMappings(ReadOccurence ** readNodes, \n\t\t\t\t\t      IDnum * readNodeCounts, \n\t\t\t\t\t      IDnum * readPairs, \n\t\t\t\t\t      Category * cats, \n\t\t\t\t\t      boolean * dubious, \n\t\t\t\t\t      boolean * shadows, \n\t\t\t\t\t      ShortLength * lengths) \n{ \n\tIDnum nodeID; \n\tIDnum nodes = nodeCount(graph); \n\tstruct timeval start, end, diff; \n\tCategory cat; \n\tboolean hasShadow; \n \n\tscaffold = callocOrExit(2 * nodes + 1, Connection *); \n \n\tvelvetLog(\"Computing direct node to node mappings\\n\"); \n \n\tgettimeofday(&start, NULL); \n\tcreateNodeLocks(graph); \n \n\tint threads = omp_get_max_threads(); \n\tif (threads > 32) \n\t\tthreads = 32; \n \n #pragma omp parallel for num_threads(threads) \n\tfor (nodeID = -nodes; nodeID <= nodes; nodeID++) \n\t{ \n\t\tif (nodeID % 10000 == 0) \n\t\t\tvelvetLog(\"Scaffolding node %li\\n\", (long) nodeID); \n \n\t\tprojectFromNode(nodeID, readNodes, readNodeCounts, \n\t\t\t\treadPairs, cats, dubious, lengths, shadows, false, 0); \n\t} \n \n\tinitConnectionStackMemory(); \n \n\thasShadow = false; \n\tfor (cat = 0; cat < CATEGORIES; cat++) \n\t\tif (shadows[cat]) \n\t\t{ \n\t\t\thasShadow = true; \n\t\t\tbreak; \n\t\t} \n \n\tif (hasShadow) \n\t{ \n\t\tfor (cat = 0; cat < CATEGORIES; cat++) \n\t\t{ \n\t\t\tsetAllConnectionsClean(); \n\t\t\tif (!shadows[cat]) \n\t\t\t\tcontinue; \n\t\t\tvelvetLog(\"Scaffolding MP library %i\\n\", cat); \n   #pragma omp parallel for \n\t\t\tfor (nodeID = -nodes; nodeID <= nodes; nodeID++)                                                                                                                                                                                                                                              "}
{"label": " \nvoid nmult(double* A, double* B, double* C,int ra,int ca, int cb) { \n\tregister int i,j,k; \n\tint u,v,t,rb; \n\t \n\t \n  \n\t  \n\trb = ca; \n #pragma omp parallel for private(i,j,k,v,u,t) \n\tfor (i = 0; i < ra; ++i) { \n\t\tfor (j = 0; j < cb; ++j) { \n\t\t\tv = i * rb; \n\t\t\tu = i *cb; \n\t\t\tt = j + u; \n\t\t\tC[t] = 0.; \n\t\t\tfor (k = 0; k < rb;++k) { \n\t\t\t\tC[t] += A[k + v] * B[j + k * cb]; \n\t\t\t} \n\t\t} \n\t} \n \n \n} ", "pred": " \nvoid nmult(double* A, double* B, double* C,int ra,int ca, int cb) { \n\tregister int i,j,k; \n\tint u,v,t,rb; \n\t \n\t \n  \n\t  \n\trb = ca; \n #pragma omp parallel for private(i,j,k,v,u,t) \n\tfor (i = 0; i < ra; ++i) { \n\t\tfor (j = 0; j < cb; ++j) { \n\t\t\tv = i * rb; \n\t\t\tu = i *cb; \n\t\t\tt = j + u; \n\t\t\tC[t] = 0.; \n\t\t\tfor (k = 0; k < rb;++k) { \n\t\t\t\tC[t] += A[k + v] * B[j + k * cb]; \n\t\t\t} \n\t\t} \n\t} \n \n \n} "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 16; \n  tile_size[1] = 16; \n  tile_size[2] = 16; \n  tile_size[3] = 64; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,8);t1++) { \n    lbp=max(ceild(t1,2),ceild(16*t1-Nt+3,16)); \n    ubp=min(floord(Nt+Nz-4,16),floord(8*t1+Nz+5,16)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-1,2)),ceild(16*t2-Nz-12,16));t3<=min(min(min(floord(Nt+Ny-4,16),floord(8*t1+Ny+13,16)),floord(16*t2+Ny+12,16)),floord(16*t1-16*t2+Nz+Ny+11,16));t3++) { \n        for (t4=max(max(max(0,ceild(t1-7,8)),ceild(16*t2-Nz-60,64)),ceild(16*t3-Ny-60,64));t4<=min(min(min(min(floord(Nt+Nx-4,64),floord(8*t1+Nx+13,64)),floord(16*t2+Nx+12,64)),floord(16*t3+Nx+12,64)),floord(16*t1-16*t2+Nz+Nx+11,64));t4++) { \n          for (t5=max(max(max(max(max(0,8*t1),16*t1-16*t2+1),16*t2-Nz+2),16*t3-Ny+2),64*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,8*t1+15),16*t2+14),16*t3+14),64*t4+62),16*t1-16*t2+Nz+13);t5++) { \n            for (t6=max(max(16*t2,t5+1),-16*t1+16*t2+2*t5-15);t6<=min(min(16*t2+15,-16*t1+16*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(16*t3,t5+1);t7<=min(16*t3+15,t5+N", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *) tile_size, sizeof(int)*Nz);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": "d constrained_sieve_pre(index_t         n, \n                           index_t         k, \n                           index_t         g, \n                           index_t         pfx, \n                           index_t         num_shades, \n                           shade_map_t     *d_s, \n                           ffprng_scalar_t seed, \n                           line_array_t    *d_x) \n{ \n    assert(g == SCALARS_IN_LINE);    \n    assert(num_shades <= MAX_SHADES); \n \n    line_t   wdj[SHADE_LINES*MAX_K]; \n \n    ffprng_t base; \n    FFPRNG_INIT(base, seed); \n    for(index_t j = 0; j < k; j++) { \n        for(index_t dl = 0; dl < SHADE_LINES; dl++) { \n            index_t jsdl = j*SHADE_LINES+dl; \n            LINE_SET_ZERO(wdj[jsdl]); \n            for(index_t a = 0; a < SCALARS_IN_LINE; a++) { \n                ffprng_scalar_t rnd; \n                FFPRNG_RAND(rnd, base); \n                scalar_t rs = (scalar_t) rnd; \n                LINE_STORE_SCALAR(wdj[jsdl], a, rs);    \n \n            } \n        } \n    } \n \n    index_t nt = num_threads(); \n    index_t length = n; \n    index_t block_size = length/nt; \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        ffprng_t gen; \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? length-1 : (start+block_size-1); \n        FFPRNG_FWD(gen, SHADE_LINES*SCALARS_IN_LINE*start, base); \n        line_t vd[SHADE_LINES]; \n        for(index_t j = 0; j < SHADE_LINES; j++) { \n            LINE_SET_ZERO(vd[j]);  \n \n        }        \n        for(index_t u = start; u <= stop; u++) { \n            scalar_t uu[MAX_K]; \n            shade_map_t shades_u = d_s[u];             \n \n            for(index_t dl = 0; dl < SHADE_LINES; dl++) { \n                for(index_t a = 0; a < SCALARS_IN_LINE; a++) { \n                    index_t d = dl*SCALARS_IN_LINE + a; \n                    ffprng_scalar_t rnd; \n                    FFPRNG_RAND(rnd, gen); \n                    scalar_t rs = (scalar_t) rnd; \n                    rs = rs & (-((scalar_t)((shades_u >> d)&(d < num_shades))));   \n                    LINE_STORE_SCALAR(vd[dl], a, rs);  \n \n                } \n            } \n            for(index_t j = 0; j < k; j++) { \n                scalar_t uj; \n                SCALAR_SET_ZERO(uj); \n                for(index_t dl = 0; dl < SHADE_LINES; dl++) { \n                    index_t jsdl = j*SHADE_LINES+dl; \n                    line_t ln; \n                    LINE_MUL(ln, wdj[jsdl], vd[dl]);   \n \n                                                       \n \n                    scalar_t lns; \n                    LINE_SUM(lns, ln); \n                    SCALAR_ADD(uj, uj, lns); \n                } \n                uu[j] = uj; \n            } \n            line_t ln; \n            LINE_SET_ZERO(ln); \n            for(index_t a = 0; a < SCALARS_IN_LINE; a++) { \n                index_t ap = a < (1L << k)? pfx+a : 0; \n                scalar_t xua; \n                SCALAR_SET_ZERO(xua); \n            ", "pred": "d constrained_sieve_pre(index_t         n, \n                           index_t         k, \n                           index_t         g, \n                           index_t         pfx, \n                           index_t         num_shades, \n                           shade_map_t     *d_s, \n                           ffprng_scalar_t seed, \n                           line_array_t    *d_x) \n{ \n    assert(g == SCALARS_IN_LINE);    \n    assert(num_shades <= MAX_SHADES); \n \n    line_t   wdj[SHADE_LINES*MAX_K]; \n \n    ffprng_t base; \n    FFPRNG_INIT(base, seed); \n    for(index_t j = 0; j < k; j++) { \n        for(index_t dl = 0; dl < SHADE_LINES; dl++) { \n            index_t jsdl = j*SHADE_LINES+dl; \n            LINE_SET_ZERO(wdj[jsdl]); \n            for(index_t a = 0; a < SCALARS_IN_LINE; a++) { \n                ffprng_scalar_t rnd; \n                FFPRNG_INIT(a, a);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "}
{"label": " \nuint64_t grid_wtowers(double complex *uvgrid, int grid_size, \n                      double theta, \n                      struct vis_data *vis, struct w_kernel_data *wkern, \n                      int subgrid_size, int fsample_size, \n                      int subgrid_margin, double wincrement) { \n \n     \n \n    if(subgrid_margin < wkern->size_x) { \n        fprintf(stderr, \"Error: The margin is too small for this w-kernel size!\\n\"); \n        exit(1); \n    } \n    assert(wkern->size_x == wkern->size_y); \n    if(wkern->w_min > -wincrement / 2 || wkern->w_max < wincrement / 2) { \n        fprintf(stderr, \"Error: The w-kernel does not cover a whole w-increment!\\n\"); \n        exit(1); \n    } \n    assert(subgrid_size % 2 == 0 && subgrid_margin % 2 == 0);  \n \n \n     \n \n    uint64_t flops = 0; \n    double complex *wtransfer = make_wtransfer(theta, wincrement, subgrid_size, fsample_size, &flops); \n \n     \n \n    double vis_w_min = 0, vis_w_max = 0; \n    int bl; \n    for (bl = 0; bl < vis->bl_count; bl++) { \n        double w_min = lambda_min(&vis->bl[bl], vis->bl[bl].w_min); \n        double w_max = lambda_max(&vis->bl[bl], vis->bl[bl].w_max); \n        if (w_min < vis_w_min) { vis_w_min = w_min; } \n        if (w_max > vis_w_max) { vis_w_max = w_max; } \n    } \n    int wp_min = (int) floor(vis_w_min / wincrement + 0.5); \n    int wp_max = (int) floor(vis_w_max / wincrement + 0.5); \n \n     \n \n    int chunk_size = subgrid_size - subgrid_margin; \n    int chunk_count = grid_size / chunk_size + 1; \n    int bins_size = sizeof(void *) * chunk_count * chunk_count; \n    struct bl_data ***bins = (struct bl_data ***)malloc(bins_size); \n    memset(bins, 0, bins_size); \n    int bins_count_size = sizeof(int) * chunk_count * chunk_count; \n    int *bins_count = (int *)malloc(bins_count_size); \n    memset(bins_count, 0, bins_count_size); \n    for (bl = 0; bl < vis->bl_count; bl++) { \n \n         \n \n        struct bl_data *bl_data = &vis->bl[bl]; \n        double u_min = lambda_min(bl_data, bl_data->u_min); \n        double u_max = lambda_max(bl_data, bl_data->u_max); \n        double v_min = lambda_min(bl_data, bl_data->v_min); \n        double v_max = lambda_max(bl_data, bl_data->v_max); \n \n         \n \n        int cx0 = (floor(u_min * theta + 0.5) + grid_size/2) / chunk_size; \n        int cx1 = (floor(u_max * theta + 0.5) + grid_size/2) / chunk_size; \n        int cy0 = (floor(v_min * theta + 0.5) + grid_size/2) / chunk_size; \n        int cy1 = (floor(v_max * theta + 0.5) + grid_size/2) / chunk_size; \n \n        int cy, cx; \n        for (cy = cy0; cy <= cy1; cy++) { \n            for (cx = cx0; cx <= cx1; cx++) { \n \n                 \n \n                int bcount = ++bins_count[cy*chunk_count + cx]; \n                bins[cy*chunk_count + cx] = \n                    (struct bl_data **)realloc(bins[cy*chunk_count + cx], sizeof(void *) * bcount); \n                bins[cy*chunk_count + cx][bcount-1] = bl_data; \n \n            } \n        } \n \n    } \n \n     \n \n     \n \n    int subgrid_cells = subgrid_size * subgrid_size; \n    uint64_t subgrid_fft_flops = (int) ceil(5 * subgrid_cells * log(subgrid_cells) / log(2) ); \n \n    #pragma omp parallel reduction(+:flops) \n    { \n \n     \n \n    int subgrid_mem_size = sizeof(double complex) * subgrid_size * subgrid_size; \n    double complex *subgrid = (double complex *)malloc(subgrid_mem_size); \n    double complex *subimg = (double complex *)malloc(subgrid_mem_size); \n    fftw_plan fft_plan, ifft_plan; \n    #pragma omp critical \n    { \n        fft_plan = fftw_plan_dft_2d(subgrid_size, subgrid_size, subimg, subimg, -1, FFTW_MEASURE); \n        ifft_plan = fftw_plan_dft_2d(subgrid_size, subgrid_size, subgrid, subgrid, +1, FFTW_MEASURE); \n    } \n \n     \n \n    int cc; \n    #pragma omp for schedule(dynamic) \n    for (cc = 0; cc < chunk_count * chunk_count; cc++) { \n        int cx = cc % chunk_count, cy = cc / chunk_count; \n \n         \n \n        struct bl_data **bl_bin = bins[cy*chunk_count + cx]; \n        int bl_count = bins_count[cy*chunk_count + cx]; \n        if (bl_count == 0) {", "pred": " \nuint64_t grid_wtowers(double complex *uvgrid, int grid_size, \n                      double theta, \n                      struct vis_data *vis, struct w_kernel_data *wkern, \n                      int subgrid_size, int fsample_size, \n                      int subgrid_margin, double wincrement) { \n \n     \n \n    if(subgrid_margin < wkern->size_x) { \n        fprintf(stderr, \"Error: The margin is too small for this w-kernel size!\\n\"); \n        exit(1); \n    } \n    assert(wkern->size_x == wkern->size_y); \n    if(wkern->w_min > -wincrement / 2 || wkern->w_max < wincrement / 2) { \n        fprintf(stderr, \"Error: The w-kernel does not cover a whole w-increment!\\n\"); \n        exit(1); \n    } \n    assert(subgrid_size % 2 == 0 && subgrid_margin % 2 == 0);  \n \n \n     \n \n    uint64_t flops = 0; \n    double complex *wtransfer = make_wtransfer(theta, wincrement, subgrid_size, fsample_size, &flops); \n \n     \n \n    double vis_w_min = 0, vis_w_max = 0; \n    int bl; \n    for (bl = 0; bl < vis->bl_count; bl++) { \n        double w_min = lambda_min(&vis->bl[bl], vis->bl[bl].w_min); \n        double w_max = lambda_max(&vis->bl[bl], vis->bl[bl].w_max); \n        if (w_min < vis_w_min) { vis_w_min = w_min; }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "}
{"label": " R_StudioDrawPoints( void ) \n{ \n\tint\t\ti, j, m_skinnum; \n\tbyte\t\t*pvertbone; \n\tbyte\t\t*pnormbone; \n\tvec3_t\t\t*pstudioverts; \n\tvec3_t\t\t*pstudionorms; \n\tmstudiotexture_t\t*ptexture; \n\tmstudiomesh_t\t*pmesh; \n\tshort\t\t*pskinref; \n\tfloat\t\t*lv, scale = 0.0f; \n \n\tif(!r_studio_drawelements->integer ) \n\t{ \n\t\tR_StudioDrawPoints_legacy(); \n\t\treturn; \n\t} \n \n\tR_StudioSetupTextureHeader (); \n \n\tg_nNumArrayVerts = g_nNumArrayElems = 0; \n \n\tif(!m_pTextureHeader ) return; \n\tif( RI.currententity->curstate.renderfx == kRenderFxGlowShell ) \n\t\tg_nStudioCount++; \n \n\t \n \n\tm_skinnum = bound( 0, RI.currententity->curstate.skin, ( m_pTextureHeader->numskinfamilies - 1 )); \n\tpvertbone = ((byte *)m_pStudioHeader + m_pSubModel->vertinfoindex); \n\tpnormbone = ((byte *)m_pStudioHeader + m_pSubModel->norminfoindex); \n \n\t \n \n\tif( m_fDoRemap ) ptexture = CL_GetRemapInfoForEntity( RI.currententity )->ptexture; \n\telse ptexture = (mstudiotexture_t *)((byte *)m_pTextureHeader + m_pTextureHeader->textureindex); \n \n\tASSERT( ptexture!= NULL ); \n \n\tpmesh = (mstudiomesh_t *)((byte *)m_pStudioHeader + m_pSubModel->meshindex); \n\tpstudioverts = (vec3_t *)((byte *)m_pStudioHeader + m_pSubModel->vertindex); \n\tpstudionorms = (vec3_t *)((byte *)m_pStudioHeader + m_pSubModel->normindex); \n \n\tpskinref = (short *)((byte *)m_pTextureHeader + m_pTextureHeader->skinindex); \n\tif( m_skinnum!= 0 && m_skinnum < m_pTextureHeader->numskinfamilies ) \n\t\tpskinref += (m_skinnum * m_pTextureHeader->numskinref); \n \n\tif( m_pSubModel->numverts > MAXSTUDIOVERTS ) \n\t\tm_pSubModel->numverts = MAXSTUDIOVERTS; \n \n#pragma omp parallel for private(i) if(m_pSubModel->numverts > STUDIO_SKINNING_OMP_MIN) \n\tfor( i = 0; i < m_pSubModel->numverts; i++ ) \n\t\tMatrix3x4_VectorTransform( g_bonestransform[pvertbone[i]], pstudioverts[i], g_xformverts[i] ); \n \n\tif( g_nForceFaceFlags & STUDIO_NF_CHROME ) \n\t{ \n\t\tscale = RI.currententity->curstate.renderamt * (1.0f / 255.0f); \n \n\t\tfor( i = 0; i < m_pSubModel->numnorms; i++ ) \n\t\t\tMatrix3x4_VectorRotate( g_bonestransform[pnormbone[i]], pstudionorms[i], g_xformnorms[i] ); \n\t} \n \n\tlv = (float *)g_lightvalues; \n \n\tfor( j = 0; j < m_pSubModel->nummesh; j++ ) \n\t{ \n\t\tg_nFaceFlags = ptexture[pskinref[pmesh[j].skinref]].flags; \n \n\t\t \n \n\t\tg_sortedMeshes[j].mesh = &pmesh[j]; \n\t\tg_sortedMeshes[j].flags = g_nFaceFlags; \n \n\t\tfor( i = 0; i < pmesh[j].numnorms; i++, lv += 3, pstudionorms++, pnormbone++ ) \n\t\t{ \n\t\t\tR_StudioLighting( lv, *pnormbone, g_nFaceFlags, (float *)pstudionorms ); \n \n\t\t\tif(( g_nFaceFlags & STUDIO_NF_CHROME ) || ( g_nForceFaceFlags & STUDIO_NF_CHROME )) \n\t\t\t{ \n\t\t\t\tR_StudioSetupChrome( g_chrome[(float (*)[3])lv - g_lightvalues], *pnormbone, (float *)pstudionorms ); \n\t\t\t} \n\t\t} \n\t} \n \n\tif( r_studio_sort_textures->integer ) \n\t{ \n\t\t \n \n\t\tqsort( g_sortedMeshes, m_pSubModel->nummesh, sizeof( sortedmesh_t ), (void *)R_StudioMeshCompare ); \n\t} \n \n\tR_StudioDrawMeshes( ptexture, pskinref, scale ); \n \n\t \n \n\tif( g_iRenderMode!= kRenderTransAdd ) \n\t\tpglDepthMask( GL_TRUE ); \n} ", "pred": " R_StudioDrawPoints( void ) \n{ \n\tint\t\ti, j, m_skinnum; \n\tbyte\t\t*pvertbone; \n\tbyte\t\t*pnormbone; \n\tvec3_t\t\t*pstudioverts; \n\tvec3_t\t\t*pstudionorms; \n\tmstudiotexture_t\t*ptexture; \n\tmstudiomesh_t\t*pmesh; \n\tshort\t\t*pskinref; \n\tfloat\t\t*lv, scale = 0.0f; \n \n\tif(!r_studio_drawelements->integer ) \n\t{ \n\t\tR_StudioDrawPoints_legacy(); \n\t\treturn; \n\t} \n \n\tR_StudioSetupTextureHeader (); \n \n\tg_nNumArrayVerts = g_nNumArrayElems = 0; \n \n\tif(!m_pTextureHeader ) return; \n\tif( RI.currententity->curstate.renderfx == kRenderFxGlowShell ) \n\t\tg_nStudioCount++; \n \n\t \n \n\tm_skinnum = bound( 0, RI.currententity->curstate.skin, ( m_pTextureHeader->numskinfamilies - 1 )); \n\tpvertbone = ((byte *)m_pStudioHeader + m_pSubModel->vertinfoindex); \n\tpnormbone = ((byte *)m_pStudioHeader + m_pSubModel->norminfoindex); \n \n\t \n \n\tif( m_fDoRemap ) ptexture = CL_GetRemapInfoForEntity( RI.currententity )->ptexture; \n\telse ptexture = (mstudiotexture_t *)((byte *)m_pTextureHeader + m_pTextureHeader->textureindex); \n \n\tASSERT( ptexture!= NULL ); \n \n\tpmesh = (mstudiomesh_t *)((byte *)m_pStudioHeader + m_pSubModel->meshindex); \n\tpstudioverts = (vec3_t *)((byte *)m_pStudioHeader + m_pSubModel->vertindex); \n\tpstudionorms = (vec3_t *)((byte *)m_pStudioHeader + m_pSubModel->normindex); \n \n\tpskinref = (short *)((byte *)m_pTextureHeader + m_pTextureHeader->skinindex); \n\tif( m_skinnum ) pstudioverts->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh->pMesh"}
{"label": " \nvoid tmult(double* A, double* B, double* C,int ra,int ca, int cb) { \n\tregister int i,j,k; \n\tint u,v,t,rb; \n\tdouble *BT; \n\tBT = (double*) malloc(sizeof(double) * ca * cb); \n\t \n  \n\t  \n\tmtranspose(B,ca,cb,BT); \n\trb = ca; \n #pragma omp parallel for private(i,j,k,v,u,t) \n\tfor (i = 0; i < ra; ++i) { \n\t\tfor (j = 0; j < cb; ++j) { \n\t\t\tv = i * rb; \n\t\t\tu = i *cb; \n\t\t\tt = j + u; \n\t\t\tC[t] = 0.; \n\t\t\tfor (k = 0; k < rb;++k) { \n\t\t\t\tC[t] += A[k + v] * BT[k + j * rb]; \n\t\t\t} \n\t\t} \n\t} \n\t \n\tfree(BT); \n \n} ", "pred": " \nvoid tmult(double* A, double* B, double* C,int ra,int ca, int cb) { \n\tregister int i,j,k; \n\tint u,v,t,rb; \n\tdouble *BT; \n\tBT = (double*) malloc(sizeof(double) * ca * cb); \n\t \n  \n\t  \n\tmtranspose(B,ca,cb,BT); \n\trb = ca; \n #pragma omp parallel for private(i,j,k,v,u,t) \n\tfor (i = 0; i < ra; ++i) { \n\t\tfor (j = 0; j < cb; ++j) { \n\t\t\tv = i * rb; \n\t\t\tu = i *cb; \n\t\t\tt = j + u; \n\t\t\tC[t] = 0.; \n\t\t\tfor (k = 0; k < rb;++k) { \n\t\t\t\tC[t] += A[k + v] * BT[k + j * rb]; \n\t\t\t} \n\t\t} \n\t} \n\t \n\tfree(BT); \n \n} "}
{"label": "ex_t get_posproj(index_t n, index_t *pos, index_t *adj,  \n                    index_t nproj, index_t *proj, index_t *embed, \n                    index_t *posproj) \n{ \n \n#pragma omp parallel for \n    for(index_t v = 0; v < nproj; v++) { \n        index_t u = embed[v]; \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        index_t degproj = 0; \n        for(index_t i = 0; i < deg; i++) { \n            index_t w = proj[adj[pu + 1 + i]]; \n            if(w!= PROJ_UNDEF) \n                degproj++; \n        } \n        posproj[v] = degproj; \n    } \n \n    index_t run = prefixsum(nproj, posproj, 1); \n    return run; \n} \n \nmo ", "pred": "ex_t get_posproj(index_t n, index_t *pos, index_t *adj,  \n                    index_t nproj, index_t *proj, index_t *embed, \n                    index_t *posproj) \n{ \n \n#pragma omp parallel for \n    for(index_t v = 0; v < nproj; v++) { \n        index_t u = embed[v]; \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        index_t degproj = 0; \n        for(index_t i = 0; i < deg; i++) { \n            index_t w = proj[adj[pu + 1 + i]]; \n            if(w!= PROJ_UNDEF) \n                degproj++; \n        } \n        posproj[v] = degproj; \n    } \n \n    index_t run = prefixsum(nproj, posproj, 1); \n    return run; \n} \n \nmo "}
{"label": "ifq_t *root_build(graph_t *g, index_t k, index_t *kk) \n{ \n    push_memtrack(); \n \n    index_t n = g->num_vertices; \n    index_t m = 2*g->num_edges; \n    index_t *pos = alloc_idxtab(n); \n    index_t *adj = alloc_idxtab(n+m); \n    index_t ns = k; \n    shade_map_t *shade = (shade_map_t *) MALLOC(sizeof(shade_map_t)*n); \n \n    motifq_t *root = (motifq_t *) MALLOC(sizeof(motifq_t)); \n    root->is_stub = 0; \n    root->n       = g->num_vertices; \n    root->k       = k; \n    root->pos     = pos; \n    root->adj     = adj; \n    root->nl      = 0; \n    root->l       = (index_t *) MALLOC(sizeof(index_t)*root->nl); \n    root->ns      = ns; \n    root->shade   = shade; \n \n    push_time(); \n    fprintf(stdout, \"root build... \"); \n    fflush(stdout); \n \n    push_time(); \n#pragma omp parallel for \n    for(index_t u = 0; u < n; u++) \n        pos[u] = 0; \n    double time = pop_time(); \n    fprintf(stdout, \"[zero: %.2lf ms] \", time); \n    fflush(stdout); \n     \n    push_time(); \n    index_t *e = g->edges; \n    \n \n    \n \n    \n \n    index_t nt = num_threads(); \n    index_t block_size = n/nt; \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? n-1 : (start+block_size-1); \n        for(index_t j = 0; j < m; j++) { \n            index_t u = e[j]; \n            if(start <= u && u <= stop)                 \n                pos[u]++;  \n \n        } \n    } \n    for(index_t j = 0; j < m; j++) \n        pos[e[j]]++; \n \n    index_t run = prefixsum(n, pos, 1); \n    assert(run == n+m); \n    time = pop_time(); \n    fprintf(stdout, \"[pos: %.2lf ms] \", time); \n    fflush(stdout); \n \n    push_time(); \n#pragma omp parallel for \n    for(index_t u = 0; u < n; u++) \n        adj[pos[u]] = 0; \n \n    e = g->edges; \n     \n \n     \n \n     \n \n    nt = num_threads(); \n    block_size = n/nt; \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? n-1 : (start+block_size-1); \n        for(index_t j = 0; j < m; j+=2) { \n            index_t u0 = e[j+0]; \n            index_t u1 = e[j+1]; \n            if(start <= u0 && u0 <= stop) { \n                 \n \n                index_t pu0 = pos[u0]; \n                adj[pu0 + 1 + adj[pu0]++] = u1; \n            } \n            if(start <= u1 && u1 <= stop) { \n                 \n \n                index_t pu1 = pos[u1]; \n                adj[pu1 + 1 + adj[pu1]++] = u0; \n            } \n        } \n    } \n    for(index_t j = 0; j < m; j+=2) { \n        index_t u0 = e[j+0]; \n        index_t u1 = e[j+1]; \n        index_t p0 = pos[u0]; \n        index_t p1 = pos[u1];        \n        adj[p1 + 1 + adj[p1]++] = u0; \n        adj[p0 + 1 + adj[p0]++] = u1; \n    } \n    time = pop_time(); \n    fprintf(stdout, \"[adj: %.2lf ms] \", time); \n    fflush(stdout); \n \n    push_time(); \n    adjsort(n, pos, adj); \n    time = pop_time(); \n    fprintf(stdout, \"[adjsort: %.2lf ms] \", time); \n    fflush(stdout); \n \n    push_time(); \n#pragma omp parallel for \n    for(index_t u = 0; u < n; u++) { \n        shade_map_t s = 0; \n        for(index_t j = 0; j < k; j++) \n            if(g->colors[u] == kk[j]) \n                s |= 1UL << j; \n        shade[u] = s; \n \n \n    } \n    time = pop_time(); \n    fprintf(stdout, \"[shade: %.2lf ms] \", time); \n    fflush(stdout); \n \n    time = pop_time(); \n    fprintf(stdout, \"done. [%.2lf ms] \", time); \n    print_pop_memtrack(); \n    fprintf(stdout, \" \"); \n    print_current_mem(); \n   ", "pred": "ifq_t *root_build(graph_t *g, index_t k, index_t *kk) \n{ \n    push_memtrack(); \n \n    index_t n = g->num_vertices; \n    index_t m = 2*g->num_edges; \n    index_t *pos = alloc_idxtab(n); \n    index_t *adj = alloc_idxtab(n+m); \n    index_t ns = k; \n    shade_map_t *shade = (shade_map_t *) MALLOC(sizeof(shade_map_t)*n); \n \n    motifq_t *root = (motifq_t *) MALLOC(sizeof(motifq_t)); \n    root->is_stub = 0; \n    root->n       = g->num_vertices; \n    root->k       = k; \n    root->pos     = pos; \n    root->adj     = adj; \n    root->nl      = 0; \n    root->l       = (index_t *) MALLOC(sizeof(index_t)*root->nl); \n    root->ns      = ns; \n    root->shade   = shade; \n \n    push_time(); \n    fprintf(stdout, \"root build... \"); \n    fflush(stdout); \n \n    push_time(); \n#pragma omp parallel for \n    for(index_t u = 0; u < n; u++) \n        pos[u] = 0; \n    double time = pop_time(); \n    fprintf(stdout, \"[zero: %.2lf ms] \", time); \n    fflush(stdout); \n     \n    push_time(); \n    index_t *e = g->edges; \n    \n \n    \n \n    \n \n    index_t nt = num_threads(); \n    index_t block_size = n/nt; \n#pragma omp parallel for ich                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nvoid  \nupdate_k(double *k,  \n         double *t) \n{ \n     \n \n \n    int i, j; \n \n    double ref_k = 100.; \n    double ref_temp = 500.; \n    double thermal_factor = 0.001; \n \n    #pragma omp parallel for \n    for ( j = 0; j < NY; j++ ){ \n       for ( i = 0; i < NX; i++ ){ \n           k[NX*j + i] = ref_k * (1. - (thermal_factor * (t[NX*j + i] - ref_temp))); \n       } \n    } \n} ", "pred": " \nvoid  \nupdate_k(double *k,  \n         double *t) \n{ \n     \n \n \n    int i, j; \n \n    double ref_k = 100.; \n    double ref_temp = 500.; \n    double thermal_factor = 0.001; \n \n    #pragma omp parallel for \n    for ( j = 0; j < NY; j++ ){ \n       for ( i = 0; i < NX; i++ ){ \n           k[NX*j + i] = ref_k * (1. - (thermal_factor * (t[NX*j + i] - ref_temp))); \n       } \n    } \n} "}
{"label": " \nvoid _PSWITCH(little_D)(_C_TYPE * v, _C_TYPE *w) { \n  int sq = g_N_s*g_N_s; \n  _PSWITCH(CONE) = 1.0; \n  _PSWITCH(CMONE) = -1.0; \n  _PSWITCH(CZERO) = 0.0; \n \n  if(dfl_subspace_updated) { \n    compute_little_D(0); \n    dfl_subspace_updated = 0; \n  } \n   \n  _PSWITCH(little_field_gather)(w); \n   \n#pragma omp parallel for \n  for(int i = 0; i < nb_blocks; i++) { \n    for(int j = 0; j < 9; j++) { \n      _MV(zgemv)(\"N\", &g_N_s, &g_N_s, &_PSWITCH(CONE), _PSWITCH(block_list[i].little_dirac_operator) + j * sq, \n                 &g_N_s, w + (nb_blocks * j + i) * g_N_s, &ONE, &_PSWITCH(CONE), v + i * g_N_s, &ONE, 1); \n    } \n  } \n  return; \n} ", "pred": " \nvoid _PSWITCH(little_D)(_C_TYPE * v, _C_TYPE *w) { \n  int sq = g_N_s*g_N_s; \n  _PSWITCH(CONE) = 1.0; \n  _PSWITCH(CMONE) = -1.0; \n  _PSWITCH(CZERO) = 0.0; \n \n  if(dfl_subspace_updated) { \n    compute_little_D(0); \n    dfl_subspace_updated = 0; \n  } \n   \n  _PSWITCH(little_field_gather)(w); \n   \n#pragma omp parallel for \n  for(int i = 0; i < nb_blocks; i++) { \n    for(int j = 0; j < 9; j++) { \n      _MV(zgemv)(\"N\", &g_N_s, &g_N_s, &_PSWITCH(CONE), _PSWITCH(block_list[i].little_dirac_operator) + j * sq, \n                 &g_N_s, w + (nb_blocks * j + i) * g_N_s, &ONE, &_PSWITCH(CONE), v + i * g_N_s, &ONE, 1); \n    } \n  } \n  return; \n} "}
{"label": "ifq_t *motifq_cut(motifq_t *q, index_t lo_v, index_t hi_v) \n{ \n     \n \n \n    index_t n = q->n; \n    index_t *pos = q->pos; \n    index_t *adj = q->adj;     \n    assert(0 <= lo_v && lo_v <= hi_v && hi_v < n); \n \n     \n \n     \n \n    for(index_t i = 0; i < q->nl; i++) { \n        if(q->l[i] >= lo_v && q->l[i] <= hi_v) { \n            motifq_t *qs = (motifq_t *) MALLOC(sizeof(motifq_t)); \n            qs->is_stub = 1; \n            return qs; \n        } \n    } \n \n    index_t ncut = n - (hi_v-lo_v+1); \n    index_t *poscut = alloc_idxtab(ncut); \n    index_t bcut = get_poscut(n, pos, adj, lo_v, hi_v, poscut); \n    index_t *adjcut = alloc_idxtab(bcut); \n    index_t gap = hi_v-lo_v+1; \n \n#pragma omp parallel for \n    for(index_t v = 0; v < ncut; v++) { \n        index_t u = v; \n        if(u >= lo_v) \n            u += gap; \n        index_t pu = pos[u]; \n        index_t degu = adj[pu]; \n        index_t cs, ce; \n        index_t l = get_interval(degu, adj + pu + 1, \n                                 lo_v, hi_v, \n                                 &cs, &ce); \n        index_t pv = poscut[v]; \n        index_t degv = degu - l; \n        adjcut[pv] = degv; \n         \n \n        for(index_t i = 0; i < cs; i++) \n            adjcut[pv + 1 + i] = adj[pu + 1 + i]; \n         \n \n        for(index_t i = cs; i < degv; i++) \n            adjcut[pv + 1 + i] = adj[pu + 1 + i + l] - gap; \n    } \n \n    motifq_t *qq = (motifq_t *) MALLOC(sizeof(motifq_t)); \n    qq->is_stub = 0; \n    qq->n = ncut; \n    qq->k = q->k; \n    qq->pos = poscut; \n    qq->adj = adjcut; \n    qq->nl = q->nl; \n    qq->l = (index_t *) MALLOC(sizeof(index_t)*qq->nl); \n    for(index_t i = 0; i < qq->nl; i++) { \n        index_t u = q->l[i]; \n        assert(u < lo_v || u > hi_v); \n        if(u > hi_v) \n            u -= gap; \n        qq->l[i] = u; \n    } \n    qq->ns = q->ns; \n    qq->shade = (shade_map_t *) MALLOC(sizeof(shade_map_t)*ncut); \n    for(index_t v = 0; v < ncut; v++) { \n        index_t u = v; \n        if(u >= lo_v) \n            u += gap; \n        qq->shade[v] = q->shade[u]; \n    } \n \n    return qq; \n} \n \n/* ", "pred": "ifq_t *motifq_cut(motifq_t *q, index_t lo_v, index_t hi_v) \n{ \n     \n \n \n    index_t n = q->n; \n    index_t *pos = q->pos; \n    index_t *adj = q->adj;     \n    assert(0 <= lo_v && lo_v <= hi_v && hi_v < n); \n \n     \n \n     \n \n    for(index_t i = 0; i < q->nl; i++) { \n        if(q->l[i] >= lo_v && q->l[i] <= hi_v) { \n            motifq_t *qs = (motifq_t *) MALLOC(sizeof(motifq_t)); \n            qs->is_stub = 1; \n            return qs; \n        } \n    } \n \n    index_t ncut = n - (hi_v-lo_v+1); \n    index_t *poscut = alloc_idxtab(ncut); \n    index_t bcut = get_poscut(n, pos, adj, lo_v, hi_v, poscut); \n    index_t *adjcut = alloc_idxtab(bcut); \n    index_t gap = hi_v-lo_v+1; \n \n#pragma omp parallel for \n    for(index_t v = 0; v < ncut; v++) { \n        index_t u = v; \n        if(u >= lo_v) \n            u += gap; \n        index_t pu = pos[u]; \n        index_t degu = adj[pu]; \n        index_t cs, ce; \n        index_t l = get_interval(degu, adj + pu + 1, \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "}
{"label": "lar_t line_sum(index_t      l,  \n                  index_t      g, \n                  line_array_t *d_s) \n{ \n \n    index_t nt = num_threads(); \n    index_t block_size = l/nt; \n    assert(nt < MAX_THREADS); \n    scalar_t ts[MAX_THREADS]; \n     \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        SCALAR_SET_ZERO(ts[t]); \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? l-1 : (start+block_size-1); \n        line_t ln; \n        line_t acc; \n        LINE_SET_ZERO(acc); \n        for(index_t i = start; i <= stop; i++) {     \n            LINE_LOAD(ln, d_s, i);     \n \n            LINE_ADD(acc, acc, ln); \n        } \n        scalar_t lsum; \n        LINE_SUM(lsum, acc); \n        ts[t] = lsum; \n    } \n    scalar_t sum; \n    SCALAR_SET_ZERO(sum); \n    for(index_t t = 0; t < nt; t++) { \n        SCALAR_ADD(sum, sum, ts[t]); \n    } \n \n    trans_bytes += sizeof(scalar_t)*l*g; \n \n    return sum; \n} \n \n \ns ", "pred": "lar_t line_sum(index_t      l,  \n                  index_t      g, \n                  line_array_t *d_s) \n{ \n \n    index_t nt = num_threads(); \n    index_t block_size = l/nt; \n    assert(nt < MAX_THREADS); \n    scalar_t ts[MAX_THREADS]; \n     \n#pragma omp parallel for \n    for(index_t t = 0; t < nt; t++) { \n        SCALAR_SET_ZERO(ts[t]); \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? l-1 : (start+block_size-1); \n        line_t ln; \n        line_t acc; \n        LINE_SET_ZERO(acc); \n        for(index_t i = start; i <= stop; i++) {     \n            LINE_LOAD(ln, d_s, i);     \n \n            LINE_ADD(acc, acc, ln); \n        } \n        scalar_t lsum; \n        LINE_SUM(lsum, acc); \n        ts[t] = lsum; \n    } \n    scalar_t sum; \n    SCALAR_SET_ZERO(sum); \n    for(index_t t = 0; t < nt; t++) { \n        SCALAR_ADD(sum, sum, ts[t]); \n    } \n \n    trans_bytes += sizeof(scalar_t)*l*g; \n \n    return sum; \n} \n \n \ns "}
{"label": " \nvoid bar() { \n  int **a; \n   \n \n#pragma omp for \nfor (int i = 0; i < 10; ++i) \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n#pragma omp task depend(iterator(unsigned k=0:i:2), in: a[k][i]) \n++i; \n} ", "pred": " \nvoid bar() { \n  int **a; \n   \n \n#pragma omp for \nfor (int i = 0; i < 10; ++i) \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n#pragma omp task depend(iterator(unsigned k=0:i:2), in: a[k][i]) \n++i; \n} "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_grain_data_t *data = (dt_iop_grain_data_t *)piece->data; \n \n  unsigned int hash = _hash_string(piece->pipe->image.filename) % (int)fmax(roi_out->width * 0.3, 1.0); \n \n  const int ch = piece->colors; \n   \n \n  const double strength = (data->strength / 100.0); \n  const double octaves = 3; \n   \n \n  const double wd = fminf(piece->buf_in.width, piece->buf_in.height); \n  const double zoom = (1.0 + 8 * data->scale / 100) / 800.0; \n  const int filter = fabsf(roi_out->scale - 1.0f) > 0.01; \n   \n \n   \n \n  const double filtermul = piece->iscale / (roi_out->scale * wd); \n  const float fib1 = 34.0, fib2 = 21.0; \n  const float fib1div2 = fib1 / fib2; \n \n#pragma omp parallel for default(none) shared(data, hash) \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    float *in = ((float *)ivoid) + (size_t)roi_out->width * j * ch; \n    float *out = ((float *)ovoid) + (size_t)roi_out->width * j * ch; \n    const double wy = (roi_out->y + j) / roi_out->scale; \n    const double y = wy / wd; \n     \n \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n       \n \n       \n \n      const double wx = (roi_out->x + i) / roi_out->scale; \n       \n \n      const double x = wx / wd; \n       \n \n      double noise = 0.0; \n      if(filter) \n      { \n         \n \n        for(int l = 0; l < fib2; l++) \n        { \n          float px = l / fib2, py = l * fib1div2; \n          py -= (int)py; \n          float dx = px * filtermul, dy = py * filtermul; \n          noise += (1.0 / fib2) * _simplex_2d_noise(x + dx + hash, y + dy, octaves, 1.0, zoom); \n        } \n      } \n      else \n      { \n        noise = _simplex_2d_noise(x + hash, y, octaves, 1.0, zoom); \n      } \n \n      out[0] = in[0] + dt_lut_lookup_2d_1c(data->grain_lut, (noise * strength) * GRAIN_LIGHTNESS_STRENGTH_SCALE, in[0] / 100.0f); \n      out[1] = in[1]; \n      out[2] = in[2]; \n      out[3] = in[3]; \n \n      out += ch; \n      in += ch; \n    } \n  } \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_grain_data_t *data = (dt_iop_grain_data_t *)piece->data; \n \n  unsigned int hash = _hash_string(piece->pipe->image.filename) % (int)fmax(roi_out->width * 0.3, 1.0); \n \n  const int ch = piece->colors; \n   \n \n  const double strength = (data->strength / 100.0); \n  const double octaves = 3; \n   \n \n  const double wd = fminf(piece->buf_in.width, piece->buf_in.height); \n  const double zoom = (1.0 + 8 * data->scale / 100) / 800.0; \n  const int filter = fabsf(roi_out->scale - 1.0f) > 0.01; \n   \n \n   \n \n  const double filtermul = piece->iscale / (roi_out->scale * wd); \n  const float fib1 = 34.0, fib2 = 21.0; \n  const float fib1div2 = fib1 / fib2; \n \n#pragma omp parallel for default(none) shared(data, hash) \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    float *in = ((float *)ivoid) + (size_t)roi_out->width * j * ch; \n    float *out = ((float *)ovoid) + (size_t)roi_out->width * j * ch; \n    const double wy = (roi_out->y + j) / roi_out->scale; \n    const double y = wy / wd; \n     \n \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n       \n \n       \n \n      const double wx = (double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)((double)(("}
{"label": " \nint main(int argc, char **argv) \n{ \n  if (argc!= 5) { \n    fprintf(stderr, \"usage:./life <cores> <infile name> <# of iterations> <print frequency> \\n\"); \n    exit(EXIT_FAILURE); \n  } \n \n  double time_start, time_end; \n  time_start = omp_get_wtime(); \n \n  cell *lifeGrid, *tempGrid, *swapPtr;       \n \n  int rows = 0, cols = 0, neighborCount = 0, i = 0, j = 0, k = 0; \n  const int cores = atoi(argv[ARG_CORES]); \n \n  getRowsAndCols(argv[ARG_FILE_NAME], &rows, &cols); \n \n  const int num_steps = atoi(argv[ARG_NUM_ITERATIONS]); \n  const int print_frequency = atoi(argv[ARG_PRINT_FREQ]); \n \n  char *outfile_name = calloc(100, sizeof(char)); \n  snprintf(outfile_name, 100, \"%s_%s_%s_%s.out\", argv[ARG_CORES], argv[ARG_FILE_NAME], argv[ARG_NUM_ITERATIONS], argv[ARG_PRINT_FREQ]); \n \n  lifeGrid = calloc(rows * cols, sizeof(cell));    \n \n  tempGrid = calloc(rows * cols, sizeof(cell));    \n \n  initializeGrid(lifeGrid, argv[ARG_FILE_NAME]); \n \n \n  for ( ; i < num_steps; i++) \n  { \n    if (i % print_frequency == 0) { \n      printGrid(lifeGrid, rows, cols, i, stdout); \n    } \n \n     \n \n    #pragma omp parallel for private(j, k, neighborCount) shared (lifeGrid, tempGrid, rows, cols) default (none) \n    for (j=0; j<rows; j++ ) { \n       \n \n      for (k=0; k<cols; k++) { \n        neighborCount = getNeighborCount( lifeGrid, rows, cols, j, k ); \n \n        if(neighborCount == 2) tempGrid[j*cols+k] = lifeGrid[j*cols+k]; \n        if(neighborCount == 3) tempGrid[j*cols+k] = ALIVE; \n        if(neighborCount < 2) tempGrid[j*cols+k] = DEAD; \n        if(neighborCount > 3) tempGrid[j*cols+k] = DEAD; \n      } \n    } \n \n     \n \n    swapPtr = lifeGrid; \n    lifeGrid = tempGrid; \n    tempGrid = swapPtr; \n  } \n \n \n  FILE *outfile = fopen(outfile_name, \"w\"); \n  printGrid(lifeGrid, rows, cols, i, outfile); \n \n   \n \n  fclose(outfile); \n  free(outfile_name); \n  free(tempGrid); \n  free(lifeGrid); \n \n  time_end = omp_get_wtime(); \n  printf(\"Execution Time (s): %f\\n\", time_end-time_start ); \n \n  return (EXIT_SUCCESS); \n} ", "pred": " \nint main(int argc, char **argv) \n{ \n  if (argc!= 5) { \n    fprintf(stderr, \"usage:./life <cores> <infile name> <# of iterations> <print frequency> \\n\"); \n    exit(EXIT_FAILURE); \n  } \n \n  double time_start, time_end; \n  time_start = omp_get_wtime(); \n \n  cell *lifeGrid, *tempGrid, *swapPtr;       \n \n  int rows = 0, cols = 0, neighborCount = 0, i = 0, j = 0, k = 0; \n  const int cores = atoi(argv[ARG_CORES]); \n \n  getRowsAndCols(argv[ARG_FILE_NAME], &rows, &cols); \n \n  const int num_steps = atoi(argv[ARG_NUM_ITERATIONS]); \n  const int print_frequency = atoi(argv[ARG_PRINT_FREQ]); \n \n  char *outfile_name = calloc(100, sizeof(char)); \n  snprintf(outfile_name, 100, \"%s_%s_%s_%s.out\", argv[ARG_CORES], argv[ARG_FILE_NAME], argv[ARG_NUM_ITERATIONS], argv[ARG_PRINT_FREQ]); \n \n  lifeGrid = calloc(rows * cols, sizeof(cell));    \n \n  tempGrid = calloc(rows * cols, sizeof(cell));    \n \n  initializeGrid(lifeGrid, argv[ARG_FILE_NAME]); \n \n \n  for ( ; i < num_steps; i++) \n  { \n    if (i % print_frequency == 0) { \n      printGrid(lifeGrid, rows, cols, i, stdout); \n    } \n \n     \n \n    #pragma omp parallel for private(j, k, neighborCount) shared (lifeGrid, tempGrid, rows, cols) default (none) \n    for (j=0; j<rows; j++ ) { \n       \n \n      for (k=0; k<cols; k++) { \n                                                                                                                                                                                                                                                                                                                                                                               "}
{"label": " \nint transfer_init( \n                  struct precision * ppr, \n                  struct background * pba, \n                  struct thermo * pth, \n                  struct perturbs * ppt, \n                  struct nonlinear * pnl, \n                  struct transfers * ptr \n                  ) { \n \n   \n \n \n   \n \n \n   \n \n  int index_q; \n \n   \n \n  double tau0; \n   \n \n  double tau_rec; \n   \n \n  double q_period; \n \n   \n \n  int tau_size_max; \n \n   \n \n  double *** sources; \n \n   \n \n  double *** sources_spline; \n \n   \n \n  struct transfer_workspace * ptw; \n \n   \n \n  int ** tp_of_tt; \n \n   \n \n \n  HyperInterpStruct BIS; \n  double xmax; \n \n   \n \n  FILE * input_file; \n  int row,status; \n  double tmp1,tmp2; \n \n   \n \n  int abort; \n \n \n   \n \n  double tstart, tstop, tspent; \n \n \n   \n \n \n  if (ppt->has_cls == _FALSE_) { \n    ptr->has_cls = _FALSE_; \n    if (ptr->transfer_verbose > 0) \n      printf(\"No harmonic space transfer functions to compute. Transfer module skipped.\\n\"); \n    return _SUCCESS_; \n  } \n  else \n    ptr->has_cls = _TRUE_; \n \n  if (ptr->transfer_verbose > 0) \n    fprintf(stdout,\"Computing transfers\\n\"); \n \n   \n \n \n  ptr->md_size = ppt->md_size; \n \n   \n \n \n  tau0 = pba->conformal_age; \n  tau_rec = pth->tau_rec; \n \n   \n \n \n  ptr->angular_rescaling = pth->angular_rescaling; \n \n   \n \n \n  q_period = 2.*_PI_/(tau0-tau_rec)*ptr->angular_rescaling; \n \n   \n \n \n  class_call(transfer_indices_of_transfers(ppr,ppt,ptr,q_period,pba->K,pba->sgnK), \n             ptr->error_message, \n             ptr->error_message); \n \n   \n \n \n  class_alloc(sources, \n              ptr->md_size*sizeof(double**), \n              ptr->error_message); \n \n  class_call(transfer_perturbation_copy_sources_and_nl_corrections(ppt,pnl,ptr,sources), \n             ptr->error_message, \n             ptr->error_message); \n \n   \n \n \n  class_alloc(sources_spline, \n              ptr->md_size*sizeof(double**), \n              ptr->error_message); \n \n  class_call(transfer_perturbation_source_spline(ppt,ptr,sources,sources_spline), \n             ptr->error_message, \n             ptr->error_message); \n \n   \n \n \n  class_alloc(tp_of_tt, \n              ptr->md_size*sizeof(int*), \n              ptr->error_message); \n \n  class_call(transfer_get_source_correspondence(ppt,ptr,tp_of_tt), \n             ptr->error_message, \n             ptr->error_message); \n \n   \n \n \n  class_call(transfer_source_tau_size_max(ppr,pba,ppt,ptr,tau_rec,tau0,&tau_size_max), \n             ptr->error_message, \n             ptr->error_message); \n \n   \n \n \n  xmax = ptr->q[ptr->q_size-1]*tau0; \n  if (pba->sgnK == -1) \n    xmax *= (ptr->l[ptr->l_size_max-1]/ppr->hyper_flat_approximation_nu)/asinh(ptr->l[ptr->l_size_max-1]/ppr->hyper_flat_approximation_nu)*1.01; \n \n  class_call(hyperspherical_HIS_create(0, \n                                       1., \n                                       ptr->l_size_max, \n                                       ptr->l, \n                                       ppr->hyper_x_min, \n                                       xmax, \n                                       ppr->hyper_sampling_flat, \n                                       ptr->l[ptr->l_size_max-1]+1, \n                                       ppr->hyper_phi_min_abs, \n                                       &BIS, \n                                       ptr->error_message), \n             ptr->error_message, \n             ptr->error_message); \n \n   \n \n \n   \n \n \n  ptr->nz_size = 0;", "pred": " \nint transfer_init( \n                  struct precision * ppr, \n                  struct background * pba, \n                  struct thermo * pth, \n                  struct perturbs * ppt, \n                  struct nonlinear * pnl, \n                  struct transfers * ptr \n                  ) { \n \n   \n \n \n   \n \n \n   \n \n  int index_q; \n \n   \n \n  double tau0; \n   \n \n  double tau_rec; \n   \n \n  double q_period; \n \n   \n \n  int tau_size_max; \n \n   \n \n  double *** sources; \n \n   \n \n  double *** sources_spline; \n \n   \n \n  struct transfer_workspace * ptw; \n \n   \n \n  int ** tp_of_tt; \n \n   \n \n \n  HyperInterpStruct BIS; \n  double xmax; \n \n   \n \n  FILE * input_file; \n  int row,status; \n  double tmp1,tmp2; \n \n   \n \n  int abort; \n \n \n   \n \n  double tstart, tstop, tspent; \n \n \n   \n \n \n  if (ppt->has_cls == _FALSE_) { \n    ptr->has_cls = _FALSE_; \n    if (ptr->transfer_verbose > 0) \n      printf(\"No harmonic space transfer functions to compute. Transfer module skipped.\\n\"); \n    return _SUCCESS_; \n  } \n  else \n    ptr->has_cls = _TRUE_; \n \n  if (ptr->transfer_verbose > 0) \n    fprintf(stdout,\", \" \\\"%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s"}
{"label": " \nMAT * dilate_f(MAT * img_in, MAT * strel) { \n\tMAT * dilated = m_get(img_in->m, img_in->n); \n\t \n\t \n \n\tint el_center_i = strel->m / 2, el_center_j = strel->n / 2, i; \n\t \n\t \n \n { const unsigned long long parallel_for_start = current_time_ns(); \n#pragma omp parallel for \nfor (i = 0; i < img_in->m; i++) { \n\t\tint j, el_i, el_j, x, y; \n\t\tfor (j = 0; j < img_in->n; j++) { \n\t\t\tdouble max = 0.0, temp; \n\t\t\t \n \n\t\t\tfor (el_i = 0; el_i < strel->m; el_i++) { \n\t\t\t\tfor (el_j = 0; el_j < strel->n; el_j++) { \n\t\t\t\t\ty = i - el_center_i + el_i; \n\t\t\t\t\tx = j - el_center_j + el_j; \n\t\t\t\t\t \n \n\t\t\t\t\tif (y >=0 && x >= 0 && y < img_in->m && x < img_in->n && m_get_val(strel, el_i, el_j)!= 0) { \n\t\t\t\t\t\t \n \n\t\t\t\t\t\ttemp = m_get_val(img_in, y, x); \n\t\t\t\t\t\tif (temp > max)\tmax = temp; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t\t \n \n\t\t\tm_set_val(dilated, i, j, max); \n\t\t} \n\t} ;  \nconst unsigned long long parallel_for_end = current_time_ns(); \nprintf(\"pragma186_omp_parallel %llu ns\\n\", parallel_for_end - parallel_for_start); }  \n \n \n\treturn dilated; \n} ", "pred": " \nMAT * dilate_f(MAT * img_in, MAT * strel) { \n\tMAT * dilated = m_get(img_in->m, img_in->n); \n\t \n\t \n \n\tint el_center_i = strel->m / 2, el_center_j = strel->n / 2, i; \n\t \n\t \n \n { const unsigned long long parallel_for_start = current_time_ns(); \n#pragma omp parallel for \nfor (i = 0; i < img_in->m; i++) { \n\t\tint j, el_i, el_j, x, y; \n\t\tfor (j = 0; j < img_in->n; j++) { \n\t\t\tdouble max = 0.0, temp; \n\t\t\t \n \n\t\t\tfor (el_i = 0; el_i < strel->m; el_i++) { \n\t\t\t\tfor (el_j = 0; el_j < strel->n; el_j++) { \n\t\t\t\t\ty = i - el_center_i + el_i; \n\t\t\t\t\tx = j - el_center_j + el_j; \n\t\t\t\t\t \n \n\t\t\t\t\tif (y >=0 && x >= 0 && y < img_in->m && x < img_in->n && m_get_val(strel, el_i, el_j)!= 0) { \n\t\t\t\t\t\t \n \n\t\t\t\t\t\ttemp = m_get_val(img_in, y, x); \n\t\t\t\t\t\tif (temp > max)\tmax = temp; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t\t \n \n\t\t\tm_set_val(dilated, i, j, max); \n\t\t} \n\t} ;  \nconst unsigned long long parallel_for_end = current_time_ns(); \nprintf(\"pragma186_omp_parallel %llu ns\\n\", parallel_for_end - parallel_for_start); }  \n \n \n\treturn dilated; \n} "}
{"label": "void CLASS cfa_impulse_gauss(float lclean, float cclean) \n{   \n\tdouble dt; \n\tclock_t t1, t2; \n\tint winx=0, winy=0,winw=width, winh=height; \n \n\tint compt=0, compt10=0,compt50=0,compt250=0,compt500=0,comptmax=0; \n\tstatic const int border=8; \n\tint rayo=1,i,d; \n\tint compte1=0; \n\tstatic const float eps1=1e-10; \n\t \n\tif (verbose) fprintf (stderr,_(\"CFA impulse-hot and gaussian denoise [E.Martinec +JD] g:%1.4f  br:%1.4f\\n\"), lclean,cclean); \n\tt1 = clock(); \n\tborder_interpolate(16); \n\tfloat noisevar=SQRF(lclean);  \n\tfloat noisevarbr=SQRF(cclean); \n \n#pragma omp parallel \n{\t \n\tint top,left; \n\tchar\t\t*buffer;\t\t\t\t \n \n\tfloat         (*rgb)[3];\t\t \n \n\tfloat         (*lpf);\t\t\t \n \n\tfloat         (*hpf);\t\t\t \n \n \n\t \n \n\tbuffer = (char *) calloc((4*sizeof(float)+sizeof(int))*TS*TS,1); \n\t \n\t \n \n\trgb         = (float (*)[3])\t\tbuffer;  \n \n \tlpf\t\t\t= (float (*))\t\t\t(buffer +  3*sizeof(float)*TS*TS); \n\thpf\t\t\t= (float (*))\t\t\t(buffer +  4*sizeof(float)*TS*TS); \n\t \n\t \n \n\t \n\t \n \n \n \n\t \n \n\t \n \n \n#pragma omp for schedule(dynamic) nowait  \n\tfor (top=0; top < winh-16; top += TS-32) \n\t\tfor (left=0; left < winw-16; left += TS-32) { \n \n\t\t\tint bottom = MIN( top+TS,winh); \n\t\t\tint right  = MIN(left+TS, winw); \n\t\t\tint rr1 = bottom - top; \n\t\t\tint cc1 = right - left; \n\t\t\t \n\t\t\tint rr,cc; \n\t\t\tint c; \n\t\t\tint row, col; \n\t\t\tint indx; \n\t\t\tfloat  hfvar[3]; \n\t\t\tfloat gin, g[8]; \n\t\t\tfloat norm; \n\t\t\tfloat wtdsum; \n\t\t\tint dir,dirwt; \n\t\t\tfloat rbin,rb[8],hfnbrave; \n\t\t\tfloat v1; \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\tfor (rr=0; rr < rr1; rr++) \n\t\t\t\tfor (row=rr+top, cc=0; cc < cc1; cc++) { \n\t\t\t\t\tcol = cc+left; \n\t\t\t\t\tc = FC(rr,cc); \n\t\t\t\t\t \n \n\t\t\t\t\trgb[rr*TS+cc][c] = image[row*width+col][c]/65535.0f;  \n\t\t\t\t} \n\t\t\tfor (c=0; c<3; c++){hfvar[c]=0.0f;} \n\t\t\t \n\t\t\t \n \n\t\t\t \n\t\t\tfor (rr=2; rr < rr1-1; rr++) \n\t\t\t\tfor (cc=2; cc < cc1-1; cc++) { \n\t\t\t\t\tc = FC(rr,cc); \n\t\t\t\t\tif (c==1) {  \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tgin=rgb[(rr)*TS+cc][c]; \n\t\t\t\t\t\tg[0]=rgb[(rr-2)*TS+cc][c]; \n\t\t\t\t\t\tg[1]=rgb[(rr-1)*TS+cc-1][c]; \n\t\t\t\t\t\tg[2]=rgb[(rr-1)*TS+cc+1][c]; \n\t\t\t\t\t\tg[3]=rgb[(rr)*TS+cc-2][c]; \n\t\t\t\t\t\tg[4]=rgb[(rr)*TS+cc+2][c]; \n\t\t\t\t\t\tg[5]=rgb[(rr+1)*TS+cc-1][c]; \n\t\t\t\t\t\tg[6]=rgb[(rr+1)*TS+cc+1][c]; \n\t\t\t\t\t\tg[7]=rgb[(rr+2)*TS+cc][c]; \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tnorm=0.0f; \n\t\t\t\t\t\twtdsum=0.0f; \n\t\t\t\t\t\tfor (dir=0; dir<8; dir++){ \n\t\t\t\t\t\t\tdirwt=1/(SQRF(gin-g[dir])+noisevar+eps1); \n \n\t\t\t\t\t\t\tnorm+=dirwt; \n\t\t\t\t\t\t\twtdsum+=g[dir]*dirwt; \n\t\t\t\t\t\t} \n\t\t\t\t\t\twtdsum=wtdsum/norm; \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tlpf[(rr)*TS+cc]=(gin+wtdsum)/2; \n\t\t\t\t\t\thpf[(rr)*TS+cc]=(gin-wtdsum)/2; \n\t\t\t\t\t\thfvar[c]=hfvar[c]+SQRF(hpf[(rr)*TS+cc]); \n \n\t\t\t\t\t} \n\t\t\t\t\telse { \n\t\t\t\t \n\t\t\t\t\t\t \n \n\t\t\t\t\t\trbin=rgb[(rr)*TS+cc][c]; \n\t\t\t\t\t\trb[0]=rgb[(rr-2)*TS+cc-2][c]; \n\t\t\t\t\t\trb[1]=rgb[(rr-2)*TS+cc][c]; \n\t\t\t\t\t\trb[2]=rgb[(rr-2)*TS+cc+2][c]; \n\t\t\t\t\t\trb[3]=rgb[(rr)*TS+cc-2][c]; \n\t\t\t\t\t\trb[4]=rgb[(rr)*TS+cc+2][c]; \n\t\t\t\t\t\trb[5]=rgb[(rr+2)*TS+cc-2][c]; \n\t\t\t\t\t\trb[6]=rgb[(rr+2)*TS+cc][c]; \n\t\t\t\t\t\trb[7]=rgb[(rr+2)*TS+cc+2][c]; \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tnorm=0.0f; \n\t\t\t\t\t\twtdsum=0.0f; \n\t\t\t\t\t\tfor (dir=0; dir<8; dir++) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tdirwt=1/(SQRF(rbin-rb[dir])+noisevarbr+eps1); \n \n\t\t\t\t\t\t\tnorm+=dirwt; \n\t\t\t\t\t\t\twtdsum+=rb[dir]*dirwt; \n\t\t\t\t\t\t} \n\t\t\t\t\t\twtdsum=wtdsum/norm; \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tlpf[(rr)*TS+cc]=(rbin+wtdsum)/2; \n\t", "pred": "void CLASS cfa_impulse_gauss(float lclean, float cclean) \n{   \n\tdouble dt; \n\tclock_t t1, t2; \n\tint winx=0, winy=0,winw=width, winh=height; \n \n\tint compt=0, compt10=0,compt50=0,compt250=0,compt500=0,comptmax=0; \n\tstatic const int border=8; \n\tint rayo=1,i,d; \n\tint compte1=0; \n\tstatic const float eps1=1e-10; \n\t \n\tif (verbose) fprintf (stderr,_(\"CFA impulse-hot and gaussian denoise [E.Martinec +JD] g:%1.4f  br:%1.4f\\n\"), lclean,cclean); \n\tt1 = clock(); \n\tborder_interpolate(16); \n\tfloat noisevar=SQRF(lclean);  \n\tfloat noisevarbr=SQRF(cclean); \n \n#pragma omp parallel \n{\t \n\tint top,left; \n\tchar\t\t*buffer;\t\t\t\t \n \n\tfloat         (*rgb)[3];\t\t \n \n\tfloat         (*lpf);\t\t\t \n \n\tfloat         (*hpf);\t\t\t \n \n \n\t \n \n\tbuffer = (char *) calloc((4*sizeof(float)+sizeof(int))*TS*TS,1); \n\t \n\t \n \n\trgb         = (float (*)[3])\t\tbuffer;  \n \n \tlpf\t\t\t= (float (*))\t\t\t(buffer +  3*sizeof(float)*TS*TS); \n\thpf\t\t\t= (float (*))\t\t\t(buffer +  4*sizeof(float)*TS*TS); \n\t \n\t \n \n\t \n\t \n \n \n \n\t \n \n\t \n \n \n#pragma omp for schedule(dynamic) nowait  \n\tfor (top=0; top < winh-16; top += TS-32) \n\t\tfor (left=0; left < winw-16; left += TS-32)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \nint \nyescrypt_kdf(const yescrypt_shared_t * shared, yescrypt_local_t * local, \n    const uint8_t * passwd, size_t passwdlen, \n    const uint8_t * salt, size_t saltlen, \n    uint64_t N, uint32_t r, uint32_t p, uint32_t t, yescrypt_flags_t flags, \n    uint8_t * buf, size_t buflen) \n{ \n\tyescrypt_region_t tmp; \n\tuint64_t NROM; \n\tsize_t B_size, V_size, XY_size, need; \n\tuint8_t * B, * S; \n\tsalsa20_blk_t * V, * XY; \n\tuint8_t sha256[32]; \n \n\t \n \n\tif (p == 1) \n\t\tflags &= ~YESCRYPT_PARALLEL_SMIX; \n \n\t \n \n\tif (flags & ~YESCRYPT_KNOWN_FLAGS) { \n\t\terrno = EINVAL; \n\t\treturn -1; \n\t} \n\tif (buflen > (((uint64_t)(1) << 32) - 1) * 32) { \n\t\terrno = EFBIG; \n\t\treturn -1; \n\t} \n\tif ((uint64_t)(r) * (uint64_t)(p) >= (1 << 30)) { \n\t\terrno = EFBIG; \n\t\treturn -1; \n\t} \n\tif (N > UINT32_MAX) { \n\t\terrno = EFBIG; \n\t\treturn -1; \n\t} \n\tif (((N & (N - 1))!= 0) || (N <= 7) || (r < 1) || (p < 1)) { \n\t\terrno = EINVAL; \n\t\treturn -1; \n\t} \n\tif ((flags & YESCRYPT_PARALLEL_SMIX) && (N / p <= 7)) { \n\t\terrno = EINVAL; \n\t\treturn -1; \n\t} \n\tif ((r > SIZE_MAX / 256 / p) || \n\t    (N > SIZE_MAX / 128 / r)) { \n\t\terrno = ENOMEM; \n\t\treturn -1; \n\t} \n\tif (!(flags & YESCRYPT_PARALLEL_SMIX) && \n\t    (N > SIZE_MAX / 128 / (r * p))) { \n\t\terrno = ENOMEM; \n\t\treturn -1; \n\t} \n\tif ((flags & YESCRYPT_PWXFORM) && \n\t    (flags & YESCRYPT_PARALLEL_SMIX) && \n\t    p > SIZE_MAX / S_SIZE_ALL) { \n\t\terrno = ENOMEM; \n\t\treturn -1; \n\t} \n \n\tNROM = 0; \n\tif (shared->shared1.aligned) { \n\t\tNROM = shared->shared1.aligned_size / ((size_t)128 * r); \n\t\tif (NROM > UINT32_MAX) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (((NROM & (NROM - 1))!= 0) || (NROM <= 7) || \n\t\t   !(flags & YESCRYPT_RW)) { \n\t\t\terrno = EINVAL; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n\t \n \n\tV = NULL; \n\tV_size = (size_t)128 * r * N; \n\tif (!(flags & YESCRYPT_PARALLEL_SMIX)) \n\t\tV_size *= p; \n\tneed = V_size; \n\tif (flags & __YESCRYPT_INIT_SHARED) { \n\t\tif (local->aligned_size < need) { \n\t\t\tif (local->base || local->aligned || \n\t\t\t    local->base_size || local->aligned_size) { \n\t\t\t\terrno = EINVAL; \n\t\t\t\treturn -1; \n\t\t\t} \n\t\t\tif (!alloc_region(local, need)) \n\t\t\t\treturn -1; \n\t\t} \n\t\tV = (salsa20_blk_t *)local->aligned; \n\t\tneed = 0; \n\t} \n\tB_size = (size_t)128 * r * p; \n\tneed += B_size; \n\tif (need < B_size) { \n\t\terrno = ENOMEM; \n\t\treturn -1; \n\t} \n\tXY_size = (size_t)256 * r; \n\tXY_size *= p; \n\tneed += XY_size; \n\tif (need < XY_size) { \n\t\terrno = ENOMEM; \n\t\treturn -1; \n\t} \n\tif (flags & YESCRYPT_PWXFORM) { \n\t\tsize_t S_size = S_SIZE_ALL; \n\t\tS_size *= p; \n\t\tif (flags & YESCRYPT_PARALLEL_SMIX) \n\t\t\tS_size *= p; \n\t\tneed += S_size; \n\t\tif (need < S_size) { \n\t\t\terrno = ENOMEM; \n\t\t\treturn -1; \n\t\t} \n\t} \n\tif (flags & __YESCRYPT_INIT_SHARED) { \n\t\tif (!alloc_region(&tmp, need)) \n\t\t\treturn -1; \n\t\tB = (uint8_t *)tmp.aligned; \n\t\tXY = (salsa20_blk_t *)((uint8_t *)B + B_size); \n\t} else { \n\t\tinit_region(&tmp); \n\t\tif (local->aligned_size < need) { \n\t\t\tif (free_region(local)) \n\t\t\t\treturn -1; \n\t\t\tif (!alloc_region(local, need)) \n\t\t\t\treturn -1; \n\t\t} \n\t\tB = (uint8_t *)local->aligned; \n\t\tV = (salsa20_blk_t *)((uint8_t *)B + B_size); \n\t\tXY = (salsa20_blk_t *)((uint8_t *)V + V_size); \n\t} \n\tS = NULL; \n\tif (flags & YESCRYPT_PWXFORM) \n\t\tS = (uint8_t *)XY + XY_size; \n \n\tif (t || flags) { \n\t\tSHA256_CTX_Y ctx; \n\t\tSHA256_Init_Y(&ctx); \n\t\tSHA256_Update_Y(&ctx, passwd, passwdlen); \n\t\tSHA256_Final_Y(sha256, &ctx); \n\t\tpasswd = sha256; \n\t\tpasswdlen = sizeof(sha256); \n\t} \n \n\t \n \n\tPBKDF2_SHA256(passwd, passwdlen, salt, saltlen, 1, B, B_size); \n \n\tif (t || flags) \n\t\tmemcpy(sha256, B, sizeof(sha256)); \n \n\tif (p == 1 || (flags & YESCRYPT_PARALLEL_SMIX)) { \n\t\tsmix(B, r, N, p, t, flags, V, NROM, shared, XY, S); \n\t} else { \n\t\tuint32_t i; \n \n\t\t \n \n#pragma omp parallel for default(none) private(i) shared(B, r, N, p, t, flags, V, NROM, shared, XY, S) \n\t\tfor (i = 0; i < p; i++) { \n\t\t\t \n \n", "pred": " \nint \nyescrypt_kdf(const yescrypt_shared_t * shared, yescrypt_local_t * local, \n    const uint8_t * passwd, size_t passwdlen, \n    const uint8_t * salt, size_t saltlen, \n    uint64_t N, uint32_t r, uint32_t p, uint32_t t, yescrypt_flags_t flags, \n    uint8_t * buf, size_t buflen) \n{ \n\tyescrypt_region_t tmp; \n\tuint64_t NROM; \n\tsize_t B_size, V_size, XY_size, need; \n\tuint8_t * B, * S; \n\tsalsa20_blk_t * V, * XY; \n\tuint8_t sha256[32]; \n \n\t \n \n\tif (p == 1) \n\t\tflags &= ~YESCRYPT_PARALLEL_SMIX; \n \n\t \n \n\tif (flags & ~YESCRYPT_KNOWN_FLAGS) { \n\t\terrno = EINVAL; \n\t\treturn -1; \n\t} \n\tif (buflen > (((uint64_t)(1) << 32) - 1) * 32) { \n\t\terrno = EFBIG; \n\t\treturn -1; \n\t} \n\tif ((uint64_t)(r) * (uint64_t)(p) >= (1 << 30)) { \n\t\terrno = EFBIG; \n\t\treturn -1; \n\t} \n\tif (N > UINT32_MAX) { \n\t\terrno = EFBIG; \n\t\treturn -1; \n\t} \n\tif (((N & (N - 1))!= 0) || (N <= 7) || (r < 1) || (p < 1)) { \n\t\terrno = EINVAL; \n\t\treturn -1; \n\t} \n\tif ((flags & YESCRYPT_PARALLEL_SMIX) && (N / p <= 7)) { \n\t\terrno = EINVAL; \n\t\treturn -1; \n\t} \n\tif ((r > SIZE_MAX / 256 / p) || \n\t    (N > SIZE_MAX / 128 / r)) { \n\t\terrno = ENOMEM;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         "}
{"label": " \nvoid fmf_round(int num_docs, \n               doc_t *docs, \n               int num_clusters, \n               double shrink_factor, \n               int fast_scoring, \n               cluster_center_t *cluster_centers, \n               uint32_t *cluster_assignments, \n               double **prefixsums, \n               tfreq_t *cfreqs, \n               double *cfreqs_prefixsums, \n               term_freqs_t *tfreqs) { \n    int i, k; \n    if (num_docs == num_clusters) { \n        for (i = 0; i < num_clusters; i++) { \n            cluster_assignments[i] = i; \n        } \n        return; \n    } else { \n        int subset_size = (int)(num_docs*shrink_factor); \n        if (subset_size < num_clusters) { \n            subset_size = num_clusters; \n        } \n        fmf_round(subset_size, \n                  docs, \n                  num_clusters, \n                  shrink_factor, \n                  fast_scoring, \n                  cluster_centers, \n                  cluster_assignments, \n                  prefixsums, \n                  cfreqs, \n                  cfreqs_prefixsums, \n                  tfreqs); \n \n        double totalscore = 0; \n        double lastscore = 0; \n \n        uint32_t num_terms = tfreqs->len; \n \n         \n \n         \n \n         \n \n \n        for (k = 0; k < 3 || totalscore < lastscore*0.99; k++) { \n             \n \n            for (i = 0; i < num_clusters; i++) { \n                bzero(cluster_centers[i], sizeof(tfreq_t)*num_terms); \n            } \n \n            int num_assignments = (k>0)? num_docs : subset_size; \n \n            #pragma omp parallel shared(num_clusters, cluster_centers, docs, cluster_assignments, num_assignments) private(i) \n            { \n                int numthreads = omp_get_num_threads(); \n                int tid = omp_get_thread_num(); \n                int bucketsize = (num_clusters + numthreads)/numthreads; \n                 \n \n                for (i = 0; i < num_assignments; i++) { \n                    uint32_t cid = cluster_assignments[i]; \n                    if (cid >= tid*bucketsize && cid < (tid+1)*bucketsize) { \n                        add_to_cluster(docs[i], cluster_centers[cid]); \n                    } \n                } \n            } \n \n \n            #pragma omp parallel shared(num_clusters, cluster_centers, tfreqs, prefixsums) private(i) \n            { \n                 \n \n                #pragma omp for schedule(static) nowait \n                for (i = 0; i < num_clusters; i++) { \n                    calc_prefix_sum(cluster_centers[i], tfreqs, prefixsums[i]); \n                } \n            } \n \n            calc_cfreqs(cfreqs, cluster_centers, num_clusters, num_terms); \n            calc_prefix_sum(cfreqs, tfreqs, cfreqs_prefixsums); \n \n            lastscore = totalscore; \n            totalscore = 0; \n \n            int clustercount[num_clusters]; \n            for (i = 0; i < num_clusters; i++) { \n                clustercount[i] = 0; \n            } \n \n            if (num_docs < num_clusters*100) { \n                double scorebuf[num_clusters]; \n                for (i = 0; i < num_docs; i++) { \n                    uint32_t clusterid; \n                    if (fast_scoring) { \n                        clusterid = assign_cluster_fast(i, \n                                                        docs, \n                   ", "pred": " \nvoid fmf_round(int num_docs, \n               doc_t *docs, \n               int num_clusters, \n               double shrink_factor, \n               int fast_scoring, \n               cluster_center_t *cluster_centers, \n               uint32_t *cluster_assignments, \n               double **prefixsums, \n               tfreq_t *cfreqs, \n               double *cfreqs_prefixsums, \n               term_freqs_t *tfreqs) { \n    int i, k; \n    if (num_docs == num_clusters) { \n        for (i = 0; i < num_clusters; i++) { \n            cluster_assignments[i] = i; \n        } \n        return; \n    } else { \n        int subset_size = (int)(num_docs*shrink_factor); \n        if (subset_size < num_clusters) { \n            subset_size = num_clusters; \n        } \n        fmf_round(subset_size, \n                  docs, \n                  num_clusters, \n                  shrink_factor, \n                  fast_scoring, \n                  cluster_centers, \n                  cluster_assignments,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nMAT * ellipsematching(MAT * grad_x, MAT * grad_y) { \n\tint i, n, k; \n\t \n \n\t \n \n\tdouble sin_angle[NPOINTS], cos_angle[NPOINTS], theta[NPOINTS]; \n\tfor (n = 0; n < NPOINTS; n++) { \n\t\ttheta[n] = (double) n * 2.0 * PI / (double) NPOINTS; \n\t\tsin_angle[n] = sin(theta[n]); \n\t\tcos_angle[n] = cos(theta[n]); \n\t} \n \n\t \n \n\tint tX[NCIRCLES][NPOINTS], tY[NCIRCLES][NPOINTS]; \n\tfor (k = 0; k < NCIRCLES; k++) { \n\t\tdouble rad = (double) (MIN_RAD + 2 * k);  \n\t\tfor (n = 0; n < NPOINTS; n++) { \n\t\t\ttX[k][n] = (int) (cos(theta[n]) * rad); \n\t\t\ttY[k][n] = (int) (sin(theta[n]) * rad); \n\t\t} \n\t} \n\t \n\tint MaxR = MAX_RAD + 2; \n\t \n\t \n \n\tint height = grad_x->m, width = grad_x->n; \n\tMAT * gicov = m_get(height, width); \n\t \n\t \n \n { const unsigned long long parallel_for_start = current_time_ns(); \n#pragma omp parallel for \nfor (i = MaxR; i < width - MaxR; i++) { \n\t\tdouble Grad[NPOINTS]; \n\t\tint j, k, n, x, y; \n\t\t \n\t\tfor (j = MaxR; j < height - MaxR; j++) { \n\t\t\t \n \n\t\t\tdouble max_GICOV = 0;\t \n\t\t\t \n\t\t\t \n \n\t\t\tfor (k = 0; k < NCIRCLES; k++) { \n\t\t\t\t \n \n\t\t\t\tfor (n = 0; n < NPOINTS; n++)\t{ \n\t\t\t\t\t \n \n\t\t\t\t\ty = j + tY[k][n]; \n\t\t\t\t\tx = i + tX[k][n]; \n\t\t\t\t\t \n\t\t\t\t\t \n \n\t\t\t\t\tGrad[n] = m_get_val(grad_x, y, x) * cos_angle[n] + m_get_val(grad_y, y, x) * sin_angle[n]; \n\t\t\t\t} \n\t\t\t\t \n\t\t\t\t \n \n\t\t\t\tdouble sum = 0.0; \n\t\t\t\tfor (n = 0; n < NPOINTS; n++) sum += Grad[n]; \n\t\t\t\tdouble mean = sum / (double)NPOINTS; \n\t\t\t\t \n\t\t\t\t \n \n\t\t\t\tdouble var = 0.0;\t\t\t\t \n\t\t\t\tfor (n = 0; n < NPOINTS; n++)\t{ \n\t\t\t\t\tsum = Grad[n] - mean; \n\t\t\t\t\tvar += sum * sum; \n\t\t\t\t}\t\t\t\t \n\t\t\t\tvar = var / (double) (NPOINTS - 1); \n\t\t\t\t \n\t\t\t\t \n \n\t\t\t\tif (mean * mean / var > max_GICOV) { \n\t\t\t\t\tm_set_val(gicov, j, i, mean / sqrt(var)); \n\t\t\t\t\tmax_GICOV = mean * mean / var; \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t} ;  \nconst unsigned long long parallel_for_end = current_time_ns(); \nprintf(\"pragma111_omp_parallel %llu ns\\n\", parallel_for_end - parallel_for_start); }  \n \n\t \n\treturn gicov; \n} ", "pred": " \nMAT * ellipsematching(MAT * grad_x, MAT * grad_y) { \n\tint i, n, k; \n\t \n \n\t \n \n\tdouble sin_angle[NPOINTS], cos_angle[NPOINTS], theta[NPOINTS]; \n\tfor (n = 0; n < NPOINTS; n++) { \n\t\ttheta[n] = (double) n * 2.0 * PI / (double) NPOINTS; \n\t\tsin_angle[n] = sin(theta[n]); \n\t\tcos_angle[n] = cos(theta[n]); \n\t} \n \n\t \n \n\tint tX[NCIRCLES][NPOINTS], tY[NCIRCLES][NPOINTS]; \n\tfor (k = 0; k < NCIRCLES; k++) { \n\t\tdouble rad = (double) (MIN_RAD + 2 * k);  \n\t\tfor (n = 0; n < NPOINTS; n++) { \n\t\t\ttX[k][n] = (int) (cos(theta[n]) * rad); \n\t\t\ttY[k][n] = (int) (sin(theta[n]) * rad); \n\t\t} \n\t} \n\t \n\tint MaxR = MAX_RAD + 2; \n\t \n\t \n \n\tint height = grad_x->m, width = grad_x->n; \n\tMAT * gicov = m_get(height, width); \n\t \n\t \n \n { const unsigned long long parallel_for_start = current_time_ns(); \n#pragma omp parallel for \nfor (i = MaxR; i < width - MaxR; i++) { \n\t\tdouble Grad[NPOINTS]; \n\t\tint j, k, n, x, y; \n\t\t \n\t\tfor (j = MaxR; j < height - MaxR; j++) { \n\t\t\t \n \n\t\t\tdouble max_GICOV = 0;\t \n\t\t\t \n\t\t\t \n \n\t\t\tfor (k = 0; k < NCIRCLES; k++) { \n\t\t\t\t \n \n\t\t\t\tfor (n = 0; n < NPOINTS; n++)\t{ \n\t\t\t\t\t \n \n\t\t\t\t\ty = j + tY[k];                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": " \nint lrexp(sf_complex **img, sf_complex **dat, bool adj, sf_complex **lt, sf_complex **rt, geopar geop, sf_complex ***wvfld) \n \n \n{ \n    int it, nt, ix, nx, nx2, iz, nz, nz2, nzx2, gpz, wfnt, wfit, snap; \n    int im, i, j, m2, ik, nk, pad1; \n    float dt, dx, dz, ox; \n    sf_complex *curr, **wave, *cwave, *cwavem, c; \n    sf_complex *currm; \n    bool verb; \n \n    nx  = geop->nx; \n    nz  = geop->nz; \n    dx  = geop->dx; \n    dz  = geop->dz; \n    ox  = geop->ox; \n    gpz = geop->gpz; \n    nt  = geop->nt; \n    dt  = geop->dt; \n    snap= geop->snap; \n    nzx2= geop->nzx2; \n    m2  = geop->m2; \n    wfnt= geop->wfnt; \n    pad1= geop->pad1; \n    verb= geop->verb; \n \n    nk = cfft2_init(pad1,nz,nx,&nz2,&nx2); \n    if (nk!=geop->nk) sf_error(\"nk discrepancy!\"); \n \n    curr = sf_complexalloc(nzx2); \n    cwave  = sf_complexalloc(nk); \n    wave = sf_complexalloc2(nzx2,m2); \n    if (adj) { \n\tcurrm  = sf_complexalloc(nzx2); \n\ticfft2_allocate(cwave); \n    } else { \n\tcwavem = sf_complexalloc(nk); \n\ticfft2_allocate(cwavem); \n    } \n \n#pragma omp parallel for private(iz) \n    for (iz=0; iz < nzx2; iz++) { \n\tcurr[iz] = sf_cmplx(0.,0.); \n    } \n \n    if (adj) {  \n \n        if (snap>0) wfit = (int)(nt-1)/snap;  \n \n\t \n \n\tfor (it=nt-1; it > -1; it--) { \n\t    if (verb) sf_warning(\"it=%d;\",it); \n\t \n\t     \n \n\t    for (im = 0; im < m2; im++) { \n#pragma omp parallel for private(ix,iz,i,j) shared(currm,lt,curr) \n\t\tfor (ix = 0; ix < nx; ix++) { \n\t\t    for (iz=0; iz < nz; iz++) { \n\t\t\ti = iz+ix*nz;   \n \n\t\t\tj = iz+ix*nz2;  \n \n\t\t\tcurrm[j] = conjf(lt[im][i])*curr[j]; \n\t\t\tcurrm[j] = sf_cmul(conjf(lt[im][i]), curr[j]); \n\t\t    } \n\t\t} \n\t\tcfft2(currm,wave[im]); \n\t    } \n#pragma omp parallel for private(ik,im,c) shared(wave,rt,cwave) \n\t    for (ik = 0; ik < nk; ik++) { \n\t\tc = sf_cmplx(0.,0.); \n\t\tfor (im = 0; im < m2; im++) { \n\t\t    c += wave[im][ik]*conjf(rt[ik][im]); \n\t\t    c += sf_cmul(wave[im][ik],conjf(rt[ik][im]));  \n \n\t\t} \n\t\tcwave[ik] = c; \n\t    } \n \n\t    icfft2(curr,cwave); \n \n#pragma omp parallel for private(ix) \n\t    for (ix=0; ix < nx; ix++) {  \n \n\t\tcurr[gpz+ix*nz2] += dat[ix][it]; \n\t    } \n \n\t    if (snap > 0 && it%snap == 0) { \n#pragma omp parallel for private(ix,iz,j) \n\t\tfor ( ix = 0; ix < nx; ix++) { \n\t\t    for ( iz = 0; iz<nz; iz++ ) {  \n\t\t\tj = iz+ix*nz2;  \n \n\t\t\twvfld[wfit][ix][iz] = curr[j]; \n\t\t    } \n\t\t} \n\t\tif (snap>0) wfit--; \n\t    } \n\t}  \n \n\t \n \n#pragma omp parallel for private(ix,iz) \n\tfor (ix=0; ix < nx; ix++) { \n\t    for (iz=0; iz < nz; iz++) { \n\t\timg[ix][iz] = curr[iz+ix*nz2]; \n\t    } \n\t} \n    } else {  \n \n\t \n \n#pragma omp parallel for private(ix,iz) \n\tfor (ix=0; ix < nx; ix++) { \n\t    for (iz=0; iz < nz; iz++) { \n\t\tcurr[iz+ix*nz2]=img[ix][iz]; \n\t    } \n\t} \n\tif (snap>0) wfit = 0; \n\t \n \n\tfor (it=0; it < nt; it++) { \n\t    if (verb) sf_warning(\"it=%d;\",it); \n#pragma omp parallel for private(ix) \n\t    for (ix=0; ix < nx; ix++) {  \n \n\t\tdat[ix][it] = curr[gpz+ix*nz2]; \n\t    } \n\t     \n \n\t    cfft2(curr,cwave); \n\t     \n\t    for (im = 0; im < m2; im++) { \n#pragma omp parallel for private(ik) \n\t\tfor (ik = 0; ik < nk; ik++) { \n\t\t    cwavem[ik] = cwave[ik]*rt[ik][im]; \n\t\t    cwavem[ik] = sf_cmul(cwave[ik],rt[ik][im]); \n\t\t} \n\t\ticfft2(wave[im],cwavem); \n\t    } \n#pragma omp parallel for private(ix,iz,i,j,im,c) shared(curr,lt,wave) \n\t    for (ix = 0; ix < nx; ix++) { \n\t\tfor (iz=0; iz < nz; iz++) { \n\t\t    i = iz+ix*nz;   \n \n\t\t    j = iz+ix*nz2;  \n \n\t\t     \n\t\t    c = sf_cmplx(0.,0.);  \n", "pred": " \nint lrexp(sf_complex **img, sf_complex **dat, bool adj, sf_complex **lt, sf_complex **rt, geopar geop, sf_complex ***wvfld) \n \n \n{ \n    int it, nt, ix, nx, nx2, iz, nz, nz2, nzx2, gpz, wfnt, wfit, snap; \n    int im, i, j, m2, ik, nk, pad1; \n    float dt, dx, dz, ox; \n    sf_complex *curr, **wave, *cwave, *cwavem, c; \n    sf_complex *currm; \n    bool verb; \n \n    nx  = geop->nx; \n    nz  = geop->nz; \n    dx  = geop->dx; \n    dz  = geop->dz; \n    ox  = geop->ox; \n    gpz = geop->gpz; \n    nt  = geop->nt; \n    dt  = geop->dt; \n    snap= geop->snap; \n    nzx2= geop->nzx2; \n    m2  = geop->m2; \n    wfnt= geop->wfnt; \n    pad1= geop->pad1; \n    verb= geop->verb; \n \n    nk = cfft2_init(pad1,nz,nx,&nz2,&nx2); \n    if (nk!=geop->nk) sf_error(\"nk discrepancy!\"); \n \n    curr = sf_complexalloc(nzx2); \n    cwave  = sf_complexalloc(nk); \n    wave = sf_complexalloc2(nzx2,m2); \n    if (adj) { \n\tcurrm  = sf_complexalloc(nzx2); \n\ticfft2_allocate(cwave); \n    } else { \n\tcwavem = sf_complexalloc(nk); \n\ticfft2_allocate(cwavem); \n    } \n \n#pragma omp parallel for private(iz) do {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": " \nvoid CVHFnr_direct_drv(int (*intor)(), void (*fdot)(), JKOperator **jkop, \n                       double **dms, double **vjk, int n_dm, int ncomp, \n                       int *shls_slice, int *ao_loc, \n                       CINTOpt *cintopt, CVHFOpt *vhfopt, \n                       int *atm, int natm, int *bas, int nbas, double *env) \n{ \n        IntorEnvs envs = {natm, nbas, atm, bas, env, shls_slice, ao_loc, NULL, \n                cintopt, ncomp}; \n        int idm; \n        double *tile_dms[n_dm]; \n        for (idm = 0; idm < n_dm; idm++) { \n                CVHFzero_out_vjk(vjk[idm], jkop[idm], shls_slice, ao_loc, ncomp); \n                tile_dms[idm] = CVHFallocate_and_reorder_dm(jkop[idm], dms[idm], \n                                                            shls_slice, ao_loc); \n        } \n \n        size_t di = GTOmax_shell_dim(ao_loc, shls_slice, 4); \n        size_t cache_size = GTOmax_cache_size(intor, shls_slice, 4, \n                                              atm, natm, bas, nbas, env); \n        int ish0 = shls_slice[0]; \n        int ish1 = shls_slice[1]; \n        int jsh0 = shls_slice[2]; \n        int jsh1 = shls_slice[3]; \n        int ksh0 = shls_slice[4]; \n        int ksh1 = shls_slice[5]; \n        int lsh0 = shls_slice[6]; \n        int lsh1 = shls_slice[7]; \n        int nish = ish1 - ish0; \n        int njsh = jsh1 - jsh0; \n        int nksh = ksh1 - ksh0; \n        int nlsh = lsh1 - lsh0; \n        int *block_iloc = malloc(sizeof(int) * (nish + njsh + nksh + nlsh + 4)); \n        int *block_jloc = block_iloc + nish + 1; \n        int *block_kloc = block_jloc + njsh + 1; \n        int *block_lloc = block_kloc + nksh + 1; \n        size_t nblock_i = CVHFshls_block_partition(block_iloc, shls_slice+0, ao_loc, AO_BLOCK_SIZE); \n        size_t nblock_j = CVHFshls_block_partition(block_jloc, shls_slice+2, ao_loc, AO_BLOCK_SIZE); \n        size_t nblock_k = CVHFshls_block_partition(block_kloc, shls_slice+4, ao_loc, AO_BLOCK_SIZE); \n        size_t nblock_l = CVHFshls_block_partition(block_lloc, shls_slice+6, ao_loc, AO_BLOCK_SIZE); \n        size_t nblock_kl = nblock_k * nblock_l; \n        size_t nblock_jkl = nblock_j * nblock_kl; \n \n#pragma omp parallel \n{ \n        size_t i, j, k, l, r, blk_id; \n        JKArray *v_priv[n_dm]; \n        for (i = 0; i < n_dm; i++) { \n                v_priv[i] = CVHFallocate_JKArray(jkop[i], shls_slice, ao_loc, ncomp); \n        } \n        double *buf = malloc(sizeof(double) * (di*di*di*di*ncomp + di*di*2 + cache_size)); \n        double *cache = buf + di*di*di*di*ncomp; \n#pragma omp for nowait schedule(dynamic, 1) \n        for (blk_id = 0; blk_id < nblock_jkl; blk_id++) { \n                r = blk_id; \n                j = r / nblock_kl ; r = r % nblock_kl; \n                k = r / nblock_l  ; r = r % nblock_l; \n                l = r; \n                for (i = 0; i < nblock_i; i++) { \n                        (*fdot)(intor, jkop, v_priv, tile_dms, buf, cache, n_dm, \n                                block_iloc+i, block_jloc+j, block_kloc+k, block_lloc+l, \n                                vhfopt, &envs); \n                } \n        } \n#pragma omp critical \n        { \n                for (i = 0; i < n_dm; i++) { \n                        CVHFassemble_v(vjk[i], jkop[i], v_priv[i], shls_slice, ao_loc); \n                        CVHFdeallocate_JKArray(v_priv[i]); \n      ", "pred": " \nvoid CVHFnr_direct_drv(int (*intor)(), void (*fdot)(), JKOperator **jkop, \n                       double **dms, double **vjk, int n_dm, int ncomp, \n                       int *shls_slice, int *ao_loc, \n                       CINTOpt *cintopt, CVHFOpt *vhfopt, \n                       int *atm, int natm, int *bas, int nbas, double *env) \n{ \n        IntorEnvs envs = {natm, nbas, atm, bas, env, shls_slice, ao_loc, NULL, \n                cintopt, ncomp}; \n        int idm; \n        double *tile_dms[n_dm]; \n        for (idm = 0; idm < n_dm; idm++) { \n                CVHFzero_out_vjk(vjk[idm], jkop[idm], shls_slice, ao_loc, ncomp); \n                tile_dms[idm] = CVHFallocate_and_reorder_dm(jkop[idm], dms[idm], \n                                                            shls_slice, ao_loc); \n        } \n \n        size_t di = GTOmax_shell_dim(ao_loc, shls_slice, 4); \n        size_t cache_size = GTOmax_cache_size(intor, shls_slice, 4, \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "}
{"label": " \nstatic void fwd(TYPE *next, TYPE *curr, TYPE *vsq, \n        TYPE *c_coeff, int nx, int ny, int nz, int dimx, int dimy, int dimz, \n        int radius) { \n \n#pragma omp parallel for collapse(3) \n    for (int z = 0; z < nz; z++) { \n        for (int y = 0; y < ny; y++) { \n            for (int x = 0; x < nx; x++) { \n                int this_offset = POINT_OFFSET(x, y, z, dimy, dimx, radius); \n                TYPE temp = 2.0f * curr[this_offset] - next[this_offset]; \n                TYPE div = c_coeff[0] * curr[this_offset]; \n                for (int d = 1; d <= radius; d++) { \n                    int z_pos_offset = POINT_OFFSET(x, y, z + d, dimy, dimx, \n                            radius); \n                    int z_neg_offset = POINT_OFFSET(x, y, z - d, dimy, dimx, \n                            radius); \n                    int y_pos_offset = POINT_OFFSET(x, y + d, z, dimy, dimx, \n                            radius); \n                    int y_neg_offset = POINT_OFFSET(x, y - d, z, dimy, dimx, \n                            radius); \n                    int x_pos_offset = POINT_OFFSET(x + d, y, z, dimy, dimx, \n                            radius); \n                    int x_neg_offset = POINT_OFFSET(x - d, y, z, dimy, dimx, \n                            radius); \n                    div += c_coeff[d] * (curr[z_pos_offset] + \n                            curr[z_neg_offset] + curr[y_pos_offset] + \n                            curr[y_neg_offset] + curr[x_pos_offset] + \n                            curr[x_neg_offset]); \n                } \n                next[this_offset] = temp + div * vsq[this_offset]; \n            } \n        } \n    } \n} ", "pred": " \nstatic void fwd(TYPE *next, TYPE *curr, TYPE *vsq, \n        TYPE *c_coeff, int nx, int ny, int nz, int dimx, int dimy, int dimz, \n        int radius) { \n \n#pragma omp parallel for collapse(3) \n    for (int z = 0; z < nz; z++) { \n        for (int y = 0; y < ny; y++) { \n            for (int x = 0; x < nx; x++) { \n                int this_offset = POINT_OFFSET(x, y, z, dimy, dimx, radius); \n                TYPE temp = 2.0f * curr[this_offset] - next[this_offset]; \n                TYPE div = c_coeff[0] * curr[this_offset]; \n                for (int d = 1; d <= radius; d++) { \n                    int z_pos_offset = POINT_OFFSET(x, y, z + d, dimy, dimx, \n                            radius); \n                    int z_neg_offset = POINT_OFFSET(x, y, z - d, dimy, dimx, \n                            radius); \n                    int y_pos_offset = POINT_OFFSET(x, y + d, z, dimy, dimx, \n                            radius); \n                    int y_neg_offset = POINT_OFFSET(x, y - d, z, dimy, dimx, \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "}
{"label": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const restrict ivoid, \n                  void *const restrict ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n   \n \n \n   \n \n  const dt_iop_colorcontrast_params_t *const d = (dt_iop_colorcontrast_params_t *)piece->data; \n \n   \n \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return;  \n \n \n  const __m128 scale = _mm_set_ps(1.0f, d->b_steepness, d->a_steepness, 1.0f); \n  const __m128 offset = _mm_set_ps(0.0f, d->b_offset, d->a_offset, 0.0f); \n  const __m128 min = _mm_set_ps(-INFINITY, -128.0f, -128.0f, -INFINITY); \n  const __m128 max = _mm_set_ps(INFINITY, 128.0f, 128.0f, INFINITY); \n \n  const float *const restrict in = (float*)ivoid; \n  float *const restrict out = (float*)ovoid; \n \n   \n \n  const int npixels = roi_out->height * roi_out->width; \n  if(d->unbound) \n  { \n#pragma omp parallel for default(none)    dt_omp_firstprivate(in, out, offset, npixels, scale)    schedule(static) \n    for(int j = 0; j < 4 * npixels; j += 4) \n    { \n      _mm_stream_ps(out + j, offset + scale * _mm_load_ps(in + j)); \n    } \n  } \n  else \n  { \n#pragma omp parallel for default(none)    dt_omp_firstprivate(in, out, max, min, offset, npixels, scale)    schedule(static) \n    for(int j = 0; j < 4 * npixels; j += 4) \n    { \n      _mm_stream_ps(out + j, _mm_min_ps(max, _mm_max_ps(min, offset + scale * _mm_load_ps(in + j)))); \n    } \n  } \n  _mm_sfence(); \n} ", "pred": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const restrict ivoid, \n                  void *const restrict ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n   \n \n \n   \n \n  const dt_iop_colorcontrast_params_t *const d = (dt_iop_colorcontrast_params_t *)piece->data; \n \n   \n \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return;  \n \n \n  const __m128 scale = _mm_set_ps(1.0f, d->b_steepness, d->a_steepness, 1.0f); \n  const __m128 offset = _mm_set_ps(0.0f, d->b_offset, d->a_offset, 0.0f); \n  const __m128 min = _mm_set_ps(-INFINITY, -128.0f, -128.0f, -INFINITY); \n  const __m128 max = _mm_set_ps(INFINITY, 128.0f, 128.0f, INFINITY); \n \n  const float *const restrict in = (float*)ivoid; \n  float *const restrict out = (float*)ovoid; \n \n   \n \n  const int npixels = roi_out->height * roi_out->width; \n  if(d->unbound) \n  { \n#pragma omp parallel for default(none)    dt_omp_firstprivate(in, out, offset, npixels, scale)    schedule(static) \n    for(int j = 0; j < 4 * npixels; j += 4) \n    { \n      _mm_stream_ps(out + j, offset + scale * _mm_load_ps(in + j)); \n{\"\\n                                                                                                                                                                    "}
{"label": " \nvoid mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])  \n{     \n     \n \n    const int nTheta  = (int)mxGetM(prhs[0] ); \n    const int nIndex = (int)mxGetN(prhs[1]);     \n    int iIndex; \n     \n     \n \n    double *result; \n     \n     \n \n    double *theta  = mxGetPr( prhs[0] ); \n     \n     \n \n    double *theta_indexes_start = mxGetPr( prhs[1] ); \n             \n     \n \n    const int theta_indexes_end = (int)mxGetScalar(prhs[2]) + 1;         \n      \n     \n     \n    double *forcing = mxGetPr( prhs[3] ); \n    const int nForcing = (int)mxGetM(prhs[3] ); \n     \n     \n \n    const int isForcingAnIntegral = (int)mxGetScalar(prhs[4]);     \n    \n     \n \n    const double inteTheta_0to1 = mxGetScalar(prhs[5]);     \n     \n    \n \n   __declspec(target(mic:coprocessorNum))  double trapazoidal(const int theta_index_start, const int theta_index_end, const double *dx, const double *dy, const double *intTheta); \n   __declspec(target(mic:coprocessorNum))  double Simpsons_ExtendedRule(const int theta_index_start, const int theta_index_end, const double *dx, const double *dy, const double *intTheta);           \n    \n    \n    double trapazoidal(const int theta_index_start, const int theta_index_end, const double *dx, const double *dy, const double *intTheta); \n    double Simpsons_ExtendedRule(const int theta_index_start, const int theta_index_end, const double *dx, const double *dy, const double *intTheta);       \n     \n     \n \n    plhs[0] = mxCreateDoubleMatrix(1,nIndex,mxREAL); \n    result = mxGetPr(plhs[0]); \n         \n     \n       \n \n   static int coprocessorNum=-999; \n   static int isCoprocessorMemAlloc = 0; \n   static int isCPUMemAlloc = 0; \n   int debugOffload=0; \n    \n   if (coprocessorNum==-999) { \n       \n \n      time_t t;     \n      srand((unsigned) time(&t)); \n      int coprocessorCount = _Offload_number_of_devices();       \n      coprocessorNum = rand() % coprocessorCount;           \n   } \n      \n     \n \n    __declspec( target (mic:coprocessorNum)) static int nTheta_offload = 0, nIndex_offload = 0; \n    __declspec( target (mic:coprocessorNum)) static int nForcing_offload = 0, theta_indexes_end_offload  = 0; \n    __declspec( target (mic:coprocessorNum)) static double *result_offload, *theta_offload, *theta_indexes_start_offload, *forcing_offload, inteTheta_0to1_offload; \n     \n     \n \n    _Offload_status x; \n \n     \n \n   if (nTheta==0 && nIndex==0 && nForcing ==0) {     \n      if (debugOffload==1) \n         mexPrintf(\"Freeing memory on CPU and card %d. \\n\",coprocessorNum);  \n             \n      if (isCoprocessorMemAlloc==1) { \n         #pragma offload target(mic:coprocessorNum)           nocopy(nIndex_offload : FREE REUSE)           nocopy(theta_indexes_start_offload : FREE REUSE)           nocopy(theta_indexes_end_offload : FREE REUSE)           nocopy(theta_offload : FREE REUSE)           nocopy(forcing_offload : FREE REUSE)           nocopy(inteTheta_0to1_offload : FREE REUSE)           nocopy(result_offload : FREE REUSE) status(x) optional \n         {}   \n          \n         if (x.result == OFFLOAD_SUCCESS) \n            isCoprocessorMemAlloc=0;    \n      } \n       \n      if (isCPUMemAlloc==1) { \n         mxFree(theta_offload); \n         mxFree(result_offload); \n         mxFree(theta_indexes_start_offload); \n         mxFree(forcing_offload); \n         isCPUMemAlloc=0; \n      } \n     \n      nTheta_offload = 0; \n      nIndex_offload = 0;  \n      nForcing_offload = 0;             \n       \n      coprocessorNum==-999; \n       \n      return; \n   } \n     \n    \n \n   if (nTheta_offload==0 || nIndex_offload==0 || nForcing_offload ==0  \n   || nTheta!=nTheta_offload || nIndex!=nIndex_offload || nForcing!=nForcing_offload) { \n      if (debugOffload==1) \n         mexPrintf(\"Offload Initialisation to card %d. \\n\",coprocessorNum);  \n       \n       \n \n      nTheta_offload  = nTheta; \n      nIndex_offload = nIndex; \n      nForcing_offload = nForcing; \n      theta_indexes_end_offload = theta_indexes_end; \n      inteTheta_0to1_offload =", "pred": " \nvoid mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])  \n{     \n     \n \n    const int nTheta  = (int)mxGetM(prhs[0] ); \n    const int nIndex = (int)mxGetN(prhs[1]);     \n    int iIndex; \n     \n     \n \n    double *result; \n     \n     \n \n    double *theta  = mxGetPr( prhs[0] ); \n     \n     \n \n    double *theta_indexes_start = mxGetPr( prhs[1] ); \n             \n     \n \n    const int theta_indexes_end = (int)mxGetScalar(prhs[2]) + 1;         \n      \n     \n     \n    double *forcing = mxGetPr( prhs[3] ); \n    const int nForcing = (int)mxGetM(prhs[3] ); \n     \n     \n \n    const int isForcingAnIntegral = (int)mxGetScalar(prhs[4]);     \n    \n     \n \n    const double inteTheta_0to1 = mxGetScalar(prhs[5]);     \n     \n    \n \n   __declspec(target(mic:coprocessorNum))  double trapazoidal(const int theta_index_start, const int theta_index_end, const double *dx, const double *dy, const double *intTheta); \n   __declspec(target(mic:coprocessorNum))  double Simpsons_ExtendedRule(const int theta_index_start, const int theta_index_end, const double *dx, const double *dy, const double *intTheta);           \n    \n    \n    double trapazoidal(const int theta_index_start, const int theta_index_end, const double *dx, const double *dy, const double *intTheta);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " \nvoid initialize() \n{ \n  int i, j, k, m, ix, iy, iz; \n  double xi, eta, zeta, Pface[2][3][5], Pxi, Peta, Pzeta, temp[5]; \n \n  #pragma omp parallel default(shared)            private(i,j,k,m,zeta,eta,xi,ix,iy,iz,Pxi,Peta,Pzeta,Pface,temp) \n  { \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  #pragma omp for schedule(static) \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        u[k][j][i][0] = 1.0; \n        u[k][j][i][1] = 0.0; \n        u[k][j][i][2] = 0.0; \n        u[k][j][i][3] = 0.0; \n        u[k][j][i][4] = 1.0; \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n  #pragma omp for schedule(static) nowait \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    zeta = (double)k * dnzm1; \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      eta = (double)j * dnym1; \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        xi = (double)i * dnxm1; \n \n        for (ix = 0; ix < 2; ix++) { \n          Pxi = (double)ix; \n          exact_solution(Pxi, eta, zeta, &Pface[ix][0][0]); \n        } \n \n        for (iy = 0; iy < 2; iy++) { \n          Peta = (double)iy; \n          exact_solution(xi, Peta, zeta, &Pface[iy][1][0]); \n        } \n \n        for (iz = 0; iz < 2; iz++) { \n          Pzeta = (double)iz; \n          exact_solution(xi, eta, Pzeta, &Pface[iz][2][0]); \n        } \n \n        for (m = 0; m < 5; m++) { \n          Pxi   = xi   * Pface[1][0][m] + (1.0-xi)   * Pface[0][0][m]; \n          Peta  = eta  * Pface[1][1][m] + (1.0-eta)  * Pface[0][1][m]; \n          Pzeta = zeta * Pface[1][2][m] + (1.0-zeta) * Pface[0][2][m]; \n \n          u[k][j][i][m] = Pxi + Peta + Pzeta -  \n                          Pxi*Peta - Pxi*Pzeta - Peta*Pzeta +  \n                          Pxi*Peta*Pzeta; \n        } \n      } \n    } \n  } \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n  xi = 0.0; \n  i  = 0; \n  #pragma omp for schedule(static) nowait \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    zeta = (double)k * dnzm1; \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      eta = (double)j * dnym1; \n      exact_solution(xi, eta, zeta, temp); \n      for (m = 0; m < 5; m++) { \n        u[k][j][i][m] = temp[m]; \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n  xi = 1.0; \n  i  = grid_points[0]-1; \n  #pragma omp for schedule(static) nowait \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    zeta = (double)k * dnzm1; \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      eta = (double)j * dnym1; \n      exact_solution(xi, eta, zeta, temp); \n      for (m = 0; m < 5; m++) { \n        u[k][j][i][m] = temp[m]; \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n  eta = 0.0; \n  j   = 0; \n  #pragma omp for schedule(static) nowait \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    zeta = (double)k * dnzm1; \n    for (i = 0; i <= grid_points[0]-1; i++) { \n      xi = (double)i * dnxm1; \n      exact_solution(xi, eta, zeta, temp); \n      for (m = 0; m < 5; m++) { \n        u[k][j][i][m] = temp[m]; \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n  eta = 1.0; \n  j   = grid_points[1]-1; \n  #pragma omp for schedule(static) \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    zeta = (double)k * dnzm1; \n    for (i = 0; i <= grid_points[0]-1; i++) { \n      xi = (double)i * dnxm1; \n      exact_solution(xi, eta, zeta, temp); \n      for (m = 0; m < 5; m++) { \n        u[k][j][i][m", "pred": " \nvoid initialize() \n{ \n  int i, j, k, m, ix, iy, iz; \n  double xi, eta, zeta, Pface[2][3][5], Pxi, Peta, Pzeta, temp[5]; \n \n  #pragma omp parallel default(shared)            private(i,j,k,m,zeta,eta,xi,ix,iy,iz,Pxi,Peta,Pzeta,Pface,temp) \n  { \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  #pragma omp for schedule(static) \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        u[k][j][i][0] = 1.0; \n        u[k][j][i][1] = 0.0; \n        u[k][j][i][2] = 0.0; \n        u[k][j][i][3] = 0.0; \n        u[k][j][i][4] = 1.0; \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n  #pragma omp for schedule(static) nowait \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    zeta = (double)k * dnzm1; \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      eta = (double)j * dnym1; \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        xi = (double)i * dnxm1; \n \n        for (ix = 0; ix < 2; ix++) { \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n   \n \n \n   \n \n  const dt_iop_colorcontrast_params_t *const d = (dt_iop_colorcontrast_params_t *)piece->data; \n \n   \n \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return;  \n \n \n  const float *const restrict in = DT_IS_ALIGNED((const float *const)ivoid); \n  float *const restrict out = DT_IS_ALIGNED((float *const)ovoid); \n  const size_t npixels = (size_t)roi_out->width * roi_out->height; \n \n  const dt_aligned_pixel_t slope = { 1.0f, d->a_steepness, d->b_steepness, 1.0f }; \n  const dt_aligned_pixel_t offset = { 0.0f, d->a_offset, d->b_offset, 0.0f }; \n  const dt_aligned_pixel_t lowlimit = { -INFINITY, -128.0f, -128.0f, -INFINITY }; \n  const dt_aligned_pixel_t highlimit = { INFINITY, 128.0f, 128.0f, INFINITY }; \n \n  if(d->unbound) \n  { \n#pragma omp parallel for default(none)      dt_omp_firstprivate(in, out, npixels, slope, offset)      schedule(static) \n    for(size_t k = 0; k < (size_t)4 * npixels; k += 4) \n    { \n      for_each_channel(c,dt_omp_nontemporal(out)) \n      { \n        out[k + c] = (in[k + c] * slope[c]) + offset[c]; \n      } \n    } \n  } \n  else \n  { \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(in, out, npixels, slope, offset, lowlimit, highlimit)      schedule(static) \n    for(size_t k = 0; k < npixels; k ++) \n    { \n       \n \n       \n \n       \n \n      clamped_scaling(out + 4*k, in + 4*k, slope, offset, lowlimit, highlimit); \n    } \n  } \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n   \n \n \n   \n \n  const dt_iop_colorcontrast_params_t *const d = (dt_iop_colorcontrast_params_t *)piece->data; \n \n   \n \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return;  \n \n \n  const float *const restrict in = DT_IS_ALIGNED((const float *const)ivoid); \n  float *const restrict out = DT_IS_ALIGNED((float *const)ovoid); \n  const size_t npixels = (size_t)roi_out->width * roi_out->height; \n \n  const dt_aligned_pixel_t slope = { 1.0f, d->a_steepness, d->b_steepness, 1.0f }; \n  const dt_aligned_pixel_t offset = { 0.0f, d->a_offset, d->b_offset, 0.0f }; \n  const dt_aligned_pixel_t lowlimit = { -INFINITY, -128.0f, -128.0f, -INFINITY }; \n  const dt_aligned_pixel_t highlimit = { INFINITY, 128.0f, 128.0f, INFINITY }; \n \n  if(d->unbound) \n  { \n#pragma omp parallel for default(none)      dt_omp_firstprivate(in, out, npixels, slope, offset)      schedule(static) \n    for(size_t k = 0; k < (size_t)4 * npixels; k += 4) \n    { \n      for_each_channel(c,dt_iop_get_pixel_size(self, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,"}
{"label": " \nstatic \nvoid MakeGeopotHeight(double *geop, double* gt, double *gq, double *ph, int nhor, int nlev) \n{ \n  int i, j; \n  double vtmp; \n  double zrg; \n  double z2log2; \n  double *geopl, *gtl, *gql, *phl; \n \n  z2log2 = 2.0 * log(2.0); \n  vtmp   = (C_RV / RD) - 1.0; \n  zrg    = 1.0 / Grav; \n \n  if ( gq )  \n \n    { \n      for ( j = nlev ; j > 1 ; j-- ) \n        { \n          geopl = geop + nhor*(j-1); \n          gtl   = gt   + nhor*(j-1); \n          gql   = gq   + nhor*(j-1); \n          phl   = ph   + nhor*(j-1); \n#pragma vdir nodep \n#pragma omp parallel for \n          for ( i = 0; i < nhor; i++ ) \n            geopl[i] = geopl[i+nhor] + RD * gtl[i] * (1.0 + vtmp * gql[i]) \n                     * log(phl[i+nhor] / phl[i]); \n        } \n \n#pragma vdir nodep \n#pragma omp parallel for \n      for ( i = 0; i < nhor; i++ ) \n        geop[i] = geop[i+nhor] + RD * gt[i] * (1.0 + vtmp * gq[i]) * z2log2; \n    } \n  else     \n \n    { \n      for ( j = nlev ; j > 1 ; j-- ) \n#pragma vdir nodep \n        for ( i = nhor * (j-1) ; i < nhor * j ; i++ ) \n          geop[i] = geop[i+nhor] + RD * gt[i] * log(ph[i+nhor] / ph[i]); \n \n#pragma vdir nodep \n      for ( i = 0; i < nhor; i++ ) \n        geop[i] = geop[i+nhor] + RD * gt[i] * z2log2; \n    } \n \n#pragma vdir nodep \n#pragma omp parallel for \n  for ( i = 0; i < nhor * (nlev+1); i++ ) geop[i] *= zrg; \n} ", "pred": " \nstatic \nvoid MakeGeopotHeight(double *geop, double* gt, double *gq, double *ph, int nhor, int nlev) \n{ \n  int i, j; \n  double vtmp; \n  double zrg; \n  double z2log2; \n  double *geopl, *gtl, *gql, *phl; \n \n  z2log2 = 2.0 * log(2.0); \n  vtmp   = (C_RV / RD) - 1.0; \n  zrg    = 1.0 / Grav; \n \n  if ( gq )  \n \n    { \n      for ( j = nlev ; j > 1 ; j-- ) \n        { \n          geopl = geop + nhor*(j-1); \n          gtl   = gt   + nhor*(j-1); \n          gql   = gq   + nhor*(j-1); \n          phl   = ph   + nhor*(j-1); \n#pragma vdir nodep \n#pragma omp parallel for \n          for ( i = 0; i < nhor; i++ ) \n            geopl[i] = geopl[i+nhor] + RD * gtl[i] * (1.0 + vtmp * gql[i]) \n                     * log(phl[i+nhor] / phl[i]); \n        } \n \n#pragma vdir nodep \n#pragma omp parallel for \n      for ( i = 0; i < nhor; i++ ) \n        geop[i] = geop[i+nhor] + RD * gt[i] * (1.0 + vtmp * gq[i]) * z2log2; \n    } \n  else     \n \n    { \n      for ( j = nlev ; j > 1 ; j-- ) \n#pragma vdir nodep \n                 * log(phl[j+nhor] / phl[j]);\\n                                                                                                                                                                             "}
{"label": " \nvoid exact_rhs() \n{ \n  double dtemp[5], xi, eta, zeta, dtpp; \n  int m, i, j, k, ip1, im1, jp1, jm1, km1, kp1; \n \n  #pragma omp parallel default(shared)            private(i,j,k,m,zeta,eta,xi,dtpp,im1,ip1,jm1,jp1,km1,kp1,dtemp) \n  { \n   \n \n   \n \n   \n \n  #pragma omp for schedule(static) \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        for (m = 0; m < 5; m++) { \n          forcing[k][j][i][m] = 0.0; \n        } \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n  #pragma omp for schedule(static) nowait \n  for (k = 1; k <= grid_points[2]-2; k++) { \n    zeta = (double)k * dnzm1; \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      eta = (double)j * dnym1; \n \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        xi = (double)i * dnxm1; \n \n        exact_solution(xi, eta, zeta, dtemp); \n        for (m = 0; m < 5; m++) { \n          ue[i][m] = dtemp[m]; \n        } \n \n        dtpp = 1.0 / dtemp[0]; \n \n        for (m = 1; m < 5; m++) { \n          buf[i][m] = dtpp * dtemp[m]; \n        } \n \n        cuf[i]    = buf[i][1] * buf[i][1]; \n        buf[i][0] = cuf[i] + buf[i][2] * buf[i][2] + buf[i][3] * buf[i][3];  \n        q[i] = 0.5*(buf[i][1]*ue[i][1] + buf[i][2]*ue[i][2] + \n                    buf[i][3]*ue[i][3]); \n      } \n \n      for (i = 1; i <= grid_points[0]-2; i++) { \n        im1 = i-1; \n        ip1 = i+1; \n \n        forcing[k][j][i][0] = forcing[k][j][i][0] - \n          tx2*( ue[ip1][1]-ue[im1][1] )+ \n          dx1tx1*(ue[ip1][0]-2.0*ue[i][0]+ue[im1][0]); \n \n        forcing[k][j][i][1] = forcing[k][j][i][1] - tx2 * ( \n            (ue[ip1][1]*buf[ip1][1]+c2*(ue[ip1][4]-q[ip1]))- \n            (ue[im1][1]*buf[im1][1]+c2*(ue[im1][4]-q[im1])))+ \n          xxcon1*(buf[ip1][1]-2.0*buf[i][1]+buf[im1][1])+ \n          dx2tx1*( ue[ip1][1]-2.0* ue[i][1]+ue[im1][1]); \n \n        forcing[k][j][i][2] = forcing[k][j][i][2] - tx2 * ( \n            ue[ip1][2]*buf[ip1][1]-ue[im1][2]*buf[im1][1])+ \n          xxcon2*(buf[ip1][2]-2.0*buf[i][2]+buf[im1][2])+ \n          dx3tx1*( ue[ip1][2]-2.0*ue[i][2] +ue[im1][2]); \n \n        forcing[k][j][i][3] = forcing[k][j][i][3] - tx2*( \n            ue[ip1][3]*buf[ip1][1]-ue[im1][3]*buf[im1][1])+ \n          xxcon2*(buf[ip1][3]-2.0*buf[i][3]+buf[im1][3])+ \n          dx4tx1*( ue[ip1][3]-2.0* ue[i][3]+ ue[im1][3]); \n \n        forcing[k][j][i][4] = forcing[k][j][i][4] - tx2*( \n            buf[ip1][1]*(c1*ue[ip1][4]-c2*q[ip1])- \n            buf[im1][1]*(c1*ue[im1][4]-c2*q[im1]))+ \n          0.5*xxcon3*(buf[ip1][0]-2.0*buf[i][0]+buf[im1][0])+ \n          xxcon4*(cuf[ip1]-2.0*cuf[i]+cuf[im1])+ \n          xxcon5*(buf[ip1][4]-2.0*buf[i][4]+buf[im1][4])+ \n          dx5tx1*( ue[ip1][4]-2.0* ue[i][4]+ ue[im1][4]); \n      } \n \n       \n \n       \n \n       \n \n      for (m = 0; m < 5; m++) { \n        i = 1; \n        forcing[k][j][i][m] = forcing[k][j][i][m] - dssp * \n          (5.0*ue[i][m] - 4.0*ue[i+1][m] +ue[i+2][m]); \n        i = 2; \n        forcing[k][j][i][m] = forcing[k][j][i][m] - dssp * \n          (-4.0", "pred": " \nvoid exact_rhs() \n{ \n  double dtemp[5], xi, eta, zeta, dtpp; \n  int m, i, j, k, ip1, im1, jp1, jm1, km1, kp1; \n \n  #pragma omp parallel default(shared)            private(i,j,k,m,zeta,eta,xi,dtpp,im1,ip1,jm1,jp1,km1,kp1,dtemp) \n  { \n   \n \n   \n \n   \n \n  #pragma omp for schedule(static) \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        for (m = 0; m < 5; m++) { \n          forcing[k][j][i][m] = 0.0; \n        } \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n  #pragma omp for schedule(static) nowait \n  for (k = 1; k <= grid_points[2]-2; k++) { \n    zeta = (double)k * dnzm1; \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      eta = (double)j * dnym1; \n \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        xi = (double)i * dnxm1; \n \n        exact_solution(xi, eta, zeta, dtemp); \n        for (m = 0; m < 5; m++) { \n          ue[i][m] = dtemp[m]; \n        } \n \n        dtpp = 1.0 / dtemp[0]; \n{\"\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nint main() \n{ \n  init_input_vars(); \n \n \n  double orio_t_start=0, orio_t_end=0, orio_t_total=0; \n  int orio_i; \n  int t,i,j; \n \n  for (orio_i=0; orio_i<REPS; orio_i++) \n  { \n    orio_t_start = rtclock(); \n     \n \n   \n \n \nregister int i,j,k,t;  \nregister int c1t, c2t, c3t, c4t, c5t, c6t, c7t, c8t, c9t, c10t, c11t, c12t;  \nregister int newlb_c1, newlb_c2, newlb_c3, newlb_c4, newlb_c5, newlb_c6,  \n  newlb_c7, newlb_c8, newlb_c9, newlb_c10, newlb_c11, newlb_c12;  \nregister int newub_c1, newub_c2, newub_c3, newub_c4, newub_c5, newub_c6,  \n  newub_c7, newub_c8, newub_c9, newub_c10, newub_c11, newub_c12;  \n \n \n#define ceild(n,d)  ceil(((double)(n))/((double)(d))) \n#define floord(n,d) floor(((double)(n))/((double)(d))) \n#define max(x,y)    ((x) > (y)? (x) : (y)) \n#define min(x,y)    ((x) < (y)? (x) : (y)) \n \n\t \n\tint c1, c2, c3, c4, c5, c6; \n \n\tregister int lb, ub, lb1, ub1, lb2, ub2; \n \n \nfor (c1=-1;c1<=floord(33*T+N-35,1024);c1++) { \n\tlb1=max(max(0,ceild(16*c1-511,528)),ceild(32*c1-T+1,32)); \n\tub1=min(min(floord(16*c1+15,16),floord(32*c1+N+29,1056)),floord(T+N-3,1024)); \n#pragma omp parallel for shared(c1,lb1,ub1) private(c2,c3,c4,c5,c6) \n\tfor (c2=lb1; c2<=ub1; c2++) { \n \nfor (c4=max(max(0,ceild(16*c1-16*c2-63,64)),8*c2); c4<=min(min(8*c2+7,floord(32*c1-32*c2+N+29,128)),floord(T+N-3,128)); c4++ ) { \n  for (c5t=max(max(32*c1-32*c2,1),128*c4-N+2); c5t<=min(min(128*c4+126,T-1),32*c1-32*c2+31)-1; c5t=c5t+2) { \n    newlb_c6=-2147483648; \n    newub_c6=2147483647; \n    register int cbv_1; \n    cbv_1=c5t+1; \n#pragma ivdep \n#pragma vector always \n    for (c5=c5t; c5<=cbv_1; c5=c5+1) { \n      newlb_c6=max(newlb_c6,max(c5+1,128*c4)); \n      newub_c6=min(newub_c6,min(128*c4+127,c5+N-2)); \n    } \n    for (c5=c5t; c5<=c5t+1; c5=c5+1) { \n      register int cbv_2, cbv_3; \n      cbv_2=max(c5+1,128*c4); \n      cbv_3=newlb_c6-1; \n#pragma ivdep \n#pragma vector always \n      for (c6=cbv_2; c6<=cbv_3; c6=c6+1) { \n        a[c5][-c5+c6]=((double)(333))/1000*(a[c5-1][1+-c5+c6]+a[c5-1][-c5+c6]+a[c5-1][-c5+c6-1]); \n      } \n    } \n    register int cbv_4; \n    cbv_4=newub_c6-7; \n#pragma ivdep \n#pragma vector always \n    for (c6t=newlb_c6; c6t<=cbv_4; c6t=c6t+8) { \n      a[c5t][-c5t+c6t]=((double)(333))/1000*(a[c5t-1][1+-c5t+c6t]+a[c5t-1][-c5t+c6t]+a[c5t-1][-c5t+c6t-1]); \n      a[c5t][-c5t+(c6t+1)]=((double)(333))/1000*(a[c5t-1][1+-c5t+(c6t+1)]+a[c5t-1][-c5t+(c6t+1)]+a[c5t-1][-c5t+(c6t+1)-1]); \n      a[c5t][-c5t+(c6t+2)]=((double)(333))/1000*(a[c5t-1][1+-c5t+(c6t+2)]+a[c5t-1][-c5t+(c6t+2)]+a[c5t-1][-c5t+(c6t+2)-1]); \n      a[c5t][-c5t+(c6t+3)]=((double)(333))/1000*(a[c5t-1][1+-c5t+(c6t+3)]+a[c5t-1][-c5t+(c6t+3)]+a[c5t-1][-c5t+(c6t+3)-1]); \n      a[c5t][-c5t+(c6t+4)]=((double)(333))/1000*(a[c5t-1][1+-c5t+(c6t+4)]+a[c5t-1][-c5t+(c6t+4)]+a[c5t-1][-c5t+(c6t+4)-1]); \n      a[c5t][-c5t+(c6t+5)]=((double)(333))/1000*(a[c5t-1][1+-c5t+(c6t+5)]+a[c5t-1][-c5t+(c6t+5)]+a[c5t-1][-c5t+(c6t+5)-1]); \n      a[c5t][-c5t+(c6t+6)]=((double)(333))/1000*(a[c5t-1][1+-c5t+(c6t+6)]+a[c5t-1][-c5t+(c6t+6)]+a[c5t-1][-c5t+(c6t+6", "pred": " \nint main() \n{ \n  init_input_vars(); \n \n \n  double orio_t_start=0, orio_t_end=0, orio_t_total=0; \n  int orio_i; \n  int t,i,j; \n \n  for (orio_i=0; orio_i<REPS; orio_i++) \n  { \n    orio_t_start = rtclock(); \n     \n \n   \n \n \nregister int i,j,k,t;  \nregister int c1t, c2t, c3t, c4t, c5t, c6t, c7t, c8t, c9t, c10t, c11t, c12t;  \nregister int newlb_c1, newlb_c2, newlb_c3, newlb_c4, newlb_c5, newlb_c6,  \n  newlb_c7, newlb_c8, newlb_c9, newlb_c10, newlb_c11, newlb_c12;  \nregister int newub_c1, newub_c2, newub_c3, newub_c4, newub_c5, newub_c6,  \n  newub_c7, newub_c8, newub_c9, newub_c10, newub_c11, newub_c12;  \n \n \n#define ceild(n,d)  ceil(((double)(n))/((double)(d))) \n#define floord(n,d) floor(((double)(n))/((double)(d))) \n#define max(x,y)    ((x) > (y)? (x) : (y)) \n#define min(x,y)    ((x) < (y)? (x) : (y)) \n \n\t \n\tint c1, c2, c3, c4, c5, c6; \n \n\tregister int lb, ub, lb1, ub1, lb2, ub2; \n \n \nfor (c1=-1;c1<=floord(33*T+N-35,1024);c1++) { \n\tlb1=max(max(0,ceild(16*c1-511,528)),ceild(32*c1-T+1,32)); \n\tub1=min(max(0,ceild(16*c1-511,52),ceild(16*c1-T+1,32));                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "}
{"label": " \nvoid \nfoo (int *a, long long int b, long long int c) \n{ \n  int i; \n  long long j; \n  #pragma omp parallel for lastprivate (conditional: u, x) \n  for (i = 15; i < 64; i++) \n    { \n      if ((a[i] % 5) == 3) \n\tu = i; \n      if ((a[i] % 7) == 2) \n\tx = &a[i]; \n    } \n  #pragma omp parallel for lastprivate (conditional: v) reduction (+:r, s) schedule (nonmonotonic: static) \n  for (i = -3; i < 119; i += 2) \n    { \n      ++s; \n      if ((a[i + 4] % 11) == 9) \n\tv = i; \n      else \n\t++r; \n    } \n  #pragma omp parallel for schedule (monotonic: static) lastprivate (conditional: w) \n  for (j = b; j < b + 115 * c; j += (b & 3) + 7) \n    if ((a[j] % 13) == 5) \n      w = j * 2; \n  #pragma omp parallel for schedule (auto) lastprivate (conditional: p) collapse(3) \n  for (i = -5; i < (int) (b + 5); i += 2) \n    for (j = b + 12 + c; j > b; --j) \n      for (int k = 0; k < 5; k += c) \n\tif (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6) \n\t  p = i * 10000 + j * 100 + k; \n \n  #pragma omp parallel for schedule (nonmonotonic: static, 2) lastprivate (conditional: u2, x2) \n  for (i = 15; i < 64; i++) \n    { \n      if ((a[i] % 5) == 3) \n\tu2 = i; \n      if ((a[i] % 7) == 2) \n\tx2 = &a[i]; \n    } \n  #pragma omp parallel for schedule (static, 3) lastprivate (conditional: v2) reduction (+:r2, s2) \n  for (i = -3; i < 119; i += 2) \n    { \n      ++s2; \n      if ((a[i + 4] % 11) == 9) \n\tv2 = i; \n      else \n\t++r2; \n    } \n  #pragma omp parallel for lastprivate (conditional: w2) schedule (static, 1) \n  for (j = b; j < b + 115 * c; j += (b & 3) + 7) \n    if ((a[j] % 13) == 5) \n      w2 = j * 2; \n  #pragma omp parallel for schedule (static, 3) collapse (3) lastprivate (conditional: p2) \n  for (i = -5; i < (int) (b + 5); i += 2) \n    for (j = b + 12 + c; j > b; --j) \n      for (int k = 0; k < 5; k += c) \n\tif (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6) \n\t  p2 = i * 10000 + j * 100 + k; \n \n  #pragma omp parallel for lastprivate (conditional: u3, x3) schedule (runtime) \n  for (i = 15; i < 64; i++) \n    { \n      if ((a[i] % 5) == 3) \n\tu3 = i; \n      if ((a[i] % 7) == 2) \n\tx3 = &a[i]; \n    } \n  #pragma omp parallel for lastprivate (conditional: v3) reduction (+:r3, s3) schedule (nonmonotonic: dynamic) \n  for (i = -3; i < 119; i += 2) \n    { \n      ++s3; \n      if ((a[i + 4] % 11) == 9) \n\tv3 = i; \n      else \n\t++r3; \n    } \n  #pragma omp parallel for schedule (monotonic: guided, 3) lastprivate (conditional: w3) \n  for (j = b; j < b + 115 * c; j += (b & 3) + 7) \n    if ((a[j] % 13) == 5) \n      w3 = j * 2; \n  #pragma omp parallel for schedule (dynamic, 4) lastprivate (conditional: p3) collapse(3) \n  for (i = -5; i < (int) (b + 5); i += 2) \n    for (j = b + 12 + c; j > b; --j) \n      for (int k = 0; k < 5; k += c) \n\tif (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6) \n\t  p3 = i * 10000 + j * 100 + k; \n \n   \n \n  #pragma omp parallel for schedule (monotonic: static, 2) firstprivate (z)        lastprivate (conditional: z) \n  for (int k = -2000; k < 8000; ++k) \n    { \n      if (k < 3000 && (k & 3) == 1) \n\t{ \n\t  z = k; \n\t  thr1 = k; \n\t} \n      else if (k == 7931) \n\t{ \n\t  z = z; \n\t  thr2 = 1; \n\t} \n    } \n \n  if (thr2 && z!= thr1) \n    abort (); \n} ", "pred": " \nvoid \nfoo (int *a, long long int b, long long int c) \n{ \n  int i; \n  long long j; \n  #pragma omp parallel for lastprivate (conditional: u, x) \n  for (i = 15; i < 64; i++) \n    { \n      if ((a[i] % 5) == 3) \n\tu = i; \n      if ((a[i] % 7) == 2) \n\tx = &a[i]; \n    } \n  #pragma omp parallel for lastprivate (conditional: v) reduction (+:r, s) schedule (nonmonotonic: static) \n  for (i = -3; i < 119; i += 2) \n    { \n      ++s; \n      if ((a[i + 4] % 11) == 9) \n\tv = i; \n      else \n\t++r; \n    } \n  #pragma omp parallel for schedule (monotonic: static) lastprivate (conditional: w) \n  for (j = b; j < b + 115 * c; j += (b & 3) + 7) \n    if ((a[j] % 13) == 5) \n      w = j * 2; \n  #pragma omp parallel for schedule (auto) lastprivate (conditional: p) collapse(3) \n  for (i = -5; i < (int) (b + 5); i += 2) \n    for (j = b + 12 + c; j > b; --j) \n      for (int k = 0; k < 5; k += c) \n\tif (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6) \n\t  p = i * 10000 + j * 100 + k; \n \n  #pragma omp parallel for schedule (nonmonotonic: static, 2) lastprivate (conditional: u2, x2) \n  for (i = 15; i < 64; i++) \n    { \n      if ((a[i] % 5) == 3) \n\tu2 = i; \n      if ((a[i] % 7) == 2) \n\tx2 = &a[i]; \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nint main (int argc, char *argv[]) \n{ \n  static VArgVector in_files1; \n  static VArgVector in_files2; \n  static VString  out_filename=\"\"; \n  static VString  mask_filename=\"\"; \n  static VFloat   alpha = 0.05; \n  static VShort   testtype = 0; \n  static VShort   radius = 2; \n  static VFloat   rvar = 2.0; \n  static VFloat   svar = 2.0; \n  static VShort   numiter = 2; \n  static VShort   numperm = 5000; \n  static VLong    seed = 99402622; \n  static VBoolean centering = FALSE; \n  static VBoolean cleanup = TRUE; \n  static VShort   nproc = 0; \n  static VOptionDescRec options[] = { \n    {\"in1\", VStringRepn, 0, & in_files1, VRequiredOpt, NULL,\"Input files 1\" }, \n    {\"in2\", VStringRepn, 0, & in_files2, VRequiredOpt, NULL,\"Input files 2\" }, \n    {\"out\", VStringRepn, 1, & out_filename, VRequiredOpt, NULL,\"Output file\" }, \n    {\"alpha\",VFloatRepn,1,(VPointer) &alpha,VOptionalOpt,NULL,\"FDR significance level\"}, \n    {\"perm\",VShortRepn,1,(VPointer) &numperm,VOptionalOpt,NULL,\"Number of permutations\"}, \n    {\"mask\", VStringRepn, 1, (VPointer) &mask_filename, VRequiredOpt, NULL, \"Mask\"}, \n    {\"test\",VShortRepn,1,(VPointer) &testtype,VOptionalOpt,TSTDict,\"type of test\"}, \n    {\"seed\",VLongRepn,1,(VPointer) &seed,VOptionalOpt,NULL,\"Seed for random number generation\"}, \n    {\"radius\",VShortRepn,1,(VPointer) &radius,VOptionalOpt,NULL,\"Bilateral parameter (radius in voxels)\"}, \n    {\"rvar\",VFloatRepn,1,(VPointer) &rvar,VOptionalOpt,NULL,\"Bilateral parameter (radiometric)\"}, \n    {\"svar\",VFloatRepn,1,(VPointer) &svar,VOptionalOpt,NULL,\"Bilateral parameter (spatial)\"}, \n    {\"filteriterations\",VShortRepn,1,(VPointer) &numiter,VOptionalOpt,NULL,\"Bilateral parameter (number of iterations)\"}, \n    {\"cleanup\",VBooleanRepn,1,(VPointer) &cleanup,VOptionalOpt,NULL,\"Whether to apply cleanup\"}, \n    {\"j\",VShortRepn,1,(VPointer) &nproc,VOptionalOpt,NULL,\"Number of processors to use, '0' to use all\"}, \n  }; \n \n  FILE *fp=NULL; \n  VString in_filename,str1,str2; \n  VAttrList list1=NULL,list2=NULL,out_list=NULL,geolist=NULL; \n  int i,nimages1=0,nimages2=0,npix=0; \n  char *prg_name=GetLipsiaName(\"vlisa_twosample\"); \n  fprintf (stderr, \"%s\\n\", prg_name); \n \n \n   \n \n  if (! VParseCommand (VNumber (options), options, & argc, argv)) { \n    VReportUsage (argv[0], VNumber (options), options, NULL); \n    exit (EXIT_FAILURE); \n  } \n  if (argc > 1) { \n    VReportBadArgs (argc, argv); \n    exit (EXIT_FAILURE); \n  } \n \n \n   \n \n  int num_procs=omp_get_num_procs(); \n  if (nproc > 0 && nproc < num_procs) num_procs = nproc; \n  fprintf(stderr,\" using %d cores\\n\",(int)num_procs); \n  omp_set_num_threads(num_procs); \n \n \n   \n \n  VImage mask = VReadImageFile(mask_filename); \n  if (mask==NULL) VError(\"Error reading mask file %s\",mask_filename); \n \n \n   \n \n  nimages1 = in_files1.number; \n  nimages2 = in_files2.number; \n  fprintf(stderr,\" nimages= %d  %d\\n\",nimages1,nimages2); \n \n \n   \n \n  VImage *src1 = (VImage *) VCalloc(nimages1,sizeof(VImage)); \n  for (i = 0; i < nimages1; i++) { \n    in_filename = ((VString *) in_files1.vector)[i]; \n    list1   = VReadAttrList(in_filename,0L,TRUE,FALSE); \n    VMaskMinval(list1,mask,0.0); \n    src1[i] = VReadImage(list1); \n    if (src1[i] == NULL) VError(\" no input image found\"); \n    if (VPixelRepn(src1[i])!= VFloatRepn) VError(\" input pixel repn must be float\"); \n    if (i == 0) npix = VImageNPixels(src1[i]); \n    else if (npix!= VImageNPixels(src1[i])) VError(\" inconsistent image dimensions\"); \n \n     \n \n    if (geolist == NULL) geolist = VGetGeoInfo(list1); \n  } \n \n \n   \n \n  VImage *src2 = (VImage *) VCalloc(nimages2,sizeof(VImage)); \n  for (i = 0; i < nimages2; i++) { \n    in_filename = ((VString *) in_files2.vector)[i]; \n    list2   = VReadAttrList(in_filename,0L,TRUE,FALSE); \n    VMaskMinval(list2,mask,0.0); \n    src2[i] = VReadImage(list2); \n    if (src2[i] == NULL) VError(\" no input image found\"); \n    if (VPixelRepn(src2[i])!= VFloatRepn) VError(\" input pixel repn must be float\"); \n    if (i == 0) npix = VImageNPixels(src2[i]); \n    else if (npix!= VImageNPixels(src2[i])) VError(\" inconsistent image dimensions\"); \n  } \n \n  if (testtype == 1) {   \n \n    for (i = 0; i < nimages1; i++) { \n      str1 = ((VString *) in_files1.vector)[i]; \n      str2 = ((VString *) in_files2.vector)[i]; \n      fprintf(stderr,\" %3d:  %s   %s\\n\",i,str1,str2); \n    } \n  } \n  else { \n    fprintf(stderr,\" Group 1:\\n\"); \n    for (i = 0; i < nimages1; i++) { \n      str1 = ((VString *) in_files1.vector)[i]; \n      fprintf(stderr,\" %3d:  %s\\n\",i,str1); \n    } \n    fprintf(stderr,\"\\n Group 2:\\n\"); \n    for (i = 0; i < nimages2; i++) { \n      str2 = ((VString *) in_files2.vector)[i]; \n      fprintf(st", "pred": " \nint main (int argc, char *argv[]) \n{ \n  static VArgVector in_files1; \n  static VArgVector in_files2; \n  static VString  out_filename=\"\"; \n  static VString  mask_filename=\"\"; \n  static VFloat   alpha = 0.05; \n  static VShort   testtype = 0; \n  static VShort   radius = 2; \n  static VFloat   rvar = 2.0; \n  static VFloat   svar = 2.0; \n  static VShort   numiter = 2; \n  static VShort   numperm = 5000; \n  static VLong    seed = 99402622; \n  static VBoolean centering = FALSE; \n  static VBoolean cleanup = TRUE; \n  static VShort   nproc = 0; \n  static VOptionDescRec options[] = { \n    {\"in1\", VStringRepn, 0, & in_files1, VRequiredOpt, NULL,\"Input files 1\" }, \n    {\"in2\", VStringRepn, 0, & in_files2, VRequiredOpt, NULL,\"Input files 2\" }, \n    {\"out\", VStringRepn, 1, & out_filename, VRequiredOpt, NULL,\"Output file\" }, \n    {\"alpha\",VFloatRepn,1,(VPointer) &alpha,VOptionalOpt,NULL,\"FDR significance level\"}, \n    {\"perm\",VShortRepn,1,(VPointer) &numperm,VOptionalOpt,NULL,\"Number of permutations\"}, \n    {\"mask\", VStringRepn, 1, (VPointer) &mask_filename, VRequiredOpt, NULL, \"Mask\"}, \n    {\"test\",VShortRepn,1,(VPointer) &testtype,VOptionalOpt,TSTDict,\"type of test\"}, \n    {\"seed\",VLongRepn,1,(VPointer) &seed,VOptionalOpt,NULL,\"Seed for random number generation\"}, \n    {\"radius\",VShortRepn,1,(VPointer) &radius,VOptionalOpt,NULL,\"Bilateral parameter (radius in voxels)\"}, \n    {\"rvar\",VFloatRepn,1,(VPointer) &rvar,VOptionalOpt,NULL,\"Bilateral parameter (radiometric)\"}, \n    {\"svar\",VFloatRepn,1,(VPointer) &svar,VOptionalOpt,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,"}
{"label": " \nvoid particleFilter(int * I, int IszX, int IszY, int Nfr, int * seed, int Nparticles){\r \n\t\r \n\tint max_size = IszX*IszY*Nfr;\r \n\tlong long start = get_time();\r \n\t \n \n\tdouble xe = roundDouble(IszY/2.0);\r \n\tdouble ye = roundDouble(IszX/2.0);\r \n\t\r \n\t \n \n\tint radius = 5;\r \n\tint diameter = radius*2 - 1;\r \n\tint * disk = (int *)malloc(diameter*diameter*sizeof(int));\r \n\tstrelDisk(disk, radius);\r \n\tint countOnes = 0;\r \n\tint x, y;\r \n\tfor(x = 0; x < diameter; x++){\r \n\t\tfor(y = 0; y < diameter; y++){\r \n\t\t\tif(disk[x*diameter + y] == 1)\r \n\t\t\t\tcountOnes++;\r \n\t\t}\r \n\t}\r \n\tdouble * objxy = (double *)malloc(countOnes*2*sizeof(double));\r \n\tgetneighbors(disk, countOnes, objxy, radius);\r \n\t\r \n\tlong long get_neighbors = get_time();\r \n\tprintf(\"TIME TO GET NEIGHBORS TOOK: %f\\n\", elapsed_time(start, get_neighbors));\r \n\t \n \n\tdouble * weights = (double *)malloc(sizeof(double)*Nparticles);\r \n#pragma omp parallel for shared(weights, Nparticles) private(x) \n\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{\r \n\t\tweights[x] = 1/((double)(Nparticles));\r \n\t} ; } \n\r \n\tlong long get_weights = get_time();\r \n\tprintf(\"TIME TO GET WEIGHTSTOOK: %f\\n\", elapsed_time(get_neighbors, get_weights));\r \n\t \n \n\tdouble * likelihood = (double *)malloc(sizeof(double)*Nparticles);\r \n\tdouble * arrayX = (double *)malloc(sizeof(double)*Nparticles);\r \n\tdouble * arrayY = (double *)malloc(sizeof(double)*Nparticles);\r \n\tdouble * xj = (double *)malloc(sizeof(double)*Nparticles);\r \n\tdouble * yj = (double *)malloc(sizeof(double)*Nparticles);\r \n\tdouble * CDF = (double *)malloc(sizeof(double)*Nparticles);\r \n\tdouble * u = (double *)malloc(sizeof(double)*Nparticles);\r \n\tint * ind = (int*)malloc(sizeof(int)*countOnes*Nparticles);\r \n#pragma omp parallel for shared(arrayX, arrayY, xe, ye) private(x) \n\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{\r \n\t\tarrayX[x] = xe;\r \n\t\tarrayY[x] = ye;\r \n\t} ; } \n\r \n\tint k;\r \n\t\r \n\tprintf(\"TIME TO SET ARRAYS TOOK: %f\\n\", elapsed_time(get_weights, get_time()));\r \n\tint indX, indY;\r \n\tfor(k = 1; k < Nfr; k++){\r \n\t\tlong long set_arrays = get_time();\r \n\t\t \n \n\t\t \n \n\t\t \n \n#pragma omp parallel for shared(arrayX, arrayY, Nparticles, seed) private(x) \n\t\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{\r \n\t\t\tarrayX[x] += 1 + 5*randn(seed, x);\r \n\t\t\tarrayY[x] += -2 + 2*randn(seed, x);\r \n\t\t} ; } \n\r \n\t\tlong long error = get_time();\r \n\t\tprintf(\"TIME TO SET ERROR TOOK: %f\\n\", elapsed_time(set_arrays, error));\r \n\t\t \n \n#pragma omp parallel for shared(likelihood, I, arrayX, arrayY, objxy, ind) private(x, y, indX, indY) \n\t\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{\r \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\tfor(y = 0; y < countOnes; y++){\r \n\t\t\t\tindX = roundDouble(arrayX[x]) + objxy[y*2 + 1];\r \n\t\t\t\tindY = roundDouble(arrayY[x]) + objxy[y*2];\r \n\t\t\t\tind[x*countOnes + y] = fabs(indX*IszY*Nfr + indY*Nfr + k);\r \n\t\t\t\tif(ind[x*countOnes + y] >= max_size)\r \n\t\t\t\t\tind[x*countOnes + y] = 0;\r \n\t\t\t}\r \n\t\t\tlikelihood[x] = 0;\r \n\t\t\tfor(y = 0; y < countOnes; y++)\r \n\t\t\t\tlikelihood[x] += (pow((I[ind[x*countOnes + y]] - 100),2) - pow((I[ind[x*countOnes + y]]-228),2))/50.0;\r \n\t\t\tlikelihood[x] = likelihood[x]/((double) countOnes);\r \n\t\t} ; } \n\r \n\t\tlong long likelihood_time = get_time();\r \n\t\tprintf(\"TIME TO GET LIKELIHOODS TOOK: %f\\n\", elapsed_time(error, likelihood_time));\r \n\t\t \n \n\t\t \n \n#pragma omp parallel for shared(Nparticles, weights, likelihood) private(x) \n\t\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{\r \n\t\t\tweights[x] = weights[x] * exp(likelihood[x]);\r \n\t\t} ; } \n\r \n\t\tlong long exponential = get_time();\r \n\t\tprintf(\"TIME TO GET EXP TOOK: %f\\n\", elapsed_time(likelihood_time, exponential));\r \n\t\tdouble sumWeights = 0;\r \n#pragma omp parallel for private(x) reduction(+:sumWeights) \n\t\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{\r \n\t\t\tsumWeights += weights[x];\r \n\t\t} ; } \n\r \n\t\tlong long sum_time = get_time();\r \n\t\tprintf(\"TIME TO SUM WEIGHTS TOOK: %f\\n\", elapsed_time(exponential, sum_time));\r \n#pragma omp parallel for shared(sumWeights, weights) private(x) \n\t\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{\r \n\t\t\tweights[x] = weights[x]/sumWeights;\r \n\t\t} ; } \n\r \n\t\tlong long normalize = get_time();\r \n\t\tprintf(\"TIME TO NORMALIZE WEIGHTS TOOK: %f\\n\", elapsed_time(sum_time, normalize));\r \n\t\txe = 0;\r \n\t\tye = 0;\r \n\t\t \n \n#pragma omp parallel for", "pred": " \nvoid particleFilter(int * I, int IszX, int IszY, int Nfr, int * seed, int Nparticles){\r \n\t\r \n\tint max_size = IszX*IszY*Nfr;\r \n\tlong long start = get_time();\r \n\t \n \n\tdouble xe = roundDouble(IszY/2.0);\r \n\tdouble ye = roundDouble(IszX/2.0);\r \n\t\r \n\t \n \n\tint radius = 5;\r \n\tint diameter = radius*2 - 1;\r \n\tint * disk = (int *)malloc(diameter*diameter*sizeof(int));\r \n\tstrelDisk(disk, radius);\r \n\tint countOnes = 0;\r \n\tint x, y;\r \n\tfor(x = 0; x < diameter; x++){\r \n\t\tfor(y = 0; y < diameter; y++){\r \n\t\t\tif(disk[x*diameter + y] == 1)\r \n\t\t\t\tcountOnes++;\r \n\t\t}\r \n\t}\r \n\tdouble * objxy = (double *)malloc(countOnes*2*sizeof(double));\r \n\tgetneighbors(disk, countOnes, objxy, radius);\r \n\t\r \n\tlong long get_neighbors = get_time();\r \n\tprintf(\"TIME TO GET NEIGHBORS TOOK: %f\\n\", elapsed_time(start, get_neighbors));\r \n\t \n \n\tdouble * weights = (double *)malloc(sizeof(double)*Nparticles);\r \n#pragma omp parallel for shared(weights, Nparticles) private(x) \n\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{\r \n\t\tweights[x] = 1/((double)(Nparticles));\r \n\t} ; } \n\r \n\tlong long get_weights = get_time();\r \n\tprintf(\"TIME TO GET WEIGHTSTOOK: %f\\n\", elapsed_time(get_neighbors, get_weights));\r \n\t \n \n\tdouble * likelihood = (double *)malloc(sizeof(double)*Nparticles);\r \n\tdouble * arrayX = (double *)malloc(sizeof(double)*Nparticles);\r \n\tdouble * arrayY = (double *)malloc(sizeof(double)*Nparticles);\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nvoid CVHFnr_direct_ex_drv(int (*intor)(), void (*fdot)(), JKOperator **jkop, \n                          double **dms, double **vjk, int n_dm, int ncomp, \n                          int *shls_slice, int *ao_loc, \n                          CINTOpt *cintopt, CVHFOpt *vhfopt, \n                          int *atm, int natm, int *bas, int nbas, double *env) \n{ \n        IntorEnvs envs = {natm, nbas, atm, bas, env, shls_slice, ao_loc, NULL, \n                cintopt, ncomp}; \n        int idm; \n        double *tile_dms[n_dm]; \n        for (idm = 0; idm < n_dm; idm++) { \n                CVHFzero_out_vjk(vjk[idm], jkop[idm], shls_slice, ao_loc, ncomp); \n                tile_dms[idm] = CVHFallocate_and_reorder_dm(jkop[idm], dms[idm], \n                                                            shls_slice, ao_loc); \n        } \n \n        size_t di = GTOmax_shell_dim(ao_loc, shls_slice, 4); \n        size_t cache_size = GTOmax_cache_size(intor, shls_slice, 4, \n                                              atm, natm, bas, nbas, env); \n        int ish0 = shls_slice[0]; \n        int ish1 = shls_slice[1]; \n        int jsh0 = shls_slice[2]; \n        int jsh1 = shls_slice[3]; \n        int ksh0 = shls_slice[4]; \n        int ksh1 = shls_slice[5]; \n        int lsh0 = shls_slice[6]; \n        int lsh1 = shls_slice[7]; \n        int nish = ish1 - ish0; \n        int njsh = jsh1 - jsh0; \n        int nksh = ksh1 - ksh0; \n        int nlsh = lsh1 - lsh0; \n        int *shls_excludes = shls_slice + 8; \n        int *block_iloc = malloc(sizeof(int) * (nish + njsh + nksh + nlsh + 4)); \n        int *block_jloc = block_iloc + nish + 1; \n        int *block_kloc = block_jloc + njsh + 1; \n        int *block_lloc = block_kloc + nksh + 1; \n        size_t nblock_i = _shls_block_partition_lim(block_iloc, shls_slice+0, shls_excludes+0, ao_loc); \n        size_t nblock_j = _shls_block_partition_lim(block_jloc, shls_slice+2, shls_excludes+2, ao_loc); \n        size_t nblock_k = _shls_block_partition_lim(block_kloc, shls_slice+4, shls_excludes+4, ao_loc); \n        size_t nblock_l = _shls_block_partition_lim(block_lloc, shls_slice+6, shls_excludes+6, ao_loc); \n        size_t nblock_kl = nblock_k * nblock_l; \n        size_t nblock_jkl = nblock_j * nblock_kl; \n \n#pragma omp parallel \n{ \n        size_t i, j, k, l, r, blk_id; \n        JKArray *v_priv[n_dm]; \n        for (i = 0; i < n_dm; i++) { \n                v_priv[i] = CVHFallocate_JKArray(jkop[i], shls_slice, ao_loc, ncomp); \n        } \n        double *buf = malloc(sizeof(double) * (di*di*di*di*ncomp + di*di*2 + cache_size)); \n        double *cache = buf + di*di*di*di*ncomp; \n#pragma omp for nowait schedule(dynamic, 1) \n        for (blk_id = 0; blk_id < nblock_jkl; blk_id++) { \n                r = blk_id; \n                j = r / nblock_kl ; r = r % nblock_kl; \n                k = r / nblock_l  ; r = r % nblock_l; \n                l = r; \n                for (i = 0; i < nblock_i; i++) { \n                         \n \n                         \n \n                        if (shls_excludes[0] <= block_iloc[i] && block_iloc[i] < shls_excludes[1] && \n                            shls_excludes[2] <= block_jloc[j] && block_jloc[j] < shls_excludes[3] && \n                            shls_excludes[4] <= block_kloc[k] && block_kloc[k] < shls_excludes[5] && \n                            shls_excludes[6] <= block_lloc[l] && block_lloc[l] < shls_excludes", "pred": " \nvoid CVHFnr_direct_ex_drv(int (*intor)(), void (*fdot)(), JKOperator **jkop, \n                          double **dms, double **vjk, int n_dm, int ncomp, \n                          int *shls_slice, int *ao_loc, \n                          CINTOpt *cintopt, CVHFOpt *vhfopt, \n                          int *atm, int natm, int *bas, int nbas, double *env) \n{ \n        IntorEnvs envs = {natm, nbas, atm, bas, env, shls_slice, ao_loc, NULL, \n                cintopt, ncomp}; \n        int idm; \n        double *tile_dms[n_dm]; \n        for (idm = 0; idm < n_dm; idm++) { \n                CVHFzero_out_vjk(vjk[idm], jkop[idm], shls_slice, ao_loc, ncomp); \n                tile_dms[idm] = CVHFallocate_and_reorder_dm(jkop[idm], dms[idm], \n                                                            shls_slice, ao_loc); \n        } \n \n        size_t di = GTOmax_shell_dim(ao_loc, shls_slice, 4); \n        size_t cache_size = GTOmax_cache_size(intor, shls_slice, 4, shls_dim);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 8; \n  tile_size[3] = 512; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=floord(Nt-1,3);t1++) { \n    lbp=max(ceild(t1,2),ceild(6*t1-Nt+2,6)); \n    ubp=min(floord(4*Nt+Nz-9,24),floord(12*t1+Nz+6,24)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(max(0,ceild(3*t1,2)),ceild(24*t2-Nz+5,8)),3*t1-3*t2+1);t3<=min(min(min(floord(4*Nt+Ny-9,8),floord(12*t1+Ny+15,8)),floord(24*t2+Ny+11,8)),floord(24*t1-24*t2+Nz+Ny+13,8));t3++) { \n        for (t4=max(max(max(max(0,ceild(3*t1-3*t2-62,64)),ceild(3*t1-126,128)),ceild(24*t2-Nz-499,512)),ceild(8*t3-Ny-499,512));t4<=min(min(min(min(floord(4*Nt+Nx-9,512),floord(12*t1+Nx+15,512)),floord(24*t2+Nx+11,512)),floord(8*t3+Nx-5,512)),floord(24*t1-24*t2+Nz+Nx+13,512));t4++) { \n          for (t5=max(max(max(max(max(0,ceild(24*t2-Nz+5,4)),ceild(8*t3-Ny+5,4)),ceild(512*t4-Nx+5,4)),3*t1),6*t1-6*t2+1);t5<=min(min(min(min(min(floord(24*t1-24*t2+Nz+18,4),2*t3),Nt-1),3*t1+5),6*t2+4),128*t4+126);t5++) { \n            for (t6=max(max(24*t2,4*t5+4),-24*t1+24*t2+8*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(8*t3,4*t5+4);t7<=min(8*t3+7,4*t5+Ny-5);t7++) { \n                lbv=max(512*", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 8; \n  tile_size[3] = 24;   tile_size[4] = 24;   tile_size[5] = 24;   tile_size[6] = 24;   tile_size[7] = 24;   tile_size[8] = 24;   tile_size[9] = 24;   tile_size[10] = 24;   tile_size[11] = 24;   tile_size[12] = 24;   tile_size[13] = 24;   tile_size[14] = 24;   tile_size[15] = 24;   tile_size[16] = 24;   tile_size[17] = 24;   tile_size[18] = 24;   tile_size[19] = 24;   tile_size[20] = 24;   tile_size[21] = 24;   tile_size[22] = 24;   tile_size[23] = 24;   tile_size[24] = 24;   tile_size[25] = 24;   tile_size[26] = 24;   tile_size[27] = 24;   tile_size[28] = 24;   tile_size[29] = 24;   tile_size[30] = 24;   tile_size[31] = 24;   tile_size[32] = 24;   tile_size[33] = 24;   tile_size[34] = 24;   tile_size[35] = 24;   tile_size[36] = 24;   tile_size[37] = 24;   tile_size[38] = 24;   tile_size[39] = 24;   tile_size[40] = 24;   tile_size[41] = 24;   tile_size[42] = 24;   tile_size[43] = 24;   tile_size[44] = 24;   tile_size[45] = 24;   tile_size[46] = 24;   tile_size[47] = 24;   tile_size[48] = 24;   tile_size[49] = 24;   tile_size[50] = 24;   tile_size[51] = 24;   tile_size[52] = 24;   tile_size[53] = 24;   tile_size[54] = 24;   tile_size[55] = 24;   tile_size[56] = 24;   tile_size[57] = 24;   tile_size[58] = 24;   tile_size[59] = 24;   tile_size[60] = 24;   tile_size[61] = 24;   tile_size[62] = 24;   tile_size[63] = 24;   tile_size[64] = 24;   tile_size[65] = 24;   tile_size[66] = 24;   tile_size[67] = 24;   tile_size[68] = 24;   tile_size[69] = 24;   tile_size[70] = 24;   tile_size[72] = 24;   tile_size[73] = 24;   tile_size[73] = 24;   tile_size[74] = 24;   tile_size[75] = 24;   tile_size[76] = 24;   tile_size[77] = 24;   tile_size[78] = 24;   tile_size[81] = 24;   tile_size[81] = 24;   tile_size[82] = 24;   tile_size[83] = 24;   tile_size[84] = 24;   tile_size[85] = 24;   tile_size[86] = 24;   tile_size[86] = 24;   tile_size[87] = 24;   tile_size[88] = 24;   tile_size[89] = 24;   tile_size[90] = 24;   tile_size[91] = 24;   tile_size[92] = 24;   tile_size[93] = 24;   tile_size[93] = 24;   tile_size[94] = 24;   tile_size[95] = 24;   tile_size[96] = 24;   tile_size[97] = 24;   tile_size[98] = 24;   tile_size[99] = 24;   tile_size[100] = 24;   tile_size[101] = 24;   tile_size[102] = 24;   tile_size[103] = 24;   tile_size[104] = 24;   tile_size[105] = 24;   tile_size[106] = 24;   tile_size[107] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size[109] = 24;   tile_size"}
{"label": "d dtfield(field *f, real *w, real *dtw) { \n  if(f->pre_dtfield!= NULL)  \n \n      f->pre_dtfield(f, w); \n \n  dtfield_pthread(f, w, dtw); \n \n#pragma omp parallel \n  for(int iw = 0; iw < f->wsize; iw++) \n    dtw[iw] = 0; \n \n  bool facealgo = true; \n  if(facealgo) \n    for(int ifa = 0; ifa < f->macromesh.nbfaces; ifa++){ \n      DGMacroCellInterface((void*) (f->mface + ifa), f, w, dtw); \n    } \n \n#pragma omp parallel for schedule(dynamic, 1) \n  for(int ie = 0; ie < f->macromesh.nbelems; ++ie) { \n    MacroCell *mcelli = f->mcell + ie; \n    if(!facealgo) DGMacroCellInterfaceSlow(mcelli, f, w, dtw); \n    DGSubCellInterface(mcelli, f, w, dtw); \n    DGVolume(mcelli, f, w, dtw); \n    DGMass(mcelli, f, dtw); \n    DGSource(mcelli, f, w, dtw); \n  } \n} \n \n \n ", "pred": "d dtfield(field *f, real *w, real *dtw) { \n  if(f->pre_dtfield!= NULL)  \n \n      f->pre_dtfield(f, w); \n \n  dtfield_pthread(f, w, dtw); \n \n#pragma omp parallel \n  for(int iw = 0; iw < f->wsize; iw++) \n    dtw[iw] = 0; \n \n  bool facealgo = true; \n  if(facealgo) \n    for(int ifa = 0; ifa < f->macromesh.nbfaces; ifa++){ \n      DGMacroCellInterface((void*) (f->mface + ifa), f, w, dtw); \n    } \n \n#pragma omp parallel for schedule(dynamic, 1) \n  for(int ie = 0; ie < f->macromesh.nbelems; ++ie) { \n    MacroCell *mcelli = f->mcell + ie; \n    if(!facealgo) DGMacroCellInterfaceSlow(mcelli, f, w, dtw); \n    DGSubCellInterface(mcelli, f, w, dtw); \n    DGVolume(mcelli, f, w, dtw); \n    DGMass(mcelli, f, dtw); \n    DGSource(mcelli, f, w, dtw); \n  } \n} \n \n \n "}
{"label": " \nint main() \n{ \n  init_arrays(); \n \n  double annot_t_start=0, annot_t_end=0, annot_t_total=0; \n  int annot_i; \n \n  for (annot_i=0; annot_i<REPS; annot_i++) \n  { \n    annot_t_start = rtclock(); \n     \n    \n \nregister int i,j,k; \nregister int c1t, c2t, c3t, c4t, c5t, c6t, c7t, c8t, c9t, c10t, c11t, c12t; \nregister int newlb_c1, newlb_c2, newlb_c3, newlb_c4, newlb_c5, newlb_c6, \n  newlb_c7, newlb_c8, newlb_c9, newlb_c10, newlb_c11, newlb_c12; \nregister int newub_c1, newub_c2, newub_c3, newub_c4, newub_c5, newub_c6, \n  newub_c7, newub_c8, newub_c9, newub_c10, newub_c11, newub_c12; \n \n \n \n \n \n \n\tint c1, c2, c3, c4, c5, c6, c7, c8, c9; \n \n\tregister int lb, ub, lb1, ub1, lb2, ub2; \n \n \nfor (c1=-1;c1<=floord(3*N-5,128);c1++) { \n\tlb1=max(max(ceild(64*c1-N+2,64),ceild(32*c1-63,96)),0); \n\tub1=min(floord(64*c1+63,64),floord(N-1,128)); \n#pragma omp parallel for shared(c1,lb1,ub1) private(c2,c3,c4,c5,c6,c7,c8,c9) \n\tfor (c2=lb1; c2<=ub1; c2++) { \n    for (c3=max(ceild(32*c1-32*c2-1953,2016),ceild(32*c1-32*c2-31,32));c3<=floord(N-1,64);c3++) { \n      for (c4=max(max(0,2*c1-2*c2-64*c3-62),2*c1-2*c2);c4<=min(min(min(min(2*c1-2*c2+1,floord(992*c3+961,16)),floord(N-2,32)),floord(64*c2+63,16)),floord(32*c3+31,16));c4++) { \n        for (c5=max(max(ceild(16*c4-7,8),0),8*c2);c5<=min(8*c2+7,floord(N-1,16));c5++) { \n          for (c6=max(max(max(max(ceild(16*c4-465,496),ceild(2*c1-2*c2-2*c3-c4-31,31)),ceild(-2*c1+2*c2+2*c3+c4-31,33)),2*c3),ceild(16*c4-15,16));c6<=min(2*c3+1,floord(N-1,32));c6++) { \n            if ((c1 == c2+c3) && (c4 == c6)) { \n              for (c7=max(0,32*c6);c7<=min(min(32*c6+30,N-2),16*c5+14);c7++) { \n                for (c8=max(16*c5,c7+1);c8<=min(16*c5+15,N-1);c8++) { \n                  A[c7][c8]=A[c7][c8]/A[c7][c7] ; \n                  for (c9=c7+1;c9<=min(32*c6+31,N-1);c9++) { \n                    A[c9][c8]=A[c9][c8]-A[c9][c7]*A[c7][c8] ; \n                  } \n                } \n              } \n            } \n             \n \n{ \n  for (c7t=max(32*c4,0); c7t<=min(min(32*c6-1,16*c5+14),32*c4+31)-31; c7t=c7t+32) { \n    newlb_c8=-2147483648; \n    newub_c8=min(16*c5+15,N-1); \n    register int cbv_1; \n    cbv_1=c7t+31; \n#pragma ivdep \n#pragma vector always \n    for (c7=c7t; c7<=cbv_1; c7=c7+1) { \n      newlb_c8=max(newlb_c8,max(c7+1,16*c5)); \n    } \n    for (c7=c7t; c7<=c7t+31; c7=c7+1) { \n      for (c8=max(c7+1,16*c5); c8<=newlb_c8-1; c8=c8+1) { \n        register int cbv_2, cbv_3; \n        cbv_2=32*c6; \n        cbv_3=min(N-1,32*c6+31); \n#pragma ivdep \n#pragma vector always \n        for (c9=cbv_2; c9<=cbv_3; c9++ ) { \n          double scv_1; \n          scv_1=A[c9][c8]; \n          scv_1=scv_1-A[c9][c7]*A[c7][c8]; \n          A[c9][c8]=scv_1; \n        } \n      } \n    } \n    for (c8t=newlb_c8; c8t<=newub_c8-7; c8t=c8t+8) { \n      register int cbv_4, cbv_5; \n      cbv_4=32*c6; \n      cbv_5=min(N-1,32*c6+31); \n#pragma ivdep \n#pragma vector always \n      for (c9=cbv_4; c9<=cbv_5; c9++ ) { \n        double scv_2, scv_3, scv_4, scv_", "pred": " \nint main() \n{ \n  init_arrays(); \n \n  double annot_t_start=0, annot_t_end=0, annot_t_total=0; \n  int annot_i; \n \n  for (annot_i=0; annot_i<REPS; annot_i++) \n  { \n    annot_t_start = rtclock(); \n     \n    \n \nregister int i,j,k; \nregister int c1t, c2t, c3t, c4t, c5t, c6t, c7t, c8t, c9t, c10t, c11t, c12t; \nregister int newlb_c1, newlb_c2, newlb_c3, newlb_c4, newlb_c5, newlb_c6, \n  newlb_c7, newlb_c8, newlb_c9, newlb_c10, newlb_c11, newlb_c12; \nregister int newub_c1, newub_c2, newub_c3, newub_c4, newub_c5, newub_c6, \n  newub_c7, newub_c8, newub_c9, newub_c10, newub_c11, newub_c12; \n \n \n \n \n \n \n\tint c1, c2, c3, c4, c5, c6, c7, c8, c9; \n \n\tregister int lb, ub, lb1, ub1, lb2, ub2; \n \n \nfor (c1=-1;c1<=floord(3*N-5,128);c1++) { \n\tlb1=max(max(ceild(64*c1-N+2,64),ceild(32*c1-63,96)),0); \n\tub1=min(floord(64*c1+63,64),floord(N-1,128)); \n#pragma omp parallel for shared(c1,lb1,ub1) private(c2,c3,c4,c5,c6,c7,c8,c9) \n\tfor (c2=lb1; c2<=ub1; c2++) { \n    for (c3=max(ceild(32*c1-32*c2-1953,2016),ceild(32*c3-32,c4,c5,c7,c8,c9)));\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "}
{"label": " \nvoid partials_undefined_and_undefined_codon_openmp( const SingleTreeLikelihood *tlk, const double *partials1, const double *matrices1, const double *partials2, const double *matrices2, double *partials3 ){ \n     \n\t \n\tconst int nstate = tlk->m->nstate; \n\tconst int extra = nstate - 60; \n\tint nThreads = tlk->nthreads; \n     \n#pragma omp parallel for schedule(dynamic,1) num_threads(nThreads) \n    for ( int lk = 0; lk < tlk->pattern_count*tlk->cat_count; lk++ ) { \n        int l = lk / tlk->pattern_count; \n        int k = lk % tlk->pattern_count; \n         \n        int w = l * tlk->matrix_size; \n        int v = (l*tlk->pattern_count + k) * nstate; \n         \n        const double *m1 = matrices1 + w; \n        const double *m2 = matrices2 + w; \n         \n        double *pPartials = partials3 + v; \n         \n        double sum1, sum2; \n        const double *p1 = NULL; \n        const double *p2 = NULL; \n         \n        for ( int j = 0; j < nstate; j++ ) { \n             \n            p1 = partials1 + v; \n            p2 = partials2 + v; \n             \n            sum1   = *m1 * *p1; m1++; p1++; \n            sum2   = *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n             \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n             \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *", "pred": " \nvoid partials_undefined_and_undefined_codon_openmp( const SingleTreeLikelihood *tlk, const double *partials1, const double *matrices1, const double *partials2, const double *matrices2, double *partials3 ){ \n     \n\t \n\tconst int nstate = tlk->m->nstate; \n\tconst int extra = nstate - 60; \n\tint nThreads = tlk->nthreads; \n     \n#pragma omp parallel for schedule(dynamic,1) num_threads(nThreads) \n    for ( int lk = 0; lk < tlk->pattern_count*tlk->cat_count; lk++ ) { \n        int l = lk / tlk->pattern_count; \n        int k = lk % tlk->pattern_count; \n         \n        int w = l * tlk->matrix_size; \n        int v = (l*tlk->pattern_count + k) * nstate; \n         \n        const double *m1 = matrices1 + w; \n        const double *m2 = matrices2 + w; \n         \n        double *pPartials = partials3 + v; \n         \n        double sum1, sum2; \n        const double *p1 = NULL; \n        const double *p2 = NULL; \n         \n        for ( int j = 0; j < nstate; j++ ) { \n             \n            p1 = partials1 + v; \n            p2 = partials2 + v; \n             \n            sum1   = *m1 * *p1; m1++; p1++; \n            sum2   = *m2 * *p2; m2++; p2++;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " \nvoid recombine2d_es1_omp(struct recombine2d_worker *worker, \n                         int subgrid_off1, \n                         complex double *BF, \n                         double complex *NMBF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n    int x; \n \n     \n \n    assert(subgrid_off1 % cfg->subgrid_spacing == 0); \n    int subgrid_offset = subgrid_off1 / cfg->subgrid_spacing * cfg->yP_spacing;; \n    double start = get_time_ns(); \n#pragma omp for schedule(dynamic, worker->BF_batch) \n    for (x = 0; x < cfg->yB_size; x++) { \n        extract_subgrid(cfg->yP_size, cfg->xM_yP_size, cfg->xMxN_yP_size, cfg->xM_yN_size, \n                        subgrid_offset, cfg->m, cfg->Fn, \n                        BF+x*cfg->BF_stride0, cfg->BF_stride1, \n                        worker->MBF, worker->MBF_plan, \n                        NMBF+x*cfg->NMBF_stride0, cfg->NMBF_stride1); \n    } \n    worker->es1_time += get_time_ns() - start; \n \n} ", "pred": " \nvoid recombine2d_es1_omp(struct recombine2d_worker *worker, \n                         int subgrid_off1, \n                         complex double *BF, \n                         double complex *NMBF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n    int x; \n \n     \n \n    assert(subgrid_off1 % cfg->subgrid_spacing == 0); \n    int subgrid_offset = subgrid_off1 / cfg->subgrid_spacing * cfg->yP_spacing;; \n    double start = get_time_ns(); \n#pragma omp for schedule(dynamic, worker->BF_batch) \n    for (x = 0; x < cfg->yB_size; x++) { \n        extract_subgrid(cfg->yP_size, cfg->xM_yP_size, cfg->xMxN_yP_size, cfg->xM_yN_size, \n                        subgrid_offset, cfg->m, cfg->Fn, \n                        BF+x*cfg->BF_stride0, cfg->BF_stride1, \n                        worker->MBF, worker->MBF_plan, \n                        NMBF+x*cfg->NMBF_stride0, cfg->NMBF_stride1); \n    } \n    worker->es1_time += get_time_ns() - start; \n \n} "}
{"label": " \nvoid Pyuv422torgbstack(unsigned char *input_ptr, int *outR, int *outG, int *outB, unsigned int width, \n                       unsigned int height, const int upsideDown) { \n    unsigned int i; \n    const int size = width * height; \n#pragma omp parallel for private(i) \n    for (i = 0; i < size / 2; i++) { \n        unsigned char *b = input_ptr + i * 4; \n        unsigned char Y = b[0]; \n        unsigned char U = b[1]; \n        unsigned char Y1 = b[2]; \n        unsigned char V = b[3]; \n \n        if (upsideDown) { \n            int *R = outR + (size - 1) - i * 2; \n            int *G = outG + (size - 1) - i * 2; \n            int *B = outB + (size - 1) - i * 2; \n \n            *R-- += R_FROMYV(Y, V); \n            *G-- += G_FROMYUV(Y, U, V);  \n \n            *B-- += B_FROMYU(Y, U);  \n \n \n            *R += R_FROMYV(Y1, V); \n            *G += G_FROMYUV(Y1, U, V);  \n \n            *B += B_FROMYU(Y1, U);  \n \n        } else { \n            int *R = outR + i * 2; \n            int *G = outG + i * 2; \n            int *B = outB + i * 2; \n \n            *R++ += R_FROMYV(Y, V); \n            *G++ += G_FROMYUV(Y, U, V);  \n \n            *B++ += B_FROMYU(Y, U);  \n \n \n            *R += R_FROMYV(Y1, V); \n            *G += G_FROMYUV(Y1, U, V);  \n \n            *B += B_FROMYU(Y1, U);  \n \n        } \n    } \n} ", "pred": " \nvoid Pyuv422torgbstack(unsigned char *input_ptr, int *outR, int *outG, int *outB, unsigned int width, \n                       unsigned int height, const int upsideDown) { \n    unsigned int i; \n    const int size = width * height; \n#pragma omp parallel for private(i) \n    for (i = 0; i < size / 2; i++) { \n        unsigned char *b = input_ptr + i * 4; \n        unsigned char Y = b[0]; \n        unsigned char U = b[1]; \n        unsigned char Y1 = b[2]; \n        unsigned char V = b[3]; \n \n        if (upsideDown) { \n            int *R = outR + (size - 1) - i * 2; \n            int *G = outG + (size - 1) - i * 2; \n            int *B = outB + (size - 1) - i * 2; \n \n            *R-- += R_FROMYV(Y, V); \n            *G-- += G_FROMYUV(Y, U, V);  \n \n            *B-- += B_FROMYU(Y, U);  \n \n \n            *R += R_FROMYV(Y1, V); \n            *G += G_FROMYUV(Y1, U, V);  \n \n            *B += B_FROMYU(Y1, U);  \n \n        } else { \n            int *R = outR + i * 2; \n            int *G = outG + i * 2; \n            int *B = outB + i * 2; \n{\"\\n                                                                                                                                                                                                           "}
{"label": " \nvoid partials_states_and_states_codon_openmp( const SingleTreeLikelihood *tlk, int idx1, const double *matrices1, int idx2, const double *matrices2, double *partials ){ \n\t \n\t \n\tconst int nstate = tlk->m->nstate; \n\tconst int extra = nstate - 60; \n\tint nThreads = tlk->nthreads; \n     \n    #pragma omp parallel for schedule(dynamic,1) num_threads(nThreads) \n    for ( int lk = 0; lk < tlk->pattern_count*tlk->cat_count; lk++ ) { \n        int l = lk / tlk->pattern_count; \n        int k = lk % tlk->pattern_count; \n         \n        int state1 = tlk->sp->patterns[idx1][k]; \n        int state2 = tlk->sp->patterns[idx2][k]; \n         \n        int w = l * tlk->matrix_size; \n         \n        double *pPartials = partials + (l*tlk->pattern_count + k)*nstate; \n         \n        if (state1 < nstate && state2 < nstate) { \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n             \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n             \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n             \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *", "pred": " \nvoid partials_states_and_states_codon_openmp( const SingleTreeLikelihood *tlk, int idx1, const double *matrices1, int idx2, const double *matrices2, double *partials ){ \n\t \n\t \n\tconst int nstate = tlk->m->nstate; \n\tconst int extra = nstate - 60; \n\tint nThreads = tlk->nthreads; \n     \n    #pragma omp parallel for schedule(dynamic,1) num_threads(nThreads) \n    for ( int lk = 0; lk < tlk->pattern_count*tlk->cat_count; lk++ ) { \n        int l = lk / tlk->pattern_count; \n        int k = lk % tlk->pattern_count; \n         \n        int state1 = tlk->sp->patterns[idx1][k]; \n        int state2 = tlk->sp->patterns[idx2][k]; \n         \n        int w = l * tlk->matrix_size; \n         \n        double *pPartials = partials + (l*tlk->pattern_count + k)*nstate; \n         \n        if (state1 < nstate && state2 < nstate) { \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate;            *pPartials++ = matrices1[w + state2] * matrices2[w + state1]; w += nstate;            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate;            *pPartials++ = matrices1[w + state3] * matrices2[w + state3]; w += nstate;            *pPartials++ = matrices1[w + state4] * matrices2[w + state5]; w += nstate;            *pPartials++ = matrices1[w + state5] * matrices2[w + state6]; w += nstate;            *pPartials++ = matrices1[w + state7] * matrices2[w + state8]; w += nstate;            *pPartials++ = matrices1[w + state9] * matrices2[w + state10]; w += nstate;            *pPartials++ = matrices1[w + state11] * matrices2[w + state12]; w += nstate;            *pPartials++ = matrices1[w + state13] * matrices2[w + state14]; w += nstate;            *pPartials++ = matrices1[w + state14] * matrices2[w + state15]; w += nstate;            *pPartials++ = matrices1[w + state16] * matrices2[w + state17]; w += nstate;            *pPartials++ = matrices1[w + state18] * matrices2[w + state19]; w += nstate;            *pPartials++ = matrices1[w + state20] * matrices2[w + state21]; w += nstate;            *pPartials++ = matrices1[w + state22] * matrices2[w + state23]; w += nstate;            *pPartials++ = matrices1[w + state23] * matrices2[w + state24]; w += nstate;            *pPartials++ = matrices1[w + state25] * matrices2[w + state26]; w += nstate;            *pPartials++ = matrices1[w + state27] * matrices2[w + state28]; w += nstate;            *pPartials++ = matrices1[w + state28] * matrices2[w + state29]; w += nstate;            *pPartials++ = matrices1[w + state30] * matrices2[w + state31]; w += nstate;            *pPartials++ = matrices1[w + state31] * matrices2[w + state32]; w += nstate;            *pPartials++ = matrices1[w + state33] * matrices2[w + state33]; w += nstate;            *pPartials++ = matrices1[w + state34] * matrices2[w + state36]; w += nstate;            *pPartials++ = matrices1[w + state36] * matrices2[w + state37]; w += nstate;            *pPartials++ = matrices1[w + state36] * matrices2[w + state36]; w += nstate;            *pPartials++ = matrices1[w + state37] * matrices2[w + state38]; w += nstate;            *pPartials++ = matrices1[w + state38] * matrices2[w + state39]; w += nstate;           *pPartials++ = matrices1[w + state39] * matrices2[w + state40]; w += nstate;           *pPartials++ = matrices1[w + state40] * matrices2[w + state41]; w += nstate;           *pPartials++ = matrices1[w + state42] * matrices2[w + state43]; w += nstate;           *pPartials++ = matrices1[w + state43] * matrices2[w + state44]; w += nstate;           *pPartials++ = matrices1[w + state44] * matrices2[w + state45]; w += nstate;           *pPartials++ = matrices1[w + state44] * matrices2[w + state46]; w += nstate;           *pPartials++ = matrices1[w + state44] * matrices2[w + state47]; w += nstate;           *pPartials++ = matrices1[w + state44] * matrices2[w + state47]; w += nstate;           *pPartials++ = matrices1[w + state44] * matrices2[w + state43]; w += nstate;      "}
{"label": " \nvoid process (struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, void *ivoid, void *ovoid, const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out) \n{ \n  dt_iop_lowpass_data_t *data = (dt_iop_lowpass_data_t *)piece->data; \n  float *in  = (float *)ivoid; \n  float *out = (float *)ovoid; \n  const int ch = piece->colors; \n  float a0, a1, a2, a3, b1, b2, coefp, coefn; \n \n  const float Labmax[] = { 100.0f, 128.0f, 128.0f, 1.0f }; \n  const float Labmin[] = { 0.0f, -128.0f, -128.0f, 0.0f }; \n \n  const float radius = fmax(0.1f, data->radius); \n  const float sigma = radius * roi_in->scale / piece ->iscale; \n \n   \n \n  compute_gauss_params(sigma, data->order, &a0, &a1, &a2, &a3, &b1, &b2, &coefp, &coefn); \n \n  float *temp = dt_alloc_align(64, roi_out->width*roi_out->height*ch*sizeof(float)); \n  if(temp==NULL) return; \n \n   \n \n  #pragma omp parallel for default(none) shared(in,out,temp,roi_out,data,a0,a1,a2,a3,b1,b2,coefp,coefn) schedule(static) \n  for(int i=0; i<roi_out->width; i++) \n  { \n    float xp[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yb[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yp[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float xc[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yc[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float xn[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float xa[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yn[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float ya[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n \n     \n \n    for(int k=0; k<4; k++) \n    { \n      xp[k] = CLAMPF(in[i*ch+k], Labmin[k], Labmax[k]); \n      yb[k] = xp[k] * coefp; \n      yp[k] = yb[k]; \n    } \n  \n    for(int j=0; j<roi_out->height; j++) \n    { \n      int offset = (i + j * roi_out->width)*ch; \n \n      for(int k=0; k<4; k++) \n      { \n        xc[k] = CLAMPF(in[offset+k], Labmin[k], Labmax[k]); \n        yc[k] = (a0 * xc[k]) + (a1 * xp[k]) - (b1 * yp[k]) - (b2 * yb[k]); \n \n        temp[offset+k] = yc[k]; \n \n        xp[k] = xc[k]; \n        yb[k] = yp[k]; \n        yp[k] = yc[k]; \n      } \n    } \n \n     \n \n    for(int k=0; k<4; k++) \n    { \n      xn[k] = CLAMPF(in[((roi_out->height - 1) * roi_out->width + i)*ch+k], Labmin[k], Labmax[k]); \n      xa[k] = xn[k]; \n      yn[k] = xn[k] * coefn; \n      ya[k] = yn[k]; \n    } \n \n    for(int j=roi_out->height - 1; j > -1; j--) \n    { \n      int offset = (i + j * roi_out->width)*ch; \n \n      for(int k=0; k<4; k++) \n      {       \n        xc[k] = CLAMPF(in[offset+k], Labmin[k], Labmax[k]); \n \n        yc[k] = (a2 * xn[k]) + (a3 * xa[k]) - (b1 * yn[k]) - (b2 * ya[k]); \n \n        xa[k] = xn[k];  \n        xn[k] = xc[k];  \n        ya[k] = yn[k];  \n        yn[k] = yc[k]; \n \n        temp[offset+k] += yc[k]; \n      } \n    } \n  } \n \n   \n \n  #pragma omp parallel for default(none) shared(out,temp,roi_out,data,a0,a1,a2,a3,b1,b2,coefp,coefn) schedule(static) \n  for(int j=0; j<roi_out->height; j++) \n  { \n    float xp[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yb[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yp[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float xc[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yc[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float xn[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float xa[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yn[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float ya[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n \n     \n \n    for(int k=0; k<4; k++) \n   ", "pred": " \nvoid process (struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, void *ivoid, void *ovoid, const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out) \n{ \n  dt_iop_lowpass_data_t *data = (dt_iop_lowpass_data_t *)piece->data; \n  float *in  = (float *)ivoid; \n  float *out = (float *)ovoid; \n  const int ch = piece->colors; \n  float a0, a1, a2, a3, b1, b2, coefp, coefn; \n \n  const float Labmax[] = { 100.0f, 128.0f, 128.0f, 1.0f }; \n  const float Labmin[] = { 0.0f, -128.0f, -128.0f, 0.0f }; \n \n  const float radius = fmax(0.1f, data->radius); \n  const float sigma = radius * roi_in->scale / piece ->iscale; \n \n   \n \n  compute_gauss_params(sigma, data->order, &a0, &a1, &a2, &a3, &b1, &b2, &coefp, &coefn); \n \n  float *temp = dt_alloc_align(64, roi_out->width*roi_out->height*ch*sizeof(float)); \n  if(temp==NULL) return; \n \n   \n \n  #pragma omp parallel for default(none) shared(in,out,temp,roi_out,data,a0,a1,a2,a3,b1,b2,coefp,coefn) schedule(static) \n  for(int i=0; i<roi_out->width; i++) \n  { \n    float xp[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yb[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yp[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float xc[4] = {0.0f, 0.0f, 0.0f, 0.0f, 0.0f};                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " \nvoid VMatrixProjection(gsl_matrix_float *X,float *ev,int type,int seed) \n{ \n  size_t i,j; \n  size_t nvox = X->size1; \n  size_t nt = X->size2; \n  size_t p = 32; \n \n  fprintf(stderr,\" VMatrixProjection...\\n\"); \n   \n   \n \n  const gsl_rng_type *Tx = gsl_rng_default; \n  gsl_rng *rx = gsl_rng_alloc (Tx); \n  gsl_rng_set(rx,(unsigned long int)seed); \n  gsl_matrix *R = gsl_matrix_calloc(nvox,p); \n  for (i=0; i<nvox; i++) { \n    for (j=0; j<p; j++) { \n      gsl_matrix_set(R,i,j,gsl_ran_ugaussian(rx)); \n    } \n  } \n \n   \n \n  gsl_matrix *Y = gsl_matrix_calloc(nvox,p); \n  size_t progress=0; \n  size_t step=4;   \n \n  fprintf(stderr,\" pass 1:\\n\"); \n \n \n#pragma omp parallel for shared(progress) schedule(guided) firstprivate(X,Y,R) \n  for (i=0; i<nvox; i++) { \n    if (i%1000 == 0) fprintf(stderr,\" %d000  of  %lu\\r\",(int)(++progress),nvox); \n     \n    size_t j=0,k=0; \n    double *tmp1 = (double *)VCalloc(nvox,sizeof(double)); \n    double *tmp2 = NULL; \n    double sum=0; \n    const float *arr1 = gsl_matrix_float_const_ptr(X,i,0); \n \n    for (j=0; j<nvox; j++) { \n      const float *arr2 = gsl_matrix_float_const_ptr(X,j,0); \n      tmp1[j] = ECMcorrelation(arr1,arr2,nt,type); \n    } \n \n    for (j=0; j<p; j++) { \n      tmp2 = gsl_matrix_ptr(R,j,0); \n      sum=0; \n      for (k=0; k<nvox; k+=step) { \n\tsum += tmp1[k]*tmp2[k]; \n      } \n      gsl_matrix_set(Y,i,j,sum); \n    } \n    VFree(tmp1); \n  } \n  fprintf(stderr,\"\\n\"); \n  gsl_matrix_free(R); \n   \n  \n   \n \n  gsl_vector *sv = gsl_vector_calloc(p); \n  gsl_vector *work = gsl_vector_calloc(p); \n  gsl_matrix *V = gsl_matrix_calloc(p,p); \n  gsl_linalg_SV_decomp(Y,V,sv,work); \n \n \n   \n \n  fprintf(stderr,\" pass 2:\\n\"); \n  gsl_matrix *D = gsl_matrix_calloc(nvox,p); \n  progress=0; \n \n  #pragma omp parallel for shared(progress) schedule(guided) firstprivate(X,Y,D) \n  for (i=0; i<nvox; i++) { \n    if (i%1000 == 0) fprintf(stderr,\" %d000  of  %lu\\r\",(int)(++progress),nvox); \n \n    size_t j=0,k=0; \n    double *tmp1 = (double *)VCalloc(nvox,sizeof(double)); \n    double sum=0; \n    const float *arr1 = gsl_matrix_float_const_ptr(X,i,0); \n \n    for (j=0; j<nvox; j++) { \n      const float *arr2 = gsl_matrix_float_const_ptr(X,j,0); \n      tmp1[j] = ECMcorrelation(arr1,arr2,nt,type); \n    } \n \n    for (j=0; j<p; j++) { \n      sum=0;       \n      for (k=0; k<nvox; k+=step) { \n\tsum += tmp1[k] * gsl_matrix_get(Y,k,j); \n      } \n      gsl_matrix_set(D,i,j,sum); \n    } \n    VFree(tmp1); \n  } \n  fprintf(stderr,\"\\n\"); \n  gsl_matrix_free(Y); \n \n   \n   \n \n  gsl_linalg_SV_decomp(D,V,sv,work); \n \n   \n   \n \n  size_t k=0; \n  for (i=0; i<nvox; i++) { \n    ev[i] = gsl_matrix_get(D,i,0); \n    if (ev[i] < 0) k++; \n  } \n \n   \n \n  if (k > nvox/2) { \n    for (i=0; i<nvox; i++) { \n      ev[i] = -ev[i]; \n    } \n  } \n \n   \n \n  NormVec(ev,nvox); \n  float kx = sqrt((float)(nvox)); \n  for (i=0; i<nvox; i++)  ev[i] *= kx; \n} ", "pred": " \nvoid VMatrixProjection(gsl_matrix_float *X,float *ev,int type,int seed) \n{ \n  size_t i,j; \n  size_t nvox = X->size1; \n  size_t nt = X->size2; \n  size_t p = 32; \n \n  fprintf(stderr,\" VMatrixProjection...\\n\"); \n   \n   \n \n  const gsl_rng_type *Tx = gsl_rng_default; \n  gsl_rng *rx = gsl_rng_alloc (Tx); \n  gsl_rng_set(rx,(unsigned long int)seed); \n  gsl_matrix *R = gsl_matrix_calloc(nvox,p); \n  for (i=0; i<nvox; i++) { \n    for (j=0; j<p; j++) { \n      gsl_matrix_set(R,i,j,gsl_ran_ugaussian(rx)); \n    } \n  } \n \n   \n \n  gsl_matrix *Y = gsl_matrix_calloc(nvox,p); \n  size_t progress=0; \n  size_t step=4;   \n \n  fprintf(stderr,\" pass 1:\\n\"); \n \n \n#pragma omp parallel for shared(progress) schedule(guided) firstprivate(X,Y,R) \n  for (i=0; i<nvox; i++) { \n    if (i%1000 == 0) fprintf(stderr,\" %d000  of  %lu\\r\",(int)(++progress),nvox); \n     \n    size_t j=0,k=0; \n    double *tmp1 = (double *)VCalloc(nvox,sizeof(double)); \n    double *tmp2 = NULL; \n    double sum=0; \n    const float *arr1 = gsl_matrix_float_const_ptr(X,i,0); \n \n    for (j=0; j<nvox; j++) { \n      const float *arr2 = gsl_matrix_float_const_ptr(X,j,0); \n      tmp1[j] = EC_MALLOC(sizeof(double));\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "}
{"label": "\tFILE *fp_ref; \n\tFILE *fp_read; \n\tFILE *fp_result; \n\tFILE *fp_result_info; \n \n\tint64_t ref_total_size; \n\tint ref_len; \n\tint ref_bucket_num; \n\tint ref_bucket_count; \n\tint ref_bucket_index = 0; \n \n\tint64_t read_total_size = 0; \n\tint64_t read_total_count = 0; \n\tint read_len; \n\tint read_bucket_num = 0; \n\tint read_bucket_count = 0; \n\tint read_bucket_index = 0; \n\tint64_t read_actual_size = 0; \n \n\tint64_t preprocess_read_size; \n\tint64_t align_result_size; \n\tint64_t offload_read_size; \n\tint64_t offload_result_size; \n \n\tint word_num; \n\tint chunk_read_num; \n\tint offload_dvdh_size; \n\tint ref_start; \n\tint ref_end; \n \n\tint64_t *result_bucket_counts; \n\tint64_t *sse_result_bucket_counts; \n \n\tmic_read_t *read_ptr; \n\tmic_write_t *result_ptr; \n\tint64_t read_ptr_offset; \n\tint64_t result_ptr_offset; \n\tint64_t single_read_size; \n\tint64_t single_result_size; \n\tint64_t single_read_count; \n\tint64_t single_result_count; \n\tint64_t total_result_count = 0; \n \n\tmic_cal_t *mic_args; \n\tmic_cal_t *tmp_cal_arg; \n \n\tint sse_word_num; \n\tint sse_chunk_read_num; \n\tint sse_dvdh_size; \n\tint64_t sse_preprocess_read_size; \n\tint64_t sse_align_result_size; \n\tint64_t sse_result_total_count; \n \n\tsse_cal_t sse_arg; \n\tsse_cal_t *tmp_sse_arg; \n \n \n\tdouble *device_compute_ratio; \n\tint64_t *device_read_counts_a; \n\tint64_t *device_read_counts_b; \n\tint64_t *device_read_counts; \n \n\tthread_info input_info; \n\tthread_info output_info; \n\tthread_info cal_input_info; \n\tthread_info cal_output_info; \n\tthread_arg input_arg; \n\tthread_arg output_arg; \n \n\tdouble total_start, total_end; \n\tdouble read_start, read_end; \n\tdouble cal_start, cal_end; \n\tdouble offload_start, offload_end; \n\tdouble write_start, write_end; \n\tdouble process_start, process_end; \n\tdouble mem_start, mem_end; \n\tdouble mem_time, mem_num; \n \n\tGET_TIME(total_start); \n\tread_total_time = 0; \n\twrite_total_time = 0; \n\tmem_total_time = 0; \n \n \n\tint total_device_number; \n\tint mic_device_number = mic_number; \n\tint cpu_device_number = 1; \n\t \n \n\ttotal_device_number = mic_device_number + cpu_device_number; \n \n\tdevice_compute_ratio = (double *) malloc_mem(sizeof(double) * total_device_number); \n\tdevice_read_counts_a = (int64_t *) malloc_mem(sizeof(int64_t) * total_device_number); \n\tdevice_read_counts_b = (int64_t *) malloc_mem(sizeof(int64_t) * total_device_number); \n \n\tif (file_ratio == NULL) { \n\t\tinit_cpu_mic_ratio(device_compute_ratio, cpu_device_number, mic_device_number); \n\t} else { \n\t\tinit_device_ratio_file(device_compute_ratio, cpu_device_number, mic_device_number, file_ratio); \n\t} \n\tuse_times = (double **) malloc_mem(sizeof(double *) * total_device_number); \n \n \n\tup_signal_a = (char *) malloc_mem(sizeof(char) * mic_device_number); \n\tup_signal_b = (char *) malloc_mem(sizeof(char) * mic_device_number); \n\tdown_signal_a = (char *) malloc_mem(sizeof(char) * mic_device_number); \n\tdown_signal_b = (char *) malloc_mem(sizeof(char) * mic_device_number); \n \n\tdouble cal_total_times[total_device_number]; \n\tdouble offload_total_times[total_device_number]; \n\tdouble previous_device_times[total_device_number]; \n \n\tfor (i = 0; i < total_device_number; i++) { \n\t\tcal_total_times[i] = 0; \n\t\toffload_total_times[i] = 0; \n\t} \n\tomp_set_nested(1); \n \n\tinit_mapping_table(); \n\tinit_device(mic_device_number); \n\tmic_args = (mic_cal_t *) malloc_mem(sizeof(mic_cal_t) * mic_device_number); \n \n\tcreate_folder(\"data\", 0755); \n\tfp_ref = open_file(file_query, \"rb\"); \n\tfp_read = open_file(file_database, \"rb\"); \n\tfp_result = open_file(file_result, \"wb+\"); \n\tfp_result_info = open_file(file_result_info, \"wb+\"); \n \n\t \n \n\tref_total_size = get_filesize(file_query); \n\tref_seq.content = (char *) malloc_mem(sizeof(char) * (ref_total_size + 1)); \n\tget_ref_from_file(&ref_seq, fp_ref, ref_total_size); \n\tref_len = ref_seq.len; \n \n\tif (ref_seq.count > REF_BUCKET_COUNT) { \n\t\tref_bucket_num = (ref_seq.count + REF_BUCKET_COUNT - 1) / REF_BUCKET_COUNT; \n\t\tref_bucket_count = REF_BUCKET_COUNT; \n\t} else { \n\t\tref_bucket_num = 1; \n\t\tref_bucket_count = ref_seq.count; \n\t} \n \n\tglobal_ref_bucket_num = ref_bucket_num; \n \n\tread_total_size = get_filesize(file_database); \n\tif (read_total_size > READ_BUCKET_SIZE) { \n\t\tread_seq_a.content = (char *) malloc_mem(sizeof(char) * (READ_BUCKET_SIZE + 1)); \n\t\tread_seq_b.content = (char *) malloc_mem(sizeof(char) * (READ_BUCKET_SIZE + 1)); \n\t\tread_actual_size = READ_BUCKET_SIZE; \n\t} else { \n\t\tread_seq_a.content = (char *) malloc_mem(sizeof(char) * (read_total_size * 2)); \n\t\tread_seq_b.content = (char *) malloc_mem(sizeof(char) * (read_total_size * 2)); \n\t\tread_actual_size = read_total_size; \n\t\t", "pred": "\tFILE *fp_ref; \n\tFILE *fp_read; \n\tFILE *fp_result; \n\tFILE *fp_result_info; \n \n\tint64_t ref_total_size; \n\tint ref_len; \n\tint ref_bucket_num; \n\tint ref_bucket_count; \n\tint ref_bucket_index = 0; \n \n\tint64_t read_total_size = 0; \n\tint64_t read_total_count = 0; \n\tint read_len; \n\tint read_bucket_num = 0; \n\tint read_bucket_count = 0; \n\tint read_bucket_index = 0; \n\tint64_t read_actual_size = 0; \n \n\tint64_t preprocess_read_size; \n\tint64_t align_result_size; \n\tint64_t offload_read_size; \n\tint64_t offload_result_size; \n \n\tint word_num; \n\tint chunk_read_num; \n\tint offload_dvdh_size; \n\tint ref_start; \n\tint ref_end; \n \n\tint64_t *result_bucket_counts; \n\tint64_t *sse_result_bucket_counts; \n \n\tmic_read_t *read_ptr; \n\tmic_write_t *result_ptr; \n\tint64_t read_ptr_offset; \n\tint64_t result_ptr_offset; \n\tint64_t single_read_size; \n\tint64_t single_result_size; \n\tint64_t single_read_count; \n\tint64_t single_result_count; \n\tint64_t total_result_count = 0; \n \n\tmic_cal_t *mic_args; \n\tmic_cal_t *tmp_cal_arg; \n \n\tint sse_word_num; \n\tint sse_chunk_read_num; \n\tint sse_dvdh_size; \n\tint64_t sse_preprocess_read_size; \n\tint64_t sse_align_result_size; \n\tint64_t sse_result_total_count; \n \n\tsse_cal_t sse_arg; \n\tsse_cal_t *tmp_sse_arg;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "}
{"label": " \nvoid recombine2d_pf0_ft0_omp(struct recombine2d_worker *worker, \n                             double complex *NMBF, \n                             double complex *NMBF_BF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n \n    assert(cfg->BF_stride1 == 1); \n    assert(cfg->NMBF_BF_stride0 = 1); \n    assert(cfg->BF_stride0 == cfg->NMBF_BF_stride1); \n \n    int y; \n#pragma omp for schedule(dynamic) \n    for (y = 0; y < cfg->xM_yN_size; y+=worker->BF_batch) { \n \n         \n \n        double start = get_time_ns(); \n        int y2; \n        for (y2 = y; y2 < y+worker->BF_batch && y2 < cfg->xM_yN_size; y2++) { \n            prepare_facet(cfg->yB_size, cfg->yP_size, cfg->Fb, \n                          NMBF+y2*cfg->NMBF_stride1, cfg->NMBF_stride0, \n                          NMBF_BF+y2*cfg->NMBF_BF_stride1, cfg->NMBF_BF_stride0); \n        } \n        worker->pf2_time += get_time_ns() - start; \n \n         \n \n \n         \n \n         \n \n         \n \n \n         \n \n         \n \n         \n \n        start = get_time_ns(); \n        fftw_plan plan = worker->BF_plan; \n        if (y+worker->BF_batch >= cfg->xM_yN_size) { \n            plan = recombine2d_bf_plan(worker->cfg, cfg->xM_yN_size - y, \n                                       NMBF_BF+y*cfg->NMBF_BF_stride1, \n                                       FFTW_ESTIMATE); \n        } \n        fftw_execute_dft(plan, \n                         NMBF_BF+y*cfg->NMBF_BF_stride1, \n                         NMBF_BF+y*cfg->NMBF_BF_stride1); \n        if (plan!= worker->BF_plan) \n            fftw_free(plan); \n        worker->ft2_time += get_time_ns() - start; \n \n    } \n} ", "pred": " \nvoid recombine2d_pf0_ft0_omp(struct recombine2d_worker *worker, \n                             double complex *NMBF, \n                             double complex *NMBF_BF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n \n    assert(cfg->BF_stride1 == 1); \n    assert(cfg->NMBF_BF_stride0 = 1); \n    assert(cfg->BF_stride0 == cfg->NMBF_BF_stride1); \n \n    int y; \n#pragma omp for schedule(dynamic) \n    for (y = 0; y < cfg->xM_yN_size; y+=worker->BF_batch) { \n \n         \n \n        double start = get_time_ns(); \n        int y2; \n        for (y2 = y; y2 < y+worker->BF_batch && y2 < cfg->xM_yN_size; y2++) { \n            prepare_facet(cfg->yB_size, cfg->yP_size, cfg->Fb, \n                          NMBF+y2*cfg->NMBF_stride1, cfg->NMBF_stride0, \n                          NMBF_BF+y2*cfg->NMBF_BF_stride1, cfg->NMBF_BF_stride0); \n        } \n        worker->pf2_time += get_time_ns() - start; \n \n         \n \n \n         \n \n         \n \n         \n \n \n         \n \n                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \ndouble Matrix_Multiplication_Static(double **Matrix_A,double **Matrix_B,double **Result,int N_size,int Total_threads) \n{ \n\tint\ti,j,k; \n\tstruct timeval  TimeValue_Start; \n\tstruct timezone TimeZone_Start; \n \n\tstruct timeval  TimeValue_Final; \n\tstruct timezone TimeZone_Final; \n\tlong            time_start, time_end; \n\tdouble          time_overhead; \n\t \n\tgettimeofday(&TimeValue_Start, &TimeZone_Start); \n\t \n         \n \n\tomp_set_num_threads(Total_threads); \n\t \n\t \n\t \n #pragma omp parallel for private(j,k) schedule(static) \n\tfor (i = 0; i < N_size; i = i + 1){ \n\t\tfor (j = 0; j < N_size; j = j + 1){ \n\t\t\tResult[i][j]=0.0; \n\t\t\tfor (k = 0; k < N_size; k = k + 1) \n\t\t\t\tResult[i][j] = Result[i][j] + Matrix_A[i][k] * Matrix_B[k][j]; \n\t\t} \n\t} \n \n \n\t gettimeofday(&TimeValue_Final, &TimeZone_Final); \n \n         \n \n\ttime_start = TimeValue_Start.tv_sec * 1000000 + TimeValue_Start.tv_usec; \n\ttime_end = TimeValue_Final.tv_sec * 1000000 + TimeValue_Final.tv_usec; \n\ttime_overhead = (time_end - time_start)/1000000.0; \n \n        printf(\"\\n\\t\\t Matrix into Matrix Multiplication using one Parallel for pragma with static option......Done \\n\"); \n\treturn time_overhead; \n} ", "pred": " \ndouble Matrix_Multiplication_Static(double **Matrix_A,double **Matrix_B,double **Result,int N_size,int Total_threads) \n{ \n\tint\ti,j,k; \n\tstruct timeval  TimeValue_Start; \n\tstruct timezone TimeZone_Start; \n \n\tstruct timeval  TimeValue_Final; \n\tstruct timezone TimeZone_Final; \n\tlong            time_start, time_end; \n\tdouble          time_overhead; \n\t \n\tgettimeofday(&TimeValue_Start, &TimeZone_Start); \n\t \n         \n \n\tomp_set_num_threads(Total_threads); \n\t \n\t \n\t \n #pragma omp parallel for private(j,k) schedule(static) \n\tfor (i = 0; i < N_size; i = i + 1){ \n\t\tfor (j = 0; j < N_size; j = j + 1){ \n\t\t\tResult[i][j]=0.0; \n\t\t\tfor (k = 0; k < N_size; k = k + 1) \n\t\t\t\tResult[i][j] = Result[i][j] + Matrix_A[i][k] * Matrix_B[k][j]; \n\t\t} \n\t} \n \n \n\t gettimeofday(&TimeValue_Final, &TimeZone_Final); \n \n         \n \n\ttime_start = TimeValue_Start.tv_sec * 1000000 + TimeValue_Start.tv_usec; \n\ttime_end = TimeValue_Final.tv_sec * 1000000 + TimeValue_Final.tv_usec; \n\ttime_overhead = (time_end - time_start)/1000000.0; \n \n        printf(\"\\n\\t\\t Matrix into Matrix Multiplication using one Parallel for pragma with static option......Done \\n\"); \n\treturn time_overhead; \n} "}
{"label": "oid DGMacroCellInterface(void *mc, field *f, real *w, real *dtw)  \n{ \n  MacroFace *mface = (MacroFace*) mc; \n  MacroMesh *msh = &f->macromesh; \n  const unsigned int m = f->model.m; \n \n  int iparam[8]; \n  for(int ip = 0; ip < 8; ip++) \n    iparam[ip] = f->interp_param[ip]; \n \n   \n \n  for (int ifa = mface->first; ifa < mface->last_p1; ifa++) { \n    int ieL = msh->face2elem[4 * ifa + 0]; \n    int locfaL = msh->face2elem[4 * ifa + 1]; \n \n     \n \n    real physnode[20][3]; \n    for(int inoloc = 0; inoloc < 20; inoloc++) { \n      int ino = msh->elem2node[20 * ieL + inoloc]; \n      physnode[inoloc][0] = msh->node[3 * ino + 0]; \n      physnode[inoloc][1] = msh->node[3 * ino + 1]; \n      physnode[inoloc][2] = msh->node[3 * ino + 2]; \n    } \n \n    int ieR = msh->face2elem[4 * ifa + 2]; \n    int locfaR = msh->face2elem[4 * ifa + 3]; \n    real physnodeR[20][3]; \n    if (ieR >= 0) { \n      for(int inoloc = 0; inoloc < 20; inoloc++) { \n        int ino = msh->elem2node[20 * ieR + inoloc]; \n        physnodeR[inoloc][0] = msh->node[3 * ino + 0]; \n        physnodeR[inoloc][1] = msh->node[3 * ino + 1]; \n        physnodeR[inoloc][2] = msh->node[3 * ino + 2]; \n      } \n    } \n \n     \n \n#pragma omp parallel for \n    for(int ipgfL = 0; ipgfL < NPGF(f->interp_param + 1, locfaL); ipgfL++) { \n \n      int iparam[8]; \n      for(int ip = 0; ip < 8; ip++) \n\tiparam[ip] = f->interp_param[ip]; \n \n      real xpgref[3], xpgref_in[3], wpg; \n       \n \n       \n \n      ref_pg_face(iparam + 1, locfaL, ipgfL, xpgref, &wpg, xpgref_in); \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n       \n \n      int ipgL = iparam[7]; \n \n      real flux[m]; \n      real wL[m]; \n \n       \n \n      real vnds[3], xpg[3]; \n      { \n\treal dtau[3][3], codtau[3][3]; \n\tRef2Phy(physnode, \n\t\txpgref, \n\t\tNULL, locfaL,  \n \n\t\txpg, dtau, \n\t\tcodtau, NULL, vnds);  \n \n      } \n \n      if (ieR >= 0) {   \n \n        real xrefL[3]; \n\t{ \n\t  real xpg_in[3]; \n\t  Ref2Phy(physnode, \n\t\t  xpgref_in, \n\t\t  NULL, -1,  \n \n\t\t  xpg_in, NULL, \n\t\t  NULL, NULL, NULL);  \n \n\t  PeriodicCorrection(xpg_in,f->macromesh.period); \n\t  Phy2Ref(physnodeR, xpg_in, xrefL); \n \n\t} \n \n        int ipgR = ref_ipg(iparam + 1, xrefL); \n \n\t \n \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n \n\treal wR[m]; \n        for(int iv = 0; iv < m; iv++) { \n\t  int imemL = f->varindex(iparam, ieL, ipgL, iv); \n\t  wL[iv] = w[imemL]; \n          int imemR = f->varindex(iparam, ieR, ipgR, iv); \n          wR[iv] = w[imemR]; \n        } \n \n         \n \n \n        f->model.NumFlux(wL, wR, vnds, flux); \n \n\t \n \n\tfor(int iv = 0; iv < m; iv++) { \n\t   \n \n\t  int imemL = f->varindex(iparam, ieL, ipgL, iv); \n          int imemR = f->varindex(iparam, ieR, ipgR, iv); \n\t  dtw[imemL] -= flux[iv] * wpg; \n          dtw[imemR] += flux[iv] * wpg; \n\t} \n \n      } else {  \n \n\tfor(int iv = 0; iv < m; iv++) { \n\t  int imemL = f->varindex(iparam, ieL, ipgL, iv); \n\t  wL[iv] = w[imemL]; \n\t} \n \n        f->model.BoundaryFlux(xpg, f->tnow, wL, vnds, flux); \n \n\tfor(int iv = 0; iv < m; iv++) { \n\t   \n \n\t  int imemL = f->varindex(iparam, ieL, ipgL, iv); \n\t  dtw[imemL] -= flux[iv] * wpg; \n\t} \n      } \n \n    } \n \n  } \n} \n \n \n ", "pred": "oid DGMacroCellInterface(void *mc, field *f, real *w, real *dtw)  \n{ \n  MacroFace *mface = (MacroFace*) mc; \n  MacroMesh *msh = &f->macromesh; \n  const unsigned int m = f->model.m; \n \n  int iparam[8]; \n  for(int ip = 0; ip < 8; ip++) \n    iparam[ip] = f->interp_param[ip]; \n \n   \n \n  for (int ifa = mface->first; ifa < mface->last_p1; ifa++) { \n    int ieL = msh->face2elem[4 * ifa + 0]; \n    int locfaL = msh->face2elem[4 * ifa + 1]; \n \n     \n \n    real physnode[20][3]; \n    for(int inoloc = 0; inoloc < 20; inoloc++) { \n      int ino = msh->elem2node[20 * ieL + inoloc]; \n      physnode[inoloc][0] = msh->node[3 * ino + 0]; \n      physnode[inoloc][1] = msh->node[3 * ino + 1]; \n      physnode[inoloc][2] = msh->node[3 * ino + 2]; \n    } \n \n    int ieR = msh->face2elem[4 * ifa + 2]; \n    int locfaR = msh->face2elem[4 * ifa + 3]; \n    real physnodeR[20][3]; \n    if (ieR >= 0) { \n      for(int inoloc = 0; inoloc < 20; inoloc++) { \n        int ino = msh->elem2node[20 * ieR + inoloc]; \n        physnodeR[inoloc][0] = msh->node[3 * ino + 0]; \n        physnodeR[inoloc][1] = msh->node[3 * ino + 1]; \n        physnodeR[inoloc][2] = msh->node[3 * ino + 2];        physnodeR[inoloc][3] = msh->node[3 * ino + 3];        physnodeR[inoloc][4] = msh->node[3 * ino + 4];         physnodeR[inoloc][5] = msh->node[3 * ino + 5];         physnodeR[inoloc][6] = msh->node[3 * ino + 6];          physnodeR[inoloc][7] = msh->node[3 * ino + 7];          physnodeR[inoloc][8] = msh->node[3 * ino + 8];          physnodeR[inoloc][9] = msh->node[3 * ino + 9];          physnodeR[inoloc][10] = msh->node[3 * ino + 20];          physnodeR[inoloc][11] = msh->node[3 * ino + 21];          physnodeR[inoloc][12] = msh->node[3 * ino + 22];          physnodeR[inoloc][13] = msh->node[3 * ino + 23];          physnodeR[inoloc][14] = msh->node[3 * ino + 24];          physnodeR[inoloc][15] = msh->node[3 * ino + 25];           physnodeR[inoloc][16] = msh->node[3 * ino + 26];          physnodeR[inoloc][17] = msh->node[3 * ino + 27];          physnodeR[inoloc][18] = msh->node[3 * ino + 28];          physnodeR[inoloc][19] = msh->node[3 * ino + 29];          physnodeR[inoloc][20] = msh->node[3 * ino + 30];          physnodeR[inoloc][21] = msh->node[3 * ino + 27];          physnodeR[inoloc][22] = msh->node[3 * ino + 28];          physnodeR[inoloc][23] = msh->node[3 * ino + 29];          physnodeR[inoloc][24] = msh->node[3 * ino + 29];          physnodeR[inoloc][25] = msh->node[3 * ino + 30];          physnodeR[inoloc][26] = msh->node[3 * ino + 31];          physnodeR[inoloc][27] = msh->node[3 * ino + 32];          physnodeR[inoloc][28] = msh->node[3 * ino + 35];          physnodeR[inoloc][29] = msh->node[3 * ino + 37];          physnodeR[inoloc][28] = msh->node[3 * ino + 38];          physnodeR[inoloc][29] = msh->node[3 * ino + 38];          physnodeR[inoloc][28] = msh->node[3 * ino + 39];          physnodeR[inoloc][29] = msh->node[3 * ino + 39];          physnodeR[inoloc][28] = msh->node[3 * ino + 39];          physnodeR[inoloc][29] = msh->node[3 * ino + 39];          physnodeR[inoloc][28] = msh->node[3 * ino + 39];          physnodeR[inoloc][28] = msh->node[3 * ino + 39];          physnodeR[inoloc][28] = msh->node[3 * ino + 39];          physnodeR[inoloc][28] = msh->node[3 * ino + 39];          physnodeR[inoloc][28] = msh->node[3 * ino + 39];          physnodeR[inoloc][28] = msh->node[3 * ino + 39];          physnode"}
{"label": " \nvoid Pyuv422to420(unsigned char *input_ptr, unsigned char *output_ptr, const unsigned int width, \n                  const unsigned int height, const int upsideDown) { \n    int i; \n    const int size = width * height; \n \n#pragma omp parallel for private(i) \n    for (i = 0; i < height; i++) { \n        unsigned char *b; \n        unsigned char *outY = output_ptr + i * width; \n        unsigned char *outU = output_ptr + (i / 2) * (width / 2) + size; \n        unsigned char *outV = output_ptr + (i / 2) * (width / 2) + size * 5 / 4; \n        if (!upsideDown) b = input_ptr + 2 * width * i; \n        else b = input_ptr - 2 * width * i + 2 * width * height - 4; \n \n        int j; \n        for (j = 0; j < width / 2; j++) { \n            unsigned char Y = b[0]; \n            unsigned char U = ALLDATAMONO? 128 : b[1]; \n            unsigned char Y1 = b[2]; \n            unsigned char V = ALLDATAMONO? 128 : b[3]; \n \n            if (!upsideDown) { \n                *(outY++) = Y; \n                *(outY++) = Y1; \n                b += 4; \n            } else { \n                *(outY++) = Y1; \n                *(outY++) = Y; \n                b -= 4; \n            } \n            *(outU++) = U; \n            *(outV++) = V; \n        } \n    } \n} ", "pred": " \nvoid Pyuv422to420(unsigned char *input_ptr, unsigned char *output_ptr, const unsigned int width, \n                  const unsigned int height, const int upsideDown) { \n    int i; \n    const int size = width * height; \n \n#pragma omp parallel for private(i) \n    for (i = 0; i < height; i++) { \n        unsigned char *b; \n        unsigned char *outY = output_ptr + i * width; \n        unsigned char *outU = output_ptr + (i / 2) * (width / 2) + size; \n        unsigned char *outV = output_ptr + (i / 2) * (width / 2) + size * 5 / 4; \n        if (!upsideDown) b = input_ptr + 2 * width * i; \n        else b = input_ptr - 2 * width * i + 2 * width * height - 4; \n \n        int j; \n        for (j = 0; j < width / 2; j++) { \n            unsigned char Y = b[0]; \n            unsigned char U = ALLDATAMONO? 128 : b[1]; \n            unsigned char Y1 = b[2]; \n            unsigned char V = ALLDATAMONO? 128 : b[3]; \n \n            if (!upsideDown) { \n                *(outY++) = Y; \n                *(outY++) = Y1; \n                b += 4; \n            } else { \n                *(outY++) = Y1; \n                *(outY++) = Y; \n                b -= 4;                                                                            "}
{"label": " \nvoid partials_states_and_undefined_codon_openmp( const SingleTreeLikelihood *tlk, int idx1, const double *matrices1, const double *partials2, const double *matrices2, double *partials3 ){ \n     \n\tconst int nstate = tlk->m->nstate; \n\tconst int extra = nstate - 60; \n\tint nThreads = tlk->nthreads; \n     \n#pragma omp parallel for schedule(dynamic,1) num_threads(nThreads) \n    for ( int lk = 0; lk < tlk->pattern_count*tlk->cat_count; lk++ ) { \n        int l = lk / tlk->pattern_count; \n        int k = lk % tlk->pattern_count; \n         \n        int w = l * tlk->matrix_size; \n        int v = (l*tlk->pattern_count + k) * nstate; \n        const double *m2 = matrices2 + w; \n         \n        int state1 = tlk->sp->patterns[idx1][k]; \n         \n        const double *p2 = NULL; \n        double *pPartials = partials3+v; \n         \n        if ( state1 < nstate ) { \n             \n            const double *m1 = matrices1 + w; \n             \n            for ( int j = 0; j < nstate; j++ ) { \n                 \n                p2 = partials2 + v; \n                 \n                *pPartials  = *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                 \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                 \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                 \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *", "pred": " \nvoid partials_states_and_undefined_codon_openmp( const SingleTreeLikelihood *tlk, int idx1, const double *matrices1, const double *partials2, const double *matrices2, double *partials3 ){ \n     \n\tconst int nstate = tlk->m->nstate; \n\tconst int extra = nstate - 60; \n\tint nThreads = tlk->nthreads; \n     \n#pragma omp parallel for schedule(dynamic,1) num_threads(nThreads) \n    for ( int lk = 0; lk < tlk->pattern_count*tlk->cat_count; lk++ ) { \n        int l = lk / tlk->pattern_count; \n        int k = lk % tlk->pattern_count; \n         \n        int w = l * tlk->matrix_size; \n        int v = (l*tlk->pattern_count + k) * nstate; \n        const double *m2 = matrices2 + w; \n         \n        int state1 = tlk->sp->patterns[idx1][k]; \n         \n        const double *p2 = NULL; \n        double *pPartials = partials3+v; \n         \n        if ( state1 < nstate ) { \n             \n            const double *m1 = matrices1 + w; \n             \n            for ( int j = 0; j < nstate; j++ ) { \n                 \n                p2 = partials2 + v; \n                 \n                *pPartials  = *m2 * *p2; m2++;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \nstatic void get_undone_phonons(double *frequencies, \n                               lapack_complex_double *eigenvectors, \n                               const size_t *undone_grid_points, \n                               const size_t num_undone_grid_points, \n                               PHPYCONST int (*grid_address)[3], \n                               const int mesh[3], \n                               const double *fc2, \n                               PHPYCONST double(*svecs_fc2)[27][3], \n                               const int *multi_fc2, \n                               const size_t num_patom, \n                               const size_t num_satom, \n                               const double *masses_fc2, \n                               const int *p2s_fc2, \n                               const int *s2p_fc2, \n                               const double unit_conversion_factor, \n                               PHPYCONST double (*born)[3][3], \n                               PHPYCONST double dielectric[3][3], \n                               PHPYCONST double reciprocal_lattice[3][3], \n                               const double *q_direction, \n                               const double nac_factor, \n                               const char uplo) \n{ \n  size_t i, j, gp, num_band; \n  int is_nac, info; \n  double q[3]; \n  double *freqs_tmp; \n \n  num_band = num_patom * 3; \n \n#pragma omp parallel for private(j, q, gp, is_nac) \n  for (i = 0; i < num_undone_grid_points; i++) { \n    gp = undone_grid_points[i]; \n    for (j = 0; j < 3; j++) { \n      q[j] = ((double)grid_address[gp][j]) / mesh[j]; \n    } \n \n    is_nac = needs_nac(born, grid_address, gp, q_direction); \n    get_phonons(eigenvectors + num_band * num_band * gp, \n                q, \n                fc2, \n                masses_fc2, \n                p2s_fc2, \n                s2p_fc2, \n                multi_fc2, \n                num_patom, \n                num_satom, \n                svecs_fc2, \n                is_nac, \n                born, \n                dielectric, \n                reciprocal_lattice, \n                q_direction, \n                nac_factor, \n                unit_conversion_factor); \n  } \n \n \n \n#pragma omp parallel for private(j, gp, freqs_tmp, info) \n  for (i = 0; i < num_undone_grid_points; i++) { \n    gp = undone_grid_points[i]; \n    freqs_tmp = frequencies + num_band * gp; \n     \n \n     \n \n    info = phonopy_zheev(freqs_tmp, \n                         eigenvectors + num_band * num_band * gp, \n                         num_band, \n                         uplo); \n \n     \n \n    for (j = 0; j < num_band; j++) { \n      freqs_tmp[j] = sqrt(fabs(freqs_tmp[j])) * \n        ((freqs_tmp[j] > 0) - (freqs_tmp[j] < 0)) * unit_conversion_factor; \n    } \n  } \n} ", "pred": " \nstatic void get_undone_phonons(double *frequencies, \n                               lapack_complex_double *eigenvectors, \n                               const size_t *undone_grid_points, \n                               const size_t num_undone_grid_points, \n                               PHPYCONST int (*grid_address)[3], \n                               const int mesh[3], \n                               const double *fc2, \n                               PHPYCONST double(*svecs_fc2)[27][3], \n                               const int *multi_fc2, \n                               const size_t num_patom, \n                               const size_t num_satom, \n                               const double *masses_fc2, \n                               const int *p2s_fc2, \n                               const int *s2p_fc2, \n                                  const int *s2p_fc2,                               const int *s2p_fc2,                                 const int *s2p_fc2,                                   const int *s2p_fc2,                                    const int *s2p_fc2,                                      const int *s2p_fc2,                                      const int *s2p_fc2,                                        const int *s2p_fc2,                                          const int *s2p_fc2,                                            const int *s2p_fc2,                                             const int *s2p_fc2,                                               const int *s2p_fc2,                                                const int *s2p_fc2,                                                 const int *s2p_fc2,                                                 const int *s2p_fc2,                                                 const int *s2p_fc2,                                                 const int *s2p_fc2,                                                 const int *s2p_fc2,                                                  const int *s2p_fc2,                                                  const int *s2p_fc2,                                                  const int *s2p_fc2,                                                   const int *s2p_fc2,                                                       const int *s2"}
{"label": " \nvoid compute_rhs() \n{ \n  int i, j, k, m; \n  double rho_inv, uijk, up1, um1, vijk, vp1, vm1, wijk, wp1, wm1; \n \n  if (timeron) timer_start(t_rhs); \n  #pragma omp parallel default(shared) private(i,j,k,m,rho_inv,uijk,up1,um1,                                        vijk,vp1,vm1,wijk,wp1,wm1) \n  { \n   \n \n   \n \n   \n \n   \n \n  #pragma omp for schedule(static) nowait \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        rho_inv = 1.0/u[k][j][i][0]; \n        rho_i[k][j][i] = rho_inv; \n        us[k][j][i] = u[k][j][i][1] * rho_inv; \n        vs[k][j][i] = u[k][j][i][2] * rho_inv; \n        ws[k][j][i] = u[k][j][i][3] * rho_inv; \n        square[k][j][i] = 0.5* ( \n            u[k][j][i][1]*u[k][j][i][1] +  \n            u[k][j][i][2]*u[k][j][i][2] + \n            u[k][j][i][3]*u[k][j][i][3] ) * rho_inv; \n        qs[k][j][i] = square[k][j][i] * rho_inv; \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  #pragma omp for schedule(static) \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        for (m = 0; m < 5; m++) { \n          rhs[k][j][i][m] = forcing[k][j][i][m]; \n        } \n      } \n    } \n  } \n \n  #pragma omp master \n  if (timeron) timer_start(t_rhsx); \n   \n \n   \n \n   \n \n  #pragma omp for schedule(static) nowait \n  for (k = 1; k <= grid_points[2]-2; k++) { \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      for (i = 1; i <= grid_points[0]-2; i++) { \n        uijk = us[k][j][i]; \n        up1  = us[k][j][i+1]; \n        um1  = us[k][j][i-1]; \n \n        rhs[k][j][i][0] = rhs[k][j][i][0] + dx1tx1 *  \n          (u[k][j][i+1][0] - 2.0*u[k][j][i][0] +  \n           u[k][j][i-1][0]) - \n          tx2 * (u[k][j][i+1][1] - u[k][j][i-1][1]); \n \n        rhs[k][j][i][1] = rhs[k][j][i][1] + dx2tx1 *  \n          (u[k][j][i+1][1] - 2.0*u[k][j][i][1] +  \n           u[k][j][i-1][1]) + \n          xxcon2*con43 * (up1 - 2.0*uijk + um1) - \n          tx2 * (u[k][j][i+1][1]*up1 -  \n              u[k][j][i-1][1]*um1 + \n              (u[k][j][i+1][4]- square[k][j][i+1]- \n               u[k][j][i-1][4]+ square[k][j][i-1])* \n              c2); \n \n        rhs[k][j][i][2] = rhs[k][j][i][2] + dx3tx1 *  \n          (u[k][j][i+1][2] - 2.0*u[k][j][i][2] + \n           u[k][j][i-1][2]) + \n          xxcon2 * (vs[k][j][i+1] - 2.0*vs[k][j][i] + \n              vs[k][j][i-1]) - \n          tx2 * (u[k][j][i+1][2]*up1 -  \n              u[k][j][i-1][2]*um1); \n \n        rhs[k][j][i][3] = rhs[k][j][i][3] + dx4tx1 *  \n          (u[k][j][i+1][3] - 2.0*u[k][j][i][3] + \n           u[k][j][i-1][3]) + \n          xxcon2 * (ws[k][j][i+1] - 2.0*ws[k][j][i] + \n              ws[k][j][i-1]) - \n          tx2 * (u[k][j][i+1][3]*up1 -  \n              u[k][j][i-1][3]*um1); \n \n        rhs[k][j][i][4] = rhs[k][j][i][4] + dx5tx1 *  \n          (u[k][j][i+1][4] - 2.0*u[k][j][i][4] + \n           u", "pred": " \nvoid compute_rhs() \n{ \n  int i, j, k, m; \n  double rho_inv, uijk, up1, um1, vijk, vp1, vm1, wijk, wp1, wm1; \n \n  if (timeron) timer_start(t_rhs); \n  #pragma omp parallel default(shared) private(i,j,k,m,rho_inv,uijk,up1,um1,                                        vijk,vp1,vm1,wijk,wp1,wm1) \n  { \n   \n \n   \n \n   \n \n   \n \n  #pragma omp for schedule(static) nowait \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        rho_inv = 1.0/u[k][j][i][0]; \n        rho_i[k][j][i] = rho_inv; \n        us[k][j][i] = u[k][j][i][1] * rho_inv; \n        vs[k][j][i] = u[k][j][i][2] * rho_inv; \n        ws[k][j][i] = u[k][j][i][3] * rho_inv; \n        square[k][j][i] = 0.5* ( \n            u[k][j][i][1]*u[k][j][i][1] +  \n            u[k][j][i][2]*u[k][j][i][2] + \n            u[k][j][i][3]*u[k][j][i][3] ) * rho_inv; \n        qs[k][j][i] = u[k][j][i][1]*u[k][j][i][2]*u[k][j][i][3] * u[k][j][i][3];\\n        }\\n      }\\n    }\\n  }\\n}\\n\\n}\", \"func_defs\": \"\\nvoid u_test_test(int n, int n, int m, int n, int u, int n, int u, int n, int n, int u, int n, int n, int u, int n, int n, int u, int n, int n, int u, int n, int n, int u, int n, int n, int u, int n, int n, int u, int n, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int u, int n, int"}
{"label": " \nMagickExport Image *SimilarityImage(Image *image,const Image *reference, \n  RectangleInfo *offset,double *similarity_metric,ExceptionInfo *exception) \n{ \n#define SimilarityImageTag  \"Similarity/Image\" \n \n  CacheView \n    *similarity_view; \n \n  ChannelStatistics \n    *reference_statistics; \n \n  Image \n    *similarity_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  assert(offset!= (RectangleInfo *) NULL); \n  SetGeometry(reference,offset); \n  *similarity_metric=1.0; \n  if ((reference->columns > image->columns) || (reference->rows > image->rows)) \n    ThrowImageException(ImageError,\"ImageSizeDiffers\"); \n  similarity_image=CloneImage(image,image->columns-reference->columns+1, \n    image->rows-reference->rows+1,MagickTrue,exception); \n  if (similarity_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(similarity_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&similarity_image->exception); \n      similarity_image=DestroyImage(similarity_image); \n      return((Image *) NULL); \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  reference_statistics=GetImageChannelStatistics(reference,exception); \n  similarity_view=AcquireCacheView(similarity_image); \n  #pragma omp parallel for schedule(dynamic,4) shared(progress,status) \n  for (y=0; y < (ssize_t) (image->rows-reference->rows+1); y++) \n  { \n    double \n      similarity; \n \n    register ssize_t \n      x; \n \n    register PixelPacket \n      *restrict q; \n \n    if (status == MagickFalse) \n      continue; \n    q=GetCacheViewAuthenticPixels(similarity_view,0,y,similarity_image->columns, \n      1,exception); \n    if (q == (const PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) (image->columns-reference->columns+1); x++) \n    { \n      similarity=GetSimilarityMetric(image,reference,reference_statistics,x,y, \n        exception); \n  #pragma omp critical (MagickCore_SimilarityImage) \n      if (similarity < *similarity_metric) \n        { \n          *similarity_metric=similarity; \n          offset->x=x; \n          offset->y=y; \n        } \n      SetPixelRed(q,ClampToQuantum(QuantumRange-QuantumRange* \n        similarity)); \n      SetPixelGreen(q,GetPixelRed(q)); \n      SetPixelBlue(q,GetPixelRed(q)); \n      q++; \n    } \n    if (SyncCacheViewAuthenticPixels(similarity_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n  #pragma omp critical (MagickCore_SimilarityImage) \n        proceed=SetImageProgress(image,SimilarityImageTag,progress++, \n          image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  } \n  similarity_view=DestroyCacheView(similarity_view); \n  reference_statistics=(ChannelStatistics *) RelinquishMagickMemory( \n    reference_statistics); \n  return(similarity_image); \n} ", "pred": " \nMagickExport Image *SimilarityImage(Image *image,const Image *reference, \n  RectangleInfo *offset,double *similarity_metric,ExceptionInfo *exception) \n{ \n#define SimilarityImageTag  \"Similarity/Image\" \n \n  CacheView \n    *similarity_view; \n \n  ChannelStatistics \n    *reference_statistics; \n \n  Image \n    *similarity_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  assert(offset!= (RectangleInfo *) NULL); \n  SetGeometry(reference,offset); \n  *similarity_metric=1.0; \n  if ((reference->columns > image->columns) || (reference->rows > image->rows)) \n    ThrowImageException(ImageError,\"ImageSizeDiffers\"); \n  similarity_image=CloneImage(image,image->columns-reference->columns+1, \n    image->rows-reference->rows+1,MagickTrue,exception); \n  if (similarity_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(similarity_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&similarity_image->exception); \n      similarity_image=DestroyImage(similarity_image); \n      return((Image *) NULL); \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  reference_statistics=GetImageChannelStatistics(reference,exception); \n  similarity_view=AcquireCacheView(similarity_image); \n  #pragma omp parallel for schedule(dynamic,4) shared(progress,status) \n  for (y=0; y < (int) image->columns; y++) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \nint main() \n{ \n\tMboNumOp Jx; \n\tMboProdSpace hTot; \n\tstruct MboAmplitude one, zero, *x, *y, *yomp; \n\tint i; \n\tMboGlobInd n, chunk, chunkSize, numChunks, dim; \n\tclock_t tstart, tend; \n\tdouble deltat, difference; \n\tint numThreads; \n\tMboNumSubMatrix *chunks; \n\tMBO_STATUS err; \n \n\thTot = buildSpace(numSpins); \n\tdim = mboProdSpaceDim(hTot); \n\tJx = buildJx(hTot); \n \n\tone.re = 1.0; \n\tone.im = 0.0; \n\tzero.re = 0.0; \n\tzero.im = 0.0; \n\tx = malloc(dim * sizeof(*x)); \n\ty = malloc(dim * sizeof(*x)); \n\tyomp = malloc(dim * sizeof(*x)); \n\tfor (n = 0; n < dim; ++n) { \n\t\tx[n].re = (double)rand() / RAND_MAX; \n\t\tx[n].im = (double)rand() / RAND_MAX; \n\t} \n \n\ttstart = clock(); \n\tfor (i = 0; i < numIters; ++i) { \n\t\tmboNumOpMatVec(one, Jx, x, zero, y); \n\t} \n\ttend = clock(); \n\tdeltat = (double)(tend - tstart) / (double)CLOCKS_PER_SEC; \n\tprintf(\"Serial: %2.3lf s\\n\", deltat); \n \n\tnumThreads = omp_get_max_threads(); \n\tnumThreads = 1; \n\tprintf(\"here\"); \n\tprintf(\"Using %d threads.\\n\", numThreads); \n\tchunkSize = dim / numThreads; \n\tprintf(\"Chunk Size: %lld\\n\", chunkSize); \n\tnumChunks = dim / chunkSize; \n\tprintf(\"Number of Chunks: %lld\\n\", numChunks); \n\tif (numChunks * chunkSize < dim) ++numChunks; \n\tchunks = (MboNumSubMatrix*)malloc(numChunks * sizeof(*chunks)); \n\tfor (chunk = 0; chunk < numChunks; ++chunk) { \n\t\terr = mboNumSubMatrixCreate(Jx, chunk * chunkSize, \n\t\t\t(chunk + 1) * chunkSize, 0, dim, &chunks[chunk]); \n\t\tassert(err == MBO_SUCCESS); \n\t} \n\ttstart = clock(); \n\tfor (i = 0; i < numIters; ++i) { \n#pragma omp parallel for private(chunk) \n\t\tfor (chunk = 0; chunk < numChunks; ++chunk) { \n\t\t\tmboNumSubMatrixMatVec(one, chunks[chunk], x, zero, \n\t\t\t\t\t      yomp + chunk * chunkSize); \n\t\t} \n\t} \n\ttend = clock(); \n\tdeltat = (double)(tend - tstart) / (double)CLOCKS_PER_SEC / numThreads; \n\tprintf(\"Parallel: %2.3lf s\\n\", deltat); \n \n\tdifference = 0; \n\tfor (n = 0; n < dim; ++n) { \n\t\tdifference += (yomp[n].re - y[n].re) * (yomp[n].re - y[n].re) + \n\t\t\t      (yomp[n].im - y[n].im) * (yomp[n].im - y[n].im); \n\t} \n\tdifference = sqrt(difference); \n \n\tprintf(\"Error: %lf\\n\", difference); \n \n\tfree(x); \n\tfree(y); \n\tfree(yomp); \n\tfor (chunk = 0; chunk < numChunks; ++chunk) { \n\t\tmboNumSubMatrixDestroy(&chunks[chunk]); \n\t} \n\tfree(chunks); \n\tmboNumOpDestroy(&Jx); \n\tmboProdSpaceDestroy(&hTot); \n \n\tif (difference < 1.0e-12) { \n\t\treturn 0; \n\t} else { \n\t\treturn 1; \n\t} \n \n} ", "pred": " \nint main() \n{ \n\tMboNumOp Jx; \n\tMboProdSpace hTot; \n\tstruct MboAmplitude one, zero, *x, *y, *yomp; \n\tint i; \n\tMboGlobInd n, chunk, chunkSize, numChunks, dim; \n\tclock_t tstart, tend; \n\tdouble deltat, difference; \n\tint numThreads; \n\tMboNumSubMatrix *chunks; \n\tMBO_STATUS err; \n \n\thTot = buildSpace(numSpins); \n\tdim = mboProdSpaceDim(hTot); \n\tJx = buildJx(hTot); \n \n\tone.re = 1.0; \n\tone.im = 0.0; \n\tzero.re = 0.0; \n\tzero.im = 0.0; \n\tx = malloc(dim * sizeof(*x)); \n\ty = malloc(dim * sizeof(*x)); \n\tyomp = malloc(dim * sizeof(*x)); \n\tfor (n = 0; n < dim; ++n) { \n\t\tx[n].re = (double)rand() / RAND_MAX; \n\t\tx[n].im = (double)rand() / RAND_MAX; \n\t} \n \n\ttstart = clock(); \n\tfor (i = 0; i < numIters; ++i) { \n\t\tmboNumOpMatVec(one, Jx, x, zero, y); \n\t} \n\ttend = clock(); \n\tdeltat = (double)(tend - tstart) / (double)CLOCKS_PER_SEC; \n\tprintf(\"Serial: %2.3lf s\\n\", deltat); \n \n\tnumThreads = omp_get_max_threads(); \n\tnumThreads = 1; \n\tprintf(\"here\"); \n\tprintf(\"Using %d threads.\\n\", numThreads); \n\tchunkSize = dim / numThreads; \n\tprintf(\"Chunk Size: %lld\\n\", chunkSize); \n\tnumChunks = dim / chunkSize; \n\tprintf(\"Number of Chunks: %lld\\n\", numChunks); \n\tif (numChunks * chunkSize < dim) ++numChunks; \n\tchunks = (MboNumSubMatrix*)malloc(numChunks * sizeof(*chunks)); \n{\"username = (MboNumSubMatrix*)malloc(numChunks * sizeof(*chunks));\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           "}
{"label": " \nvoid \ntime_3d_real_double_omp() \n{ \n   \n \n  int nthr = omp_get_max_threads(); \n  int nthr = 1; \n   \n \n   \n \n   \n \n   \n \n   \n \n \n  int nnodes = nthr; \n  fprintf (stderr, \"Using %d threads.\\n\", nnodes); \n \n  int Nx=63; int Ny=61; int Nz = 69; \n  int num_splines = 256; \n \n  Ugrid x_grid, y_grid, z_grid; \n  x_grid.start = 3.1; x_grid.end =  9.1; x_grid.num = Nx; \n  y_grid.start = 8.7; y_grid.end = 12.7; y_grid.num = Ny; \n  z_grid.start = 4.5; z_grid.end =  9.3; z_grid.num = Nz; \n \n  BCtype_d xBC, yBC, zBC; \n  xBC.lCode = xBC.rCode = PERIODIC; \n  yBC.lCode = yBC.rCode = PERIODIC; \n  zBC.lCode = zBC.rCode = PERIODIC; \n \n   \n \n  UBspline_3d_d* norm_splines[num_splines]; \n  multi_UBspline_3d_d *multi_spline[nnodes]; \n   \n   \n \n#pragma omp parallel for \n  for (int node=0; node<nnodes; node++)  \n  { \n     \n \n     \n \n     \n \n     \n \n    multi_spline[node] = create_multi_UBspline_3d_d  \n      (x_grid, y_grid, z_grid, xBC, yBC, zBC, num_splines); \n  } \n \n  double data[Nx*Ny*Nz]; \n   \n \n  for (int i=0; i<num_splines; i++) { \n    for (int j=0; j<Nx*Ny*Nz; j++) \n      data[j] = (drand48()-0.5); \n    norm_splines[i] = create_UBspline_3d_d  \n      (x_grid, y_grid, z_grid, xBC, yBC, zBC, data); \n#pragma omp parallel for     \n    for (int node=0; node<nnodes; node++) { \n       \n \n       \n \n       \n \n       \n \n      set_multi_UBspline_3d_d (multi_spline[node], i, data); \n    } \n  } \n   \n   \n \n  double rand_start, rand_end, norm_start[nthr], norm_end[nthr], multi_start[nthr], multi_end[nthr]; \n  int num_vals = 10000; \n  double multi_vals[nthr][num_splines], norm_vals[nthr][num_splines]; \n  double multi_grads[nthr][3*num_splines], norm_grads[nthr][3*num_splines]; \n  double multi_lapl[nthr][num_splines], norm_lapl[nthr][num_splines]; \n  double multi_hess[nthr][9*num_splines], norm_hess[nthr][9*num_splines]; \n \n  rand_start = get_time(); \n  for (int i=0; i<num_vals; i++) { \n    double rx = drand48();  double x = rx*x_grid.start + (1.0-rx)*x_grid.end; \n    double ry = drand48();  double y = ry*y_grid.start + (1.0-ry)*y_grid.end; \n    double rz = drand48();  double z = rz*z_grid.start + (1.0-rz)*z_grid.end; \n  } \n  rand_end = get_time(); \n \n   \n \n   \n \n   \n \n  double rx = drand48();  double x = rx*x_grid.start + (1.0-rx)*x_grid.end; \n  double ry = drand48();  double y = ry*y_grid.start + (1.0-ry)*y_grid.end; \n  double rz = drand48();  double z = rz*z_grid.start + (1.0-rz)*z_grid.end; \n \n  int thr_per_node = nthr/nnodes; \n \n#pragma omp parallel for \n  for (int thr=0; thr<nthr; thr++) { \n    int node = thr/thr_per_node; \n    multi_start[thr] = get_time(); \n    for (int i=0; i<num_vals; i++) { \n      double rx = drand48();  double x = rx*x_grid.start + (1.0-rx)*x_grid.end;  \n      double ry = drand48();  double y = ry*y_grid.start + (1.0-ry)*y_grid.end;  \n      double rz = drand48();  double z = rz*z_grid.start + (1.0-rz)*z_grid.end;  \n      eval_multi_UBspline_3d_d (multi_spline[node], x, y, z, multi_vals[thr]); \n    } \n    multi_end[thr] = get_time(); \n  } \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n   \n  double norm_avg=0.0, multi_avg=0.0; \n \n  for (int thr=0; thr<nthr; thr++) { \n    double norm_time   = (double)(norm_end[thr] - norm_start[thr] + rand_start - rand_end); \n    double multi_time  = (double)(multi_end[thr] - multi_start[thr] + rand_start - rand_end); \n    norm_avg += norm_time; \n    multi_avg += multi_time; \n  } \n  norm_avg  /= nthr; \n  multi_avg /= nthr; \n  double norm_speed  = (double) num_vals*num_splines / norm_avg; \n  double multi_speed = (double) num_vals*num_splines / multi_avg; \n \n   \n \n   \n \n  fprintf (stderr, \"Multi  value speed = %13.3f evaluations per second.\\n\",  \n  \t   multi_speed); \n  fprintf (stderr, \"Aggregate bandwidth = %1.3f GB/s per socket\\n\", multi_speed * 64.0*8.0 * 8 * 1.0e-9); \n \n   \n   \n \n   \n \n   \n \n  #pragma omp parallel for \n  for (int thr=0; thr<nthr; thr++) { \n    int node = thr/thr_per_node;", "pred": " \nvoid \ntime_3d_real_double_omp() \n{ \n   \n \n  int nthr = omp_get_max_threads(); \n  int nthr = 1; \n   \n \n   \n \n   \n \n   \n \n   \n \n \n  int nnodes = nthr; \n  fprintf (stderr, \"Using %d threads.\\n\", nnodes); \n \n  int Nx=63; int Ny=61; int Nz = 69; \n  int num_splines = 256; \n \n  Ugrid x_grid, y_grid, z_grid; \n  x_grid.start = 3.1; x_grid.end =  9.1; x_grid.num = Nx; \n  y_grid.start = 8.7; y_grid.end = 12.7; y_grid.num = Ny; \n  z_grid.start = 4.5; z_grid.end =  9.3; z_grid.num = Nz; \n \n  BCtype_d xBC, yBC, zBC; \n  xBC.lCode = xBC.rCode = PERIODIC; \n  yBC.lCode = yBC.rCode = PERIODIC; \n  zBC.lCode = zBC.rCode = PERIODIC; \n \n   \n \n  UBspline_3d_d* norm_splines[num_splines]; \n  multi_UBspline_3d_d *multi_spline[nnodes]; \n   \n   \n \n#pragma omp parallel for \n  for (int node=0; node<nnodes; node++)  \n  { \n     \n \n     \n \n     \n \n     \n \n    multi_spline[node] = create_multi_UBspline_3d_d  \n      (x_grid, y_grid, z_grid, xBC, yBC, zBC, num_splines); \n  } \n \n  double data[Nx*Ny*Nz]; \n   \n \n  for (int i=0; i<num_splines; i++) { \n    for (int j=0; j<Nx*Ny*Nz; j++) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " *fp_result; \n\tFILE *fp_result_info; \n \n\tint64_t ref_total_size; \n\tint ref_len; \n\tint ref_bucket_num; \n\tint ref_bucket_count; \n\tint ref_bucket_index = 0; \n \n\tint64_t read_total_size = 0; \n\tint64_t read_total_count = 0; \n\tint read_len; \n\tint read_bucket_num = 0; \n\tint read_bucket_count = 0; \n\tint read_bucket_index = 0; \n\tint64_t read_actual_size = 0; \n \n\tint64_t preprocess_read_size; \n\tint64_t align_result_size; \n\tint64_t offload_read_size; \n\tint64_t offload_result_size; \n \n\tint word_num; \n\tint chunk_read_num; \n\tint offload_dvdh_size; \n\tint ref_start; \n\tint ref_end; \n \n\tint64_t *result_bucket_counts; \n\tint64_t *sse_result_bucket_counts; \n \n\tmic_read_t *read_ptr; \n\tmic_write_t *result_ptr; \n\tint64_t read_ptr_offset; \n\tint64_t result_ptr_offset; \n\tint64_t single_read_size; \n\tint64_t single_result_size; \n\tint64_t single_read_count; \n\tint64_t single_result_count; \n\tint64_t total_result_count = 0; \n \n\tmic_cal_t *mic_args; \n\tmic_cal_t *tmp_cal_arg; \n \n\tint sse_word_num; \n\tint sse_chunk_read_num; \n\tint sse_dvdh_size; \n\tint64_t sse_preprocess_read_size; \n\tint64_t sse_align_result_size; \n\tint64_t sse_result_total_count; \n \n\tsse_cal_t sse_arg; \n\tsse_cal_t *tmp_sse_arg; \n \n \n\tdouble *device_compute_ratio; \n\tint64_t *device_read_counts_a; \n\tint64_t *device_read_counts_b; \n\tint64_t *device_read_counts; \n \n\tthread_info input_info; \n\tthread_info output_info; \n\tthread_info cal_input_info; \n\tthread_info cal_output_info; \n\tthread_arg input_arg; \n\tthread_arg output_arg; \n \n\tdouble total_start, total_end; \n\tdouble read_start, read_end; \n\tdouble cal_start, cal_end; \n\tdouble offload_start, offload_end; \n\tdouble write_start, write_end; \n\tdouble process_start, process_end; \n\tdouble mem_start, mem_end; \n\tdouble mem_time, mem_num; \n \n\tGET_TIME(total_start); \n\tread_total_time = 0; \n\twrite_total_time = 0; \n\tmem_total_time = 0; \n \n \n\tint total_device_number; \n\tint mic_device_number = mic_number; \n\tint cpu_device_number = 1; \n\t \n \n\ttotal_device_number = mic_device_number + cpu_device_number; \n \n\tdevice_compute_ratio = (double *) malloc_mem(sizeof(double) * total_device_number); \n\tdevice_read_counts_a = (int64_t *) malloc_mem(sizeof(int64_t) * total_device_number); \n\tdevice_read_counts_b = (int64_t *) malloc_mem(sizeof(int64_t) * total_device_number); \n \n\t \n \n \n\tif (file_ratio == NULL) { \n\t\tinit_cpu_mic_ratio(device_compute_ratio, cpu_device_number, mic_device_number); \n\t} else { \n\t\tinit_device_ratio_file(device_compute_ratio, cpu_device_number, mic_device_number, file_ratio); \n\t} \n \n\tuse_times = (double **) malloc_mem(sizeof(double *) * total_device_number); \n\t \n \n\t \n \n \n \n\tup_signal_a = (char *) malloc_mem(sizeof(char) * mic_device_number); \n\tup_signal_b = (char *) malloc_mem(sizeof(char) * mic_device_number); \n\tdown_signal_a = (char *) malloc_mem(sizeof(char) * mic_device_number); \n\tdown_signal_b = (char *) malloc_mem(sizeof(char) * mic_device_number); \n \n\tdouble cal_total_times[total_device_number]; \n\tdouble offload_total_times[total_device_number]; \n\tdouble previous_device_times[total_device_number]; \n \n\tfor (i = 0; i < total_device_number; i++) { \n\t\tcal_total_times[i] = 0; \n\t\toffload_total_times[i] = 0; \n\t} \n\tomp_set_nested(1); \n \n\tinit_mapping_table(); \n\tinit_device(mic_device_number); \n\tmic_args = (mic_cal_t *) malloc_mem(sizeof(mic_cal_t) * mic_device_number); \n \n\tcreate_folder(\"data\", 0755); \n\tfp_ref = open_file(file_query, \"rb\"); \n\tfp_read = open_file(file_database, \"rb\"); \n\tfp_result = open_file(file_result, \"wb+\"); \n\tfp_result_info = open_file(file_result_info, \"wb+\"); \n \n\t \n \n\tref_total_size = get_filesize(file_query); \n\tref_seq.content = (char *) malloc_mem(sizeof(char) * (ref_total_size + 1)); \n\tget_ref_from_file(&ref_seq, fp_ref, ref_total_size); \n\tref_len = ref_seq.len; \n \n\tif (ref_seq.count > REF_BUCKET_COUNT) { \n\t\tref_bucket_num = (ref_seq.count + REF_BUCKET_COUNT - 1) / REF_BUCKET_COUNT; \n\t\tref_bucket_count = REF_BUCKET_COUNT; \n\t} else { \n\t\tref_bucket_num = 1; \n\t\tref_bucket_count = ref_seq.count; \n\t} \n \n\tglobal_ref_bucket_num = ref_bucket_num; \n \n\tread_total_size = get_filesize(file_database); \n\tif (read_total_size > READ_BUCKET_SIZE) { \n\t\tread_seq_a.content = (char *) malloc_mem(sizeof(char) * (READ_BUCKET_SIZE + 1)); \n\t\tread_seq_b.content = (char *) malloc_mem(sizeof(char) * (READ_BUCKET_SIZE + 1)); \n\t\tread_actual_size = READ_BUCKET_SIZE; \n\t} else { \n\t\tread_seq_a.content = (char *) malloc_mem(sizeof(char) * (read_total_size * 2)); \n\t\tread_seq_b.content = (char *) malloc_mem(sizeof(char) * (read_total_size * 2)); \n\t\tread_actual_size = read_total_size; \n\t\tread", "pred": " *fp_result; \n\tFILE *fp_result_info; \n \n\tint64_t ref_total_size; \n\tint ref_len; \n\tint ref_bucket_num; \n\tint ref_bucket_count; \n\tint ref_bucket_index = 0; \n \n\tint64_t read_total_size = 0; \n\tint64_t read_total_count = 0; \n\tint read_len; \n\tint read_bucket_num = 0; \n\tint read_bucket_count = 0; \n\tint read_bucket_index = 0; \n\tint64_t read_actual_size = 0; \n \n\tint64_t preprocess_read_size; \n\tint64_t align_result_size; \n\tint64_t offload_read_size; \n\tint64_t offload_result_size; \n \n\tint word_num; \n\tint chunk_read_num; \n\tint offload_dvdh_size; \n\tint ref_start; \n\tint ref_end; \n \n\tint64_t *result_bucket_counts; \n\tint64_t *sse_result_bucket_counts; \n \n\tmic_read_t *read_ptr; \n\tmic_write_t *result_ptr; \n\tint64_t read_ptr_offset; \n\tint64_t result_ptr_offset; \n\tint64_t single_read_size; \n\tint64_t single_result_size; \n\tint64_t single_read_count; \n\tint64_t single_result_count; \n\tint64_t total_result_count = 0; \n \n\tmic_cal_t *mic_args; \n\tmic_cal_t *tmp_cal_arg; \n \n\tint sse_word_num; \n\tint sse_chunk_read_num; \n\tint sse_dvdh_size; \n\tint64_t sse_preprocess_read_size; \n\tint64_t sse_align_result_size; \n\tint64_t sse_result_total_count; \n \n\tsse_cal_t sse_arg; \n\tsse_cal_t *tmp_sse_arg; \n \n \n\tdouble *device_compute_ratio;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nvoid Pyuv422toMono(unsigned char *input_ptr, unsigned char *output_ptr, const unsigned int width, \n                   const unsigned int height, const int upsideDown) { \n    unsigned int i; \n    const int size = width * height / 2; \n#pragma omp parallel for private(i) \n    for (i = 0; i < size; i++) { \n        unsigned char *b = input_ptr + 4 * (upsideDown? i : (size - 1 - i)); \n        unsigned char Y = b[0]; \n        unsigned char Y1 = b[2]; \n        unsigned char *output_pt = output_ptr + 2 * i; \n        if (!upsideDown) { \n            *output_pt++ = Y; \n            *output_pt = Y1; \n        } else { \n            *output_pt++ = Y1; \n            *output_pt = Y; \n        } \n    } \n} ", "pred": " \nvoid Pyuv422toMono(unsigned char *input_ptr, unsigned char *output_ptr, const unsigned int width, \n                   const unsigned int height, const int upsideDown) { \n    unsigned int i; \n    const int size = width * height / 2; \n#pragma omp parallel for private(i) \n    for (i = 0; i < size; i++) { \n        unsigned char *b = input_ptr + 4 * (upsideDown? i : (size - 1 - i)); \n        unsigned char Y = b[0]; \n        unsigned char Y1 = b[2]; \n        unsigned char *output_pt = output_ptr + 2 * i; \n        if (!upsideDown) { \n            *output_pt++ = Y; \n            *output_pt = Y1; \n        } else { \n            *output_pt++ = Y1; \n            *output_pt = Y; \n        } \n    } \n} "}
{"label": " \nvoid Pyuv420torgb(unsigned char *Ydata, unsigned char *Udata, unsigned char *Vdata, unsigned char *outR, \n                  unsigned char *outG, unsigned char *outB, const unsigned int width, const unsigned int height) { \n    unsigned int i, j; \n \n    const int stride0 = width; \n    const int stride1 = width / 2; \n    const int stride2 = width / 2; \n#pragma omp parallel for private(i,j) \n    for (i = 0; i < height; i++) \n        for (j = 0; j < width; j++) { \n            unsigned char Y = Ydata[i * stride0 + j]; \n            unsigned char U = Udata[(i / 2) * stride1 + (j / 2)]; \n            unsigned char V = Vdata[(i / 2) * stride2 + (j / 2)]; \n            *(outR + i * width + j) = R_FROMYV(Y, V); \n            *(outG + i * width + j) = ALLDATAMONO? 128 : G_FROMYUV(Y, U, \n                                                                    V);  \n \n            *(outB + i * width + j) = ALLDATAMONO? 128 : B_FROMYU(Y, U); \n        } \n} ", "pred": " \nvoid Pyuv420torgb(unsigned char *Ydata, unsigned char *Udata, unsigned char *Vdata, unsigned char *outR, \n                  unsigned char *outG, unsigned char *outB, const unsigned int width, const unsigned int height) { \n    unsigned int i, j; \n \n    const int stride0 = width; \n    const int stride1 = width / 2; \n    const int stride2 = width / 2; \n#pragma omp parallel for private(i,j) \n    for (i = 0; i < height; i++) \n        for (j = 0; j < width; j++) { \n            unsigned char Y = Ydata[i * stride0 + j]; \n            unsigned char U = Udata[(i / 2) * stride1 + (j / 2)]; \n            unsigned char V = Vdata[(i / 2) * stride2 + (j / 2)]; \n            *(outR + i * width + j) = R_FROMYV(Y, V); \n            *(outG + i * width + j) = ALLDATAMONO? 128 : G_FROMYUV(Y, U, \n                                                                    V);  \n \n            *(outB + i * width + j) = ALLDATAMONO? 128 : B_FROMYU(Y, U); \n        } \n} "}
{"label": " \nint place_halos(long Nend, float *HaloMass, long Nlin, long NTotPart, float *PartX, float *PartY, float *PartZ, float *PartVX, float *PartVY, float *PartVZ,float L, float rho_ref, long seed, float mp, double *alpha, double *Malpha,long Nalpha,float *HaloX, float *HaloY, float *HaloZ, float *HaloVX, float *HaloVY, float *HaloVZ,float *HaloR,long **ListOfPart, long *NPartPerCell){ \n \n \nfprintf(stderr,\"\\tThis is place_halos.c v11\\n\"); \n \n \n \n \n\tlong i,j,k,lin_ijk, Nmin; \n\tlong *count,trials; \n\tlong ihalo,ilong, ipart,i_alpha; \n\tdouble invL = 1./L; \n\tfloat Mcell,Mhalo,Mchange;  \n\tfloat R; \n\ttime_t t0; \n\tint check; \n \n\tdouble mpart; \n\tdouble exponent; \n\tdouble TotProb; \n\tdouble *MassLeft; \n\tdouble *CumulativeProb;  \n\tlong **ListOfHalos,  *NHalosPerCell; \n\tlong Nstart=0,Nhalos; \n \n\t#ifdef VERB \n\ttime_t t1,t2,t3,t4,t4_5,t5; \n\tfloat diff; \n\t#endif \n \n\tNCells = Nlin; \n\tLbox = L; \n\t \n\tt0=time(NULL); \n\tNTotCells = NCells*NCells*NCells; \n\t \n\tMassLeft = malloc(NTotCells*sizeof(double)); \n \n \n\t \n \n\t \n \n   \n \n\tNHalosPerCell = (long *) calloc(NTotCells,sizeof(long)); \n  \tif(NHalosPerCell == NULL) { \n    \t\tfprintf(stderr,\"\\tplace_halos(): could not allocate %ld array for NHalosPerCell[]\\nABORTING\",NTotCells); \n    \t\texit(-1); \n\t} \n\tcount = (long *) calloc(NTotCells,sizeof(long)); \n  \tif(count == NULL) { \n    \t\tfprintf(stderr,\"\\tplace_halos(): could not allocate %ld array for NTotCells[]\\nABORTING\",NTotCells); \n    \t\texit(-1); \n\t} \n\tCumulativeProb = (double *) calloc(NTotCells, sizeof(double)); \n  \tif(CumulativeProb == NULL) { \n    \t\tfprintf(stderr,\"\\tplace_halos(): could not allocate %ld array for CumulativeProb[]\\nABORTING\",NTotCells); \n    \t\texit(-1); \n\t} \n\tfprintf(stderr,\"\\tUsing OMP with %d threads\\n\",omp_get_max_threads()); \n\t \n\t#ifdef MASS_OF_PARTS \n\tNexcluded = (long *) calloc(NTotCells,sizeof(long)); \n  \tif(Nexcluded == NULL) { \n    \t\tfprintf(stderr,\"\\tplace_halos(): could not allocate %ld array for Nexcluded[]\\nABORTING\",NTotCells); \n    \t\texit(-1); \n\t} \n \texcluded  = (int *) calloc(NTotPart, sizeof(long)); \n  \tif(excluded == NULL) { \n    \t\tfprintf(stderr,\"\\tplace_halos(): could not allocate %ld array for excluded[]\\nABORTING\",NTotPart); \n    \t\texit(-1); \n\t} \n\t#endif \n \n         \n \n\t#ifdef VERB \n        fprintf(stderr,\"\\tinput seed: %ld.    time0: %ld.\",seed,t0); \n\t#endif \n \n        if (seed>=0){ \n                srand(seed); \n\t\t#ifdef VERB \n        \tfprintf(stderr,\"Used: %ld \\n\",seed); \n\t\t#endif \n\t} \n        else { \n                srand(t0); \n        \tfprintf(stderr,\"Seed Used: %ld \\n\",t0); \n\t} \n \n\tmpart = (double) mp; \n\t \n \n\tNmin = (long)ceil(HaloMass[Nend-1]*0.8/mpart); \n \n\tlcell = (float) L/NCells; \n\t#ifdef VERB \n\tfprintf(stderr,\"\\n\\tParticles and Halos placed in %ld^3 cells\\n\",NCells); \n\tfprintf(stderr,\"\\tBOX = %f  lcell =%f   rho_ref = %e  invL %f\\n\",L,L/NCells,rho_ref,invL); \n\tfprintf(stderr,\"\\tNhalostart = %ld,Nhalosend = %ld,  NPart = %ld\\n\",Nstart, Nend, NTotPart); \n\t#endif \n\t \n \n\t#ifdef DEBUG \n\tfprintf(stderr,\"\\n\\tRAND_MAX=%d\\n\",RAND_MAX); \n\tfprintf(stderr,\"\\tX[0] = %f Y[0] = %f Z[0] = %f\\n\",PartX[0],PartY[0],PartZ[0]); \n\tfprintf(stderr,\"\\tX[1] = %f Y[1] = %f Z[1] = %f\\n\",PartX[1],PartY[1],PartZ[1]); \n\tfprintf(stderr,\"\\tM[0] = %e \\n\",HaloMass[0]); \n\tfprintf(stderr,\"\\tM[1] = %e \\n\",HaloMass[1]); \n\tfprintf(stderr,\"\\tM[%ld] = %e \\n\",Nend-1,HaloMass[Nend-1]); \n\tfprintf(stderr,\"\\n\\tMinimmum mass= %e. Minimum part per halo = %ld. mpart %e\\n\",HaloMass[Nend-1],Nmin,mpart); \n\t#endif\t \n\t \n\tif (L/NCells<R_from_mass(HaloMass[0],rho_ref)){ \n\t\tfprintf(stderr,\"ERROR: cell size is smaller than the radius of the biggest halo. Please, change the number of cells\\n\"); \n\t\texit(0); \n\t} \n\t \n\t#ifdef VERB \n\tt1=time(NULL); \n \tdiff = difftime(t1,t0); \n\tfprintf(stderr,\"\\ttime of initialisation %f\\n\",diff); \n\t#endif \n \n \n \n \n \n\tfprintf(stderr,\"\\tAssigning particles to grid...\\n\"); \n \n \n \n \n\t \n \n\t \n \n\tfprintf(stderr,\"\\t... particles counted...\\n\"); \n\tt2=time(NULL); \n \tdiff = difftime(t2,t1); \n\tfprintf(stderr,\"\\ttime counting %f\\n\",diff); \n\t \n \n\t \n \n\tListOfHalos = (long **) calloc(NCells*NCells*NCells,sizeof(long *)); \n\tfor (i", "pred": " \nint place_halos(long Nend, float *HaloMass, long Nlin, long NTotPart, float *PartX, float *PartY, float *PartZ, float *PartVX, float *PartVY, float *PartVZ,float L, float rho_ref, long seed, float mp, double *alpha, double *Malpha,long Nalpha,float *HaloX, float *HaloY, float *HaloZ, float *HaloVX, float *HaloVY, float *HaloVZ,float *HaloR,long **ListOfPart, long *NPartPerCell){ \n \n \nfprintf(stderr,\"\\tThis is place_halos.c v11\\n\"); \n \n \n \n \n\tlong i,j,k,lin_ijk, Nmin; \n\tlong *count,trials; \n\tlong ihalo,ilong, ipart,i_alpha; \n\tdouble invL = 1./L; \n\tfloat Mcell,Mhalo,Mchange;  \n\tfloat R; \n\ttime_t t0; \n\tint check; \n \n\tdouble mpart; \n\tdouble exponent; \n\tdouble TotProb; \n\tdouble *MassLeft; \n\tdouble *CumulativeProb;  \n\tlong **ListOfHalos,  *NHalosPerCell; \n\tlong Nstart=0,Nhalos; \n \n\t#ifdef VERB \n\ttime_t t1,t2,t3,t4,t4_5,t5; \n\tfloat diff; \n\t#endif \n \n\tNCells = Nlin; \n\tLbox = L; \n\t \n\tt0=time(NULL); \n\tNTotCells = NCells*NCells*NCells; \n\t \n\tMassLeft = malloc(NTotCells*sizeof(double)); \n \n \n\t \n \n\t \n \n   \n \n\tNHalosPerCell = (long *) calloc(NTotCells,sizeof(long)); \n  \tif(NHalosPerCell == NULL) { \n    \t\tfprintf(stderr,\"\\tplace_halos(): could not allocate %ld array for NHalosPerCell[]\\nABORTING\",NTotCells); \n    \t\texit(-1); \n\t} \n\tcount = (long *) calloc(NTotCells,sizeof(long));                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "}
{"label": " \nvoid set_grid_ptrs( GridPoint * energy_grid, NuclideGridPoint ** nuclide_grids, \n                    long n_isotopes, long n_gridpoints ) \n{ \n\tint mype = 0; \n \n\t#ifdef MPI \n\tMPI_Comm_rank(MPI_COMM_WORLD, &mype); \n\t#endif \n\t \n\tif( mype == 0 ) printf(\"Assigning pointers to Unionized Energy Grid...\\n\"); \n\t#ifdef OPENMP \n #pragma omp parallel for default(none)   shared( energy_grid, nuclide_grids, n_isotopes, n_gridpoints, mype ) \n\t#endif \n\tfor( long i = 0; i < n_isotopes * n_gridpoints ; i++ ) \n\t{ \n\t\tint nthreads = 1, tid = 0; \n\t\tdouble quarry = energy_grid[i].energy; \n \n\t\t#ifdef OPENMP \n\t\tnthreads = omp_get_num_threads(); \n\t\ttid = omp_get_thread_num(); \n\t\t#endif \n \n\t\tif( INFO && mype == 0 && tid == 0 && i % 200 == 0 ) \n\t\t\tprintf(\"\\rAligning Unionized Grid...(%.0lf%% complete)\", \n\t\t\t       100.0 * (double) i / (n_isotopes*n_gridpoints / \n\t\t\t\t                         nthreads)     ); \n\t\tfor( long j = 0; j < n_isotopes; j++ ) \n\t\t{ \n\t\t\t \n \n\t\t\t \n \n\t\t\tenergy_grid[i].xs_ptrs[j] =  \n\t\t\t\tbinary_search( nuclide_grids[j], quarry, n_gridpoints); \n\t\t} \n\t} \n\tif( mype == 0 ) printf(\"\\n\"); \n \n\t \n \n\t \n \n} ", "pred": " \nvoid set_grid_ptrs( GridPoint * energy_grid, NuclideGridPoint ** nuclide_grids, \n                    long n_isotopes, long n_gridpoints ) \n{ \n\tint mype = 0; \n \n\t#ifdef MPI \n\tMPI_Comm_rank(MPI_COMM_WORLD, &mype); \n\t#endif \n\t \n\tif( mype == 0 ) printf(\"Assigning pointers to Unionized Energy Grid...\\n\"); \n\t#ifdef OPENMP \n #pragma omp parallel for default(none)   shared( energy_grid, nuclide_grids, n_isotopes, n_gridpoints, mype ) \n\t#endif \n\tfor( long i = 0; i < n_isotopes * n_gridpoints ; i++ ) \n\t{ \n\t\tint nthreads = 1, tid = 0; \n\t\tdouble quarry = energy_grid[i].energy; \n \n\t\t#ifdef OPENMP \n\t\tnthreads = omp_get_num_threads(); \n\t\ttid = omp_get_thread_num(); \n\t\t#endif \n \n\t\tif( INFO && mype == 0 && tid == 0 && i % 200 == 0 ) \n\t\t\tprintf(\"\\rAligning Unionized Grid...(%.0lf%% complete)\", \n\t\t\t       100.0 * (double) i / (n_isotopes*n_gridpoints / \n\t\t\t\t                         nthreads)     ); \n\t\tfor( long j = 0; j < n_isotopes; j++ ) \n\t\t{ \n\t\t\t \n \n\t\t\t \n \n\t\t\tenergy_grid[i].xs_ptrs[j] =  \n\t\t\t\tbinary_search( nuclide_grids[j], quarry, n_gridpoints); \n\t\t} \n\t} \n\tif( mype == 0 ) printf(\"\\n\"); \n \n\t \n \n\t \n \n} "}
{"label": "d RK_out(real *dest, real *fwn, real *fdtwn, const real dt,  \n\t    const int sizew) \n{ \n#pragma omp parallel for \n  for(int iw = 0; iw < sizew; iw++) { \n    dest[iw] = fwn[iw] + dt * fdtwn[iw]; \n  } \n} \n \n \n ", "pred": "d RK_out(real *dest, real *fwn, real *fdtwn, const real dt,  \n\t    const int sizew) \n{ \n#pragma omp parallel for \n  for(int iw = 0; iw < sizew; iw++) { \n    dest[iw] = fwn[iw] + dt * fdtwn[iw]; \n  } \n} \n \n \n "}
{"label": "  int\tcnt = 0; \n \n  for (i = 1; i<thds; i*=2) \n    ; \n \n  #pragma omp parallel for \n  for (lp=thds1; lp>0; lp=lp/2) { \n    buf[cnt ++] += omp_get_num_threads (); \n  } \n} \n \n \nmain () \n{ \n  thds = omp_get_max_thre ", "pred": "  int\tcnt = 0; \n \n  for (i = 1; i<thds; i*=2) \n    ; \n \n  #pragma omp parallel for \n  for (lp=thds1; lp>0; lp=lp/2) { \n    buf[cnt ++] += omp_get_num_threads (); \n  } \n} \n \n \nmain () \n{ \n  thds = omp_get_max_thre "}
{"label": "d RK4_final_inplace(real *w, real *l1, real *l2, real *l3,  \n\t\t       real *dtw, const real dt, const int sizew) \n{ \n  const real b = -1.0 / 3.0; \n  const real a[] = {1.0 / 3.0, 2.0 / 3.0, 1.0 / 3.0, dt / 6.0}; \n#pragma omp parallel for \n  for(int i = 0; i < sizew; ++i) { \n    w[i] =  \n      b * w[i] + \n      a[0] * l1[i] + \n      a[1] * l2[i] + \n      a[2] * l3[i] + \n      a[3] * dtw[i]; \n  } \n} \n \n \n ", "pred": "d RK4_final_inplace(real *w, real *l1, real *l2, real *l3,  \n\t\t       real *dtw, const real dt, const int sizew) \n{ \n  const real b = -1.0 / 3.0; \n  const real a[] = {1.0 / 3.0, 2.0 / 3.0, 1.0 / 3.0, dt / 6.0}; \n#pragma omp parallel for \n  for(int i = 0; i < sizew; ++i) { \n    w[i] =  \n      b * w[i] + \n      a[0] * l1[i] + \n      a[1] * l2[i] + \n      a[2] * l3[i] + \n      a[3] * dtw[i]; \n  } \n} \n \n \n "}
{"label": " \nint main() \n{ \n    int i; \n    #pragma omp parallel for firstprivate(i) \n    for (i = 0; i  < 100; ++i) \n    { \n    } \n} ", "pred": " \nint main() \n{ \n    int i; \n    #pragma omp parallel for firstprivate(i) \n    for (i = 0; i  < 100; ++i) \n    { \n    } \n} "}
{"label": " \nvoid recombine2d_pf1_ft1_es1_omp(struct recombine2d_worker *worker, \n                                 int subgrid_off1, \n                                 complex double *F, \n                                 complex double *NMBF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n    int y; \n \n    int BF_chunk_size = sizeof(double complex) * cfg->yP_size * worker->BF_batch; \n    double complex *BF_chunk = malloc(BF_chunk_size); \n    assert(cfg->BF_stride1 == 1); \n    assert(cfg->NMBF_BF_stride0 == 1); \n    assert(cfg->BF_stride0 == cfg->NMBF_BF_stride1); \n    assert(subgrid_off1 % cfg->subgrid_spacing == 0); \n \n#pragma omp for schedule(dynamic) \n    for (y = 0; y < cfg->yB_size; y+=worker->BF_batch) { \n \n         \n \n        double start = get_time_ns(); \n        int y2; \n        for (y2 = y; y2 < y+worker->BF_batch && y2 < cfg->yB_size; y2++) { \n            prepare_facet(cfg->yB_size, cfg->yP_size, cfg->Fb, \n                          F+y2*cfg->F_stride0, cfg->F_stride1, \n                          BF_chunk+(y2-y)*cfg->BF_stride0, cfg->BF_stride1); \n        } \n        worker->pf1_time += get_time_ns() - start; \n \n         \n \n        start = get_time_ns(); \n        fftw_execute_dft(worker->BF_plan, BF_chunk, BF_chunk); \n        worker->ft1_time += get_time_ns() - start; \n \n         \n \n        assert(subgrid_off1 % cfg->subgrid_spacing == 0); \n        int subgrid_offset = subgrid_off1 / cfg->subgrid_spacing * cfg->yP_spacing; \n        start = get_time_ns(); \n        for (y2 = y; y2 < y+worker->BF_batch && y2 < cfg->yB_size; y2++) { \n            extract_subgrid(cfg->yP_size, cfg->xM_yP_size, cfg->xMxN_yP_size, cfg->xM_yN_size, \n                            subgrid_offset, cfg->m, cfg->Fn, \n                            BF_chunk+(y2-y)*cfg->BF_stride0, cfg->BF_stride1, \n                            worker->MBF, worker->MBF_plan, \n                            NMBF+y2*cfg->NMBF_stride0, cfg->NMBF_stride1); \n        } \n        worker->es1_time += get_time_ns() - start; \n \n    } \n \n    free(BF_chunk); \n} ", "pred": " \nvoid recombine2d_pf1_ft1_es1_omp(struct recombine2d_worker *worker, \n                                 int subgrid_off1, \n                                 complex double *F, \n                                 complex double *NMBF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n    int y; \n \n    int BF_chunk_size = sizeof(double complex) * cfg->yP_size * worker->BF_batch; \n    double complex *BF_chunk = malloc(BF_chunk_size); \n    assert(cfg->BF_stride1 == 1); \n    assert(cfg->NMBF_BF_stride0 == 1); \n    assert(cfg->BF_stride0 == cfg->NMBF_BF_stride1); \n    assert(subgrid_off1 % cfg->subgrid_spacing == 0); \n \n#pragma omp for schedule(dynamic) \n    for (y = 0; y < cfg->yB_size; y+=worker->BF_batch) { \n \n         \n \n        double start = get_time_ns(); \n        int y2; \n        for (y2 = y; y2 < y+worker->BF_batch && y2 < cfg->yB_size; y2++) { \n            prepare_facet(cfg->yB_size, cfg->yP_size, cfg->Fb, \n                          F+y2*cfg->F_stride0, cfg->F_stride1, \n                          BF_chunk+(y2-y)*cfg->BF_stride0, cfg->BF_stride1);}\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \ndouble **background_fsp(scan_t *scan_obj, int force_neutral_spectrum, \n\t\t\tchar *background_fsfname, int include_invariant) { \n  int m, k, i, depth, max_depth; \n  int __attribute__((unused))max_depth_p; \n  double fsp_sum, **fsp, *tmp_fsp, wa, wd; \n  int n_complete; \n \n  omp_init_lock(&thread_lock); \n  if (force_neutral_spectrum) return neutral_spectra(scan_obj); \n  if (background_fsfname) return load_spectra(scan_obj, background_fsfname); \n \n  logmsg(MSG_STATUS,\"Estimating background site frequency spectrum....   \"); \n  MA(fsp, sizeof(double *)*scan_obj->n_depths); \n  max_depth_p = -1; \n  max_depth = -1000; \n  for(m=0;m<scan_obj->n_depths;m++) { \n    MA(fsp[m], sizeof(double)*(scan_obj->sample_depths[m]+1)); \n    for(k=0;k<=scan_obj->sample_depths[m];k++) fsp[m][k] = 0.; \n \n    if (scan_obj->sample_depths[m] > max_depth) { \n      max_depth = scan_obj->sample_depths[m]; \n      max_depth_p = m; \n    } \n  } \n  log_fact(max_depth+1); \n  logmsg(MSG_STATUS,\"%d distinct sample depths observed. Maximum sample depth is %d haplotypes.\", scan_obj->n_depths, max_depth); \n  logmsg(MSG_DEBUG1,\"log(%d!) = %1.1f\", max_depth, log_fact(max_depth));  \n   \n  MA(tmp_fsp, sizeof(double)*(max_depth+1)); \n  for(k=0;k<=max_depth;k++) tmp_fsp[k] = 0.; \n  for(i=0;i<scan_obj->n_snps;i++) { \n     \n \n    depth = scan_obj->sample_depths[scan_obj->snps[i].depth_p]; \n    if (scan_obj->snps[i].folded) { \n      if (scan_obj->snps[i].obs_freq == 0) { \n\twa = 1; \n\twd = 0; \n      } else if (scan_obj->snps[i].obs_freq == depth) { \n\twa = 0; \n\twd = 1; \n      } else { \n\twa = 1./(scan_obj->snps[i].obs_freq); \n\twd = 1./(depth - scan_obj->snps[i].obs_freq); \n      } \n    } else { \n      wd = 1.; \n      wa = 0.; \n    } \n \n    if (depth == max_depth) { \n      tmp_fsp[scan_obj->snps[i].obs_freq] += wa/(wa + wd); \n      tmp_fsp[depth - scan_obj->snps[i].obs_freq] += wd/(wa + wd); \n    } else { \n       \n \n       \n \n       \n \n       \n \n    } \n  } \n \n  fsp_sum = 0.; \n  for(k=0;k<=max_depth;k++) fsp_sum += tmp_fsp[k]; \n  for(k=0;k<=max_depth;k++) tmp_fsp[k] /= fsp_sum; \n  logmsg(MSG_STATUS,\"Total SNPs observed at max depth %d is %1.1f (%1.1f%%)\", max_depth, fsp_sum, fsp_sum/(double) scan_obj->n_snps * 100.);   \n \n  n_complete = 0; \n#pragma omp parallel for schedule(dynamic, 2) \n  for(m=0;m<scan_obj->n_depths;m++) { \n    int k, depth; \n    double fsp_sum; \n \n    depth = scan_obj->sample_depths[m]; \n    hypergeometric_downsample_fsp(fsp[m], tmp_fsp, depth, \n\t\t\t\t  max_depth, include_invariant); \n     \n    fsp_sum = 0.; \n    for(k=0;k<=depth;k++) fsp_sum += fsp[m][k]; \n    for(k=0;k<=depth;k++) fsp[m][k] /= fsp_sum; \n \n    omp_set_lock(&thread_lock); \n    n_complete++; \n    cr_logmsg(MSG_STATUS,\"Estimating frequency spectrum for different sample\" \n\t    \" depths (%1.1f%%)\", n_complete/(double) scan_obj->n_depths * 100.); \n    omp_unset_lock(&thread_lock); \n  } \n  logmsg(MSG_STATUS,\"\\nDone estimating background frequency spectra.\"); \n \n  for(m=0;m<scan_obj->n_depths;m++) { \n    depth = scan_obj->sample_depths[m]; \n    MA(fsp[m], sizeof(double)*(depth+1)); \n \n    for(k=0;k<=depth;k++) fsp[m][k] = 0.; \n \n    for(i=0;i<scan_obj->n_snps;i++) { \n      if (scan_obj->snps[i].folded) { \n\tif (scan_obj->snps[i].obs_freq == 0) { \n\t  wa = 1; \n\t  wd = 0; \n\t} else if (scan_obj->snps[i].obs_freq == depth) { \n\t  wa = 1; \n\t  wd = 0; \n\t} else { \n\t  wa = 1./(scan_obj->snps[i].obs_freq); \n\t  wd = 1./(depth - scan_obj->snps[i].obs_freq); \n\t} \n      } else { \n\twd = 1.; \n\twa = 0.; \n      } \n \n      if (scan_obj->snps[i].depth_p == m) { \n\tfsp[m][scan_obj->snps[i].obs_freq] += wd/(wa+wd); \n\tfsp[m][depth - scan_obj->snps[i].obs_freq] += wa/(wa+wd); \n      } else { \n\tbinomial_sampling(fsp[m], wd/(wa+wd), depth,  \n\t\t\t  scan_obj->snps[i].obs_freq,  \n\t\t\t  scan_obj->sample_depths[scan_obj->snps[i].depth_p]); \n\tif (wa > 0.) \n\t  binomial_sampling(fsp[m], wa/(wa+wd), depth,  \n\t\t\t  scan_obj->sample_depths[scan_obj->snps[i].depth_p] - \n\t\t\t  scan_obj->snps[i].obs_freq,  \n\t\t\t  scan_obj->sample_depths[scan_obj->snps[i].depth_p]); \n      } ", "pred": " \ndouble **background_fsp(scan_t *scan_obj, int force_neutral_spectrum, \n\t\t\tchar *background_fsfname, int include_invariant) { \n  int m, k, i, depth, max_depth; \n  int __attribute__((unused))max_depth_p; \n  double fsp_sum, **fsp, *tmp_fsp, wa, wd; \n  int n_complete; \n \n  omp_init_lock(&thread_lock); \n  if (force_neutral_spectrum) return neutral_spectra(scan_obj); \n  if (background_fsfname) return load_spectra(scan_obj, background_fsfname); \n \n  logmsg(MSG_STATUS,\"Estimating background site frequency spectrum....   \"); \n  MA(fsp, sizeof(double *)*scan_obj->n_depths); \n  max_depth_p = -1; \n  max_depth = -1000; \n  for(m=0;m<scan_obj->n_depths;m++) { \n    MA(fsp[m], sizeof(double)*(scan_obj->sample_depths[m]+1)); \n    for(k=0;k<=scan_obj->sample_depths[m];k++) fsp[m][k] = 0.; \n \n    if (scan_obj->sample_depths[m] > max_depth) { \n      max_depth = scan_obj->sample_depths[m]; \n      max_depth_p = m; \n    } \n  } \n  log_fact(max_depth+1); \n  logmsg(MSG_STATUS,\"%d distinct sample depths observed. Maximum sample depth is %d haplotypes.\", scan_obj->n_depths, max_depth); \n  logmsg(MSG_DEBUG1,\"log(%d!) = %1.1f\", max_depth, log_fact(max_depth));  \n   \n  MA(tmp_fsp, sizeof(double)*(max_depth+1)); \n  for(k=0;k<=max_depth;k++) tmp_fsp[k] = 0.; \n  for(i=0;i<scan_obj->n_snps;i++) { \n     \n \n    depth = scan_obj->sample_depths[scan_obj->sample_depths[i];                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "}
{"label": " \nvoid mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) \n{ \n\t \n \n\tif(nrhs!= 11) \n    { \n\t\tmexWarnMsgTxt(\"11 inputs required. Aborting...\"); \n\t\treturn; \n    } \n\telse if(nlhs < 1) \n    { \n\t\tmexWarnMsgTxt(\"At least one output required. Aborting...\"); \n\t\treturn; \n\t} \n \n\t \n \n\tint i, curr_angle, im_size, n_rays_y, n_rays_z, curr_ray_y, curr_ray_z, n_angles, ray_offset; \n\tmwSize im_size_matlab[3]; \n\tdouble *source_x, *source_y, *source_z, *det_x, *det_y, *det_z; \n    double cos_curr_angle, sin_curr_angle; \n\tdouble start[3], end[3], *voxel_size, *grid_offset, *angles; \n    float *ray_data, *vol_data; \n    double *size_doubles; \n \n\tstruct jacobs_options options; \n\t \n\t \n \n\tsize_doubles = mxGetPr(prhs[0]); \n\tfor(i = 0; i < 3; i++) \n    { \n\t    im_size_matlab[i] = (int) size_doubles[i]; \n    } \n \n\t \n \n\tn_rays_y = mxGetM(prhs[5]); \n    n_rays_z = mxGetM(prhs[6]); \n     \n     \n \n \tsource_x = mxGetPr(prhs[1]);  \n \tsource_y = mxGetPr(prhs[2]);  \n \tsource_z = mxGetPr(prhs[3]);  \n \tdet_x = mxGetPr(prhs[4]);  \n \tdet_y = mxGetPr(prhs[5]);  \n \tdet_z = mxGetPr(prhs[6]);  \n \n\t \n \n\tvoxel_size = mxGetPr(prhs[7]); \n\tgrid_offset = mxGetPr(prhs[8]); \n     \n    vol_data = (float *) mxGetData(prhs[9]); \n     \n    angles = mxGetPr(prhs[10]); \n     \n    n_angles = mxGetM(prhs[10]); \n     \n     \n \n    if (mxGetM(prhs[9])!= (im_size_matlab[0] * im_size_matlab[1] * im_size_matlab[2])) \n    { \n        mexWarnMsgTxt(\"Mismatched number of voxels! Aborting.\"); \n        return; \n    } \n \n\t \n \n\toptions.im_size_default = 0; \n\toptions.im_size_x = im_size_matlab[0]; \n\toptions.im_size_y = im_size_matlab[1]; \n\toptions.im_size_z = im_size_matlab[2]; \n \n\toptions.b_default = 0; \n\toptions.b_x = grid_offset[0]; \n\toptions.b_y = grid_offset[1]; \n\toptions.b_z = grid_offset[2]; \n \n\toptions.d_default = 0; \n\toptions.d_x = voxel_size[0]; \n\toptions.d_y = voxel_size[1]; \n\toptions.d_z = voxel_size[2]; \n \n\t \n \n\tplhs[0] = mxCreateNumericMatrix(n_rays_y * n_rays_z * n_angles, 1, mxSINGLE_CLASS, mxREAL); \n\tray_data = (float *) mxGetData(plhs[0]); \n \n\t \n \n    #pragma omp parallel for shared(source_x, source_y, source_z, det_x, det_y, det_z, im_size, ray_data, vol_data, angles, options, n_angles, n_rays_y, n_rays_z) private(curr_angle, curr_ray_y, curr_ray_z, cos_curr_angle, sin_curr_angle, start, end, ray_offset) schedule(dynamic) \n    for(curr_angle = 0; curr_angle < n_angles; curr_angle++) \n    {    \t \n         \n \n        cos_curr_angle = cos(angles[curr_angle]); \n        sin_curr_angle = sin(angles[curr_angle]); \n         \n        start[0] = cos_curr_angle * (*source_x) - sin_curr_angle * (*source_y); \n        start[1] = sin_curr_angle * (*source_x) + cos_curr_angle * (*source_y); \n        start[2] = *source_z; \n         \n        ray_offset = curr_angle * n_rays_y * n_rays_z; \n         \n         \n \n        for(curr_ray_y = 0; curr_ray_y < n_rays_y; curr_ray_y++) \n        { \n            end[0] = cos_curr_angle * (*det_x) - sin_curr_angle * det_y[curr_ray_y]; \n            end[1] = sin_curr_angle * (*det_x) + cos_curr_angle * det_y[curr_ray_y]; \n             \n             \n \n            for(curr_ray_z = 0; curr_ray_z < n_rays_z; curr_ray_z++) \n            { \n                end[2] = det_z[curr_ray_z]; \n \n\t\t\t\t \n \n                project_singledata(im_size, start, end, &ray_data[ray_offset + curr_ray_z*n_rays_y + curr_ray_y], vol_data, &options); \n            } \n        } \n    } \n} ", "pred": " \nvoid mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) \n{ \n\t \n \n\tif(nrhs!= 11) \n    { \n\t\tmexWarnMsgTxt(\"11 inputs required. Aborting...\"); \n\t\treturn; \n    } \n\telse if(nlhs < 1) \n    { \n\t\tmexWarnMsgTxt(\"At least one output required. Aborting...\"); \n\t\treturn; \n\t} \n \n\t \n \n\tint i, curr_angle, im_size, n_rays_y, n_rays_z, curr_ray_y, curr_ray_z, n_angles, ray_offset; \n\tmwSize im_size_matlab[3]; \n\tdouble *source_x, *source_y, *source_z, *det_x, *det_y, *det_z; \n    double cos_curr_angle, sin_curr_angle; \n\tdouble start[3], end[3], *voxel_size, *grid_offset, *angles; \n    float *ray_data, *vol_data; \n    double *size_doubles; \n \n\tstruct jacobs_options options; \n\t \n\t \n \n\tsize_doubles = mxGetPr(prhs[0]); \n\tfor(i = 0; i < 3; i++) \n    { \n\t    im_size_matlab[i] = (int) size_doubles[i]; \n    } \n \n\t \n \n\tn_rays_y = mxGetM(prhs[5]); \n    n_rays_z = mxGetM(prhs[6]); \n     \n     \n \n \tsource_x = mxGetPr(prhs[1]);  \n \tsource_y = mxGetPr(prhs[2]);  \n \tsource_z = mxGetPr(prhs[3]);  \n \tdet_x = mxGetPr(prhs[4]);  \n \tdet_y = mxGetPr(prhs[5]);  \n \tdet_z = mxGetPr(prhs[6]);  \n \n\t \n \n\tvoxel_x = mxGetPr(prhs[7]);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 32; \n  tile_size[3] = 32; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,4);t1++) { \n    lbp=max(ceild(t1,2),ceild(8*t1-Nt+3,8)); \n    ubp=min(floord(Nt+Nz-4,8),floord(4*t1+Nz+1,8)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-7,8)),ceild(8*t2-Nz-28,32));t3<=min(min(min(floord(Nt+Ny-4,32),floord(4*t1+Ny+5,32)),floord(8*t2+Ny+4,32)),floord(8*t1-8*t2+Nz+Ny+3,32));t3++) { \n        for (t4=max(max(max(0,ceild(t1-7,8)),ceild(8*t2-Nz-28,32)),ceild(32*t3-Ny-28,32));t4<=min(min(min(min(floord(Nt+Nx-4,32),floord(4*t1+Nx+5,32)),floord(8*t2+Nx+4,32)),floord(32*t3+Nx+28,32)),floord(8*t1-8*t2+Nz+Nx+3,32));t4++) { \n          for (t5=max(max(max(max(max(0,4*t1),8*t1-8*t2+1),8*t2-Nz+2),32*t3-Ny+2),32*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,4*t1+7),8*t2+6),32*t3+30),32*t4+30),8*t1-8*t2+Nz+5);t5++) { \n            for (t6=max(max(8*t2,t5+1),-8*t1+8*t2+2*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(32*t3,t5+1);t7<=min(32*t3+31,t5+N", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *) tile_size, sizeof(int)*Nz);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": " \nvoid \ntime_3d_complex_double_omp() \n{ \n  int nthr = omp_get_max_threads(); \n  int nthr = 1; \n  int nnodes = nthr; \n  fprintf (stderr, \"Using %d threads.\\n\", nthr); \n \n  int Nx=32; int Ny=32; int Nz = 32; \n  int num_splines = 256; \n \n  Ugrid x_grid, y_grid, z_grid; \n  x_grid.start = 3.1; x_grid.end =  9.1; x_grid.num = Nx; \n  y_grid.start = 8.7; y_grid.end = 12.7; y_grid.num = Ny; \n  z_grid.start = 4.5; z_grid.end =  9.3; z_grid.num = Nz; \n \n  BCtype_z xBC, yBC, zBC; \n  xBC.lCode = xBC.rCode = PERIODIC; \n  yBC.lCode = yBC.rCode = PERIODIC; \n  zBC.lCode = zBC.rCode = PERIODIC; \n \n   \n \n  UBspline_3d_z* norm_splines[num_splines]; \n  multi_UBspline_3d_z *multi_spline[nthr]; \n   \n   \n \n#pragma omp parallel for \n  for (int node=0; node<nthr; node++)  \n  { \n     \n \n     \n \n     \n \n     \n \n    multi_spline[node] = create_multi_UBspline_3d_z \n      (x_grid, y_grid, z_grid, xBC, yBC, zBC, num_splines); \n  } \n \n  double data[Nx*Ny*Nz*2]; \n   \n \n  for (int i=0; i<num_splines; i++) { \n    for (int j=0; j<Nx*Ny*Nz; j++) \n      data[j] = (drand48()-0.5); \n    norm_splines[i] = create_UBspline_3d_z \n      (x_grid, y_grid, z_grid, xBC, yBC, zBC, (complex_double*)data); \n#pragma omp parallel for     \n    for (int node=0; node<nthr; node++) { \n       \n \n       \n \n       \n \n       \n \n      set_multi_UBspline_3d_z (multi_spline[node], i, data); \n    } \n  } \n   \n   \n \n  double rand_start, rand_end, norm_start[nthr], norm_end[nthr], multi_start[nthr], multi_end[nthr]; \n  int num_vals = 10000; \n  complex_double multi_vals[nthr][num_splines], norm_vals[nthr][num_splines]; \n  complex_double multi_grads[nthr][3*num_splines], norm_grads[nthr][3*num_splines]; \n  complex_double multi_lapl[nthr][num_splines], norm_lapl[nthr][num_splines]; \n  complex_double multi_hess[nthr][9*num_splines], norm_hess[nthr][9*num_splines]; \n \n  rand_start = get_time(); \n  for (int i=0; i<num_vals; i++) { \n    double rx = drand48();  double x = rx*x_grid.start + (1.0-rx)*x_grid.end; \n    double ry = drand48();  double y = ry*y_grid.start + (1.0-ry)*y_grid.end; \n    double rz = drand48();  double z = rz*z_grid.start + (1.0-rz)*z_grid.end; \n  } \n  rand_end = get_time(); \n \n   \n \n   \n \n   \n \n  double rx = drand48();  double x = rx*x_grid.start + (1.0-rx)*x_grid.end; \n  double ry = drand48();  double y = ry*y_grid.start + (1.0-ry)*y_grid.end; \n  double rz = drand48();  double z = rz*z_grid.start + (1.0-rz)*z_grid.end; \n \n  int thr_per_node = nthr/nthr; \n \n#pragma omp parallel for \n  for (int thr=0; thr<nthr; thr++) { \n    int node = thr/thr_per_node; \n    multi_start[thr] = get_time(); \n    for (int i=0; i<num_vals; i++) { \n      double rx = drand48();  double x = rx*x_grid.start + (1.0-rx)*x_grid.end;  \n      double ry = drand48();  double y = ry*y_grid.start + (1.0-ry)*y_grid.end;  \n      double rz = drand48();  double z = rz*z_grid.start + (1.0-rz)*z_grid.end;  \n      eval_multi_UBspline_3d_z (multi_spline[node], x, y, z, multi_vals[thr]); \n    } \n    multi_end[thr] = get_time(); \n  } \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n   \n  double norm_avg=0.0, multi_avg=0.0; \n \n  for (int thr=0; thr<nthr; thr++) { \n    double norm_time   = (double)(norm_end[thr] - norm_start[thr] + rand_start - rand_end); \n    double multi_time  = (double)(multi_end[thr] - multi_start[thr] + rand_start - rand_end); \n    norm_avg += norm_time; \n    multi_avg += multi_time; \n  } \n  norm_avg  /= nthr; \n  multi_avg /= nthr; \n  double norm_speed  = (double) num_vals*num_splines / norm_avg; \n  double multi_speed = (double) num_vals*num_splines / multi_avg; \n \n   \n \n   \n \n  fprintf (stderr, \"Multi  value speed = %13.3f evaluations per second.\\n\",  \n  \t   multi_speed); \n  fprintf (stderr, \"Aggregate bandwidth = %1.3f GB/s per socket\\n\", multi_speed * 64.0*16.0 * 8 * 1.0e-9); \n  fprintf (stderr, \"%1.3f GFLOPS per socket\\n\", multi_speed * 64.0*4.0 * 8 * 1.0e-9); \n \n   \n   \n \n   \n \n   \n \n#pragma omp parallel for \n  for (int thr=0; thr<nth", "pred": " \nvoid \ntime_3d_complex_double_omp() \n{ \n  int nthr = omp_get_max_threads(); \n  int nthr = 1; \n  int nnodes = nthr; \n  fprintf (stderr, \"Using %d threads.\\n\", nthr); \n \n  int Nx=32; int Ny=32; int Nz = 32; \n  int num_splines = 256; \n \n  Ugrid x_grid, y_grid, z_grid; \n  x_grid.start = 3.1; x_grid.end =  9.1; x_grid.num = Nx; \n  y_grid.start = 8.7; y_grid.end = 12.7; y_grid.num = Ny; \n  z_grid.start = 4.5; z_grid.end =  9.3; z_grid.num = Nz; \n \n  BCtype_z xBC, yBC, zBC; \n  xBC.lCode = xBC.rCode = PERIODIC; \n  yBC.lCode = yBC.rCode = PERIODIC; \n  zBC.lCode = zBC.rCode = PERIODIC; \n \n   \n \n  UBspline_3d_z* norm_splines[num_splines]; \n  multi_UBspline_3d_z *multi_spline[nthr]; \n   \n   \n \n#pragma omp parallel for \n  for (int node=0; node<nthr; node++)  \n  { \n     \n \n     \n \n     \n \n     \n \n    multi_spline[node] = create_multi_UBspline_3d_z \n      (x_grid, y_grid, z_grid, xBC, yBC, zBC, num_splines); \n  } \n \n  double data[Nx*Ny*Nz*2]; \n   \n \n  for (int i=0; i<num_splines; i++) { \n    for (int j=0; j<Nx*Ny*Nz; j++) \n      data[j] = (drand48()-0.5); \n    norm_splines[i] = 0;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "}
{"label": " \nint transfer_init( \n    struct precision * ppr, \n    struct background * pba, \n    struct thermo * pth, \n    struct perturbs * ppt, \n    struct nonlinear * pnl, \n    struct transfers * ptr \n) { \n \n     \n \n \n     \n \n \n     \n \n    int index_q; \n \n     \n \n    double tau0; \n     \n \n    double tau_rec; \n     \n \n    double q_period; \n \n     \n \n    int tau_size_max; \n \n     \n \n    double *** sources; \n \n     \n \n    double *** sources_spline; \n \n     \n \n    struct transfer_workspace * ptw; \n \n     \n \n    int ** tp_of_tt; \n \n     \n \n \n    HyperInterpStruct BIS; \n    double xmax; \n \n     \n \n    int abort; \n \n \n     \n \n    double tstart, tstop, tspent; \n \n \n     \n \n \n    if (ppt->has_cls == _FALSE_) { \n        ptr->has_cls = _FALSE_; \n        if (ptr->transfer_verbose > 0) \n            printf(\"No harmonic space transfer functions to compute. Transfer module skipped.\\n\"); \n        return _SUCCESS_; \n    } \n    else \n        ptr->has_cls = _TRUE_; \n \n    if (ptr->transfer_verbose > 0) \n        fprintf(stdout,\"Computing transfers\\n\"); \n \n     \n \n \n    ptr->md_size = ppt->md_size; \n \n     \n \n \n    tau0 = pba->conformal_age; \n    tau_rec = pth->tau_rec; \n \n     \n \n \n    ptr->angular_rescaling = pth->angular_rescaling; \n \n     \n \n \n    q_period = 2.*_PI_/(tau0-tau_rec)*ptr->angular_rescaling; \n \n     \n \n \n    class_call(transfer_indices_of_transfers(ppr,ppt,ptr,q_period,pba->K,pba->sgnK), \n               ptr->error_message, \n               ptr->error_message); \n \n     \n \n \n    class_alloc(sources, \n                ptr->md_size*sizeof(double**), \n                ptr->error_message); \n \n    class_call(transfer_perturbation_copy_sources_and_nl_corrections(ppt,pnl,ptr,sources), \n               ptr->error_message, \n               ptr->error_message); \n \n     \n \n \n    class_alloc(sources_spline, \n                ptr->md_size*sizeof(double**), \n                ptr->error_message); \n \n    class_call(transfer_perturbation_source_spline(ppt,ptr,sources,sources_spline), \n               ptr->error_message, \n               ptr->error_message); \n \n     \n \n \n    class_alloc(tp_of_tt, \n                ptr->md_size*sizeof(int*), \n                ptr->error_message); \n \n    class_call(transfer_get_source_correspondence(ppt,ptr,tp_of_tt), \n               ptr->error_message, \n               ptr->error_message); \n \n     \n \n \n    class_call(transfer_source_tau_size_max(ppr,pba,ppt,ptr,tau_rec,tau0,&tau_size_max), \n               ptr->error_message, \n               ptr->error_message); \n \n     \n \n \n    xmax = ptr->q[ptr->q_size-1]*tau0; \n    if (pba->sgnK == -1) \n        xmax *= (ptr->l[ptr->l_size_max-1]/ppr->hyper_flat_approximation_nu)/asinh(ptr->l[ptr->l_size_max-1]/ppr->hyper_flat_approximation_nu)*1.01; \n \n    class_call(hyperspherical_HIS_create(0, \n                                         1., \n                                         ptr->l_size_max, \n                                         ptr->l, \n                                         ppr->hyper_x_min, \n                                         xmax, \n                                         ppr->hyper_sampling_flat, \n                                         ptr->l[ptr->l_size_max-1]+1, \n                                         ppr->hyper_phi_min_abs, \n                                         &BIS, \n                                         ptr->error_message), \n     ", "pred": " \nint transfer_init( \n    struct precision * ppr, \n    struct background * pba, \n    struct thermo * pth, \n    struct perturbs * ppt, \n    struct nonlinear * pnl, \n    struct transfers * ptr \n) { \n \n     \n \n \n     \n \n \n     \n \n    int index_q; \n \n     \n \n    double tau0; \n     \n \n    double tau_rec; \n     \n \n    double q_period; \n \n     \n \n    int tau_size_max; \n \n     \n \n    double *** sources; \n \n     \n \n    double *** sources_spline; \n \n     \n \n    struct transfer_workspace * ptw; \n \n     \n \n    int ** tp_of_tt; \n \n     \n \n \n    HyperInterpStruct BIS; \n    double xmax; \n \n     \n \n    int abort; \n \n \n     \n \n    double tstart, tstop, tspent; \n \n \n     \n \n \n    if (ppt->has_cls == _FALSE_) { \n        ptr->has_cls = _FALSE_; \n        if (ptr->transfer_verbose > 0) \n            printf(\"No harmonic space transfer functions to compute. Transfer module skipped.\\n\"); \n        return _SUCCESS_; \n    } \n    else \n        ptr->has_cls = _TRUE_; \n \n    if (ptr->transfer_verbose > 0) \n        fprintf(stdout,\"Computing transfers\\n\"); \n \n     \n \n \n    ptr->md_size = ppt->md_size; \n \n     \nn        ptr->md_type = P_MULT;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_bloom_data_t *const data = (dt_iop_bloom_data_t *)piece->data; \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return;  \n \n \n  float *restrict blurlightness; \n  if(!dt_iop_alloc_image_buffers(self, roi_in, roi_out, 1, &blurlightness, 0)) \n  { \n     \n \n    dt_iop_copy_image_roi(ovoid, ivoid, piece->colors, roi_in, roi_out, TRUE); \n    return; \n  } \n \n  const float *const restrict in = DT_IS_ALIGNED((float *)ivoid); \n  float *const restrict out = DT_IS_ALIGNED((float *)ovoid); \n  const size_t npixels = (size_t)roi_out->width * roi_out->height; \n \n   \n \n  const int rad = 256.0f * (fmin(100.0f, data->size + 1.0f) / 100.0f); \n  const float _r = ceilf(rad * roi_in->scale / piece->iscale); \n  const int radius = MIN(256.0f, _r); \n \n  const float scale = 1.0f / exp2f(-1.0f * (fmin(100.0f, data->strength + 1.0f) / 100.0f)); \n \n  const float threshold = data->threshold; \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(npixels, scale, threshold)    shared(blurlightness)    dt_omp_sharedconst(in)    schedule(static) \n  for(size_t k = 0; k < npixels; k++) \n  { \n    const float L = in[4*k] * scale; \n    blurlightness[k] = (L > threshold)? L : 0.0f; \n  } \n \n   \n \n  const int range = 2 * radius + 1; \n  const int hr = range / 2; \n \n  dt_box_mean(blurlightness, roi_out->height, roi_out->width, 1, hr, BOX_ITERATIONS); \n \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(npixels)    shared(blurlightness)    dt_omp_sharedconst(in, out)    schedule(static) \n  for(size_t k = 0; k < npixels; k++) \n  { \n    out[4*k+0] = 100.0f - (((100.0f - in[4*k]) * (100.0f - blurlightness[k])) / 100.0f);  \n \n    out[4*k+1] = in[4*k+1]; \n    out[4*k+2] = in[4*k+2]; \n    out[4*k+3] = in[4*k+3]; \n  } \n  dt_free_align(blurlightness); \n \n \n \n \n \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_bloom_data_t *const data = (dt_iop_bloom_data_t *)piece->data; \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return;  \n \n \n  float *restrict blurlightness; \n  if(!dt_iop_alloc_image_buffers(self, roi_in, roi_out, 1, &blurlightness, 0)) \n  { \n     \n \n    dt_iop_copy_image_roi(ovoid, ivoid, piece->colors, roi_in, roi_out, TRUE); \n    return; \n  } \n \n  const float *const restrict in = DT_IS_ALIGNED((float *)ivoid); \n  float *const restrict out = DT_IS_ALIGNED((float *)ovoid); \n  const size_t npixels = (size_t)roi_out->width * roi_out->height; \n \n   \n \n  const int rad = 256.0f * (fmin(100.0f, data->size + 1.0f) / 100.0f); \n  const float _r = ceilf(rad * roi_in->scale / piece->iscale); \n  const int radius = MIN(256.0f, _r); \n \n  const float scale = 1.0f / exp2f(-1.0f * (fmin(100.0f, data->strength + 1.0f) / 100.0f)); \n \n  const float threshold = data->threshold; \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(npixels, scale, *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0f), *(1.0f + 0.0"}
{"label": " \nstatic PyObject *__pyx_pf_3GPy_4util_17choleskies_cython_6backprop_gradient_par(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_dL, __Pyx_memviewslice __pyx_v_L) { \n  __Pyx_memviewslice __pyx_v_dL_dK = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_v_N; \n  int __pyx_v_k; \n  int __pyx_v_j; \n  int __pyx_v_i; \n  PyObject *__pyx_r = NULL; \n  __Pyx_RefNannyDeclarations \n  PyObject *__pyx_t_1 = NULL; \n  PyObject *__pyx_t_2 = NULL; \n  PyObject *__pyx_t_3 = NULL; \n  PyObject *__pyx_t_4 = NULL; \n  __Pyx_memviewslice __pyx_t_5 = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_t_6; \n  long __pyx_t_7; \n  int __pyx_t_8; \n  long __pyx_t_9; \n  long __pyx_t_10; \n  long __pyx_t_11; \n  long __pyx_t_12; \n  int __pyx_t_13; \n  Py_ssize_t __pyx_t_14; \n  Py_ssize_t __pyx_t_15; \n  Py_ssize_t __pyx_t_16; \n  Py_ssize_t __pyx_t_17; \n  Py_ssize_t __pyx_t_18; \n  Py_ssize_t __pyx_t_19; \n  int __pyx_t_20; \n  int __pyx_t_21; \n  Py_ssize_t __pyx_t_22; \n  Py_ssize_t __pyx_t_23; \n  Py_ssize_t __pyx_t_24; \n  Py_ssize_t __pyx_t_25; \n  Py_ssize_t __pyx_t_26; \n  Py_ssize_t __pyx_t_27; \n  Py_ssize_t __pyx_t_28; \n  Py_ssize_t __pyx_t_29; \n  Py_ssize_t __pyx_t_30; \n  Py_ssize_t __pyx_t_31; \n  Py_ssize_t __pyx_t_32; \n  Py_ssize_t __pyx_t_33; \n  Py_ssize_t __pyx_t_34; \n  Py_ssize_t __pyx_t_35; \n  Py_ssize_t __pyx_t_36; \n  Py_ssize_t __pyx_t_37; \n  Py_ssize_t __pyx_t_38; \n  Py_ssize_t __pyx_t_39; \n  Py_ssize_t __pyx_t_40; \n  Py_ssize_t __pyx_t_41; \n  __Pyx_RefNannySetupContext(\"backprop_gradient_par\", 0); \n \n   \n \n  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_2); \n  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_tril); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_3); \n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; \n  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_dL, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_2); \n  __pyx_t_4 = NULL; \n  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) { \n    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3); \n    if (likely(__pyx_t_4)) { \n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3); \n      __Pyx_INCREF(__pyx_t_4); \n      __Pyx_INCREF(function); \n      __Pyx_DECREF_SET(__pyx_t_3, function); \n    } \n  } \n  __pyx_t_1 = (__pyx_t_4)? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2); \n  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0; \n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; \n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_1); \n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; \n  __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_t_1, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; \n  __pyx_v_dL_dK = __pyx_t_5; \n  __pyx_t_5.memview = NULL; \n  __pyx_t_5.data = NULL; \n \n   \n \n  __pyx_v_N = (__pyx_v_L.shape[0]); \n \n   \n \n  { \n      #ifdef WITH_THREAD \n      PyThreadState *_save; \n      Py_UNBLOCK_THREADS \n      __Pyx_FastGIL_Remember(); \n      #endif \n       \n { \n \n         \n \n        for (__pyx_t_6 = (__pyx_v_N - 1); __pyx_t_6 > -1; __pyx_t_6-=1) { \n          __pyx_v_k = __pyx_t_6; \n \n           \n \n ", "pred": " \nstatic PyObject *__pyx_pf_3GPy_4util_17choleskies_cython_6backprop_gradient_par(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_dL, __Pyx_memviewslice __pyx_v_L) { \n  __Pyx_memviewslice __pyx_v_dL_dK = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_v_N; \n  int __pyx_v_k; \n  int __pyx_v_j; \n  int __pyx_v_i; \n  PyObject *__pyx_r = NULL; \n  __Pyx_RefNannyDeclarations \n  PyObject *__pyx_t_1 = NULL; \n  PyObject *__pyx_t_2 = NULL; \n  PyObject *__pyx_t_3 = NULL; \n  PyObject *__pyx_t_4 = NULL; \n  __Pyx_memviewslice __pyx_t_5 = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_t_6; \n  long __pyx_t_7; \n  int __pyx_t_8; \n  long __pyx_t_9; \n  long __pyx_t_10; \n  long __pyx_t_11; \n  long __pyx_t_12; \n  int __pyx_t_13; \n  Py_ssize_t __pyx_t_14; \n  Py_ssize_t __pyx_t_15; \n  Py_ssize_t __pyx_t_16; \n  Py_ssize_t __pyx_t_17; \n  Py_ssize_t __pyx_t_18; \n  Py_ssize_t __pyx_t_19; \n  int __pyx_t_20; \n  int __pyx_t_21; \n  Py_ssize_t __pyx_t_22; \n  Py_ssize_t __pyx_t_23; \n  Py_ssize_t __pyx_t_24; \n  Py_ssize_t __pyx_t_25; \n  Py_ssize_t __pyx_t_26;  Py_ssize_t __pyx_t_27;  Py_ssize_t __pyx_t_28;  Py_ssize_t __pyx_t_29;  Py_ssize_t __pyx_t_30;  Py_ssize_t __pyx_t_31;  Py_ssize_t __pyx_t_32;  Py_ssize_t __pyx_t_32;  Py_ssize_t __pyx_t_33;  Py_ssize_t __pyx_t_34;  Py_ssize_t __pyx_t_35;  Py_ssize_t __pyx_t_36;  Py_ssize_t __pyx_t_37;  Py_ssize_t __pyx_t_38;  Py_ssize_t __pyx_t_39;  Py_ssize_t __pyx_t_40;  Py_ssize_t __pyx_t_41;  Py_ssize_t __pyx_t_42;  Py_ssize_t __pyx_t_43;  Py_ssize_t __pyx_t_44;  Py_ssize_t __pyx_t_45;  Py_ssize_t __pyx_t_46;  Py_ssize_t __pyx_t_47;  Py_ssize_t __pyx_t_48;  Py_ssize_t __pyx_t_49;  Py_ssize_t __pyx_t_50;  Py_ssize_t __pyx_t_51;  Py_ssize_t __pyx_t_52;  Py_ssize_t __pyx_t_53;  Py_ssize_t __pyx_t_54;  Py_ssize_t __pyx_t_55;  Py_ssize_t __pyx_t_57;  Py_ssize_t __pyx_t_58;  Py_ssize_t __pyx_t_59;  Py_ssize_t __pyx_t_61;  Py_ssize_t __pyx_t_62;  Py_ssize_t __pyx_t_62;  Py_ssize_t __pyx_t_63;  Py_ssize_t __pyx_t_64;  Py_ssize_t __pyx_t_65;  Py_ssize_t __pyx_t_66;  Py_ssize_t __pyx_t_67;  Py_ssize_t __pyx_t_68;  Py_ssize_t __pyx_t_69;  Py_ssize_t __pyx_t_70;  Py_ssize_t __pyx_t_71;  Py_ssize_t __pyx_t_72;  Py_ssize_t __pyx_t_73;  Py_ssize_t __pyx_t_73;  Py_ssize_t __pyx_t_74;  Py_ssize_t __pyx_t_75;  Py_ssize_t __pyx_t_76;  Py_ssize_t __pyx_t_77;  Py_ssize_t __pyx_t_78;  Py_ssize_t __pyx_t_79;  Py_ssize_t __pyx_t_80;  Py_ssize_t __pyx_t_81;  Py_ssize_t __pyx_t_82;  Py_ssize_t __pyx_t_83;  Py_ssize_t __pyx_t_83;  Py_ssize_t __pyx_t_84;  Py_ssize_t __pyx_t_85;  Py_ssize_t __pyx_t_86;  Py_ssize_t __pyx_t_87;  Py_ssize_t __pyx_t_87;  Py_ssize_t __pyx_t_88;  Py_ssize_t __pyx_t_89;  Py_ssize_t __pyx_t_90;  Py_ssize_t __pyx_t_91;  Py_ssize_t __pyx_t_92;  Py_ssize_t __pyx_t_93;  Py_ssize_t __pyx_t_94;  Py_ssize_t __pyx_t_95;  Py_ssize_t __pyx_t_96;  Py_ssize_t __pyx_t_97;  Py_ssize_t __pyx_t_98;  Py_ssize_t __pyx_t_99;  Py_ssize_t __pyx_t_100;  Py_ssize_t __pyx_t_101;  Py_ssize_t __pyx_t_101;  Py_ssize_t __pyx_t_102;  Py_ssize_t __pyx_t_103;  Py_ssize_t __pyx_t_104;  Py_ssize_t __pyx_t_105;  Py_ssize_t __pyx_t_106;  Py_ssize_t __pyx_t_107;  Py_ssize_t __pyx_t_108;  Py_ssize_t __pyx_t_109;  Py_ssize_t __pyx_t_109;  Py_ssize_t __pyx_t_110;  Py_ssize_t __pyx_t_111;  Py_ssize_t __pyx_t_111;  Py_ssize_t __pyx_t_113;  Py_ssize_t __pyx_t_114;  Py_ssize_t __pyx_t_114;  Py_ssize_t __pyx_t_115;  Py_ssize_t __pyx_t_116;  Py_ssize_t __py"}
{"label": "d RK_in(real *fwnp1, real *fdtwn, const real dt, const int sizew) \n{ \n#pragma omp parallel for \n  for(int iw = 0; iw < sizew; iw++) { \n    fwnp1[iw] += dt * fdtwn[iw]; \n  } \n} \n \nre ", "pred": "d RK_in(real *fwnp1, real *fdtwn, const real dt, const int sizew) \n{ \n#pragma omp parallel for \n  for(int iw = 0; iw < sizew; iw++) { \n    fwnp1[iw] += dt * fdtwn[iw]; \n  } \n} \n \nre "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 32; \n  tile_size[3] = 256; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,12);t1++) { \n    lbp=max(ceild(t1,2),ceild(24*t1-Nt+3,24)); \n    ubp=min(floord(Nt+Nz-4,24),floord(12*t1+Nz+9,24)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(3*t1-7,8)),ceild(24*t2-Nz-28,32));t3<=min(min(min(floord(Nt+Ny-4,32),floord(12*t1+Ny+21,32)),floord(24*t2+Ny+20,32)),floord(24*t1-24*t2+Nz+Ny+19,32));t3++) { \n        for (t4=max(max(max(0,ceild(3*t1-63,64)),ceild(24*t2-Nz-252,256)),ceild(32*t3-Ny-252,256));t4<=min(min(min(min(floord(Nt+Nx-4,256),floord(12*t1+Nx+21,256)),floord(24*t2+Nx+20,256)),floord(32*t3+Nx+28,256)),floord(24*t1-24*t2+Nz+Nx+19,256));t4++) { \n          for (t5=max(max(max(max(max(0,12*t1),24*t1-24*t2+1),24*t2-Nz+2),32*t3-Ny+2),256*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,12*t1+23),24*t2+22),32*t3+30),256*t4+254),24*t1-24*t2+Nz+21);t5++) { \n            for (t6=max(max(24*t2,t5+1),-24*t1+24*t2+2*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(32*t3,t5+1);t7<=min(32*t3+31,", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *) tile_size, sizeof(int)*Nz);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": " \nstatic void get_gonze_undone_phonons(double *frequencies, \n                                     lapack_complex_double *eigenvectors, \n                                     const size_t *undone_grid_points, \n                                     const size_t num_undone_grid_points, \n                                     PHPYCONST int (*grid_address)[3], \n                                     const int mesh[3], \n                                     const double *fc2, \n                                     PHPYCONST double(*svecs_fc2)[27][3], \n                                     const int *multi_fc2, \n                                     PHPYCONST double (*positions)[3], \n                                     const size_t num_patom, \n                                     const size_t num_satom, \n                                     const double *masses_fc2, \n                                     const int *p2s_fc2, \n                                     const int *s2p_fc2, \n                                     const double unit_conversion_factor, \n                                     PHPYCONST double (*born)[3][3], \n                                     PHPYCONST double dielectric[3][3], \n                                     PHPYCONST double reciprocal_lattice[3][3], \n                                     const double *q_direction, \n                                     const double nac_factor, \n                                     const double *dd_q0, \n                                     PHPYCONST double(*G_list)[3], \n                                     const size_t num_G_points, \n                                     const double lambda, \n                                     const char uplo) \n{ \n  size_t i, j, gp, num_band; \n  int is_nac, info; \n  double q[3]; \n  double *freqs_tmp; \n \n  num_band = num_patom * 3; \n \n#pragma omp parallel for private(j, q, gp, is_nac) \n  for (i = 0; i < num_undone_grid_points; i++) { \n    gp = undone_grid_points[i]; \n    for (j = 0; j < 3; j++) { \n      q[j] = ((double)grid_address[gp][j]) / mesh[j]; \n    } \n    is_nac = needs_nac(born, grid_address, gp, q_direction); \n    get_gonze_phonons(eigenvectors + num_band * num_band * gp, \n                      q, \n                      fc2, \n                      masses_fc2, \n                      p2s_fc2, \n                      s2p_fc2, \n                      multi_fc2, \n                      positions, \n                      num_patom, \n                      num_satom, \n                      svecs_fc2, \n                      is_nac, \n                      born, \n                      dielectric, \n                      reciprocal_lattice, \n                      q_direction, \n                      nac_factor, \n                      dd_q0, \n                      G_list, \n                      num_G_points, \n                      lambda); \n  } \n \n \n \n \n#pragma omp parallel for private(j, gp, freqs_tmp, info) \n  for (i = 0", "pred": " \nstatic void get_gonze_undone_phonons(double *frequencies, \n                                     lapack_complex_double *eigenvectors, \n                                     const size_t *undone_grid_points, \n                                     const size_t num_undone_grid_points, \n                                     PHPYCONST int (*grid_address)[3], \n                                     const int mesh[3], \n                                     const double *fc2, \n                                     PHPYCONST double(*svecs_fc2)[27][3], \n                                     const int *multi_fc2, \n                                     PHPYCONST double (*positions)[3], \n                                     const size_t num_patom, \n                                     const size_t num_satom, \n                                     const double *masses_fc,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nstatic void get_xyz_sample_from_image(const image_t *const image, float shrink, box_t *box, float *xyz) \n{ \n  point_t bb[4]; \n  point_t corners[4]; \n  box_t inner_box; \n  int x_start, y_start, x_end, y_end; \n \n  xyz[0] = xyz[1] = xyz[2] = 0.0; \n \n  if(!box) return; \n \n  get_boundingbox(image, bb); \n  inner_box = get_sample_box(*(image->chart), box, shrink); \n  get_corners(bb, &inner_box, corners); \n  get_pixel_region(image, corners, &x_start, &y_start, &x_end, &y_end); \n \n  float delta_x_top = corners[TOP_RIGHT].x - corners[TOP_LEFT].x; \n  float delta_y_top = corners[TOP_RIGHT].y - corners[TOP_LEFT].y; \n  float delta_x_bottom = corners[BOTTOM_RIGHT].x - corners[BOTTOM_LEFT].x; \n  float delta_y_bottom = corners[BOTTOM_RIGHT].y - corners[BOTTOM_LEFT].y; \n  float delta_x_left = corners[BOTTOM_LEFT].x - corners[TOP_LEFT].x; \n  float delta_y_left = corners[BOTTOM_LEFT].y - corners[TOP_LEFT].y; \n  float delta_x_right = corners[BOTTOM_RIGHT].x - corners[TOP_RIGHT].x; \n  float delta_y_right = corners[BOTTOM_RIGHT].y - corners[TOP_RIGHT].y; \n \n  double sample_x = 0.0, sample_y = 0.0, sample_z = 0.0; \n  size_t n_samples = 0; \n#pragma omp parallel for default(none)    dt_omp_firstprivate(image)    shared(corners, x_start, y_start, x_end, y_end, delta_x_top, delta_y_top,           delta_x_bottom, delta_y_bottom, delta_x_left, delta_y_left,           delta_x_right, delta_y_right)    reduction(+ : n_samples, sample_x, sample_y, sample_z)    schedule(static)  \n  for(int y = y_start; y < y_end; y++) \n    for(int x = x_start; x < x_end; x++) \n    { \n      if((x - corners[TOP_LEFT].x) / delta_x_top * delta_y_top + corners[TOP_LEFT].y < y \n         && (x - corners[BOTTOM_LEFT].x) / delta_x_bottom * delta_y_bottom + corners[BOTTOM_LEFT].y > y \n         && (y - corners[TOP_LEFT].y) / delta_y_left * delta_x_left + corners[TOP_LEFT].x < x \n         && (y - corners[TOP_RIGHT].y) / delta_y_right * delta_x_right + corners[TOP_RIGHT].x > x) \n      { \n        float *pixel = &image->xyz[(x + y * image->width) * 3]; \n        sample_x += pixel[0]; \n        sample_y += pixel[1]; \n        sample_z += pixel[2]; \n        n_samples++; \n      } \n    } \n \n  xyz[0] = sample_x / n_samples; \n  xyz[1] = sample_y / n_samples; \n  xyz[2] = sample_z / n_samples; \n} ", "pred": " \nstatic void get_xyz_sample_from_image(const image_t *const image, float shrink, box_t *box, float *xyz) \n{ \n  point_t bb[4]; \n  point_t corners[4]; \n  box_t inner_box; \n  int x_start, y_start, x_end, y_end; \n \n  xyz[0] = xyz[1] = xyz[2] = 0.0; \n \n  if(!box) return; \n \n  get_boundingbox(image, bb); \n  inner_box = get_sample_box(*(image->chart), box, shrink); \n  get_corners(bb, &inner_box, corners); \n  get_pixel_region(image, corners, &x_start, &y_start, &x_end, &y_end); \n \n  float delta_x_top = corners[TOP_RIGHT].x - corners[TOP_LEFT].x; \n  float delta_y_top = corners[TOP_RIGHT].y - corners[TOP_LEFT].y; \n  float delta_x_bottom = corners[BOTTOM_RIGHT].x - corners[BOTTOM_LEFT].x; \n  float delta_y_bottom = corners[BOTTOM_RIGHT].y - corners[BOTTOM_LEFT].y; \n  float delta_x_left = corners[BOTTOM_LEFT].x - corners[TOP_LEFT].x; \n  float delta_y_left = corners[BOTTOM_LEFT].y - corners[TOP_LEFT].y; \n  float delta_x_right = corners[BOTTOM_RIGHT].x - corners[TOP_RIGHT].x; \n  float delta_y_right = corners[BOTTOM_RIGHT].y - corners[TOP_RIGHT].y; \n \n  double sample_x = 0.0, sample_y = 0.0, sample_z = 0.0; \n  size_t n_samples = 0; \n#pragma omp parallel for default(none)    dt_omp_firstprivate(image)    shared(corners, x_start, y_start, x_end, y_end, delta_x_top, delta_y_top,           delta_x_bottom, delta_y_bottom, delta_x_left, delta_y_left, delta_z_top, delta_z_bottom, delta_z_left, delta_z_bottom);\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \nvoid recombine2d_pf1_ft1_omp(struct recombine2d_worker *worker, \n                             complex double *F, \n                             complex double *BF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n    int y; \n#pragma omp for schedule(dynamic) \n    for (y = 0; y < cfg->yB_size; y+=worker->BF_batch) { \n \n         \n \n        double start = get_time_ns(); \n        int y2; \n        for (y2 = y; y2 < y+worker->BF_batch && y2 < cfg->yB_size; y2++) { \n            prepare_facet(cfg->yB_size, cfg->yP_size, cfg->Fb, \n                          F+y2*cfg->F_stride0, cfg->F_stride1, \n                          BF+y2*cfg->BF_stride0, cfg->BF_stride1); \n        } \n        worker->pf1_time += get_time_ns() - start; \n \n         \n \n        start = get_time_ns(); \n        fftw_execute_dft(worker->BF_plan, BF+y*cfg->BF_stride0, BF+y*cfg->BF_stride0); \n        worker->ft1_time += get_time_ns() - start; \n    } \n \n} ", "pred": " \nvoid recombine2d_pf1_ft1_omp(struct recombine2d_worker *worker, \n                             complex double *F, \n                             complex double *BF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n    int y; \n#pragma omp for schedule(dynamic) \n    for (y = 0; y < cfg->yB_size; y+=worker->BF_batch) { \n \n         \n \n        double start = get_time_ns(); \n        int y2; \n        for (y2 = y; y2 < y+worker->BF_batch && y2 < cfg->yB_size; y2++) { \n            prepare_facet(cfg->yB_size, cfg->yP_size, cfg->Fb, \n                          F+y2*cfg->F_stride0, cfg->F_stride1, \n                          BF+y2*cfg->BF_stride0, cfg->BF_stride1); \n        } \n        worker->pf1_time += get_time_ns() - start; \n \n         \n \n        start = get_time_ns(); \n        fftw_execute_dft(worker->BF_plan, BF+y*cfg->BF_stride0, BF+y*cfg->BF_stride0); \n        worker->ft1_time += get_time_ns() - start; \n    } \n \n} "}
{"label": " \nint ro2euLoop (double* ro, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(rostep, eustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * eustep; \n      \n    trash = ro2eu(&(ro[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ro2euLoop (double* ro, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(rostep, eustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * eustep; \n      \n    trash = ro2eu(&(ro[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint eu2axLoop (double* eu, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(eustep, axstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * axstep; \n      \n    trash = eu2ax(&(eu[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint eu2axLoop (double* eu, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(eustep, axstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * axstep; \n      \n    trash = eu2ax(&(eu[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint qu2cuLoop (double* qu, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(qustep, custep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * custep; \n      \n    trash = qu2cu(&(qu[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint qu2cuLoop (double* qu, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(qustep, custep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * custep; \n      \n    trash = qu2cu(&(qu[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint qu2roLoop (double* qu, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(qustep, rostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * rostep; \n      \n    trash = qu2ro(&(qu[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint qu2roLoop (double* qu, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(qustep, rostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * rostep; \n      \n    trash = qu2ro(&(qu[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint cu2hoLoop (double* cu, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(custep, hostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * hostep; \n      \n    trash = cu2ho(&(cu[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint cu2hoLoop (double* cu, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(custep, hostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * hostep; \n      \n    trash = cu2ho(&(cu[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": "nstruct_RGB(const float *const restrict HF, const float *const restrict LF, \n                                            const float *const restrict texture, const float *const restrict mask, \n                                            float *const restrict reconstructed, const size_t width, \n                                            const size_t height, const size_t ch, const float gamma, \n                                            const float gamma_comp, const float beta, const float beta_comp, \n                                            const float delta, const size_t s, const size_t scales) \n{ \n#pragma omp parallel for default(none)                                                                            dt_omp_firstprivate(width, height, ch, HF, LF, texture, mask, reconstructed, gamma, gamma_comp, beta,                                  beta_comp, delta, s, scales) schedule(simd : static) \n  for(size_t k = 0; k < height * width * ch; k += 4) \n  { \n    const float alpha = mask[k / ch]; \n \n     \n \n    const float *const restrict HF_c = __builtin_assume_aligned(HF + k, 16); \n    const float *const restrict LF_c = __builtin_assume_aligned(LF + k, 16); \n    const float *const restrict TT_c = __builtin_assume_aligned(texture + k, 16); \n \n     \n \n     \n \n     \n \n    const float grey_texture = fmaxabsf(fmaxabsf(TT_c[0], TT_c[1]), TT_c[2]); \n \n     \n \n     \n \n    const float grey_details = (HF_c[0] + HF_c[1] + HF_c[2]) / 3.f; \n \n     \n \n     \n \n     \n \n    const float grey_HF = beta_comp * (gamma_comp * grey_details + gamma * grey_texture); \n \n     \n \n     \n \n    const float grey_residual = beta_comp * (LF_c[0] + LF_c[1] + LF_c[2]) / 3.f; \n \n    #ifdef _OPENMP \n    #pragma omp simd aligned(reconstructed:64) aligned(HF_c, LF_c, TT_c:16) \n    #endif \n    for(size_t c = 0; c < 4; c++) \n    { \n       \n \n       \n \n \n       \n \n       \n \n      const float details = (gamma_comp * HF_c[c] + gamma * TT_c[c]) * beta + grey_HF; \n \n       \n \n      const float residual = (s == scales - 1)? (grey_residual + LF_c[c] * beta) : 0.f; \n      reconstructed[k + c] += alpha * (delta * details + residual); \n    } \n  } \n} \n \ninline static void wavelets_reco ", "pred": "nstruct_RGB(const float *const restrict HF, const float *const restrict LF, \n                                            const float *const restrict texture, const float *const restrict mask, \n                                            float *const restrict reconstructed, const size_t width, \n                                            const size_t height, const size_t ch, const float gamma, \n                                            const float gamma_comp, const float beta, const float beta_comp, \n                                            const float delta, const size_t s, const size_t scales) \n{ \n#pragma omp parallel for default(none)                                                                            dt_omp_firstprivate(width, height, ch, HF, LF, texture, mask, reconstructed, gamma, gamma_comp, beta,                                  beta_comp, delta, s, scales) schedule(simd : static) \n  for(size_t k = 0; k < height * width * ch; k += 4) \n  { \n    const float alpha = mask[k / ch]; \n \n     \n \n    const float *const restrict HF_c = __builtin_assume_aligned(HF + k, 16); \n    const float *const restrict LF_c = __builtin_assume_aligned(LF + k, 16);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nint eu2quLoop (double* eu, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(eustep, qustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * qustep; \n      \n    trash = eu2qu(&(eu[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint eu2quLoop (double* eu, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(eustep, qustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * qustep; \n      \n    trash = eu2qu(&(eu[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void lhsx(void) \n{ \n    int i, j, k; \n#pragma omp for  \n    for (j = 1; \n        j < grid_points[1] - 1; \n        j++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            for (i = 0; \n                i < grid_points[0]; \n                i++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                fjac[i][j][k][0][0] = 0.0; \n                fjac[i][j][k][0][1] = 1.0; \n                fjac[i][j][k][0][2] = 0.0; \n                fjac[i][j][k][0][3] = 0.0; \n                fjac[i][j][k][0][4] = 0.0; \n                fjac[i][j][k][1][0] = - (u[i][j][k][1] * tmp2 * u[i][j][k][1]) + c2 * 0.50 * (u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][1][1] = (2.0 - c2) * (u[i][j][k][1] / u[i][j][k][0]); \n                fjac[i][j][k][1][2] = - c2 * (u[i][j][k][2] * tmp1); \n                fjac[i][j][k][1][3] = - c2 * (u[i][j][k][3] * tmp1); \n                fjac[i][j][k][1][4] = c2; \n                fjac[i][j][k][2][0] = - (u[i][j][k][1] * u[i][j][k][2]) * tmp2; \n                fjac[i][j][k][2][1] = u[i][j][k][2] * tmp1; \n                fjac[i][j][k][2][2] = u[i][j][k][1] * tmp1; \n                fjac[i][j][k][2][3] = 0.0; \n                fjac[i][j][k][2][4] = 0.0; \n                fjac[i][j][k][3][0] = - (u[i][j][k][1] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][3][1] = u[i][j][k][3] * tmp1; \n                fjac[i][j][k][3][2] = 0.0; \n                fjac[i][j][k][3][3] = u[i][j][k][1] * tmp1; \n                fjac[i][j][k][3][4] = 0.0; \n                fjac[i][j][k][4][0] = (c2 * (u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2 - c1 * (u[i][j][k][4] * tmp1)) * (u[i][j][k][1] * tmp1); \n                fjac[i][j][k][4][1] = c1 * u[i][j][k][4] * tmp1 - 0.50 * c2 * (3.0 * u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][4][2] = - c2 * (u[i][j][k][2] * u[i][j][k][1]) * tmp2; \n                fjac[i][j][k][4][3] = - c2 * (u[i][j][k][3] * u[i][j][k][1]) * tmp2; \n                fjac[i][j][k][4][4] = c1 * (u[i][j][k][1] * tmp1); \n                njac[i][j][k][0][0] = 0.0; \n                njac[i][j][k][0][1] = 0.0; \n                njac[i][j][k][0][2] = 0.0; \n                njac[i][j][k][0][3] = 0.0; \n                njac[i][j][k][0][4] = 0.0; \n                njac[i][j][k][1][0] = - con43 * c3c4 * tmp2 * u[i][j][k][1]; \n                njac[i][j][k][1][1] = con43 * c3c4 * tmp1; \n                njac[i][j][k][1][2] = 0.0; \n                njac[i][j][k][1][3] = 0.0; \n               ", "pred": " \nstatic void lhsx(void) \n{ \n    int i, j, k; \n#pragma omp for  \n    for (j = 1; \n        j < grid_points[1] - 1; \n        j++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            for (i = 0; \n                i < grid_points[0]; \n                i++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                fjac[i][j][k][0][0] = 0.0; \n                fjac[i][j][k][0][1] = 1.0; \n                fjac[i][j][k][0][2] = 0.0; \n                fjac[i][j][k][0][3] = 0.0; \n                fjac[i][j][k][0][4] = 0.0; \n                fjac[i][j][k][1][0] = - (u[i][j][k][1] * tmp2 * u[i][j][k][1]) + c2 * 0.50 * (u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][2] + u[i][j][k][3];\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           "}
{"label": " \nint ho2roLoop (double* ho, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(hostep, rostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * rostep; \n      \n    trash = ho2ro(&(ho[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ho2roLoop (double* ho, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(hostep, rostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * rostep; \n      \n    trash = ho2ro(&(ho[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": "loat *const restrict in, float *const restrict norms, \n                                  float *const restrict ratios, \n                                  const dt_iop_order_iccprofile_info_t *const work_profile, const int variant, \n                                  const size_t width, const size_t height) \n{ \n#pragma omp parallel for default(none)                                     dt_omp_firstprivate(width, height, norms, ratios, in, work_profile, variant) schedule(static) \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float norm = fmaxf(get_pixel_norm(in + k, variant, work_profile), NORM_MIN); \n    norms[k / 4] = norm; \n    for_each_channel(c,aligned(ratios,in)) \n      ratios[k + c] = in[k + c] / norm; \n  } \n} \n \n \nstatic inline void restore_ratios(float ", "pred": "loat *const restrict in, float *const restrict norms, \n                                  float *const restrict ratios, \n                                  const dt_iop_order_iccprofile_info_t *const work_profile, const int variant, \n                                  const size_t width, const size_t height) \n{ \n#pragma omp parallel for default(none)                                     dt_omp_firstprivate(width, height, norms, ratios, in, work_profile, variant) schedule(static) \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float norm = fmaxf(get_pixel_norm(in + k, variant, work_profile), NORM_MIN); \n    norms[k / 4] = norm; \n    for_each_channel(c,aligned(ratios,in)) \n      ratios[k + c] = in[k + c] / norm; \n  } \n} \n \n \nstatic inline void restore_ratios(float "}
{"label": "nst float *const restrict in, float *const restrict out, \n                                      const dt_iop_order_iccprofile_info_t *const work_profile, \n                                      const dt_iop_filmicrgb_data_t *const data, \n                                      const dt_iop_filmic_rgb_spline_t spline, const size_t width, \n                                      const size_t height) \n{ \n#pragma omp parallel for default(none)    dt_omp_firstprivate(width, height, data, in, out, work_profile, spline)    schedule(simd : static) \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n    dt_aligned_pixel_t temp; \n \n     \n \n    for(int c = 0; c < 3; c++) \n      temp[c] = log_tonemapping_v2(fmaxf(pix_in[c], NORM_MIN), data->grey_source, data->black_source, \n                                   data->dynamic_range); \n \n     \n \n    const float lum = (work_profile) \n                         ? dt_ioppr_get_rgb_matrix_luminance(temp, work_profile->matrix_in, work_profile->lut_in, \n                                                              work_profile->unbounded_coeffs_in, \n                                                              work_profile->lutsize, work_profile->nonlinearlut) \n                          : dt_camera_rgb_luminance(temp); \n    const float desaturation = filmic_desaturate_v2(lum, data->sigma_toe, data->sigma_shoulder, data->saturation); \n \n     \n \n     \n \n     \n \n    for(int c = 0; c < 3; c++) \n      pix_out[c] = powf( \n          clamp_simd(filmic_spline(linear_saturation(temp[c], lum, desaturation), spline.M1, spline.M2, spline.M3, \n                                   spline.M4, spline.M5, spline.latitude_min, spline.latitude_max, spline.type)), \n          data->output_power); \n  } \n} \n \n \nstatic inline void filmic_chroma_v1(co ", "pred": "nst float *const restrict in, float *const restrict out, \n                                      const dt_iop_order_iccprofile_info_t *const work_profile, \n                                      const dt_iop_filmicrgb_data_t *const data, \n                                      const dt_iop_filmic_rgb_spline_t spline, const size_t width, \n                                      const size_t height) \n{ \n#pragma omp parallel for default(none)    dt_omp_firstprivate(width, height, data, in, out, work_profile, spline)    schedule(simd : static) \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n    dt_aligned_pixel_t temp; \n \n     \n \n    for(int c = 0; c < 3; c++) \n      temp[c] = log_tonemapping_v2(fmaxf(pix_in[c], NORM_MIN), data->grey_source, data->black_source, \n                                   data->dynamic_range); \n \n     \n \n    const float lum = (work_profile) \n                         ? dt_ioppr_get_rgb_matrix_luminance(temp, work_profile->matrix_in, work_profile->lut_in, \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nint ro2omLoop (double* ro, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(rostep, omstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * omstep; \n      \n    trash = ro2om(&(ro[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ro2omLoop (double* ro, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(rostep, omstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * omstep; \n      \n    trash = ro2om(&(ro[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic int crypt_all(int *pcount, struct db_salt *salt) \n{ \n\tint count = *pcount; \n\tint index; \n \n\tglobal_work_size = (count + local_work_size - 1) / local_work_size * local_work_size; \n \n\tif (any_cracked) { \n\t\tmemset(cracked, 0, cracked_size); \n\t\tany_cracked = 0; \n\t} \n \n\t \n \n\tHANDLE_CLERROR(clEnqueueWriteBuffer(queue[gpu_id], mem_in, CL_FALSE, 0, \n\t\tinsize, inbuffer, 0, NULL, multi_profilingEvent[0]), \n\t        \"Copy data to gpu\"); \n \n\t \n \n\tHANDLE_CLERROR(clEnqueueNDRangeKernel(queue[gpu_id], crypt_kernel, 1, \n\t\tNULL, &global_work_size, &local_work_size, 0, NULL, \n\t        multi_profilingEvent[1]), \"Run kernel\"); \n \n\t \n \n\tHANDLE_CLERROR(clEnqueueReadBuffer(queue[gpu_id], mem_out, CL_TRUE, 0, \n\t\toutsize, outbuffer, 0, NULL, multi_profilingEvent[2]), \"Copy result back\"); \n \n#pragma omp parallel for \n\tfor (index = 0; index < count; index++) \n\tif (!blockchain_decrypt((unsigned char*)outbuffer[index].v, cur_salt->data)) \n\t{ \n\t\tcracked[index] = 1; \n#pragma omp atomic \n\t\tany_cracked |= 1; \n\t} \n \n\treturn count; \n} ", "pred": " \nstatic int crypt_all(int *pcount, struct db_salt *salt) \n{ \n\tint count = *pcount; \n\tint index; \n \n\tglobal_work_size = (count + local_work_size - 1) / local_work_size * local_work_size; \n \n\tif (any_cracked) { \n\t\tmemset(cracked, 0, cracked_size); \n\t\tany_cracked = 0; \n\t} \n \n\t \n \n\tHANDLE_CLERROR(clEnqueueWriteBuffer(queue[gpu_id], mem_in, CL_FALSE, 0, \n\t\tinsize, inbuffer, 0, NULL, multi_profilingEvent[0]), \n\t        \"Copy data to gpu\"); \n \n\t \n \n\tHANDLE_CLERROR(clEnqueueNDRangeKernel(queue[gpu_id], crypt_kernel, 1, \n\t\tNULL, &global_work_size, &local_work_size, 0, NULL, \n\t        multi_profilingEvent[1]), \"Run kernel\"); \n \n\t \n \n\tHANDLE_CLERROR(clEnqueueReadBuffer(queue[gpu_id], mem_out, CL_TRUE, 0, \n\t\toutsize, outbuffer, 0, NULL, multi_profilingEvent[2]), \"Copy result back\"); \n \n#pragma omp parallel for \n\tfor (index = 0; index < count; index++) \n\tif (!blockchain_decrypt((unsigned char*)outbuffer[index].v, cur_salt->data)) \n\t{ \n\t\tcracked[index] = 1; \n#pragma omp atomic \n\t\tany_cracked |= 1; \n\t} \n \n\treturn count; \n} "}
{"label": " \nstatic void lhsz(void) \n{ \n    int i, j, k; \n#pragma omp for  \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                fjac[i][j][k][0][0] = 0.0; \n                fjac[i][j][k][0][1] = 0.0; \n                fjac[i][j][k][0][2] = 0.0; \n                fjac[i][j][k][0][3] = 1.0; \n                fjac[i][j][k][0][4] = 0.0; \n                fjac[i][j][k][1][0] = - (u[i][j][k][1] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][1][1] = u[i][j][k][3] * tmp1; \n                fjac[i][j][k][1][2] = 0.0; \n                fjac[i][j][k][1][3] = u[i][j][k][1] * tmp1; \n                fjac[i][j][k][1][4] = 0.0; \n                fjac[i][j][k][2][0] = - (u[i][j][k][2] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][2][1] = 0.0; \n                fjac[i][j][k][2][2] = u[i][j][k][3] * tmp1; \n                fjac[i][j][k][2][3] = u[i][j][k][2] * tmp1; \n                fjac[i][j][k][2][4] = 0.0; \n                fjac[i][j][k][3][0] = - (u[i][j][k][3] * u[i][j][k][3] * tmp2) + 0.50 * c2 * ((u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2); \n                fjac[i][j][k][3][1] = - c2 * u[i][j][k][1] * tmp1; \n                fjac[i][j][k][3][2] = - c2 * u[i][j][k][2] * tmp1; \n                fjac[i][j][k][3][3] = (2.0 - c2) * u[i][j][k][3] * tmp1; \n                fjac[i][j][k][3][4] = c2; \n                fjac[i][j][k][4][0] = (c2 * (u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2 - c1 * (u[i][j][k][4] * tmp1)) * (u[i][j][k][3] * tmp1); \n                fjac[i][j][k][4][1] = - c2 * (u[i][j][k][1] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][4][2] = - c2 * (u[i][j][k][2] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][4][3] = c1 * (u[i][j][k][4] * tmp1) - 0.50 * c2 * ((u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + 3.0 * u[i][j][k][3] * u[i][j][k][3]) * tmp2); \n                fjac[i][j][k][4][4] = c1 * u[i][j][k][3] * tmp1; \n                njac[i][j][k][0][0] = 0.0; \n                njac[i][j][k][0][1] = 0.0; \n                njac[i][j][k][0][2] = 0.0; \n                njac[i][j][k][0][3] = 0.0; \n                njac[i][j][k][0][4] = 0.0; \n                njac[i][j][k][1][0] = - c3c4 * tmp2 * u[i][j][k][1]; \n                njac[i][j][k][1][1] = c3c4 * tmp1; \n                njac[i][j][k][1][2] = 0.0; \n                njac[i][j][k][1][3] = 0.0; \n                njac[i][j][k][1][4] =", "pred": " \nstatic void lhsz(void) \n{ \n    int i, j, k; \n#pragma omp for  \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                fjac[i][j][k][0][0] = 0.0; \n                fjac[i][j][k][0][1] = 0.0; \n                fjac[i][j][k][0][2] = 0.0; \n                fjac[i][j][k][0][3] = 1.0; \n                fjac[i][j][k][0][4] = 0.0; \n                fjac[i][j][k][1][0] = - (u[i][j][k][1] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][1][1] = u[i][j][k][3] * tmp1; \n                fjac[i][j][k][2][0] = u[i][j][k][3];\\n                  fjac[i][j][k][2][0] = u[i][j][k][3];\\n                  fjac[i][j][k][3][0] = u[i][j][k][4];\\n                  fjac[i][j][k][4][0] = u[i][j][k][5];\\n                  fjac[i][j][k][5][0] = u[i][j][k][6];\\n                  fjac[i][j][k][6][0] = u[i][j][k][7];\\n                  fjac[i][j][k][7][0] = u[i][j][k][8];\\n                  fjac[i][j][k][7][1] = u[i][j][k][4];\\n                  fjac[i][j][k][7][2] = u[i][j][k][5];\\n                  fjac[i][j][k][7][3] = u[i][j][k][6];\\n                  fjac[i][j][k][7][4] = u[i][j][k][7];\\n                  fjac[i][j][k][7][5] = u[i][j][k][6];\\n                  fjac[i][j][k][7][6] = u[i][j][k][7];\\n                  fjac[i][j][k][7][7] = u[i][j][k][8];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][8];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][8];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];\\n                  fjac[i][j][k][7][8] = u[i][j][k][7];"}
{"label": " \nint om2euLoop (double* om, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(omstep, eustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * eustep; \n      \n    trash = om2eu(&(om[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint om2euLoop (double* om, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(omstep, eustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * eustep; \n      \n    trash = om2eu(&(om[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ax2quLoop (double* ax, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(axstep, qustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * qustep; \n      \n    trash = ax2qu(&(ax[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ax2quLoop (double* ax, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(axstep, qustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * qustep; \n      \n    trash = ax2qu(&(ax[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": "t float *const restrict in, float *const restrict out, \n                                    const dt_iop_order_iccprofile_info_t *const work_profile, \n                                    const dt_iop_filmicrgb_data_t *const data, \n                                    const dt_iop_filmic_rgb_spline_t spline, const int variant, const size_t width, \n                                    const size_t height) \n{ \n#pragma omp parallel for default(none)                                                                            dt_omp_firstprivate(width, height, data, in, out, work_profile, variant, spline) schedule(simd : static) \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n \n    dt_aligned_pixel_t ratios = { 0.0f }; \n    float norm = fmaxf(get_pixel_norm(pix_in, variant, work_profile), NORM_MIN); \n \n     \n \n    for_each_channel(c,aligned(pix_in)) \n      ratios[c] = pix_in[c] / norm; \n \n     \n \n    const float min_ratios = fminf(fminf(ratios[0], ratios[1]), ratios[2]); \n    if(min_ratios < 0.0f) \n      for_each_channel(c) ratios[c] -= min_ratios; \n \n     \n \n    norm = log_tonemapping_v1(norm, data->grey_source, data->black_source, data->dynamic_range); \n \n     \n \n    const float desaturation = filmic_desaturate_v1(norm, data->sigma_toe, data->sigma_shoulder, data->saturation); \n \n    for_each_channel(c) ratios[c] *= norm; \n \n    const float lum = (work_profile)? dt_ioppr_get_rgb_matrix_luminance( \n                          ratios, work_profile->matrix_in, work_profile->lut_in, work_profile->unbounded_coeffs_in, \n                          work_profile->lutsize, work_profile->nonlinearlut) \n                                     : dt_camera_rgb_luminance(ratios); \n \n     \n \n    for(int c = 0; c < 3; c++) ratios[c] = linear_saturation(ratios[c], lum, desaturation) / norm; \n \n     \n \n     \n \n    norm = powf(clamp_simd(filmic_spline(norm, spline.M1, spline.M2, spline.M3, spline.M4, spline.M5, \n                                         spline.latitude_min, spline.latitude_max, spline.type)), \n                data->output_power); \n \n     \n \n    for_each_channel(c,aligned(pix_out)) pix_out[c] = ratios[c] * norm; \n  } \n} \n \n \nstatic inline void filmic_chroma_v2_v3 ", "pred": "t float *const restrict in, float *const restrict out, \n                                    const dt_iop_order_iccprofile_info_t *const work_profile, \n                                    const dt_iop_filmicrgb_data_t *const data, \n                                    const dt_iop_filmic_rgb_spline_t spline, const int variant, const size_t width, \n                                    const size_t height) \n{ \n#pragma omp parallel for default(none)                                                                            dt_omp_firstprivate(width, height, data, in, out, work_profile, variant, spline) schedule(simd : static) \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n \n    dt_aligned_pixel_t ratios = { 0.0f }; \n    float norm = fmaxf(get_pixel_norm(pix_in, variant, work_profile), NORM_MIN); \n \n     \n \n    for_each_channel(c,aligned(pix_in)) \n      ratios[c] = pix_in[c] / norm; \n \n     \n \n    const float min_ratios = fminf(fminf(ratios[0], ratios[1]), ratios[2]); \n    if(min_ratios < 0.0f) \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "}
{"label": " \nint ho2omLoop (double* ho, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(hostep, omstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * omstep; \n      \n    trash = ho2om(&(ho[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ho2omLoop (double* ho, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(hostep, omstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * omstep; \n      \n    trash = ho2om(&(ho[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ro2hoLoop (double* ro, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(rostep, hostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * hostep; \n      \n    trash = ro2ho(&(ro[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ro2hoLoop (double* ro, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(rostep, hostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * hostep; \n      \n    trash = ro2ho(&(ro[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void y_solve_cell(void) \n{ \n    int i, j, k, jsize; \n    jsize = grid_points[1] - 1; \n#pragma omp for  \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            binvcrhs(lhs[i][0][k][1], lhs[i][0][k][2], rhs[i][0][k]); \n        } \n    } \n    for (j = 1; \n        j < jsize; \n        j++) \n    { \n#pragma omp for  \n        for (i = 1; \n            i < grid_points[0] - 1; \n            i++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                matvec_sub(lhs[i][j][k][0], rhs[i][j - 1][k], rhs[i][j][k]); \n                matmul_sub(lhs[i][j][k][0], lhs[i][j - 1][k][2], lhs[i][j][k][1]); \n                binvcrhs(lhs[i][j][k][1], lhs[i][j][k][2], rhs[i][j][k]); \n            } \n        } \n    } \n#pragma omp for  \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            matvec_sub(lhs[i][jsize][k][0], rhs[i][jsize - 1][k], rhs[i][jsize][k]); \n            matmul_sub(lhs[i][jsize][k][0], lhs[i][jsize - 1][k][2], lhs[i][jsize][k][1]); \n            binvrhs(lhs[i][jsize][k][1], rhs[i][jsize][k]); \n        } \n    } \n} ", "pred": " \nstatic void y_solve_cell(void) \n{ \n    int i, j, k, jsize; \n    jsize = grid_points[1] - 1; \n#pragma omp for  \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            binvcrhs(lhs[i][0][k][1], lhs[i][0][k][2], rhs[i][0][k]); \n        } \n    } \n    for (j = 1; \n        j < jsize; \n        j++) \n    { \n#pragma omp for  \n        for (i = 1; \n            i < grid_points[0] - 1; \n            i++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                matvec_sub(lhs[i][j][k][0], rhs[i][j - 1][k], rhs[i][j][k]); \n                matmul_sub(lhs[i][j][k][0], lhs[i][j - 1][k][2], lhs[i][j][k][1]); \n                binvcrhs(lhs[i][j][k][1], lhs[i][j][k][2], rhs[i][j][k]); \n              matmul_sub(lhs[i][j][k][1], lhs[i][j][k][2], rhs[i][j][k]);            matmul_sub(lhs[i][j][k][2], lhs[i][j][k][1], rhs[i][j][k]);            matmul_sub(lhs[i][j][k][2], lhs[i][j][k][1], rhs[i][j][k]);            matmul_sub(lhs[i][j][k][2], lhs[i][j][k][1], rhs[i][j][k]);            matmul_sub(lhs[i][j][k][2], lhs[i][j][k][1], rhs[i][j][k]);            matmul_sub(lhs[i][j][k][2], lhs[i][j][k][1], rhs[i][j][k]);            matmul_sub(lhs[i][j][k][2],"}
{"label": " \nint ro2axLoop (double* ro, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(rostep, axstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * axstep; \n      \n    trash = ro2ax(&(ro[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ro2axLoop (double* ro, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(rostep, axstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * axstep; \n      \n    trash = ro2ax(&(ro[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void z_backsubstitute(void) \n{ \n    int i, j, k, m, n; \n#pragma omp for  \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = grid_points[2] - 2; \n                k >= 0; \n                k--) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        rhs[i][j][k][m] = rhs[i][j][k][m] - lhs[i][j][k][2][m][n] * rhs[i][j][k + 1][n]; \n                    } \n                } \n            } \n        } \n    } \n} ", "pred": " \nstatic void z_backsubstitute(void) \n{ \n    int i, j, k, m, n; \n#pragma omp for  \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = grid_points[2] - 2; \n                k >= 0; \n                k--) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        rhs[i][j][k][m] = rhs[i][j][k][m] - lhs[i][j][k][2][m][n] * rhs[i][j][k + 1][n]; \n                    } \n                } \n            } \n        } \n    } \n} "}
{"label": " \nint main() \n{ \n  Entero_grande i, n; \n   \n  #ifdef _OPENMP \n  double t1 = omp_get_wtime(); \n  #endif   \n   \n  int numberOfThreads; \n  #pragma omp parallel \n  numberOfThreads = omp_get_num_threads(); \n  n = 2;  \n \n  #pragma omp parallel for reduction(+:n) schedule(runtime) \n  for (i = 3; i <= N; i += 2){ \n      if (primo(i)) \n      { \n         n++; \n      } \n  } \n   \n  #ifdef _OPENMP \n  double t2 = omp_get_wtime(); \n  printf(\"looptime: %f seconds \\n\", t2-t1); \n  #endif \n   \n  printf(\"Entre el 1 y el %llu hay %llu numeros primos.\\n\", \n         N, n); \n \n  return 0; \n} ", "pred": " \nint main() \n{ \n  Entero_grande i, n; \n   \n  #ifdef _OPENMP \n  double t1 = omp_get_wtime(); \n  #endif   \n   \n  int numberOfThreads; \n  #pragma omp parallel \n  numberOfThreads = omp_get_num_threads(); \n  n = 2;  \n \n  #pragma omp parallel for reduction(+:n) schedule(runtime) \n  for (i = 3; i <= N; i += 2){ \n      if (primo(i)) \n      { \n         n++; \n      } \n  } \n   \n  #ifdef _OPENMP \n  double t2 = omp_get_wtime(); \n  printf(\"looptime: %f seconds \\n\", t2-t1); \n  #endif \n   \n  printf(\"Entre el 1 y el %llu hay %llu numeros primos.\\n\", \n         N, n); \n \n  return 0; \n} "}
{"label": " \nstatic void exact_rhs(void) \n{ \n    double dtemp[5], xi, eta, zeta, dtpp; \n    int m, i, j, k, ip1, im1, jp1, jm1, km1, kp1; \n#pragma omp for  \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    forcing[i][j][k][m] = 0.0; \n                } \n            } \n        } \n    } \n#pragma omp for  \n    for (j = 1; \n        j < grid_points[1] - 1; \n        j++) \n    { \n        eta = (double) j * dnym1; \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            zeta = (double) k * dnzm1; \n            for (i = 0; \n                i < grid_points[0]; \n                i++) \n            { \n                xi = (double) i * dnxm1; \n                exact_solution(xi, eta, zeta, dtemp); \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    ue[i][m] = dtemp[m]; \n                } \n                dtpp = 1.0 / dtemp[0]; \n                for (m = 1; \n                    m <= 4; \n                    m++) \n                { \n                    buf[i][m] = dtpp * dtemp[m]; \n                } \n                cuf[i] = buf[i][1] * buf[i][1]; \n                buf[i][0] = cuf[i] + buf[i][2] * buf[i][2] + buf[i][3] * buf[i][3]; \n                q[i] = 0.5 * (buf[i][1] * ue[i][1] + buf[i][2] * ue[i][2] + buf[i][3] * ue[i][3]); \n            } \n            for (i = 1; \n                i < grid_points[0] - 1; \n                i++) \n            { \n                im1 = i - 1; \n                ip1 = i + 1; \n                forcing[i][j][k][0] = forcing[i][j][k][0] - tx2 * (ue[ip1][1] - ue[im1][1]) + dx1tx1 * (ue[ip1][0] - 2.0 * ue[i][0] + ue[im1][0]); \n                forcing[i][j][k][1] = forcing[i][j][k][1] - tx2 * ((ue[ip1][1] * buf[ip1][1] + c2 * (ue[ip1][4] - q[ip1])) - (ue[im1][1] * buf[im1][1] + c2 * (ue[im1][4] - q[im1]))) + xxcon1 * (buf[ip1][1] - 2.0 * buf[i][1] + buf[im1][1]) + dx2tx1 * (ue[ip1][1] - 2.0 * ue[i][1] + ue[im1][1]); \n                forcing[i][j][k][2] = forcing[i][j][k][2] - tx2 * (ue[ip1][2] * buf[ip1][1] - ue[im1][2] * buf[im1][1]) + xxcon2 * (buf[ip1][2] - 2.0 * buf[i][2] + buf[im1][2]) + dx3tx1 * (ue[ip1][2] - 2.0 * ue[i][2] + ue[im1][2]); \n                forcing[i][j][k][3] = forcing[i][j][k][3] - tx2 * (ue[ip1][3] * buf[ip1][1] - ue[im1][3] * buf[im1][1]) + xxcon2 * (buf[ip1][3] - 2.0 * buf[i][3] + buf[im1][3]) + dx4tx1 * (ue[ip1][3] - 2.0 * ue[i][3] + ue[im1][3]); \n                forcing[i][j][k][4] = forcing[i][j][k][4] - tx2 * (buf[ip1][1] * (c1 * ue[ip1][4] - c2 * q[ip1]) - buf[im1][1] * (c1 * ue[im1][4] - c2 * q[im1])) + 0.5 * xxcon3 * (buf[ip1][0", "pred": " \nstatic void exact_rhs(void) \n{ \n    double dtemp[5], xi, eta, zeta, dtpp; \n    int m, i, j, k, ip1, im1, jp1, jm1, km1, kp1; \n#pragma omp for  \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    forcing[i][j][k][m] = 0.0; \n                } \n            } \n        } \n    } \n#pragma omp for  \n    for (j = 1; \n        j < grid_points[1] - 1; \n        j++) \n    { \n        eta = (double) j * dnym1; \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            zeta = (double) j * dnym1;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "}
{"label": " \nint eu2hoLoop (double* eu, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(eustep, hostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * hostep; \n      \n    trash = eu2ho(&(eu[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint eu2hoLoop (double* eu, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(eustep, hostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * hostep; \n      \n    trash = eu2ho(&(eu[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nvoid \nf1 (void) \n{ \n  int i; \n  #pragma omp distribute \n  for (i = 0; i < 64; i++) \n    ; \n  #pragma omp distribute private (i) \n  for (i = 0; i < 64; i++) \n    ; \n  #pragma omp distribute \n  for (int j = 0; j < 64; j++) \n    ; \n  #pragma omp distribute lastprivate (s1) \n  for (s1 = 0; s1 < 64; s1 += 2) \n    ; \n  #pragma omp distribute lastprivate (s2) \n  for (i = 0; i < 64; i++) \n    s2 = 2 * i; \n  #pragma omp distribute simd \n  for (i = 0; i < 64; i++) \n    ; \n  #pragma omp distribute simd lastprivate (s3, s4) collapse(2) \n  for (s3 = 0; s3 < 64; s3++) \n    for (s4 = 0; s4 < 3; s4++) \n      ; \n  #pragma omp distribute parallel for \n  for (i = 0; i < 64; i++) \n    ; \n  #pragma omp distribute parallel for private (i) \n  for (i = 0; i < 64; i++) \n    ; \n  #pragma omp distribute parallel for lastprivate (s5) \n  for (s5 = 0; s5 < 64; s5++) \n    ; \n  #pragma omp distribute firstprivate (s7) private (s8) \n  for (i = 0; i < 64; i++) \n    s8 = s7++; \n} ", "pred": " \nvoid \nf1 (void) \n{ \n  int i; \n  #pragma omp distribute \n  for (i = 0; i < 64; i++) \n    ; \n  #pragma omp distribute private (i) \n  for (i = 0; i < 64; i++) \n    ; \n  #pragma omp distribute \n  for (int j = 0; j < 64; j++) \n    ; \n  #pragma omp distribute lastprivate (s1) \n  for (s1 = 0; s1 < 64; s1 += 2) \n    ; \n  #pragma omp distribute lastprivate (s2) \n  for (i = 0; i < 64; i++) \n    s2 = 2 * i; \n  #pragma omp distribute simd \n  for (i = 0; i < 64; i++) \n    ; \n  #pragma omp distribute simd lastprivate (s3, s4) collapse(2) \n  for (s3 = 0; s3 < 64; s3++) \n    for (s4 = 0; s4 < 3; s4++) \n      ; \n  #pragma omp distribute parallel for \n  for (i = 0; i < 64; i++) \n    ; \n  #pragma omp distribute parallel for private (i) \n  for (i = 0; i < 64; i++) \n    ; \n  #pragma omp distribute parallel for lastprivate (s5) \n  for (s5 = 0; s5 < 64; s5++) \n    ; \n  #pragma omp distribute firstprivate (s7) private (s8) \n  for (i = 0; i < 64; i++) \n    s8 = s7++; \n} "}
{"label": "struct_ratios(const float *const restrict HF, const float *const restrict LF, \n                                               const float *const restrict texture, \n                                               const float *const restrict mask, \n                                               float *const restrict reconstructed, const size_t width, \n                                               const size_t height, const size_t ch, const float gamma, \n                                               const float gamma_comp, const float beta, const float beta_comp, \n                                               const float delta, const size_t s, const size_t scales) \n{ \n \n \n#pragma omp parallel for default(none)                                                                            dt_omp_firstprivate(width, height, ch, HF, LF, texture, mask, reconstructed, gamma, gamma_comp, beta,                                  beta_comp, delta, s, scales) schedule(simd                                                                                                               : static) \n  for(size_t k = 0; k < height * width * ch; k += 4) \n  { \n    const float alpha = mask[k / ch]; \n \n     \n \n    const float *const restrict HF_c = __builtin_assume_aligned(HF + k, 16); \n    const float *const restrict LF_c = __builtin_assume_aligned(LF + k, 16); \n    const float *const restrict TT_c = __builtin_assume_aligned(texture + k, 16); \n \n     \n \n     \n \n     \n \n    const float grey_texture = fmaxabsf(fmaxabsf(TT_c[0], TT_c[1]), TT_c[2]); \n \n     \n \n     \n \n    const float grey_details = (HF_c[0] + HF_c[1] + HF_c[2]) / 3.f; \n \n     \n \n     \n \n     \n \n    const float grey_HF = (gamma_comp * grey_details + gamma * grey_texture); \n \n    #ifdef _OPENMP \n    #pragma omp simd aligned(reconstructed:64) aligned(HF_c, TT_c, LF_c:16) linear(k:4) \n    #endif \n    for(size_t c = 0; c < 4; c++) \n    { \n       \n \n       \n \n      const float details = 0.5f * ((gamma_comp * HF_c[c] + gamma * TT_c[c]) + grey_HF); \n \n       \n \n      const float residual = (s == scales - 1)? LF_c[c] : 0.f; \n      reconstructed[k + c] += alpha * (delta * details + residual); \n    } \n  } \n} \n \n \nstatic inline void init_reconstru ", "pred": "struct_ratios(const float *const restrict HF, const float *const restrict LF, \n                                               const float *const restrict texture, \n                                               const float *const restrict mask, \n                                               float *const restrict reconstructed, const size_t width, \n                                               const size_t height, const size_t ch, const float gamma, \n                                               const float gamma_comp, const float beta, const float beta_comp, \n                                               const float delta, const size_t s, const size_t scales) \n{ \n \n \n#pragma omp parallel for default(none)                                                                            dt_omp_firstprivate(width, height, ch, HF, LF, texture, mask, reconstructed, gamma, gamma_comp, beta,                                  beta_comp, delta, s, scales) schedule(simd                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " \nstatic void lhsinit(void) \n{ \n    int i, j, k, m, n; \n#pragma omp for  \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        lhs[i][j][k][0][m][n] = 0.0; \n                        lhs[i][j][k][1][m][n] = 0.0; \n                        lhs[i][j][k][2][m][n] = 0.0; \n                    } \n                } \n            } \n        } \n    } \n#pragma omp for  \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    lhs[i][j][k][1][m][m] = 1.0; \n                } \n            } \n        } \n    } \n} ", "pred": " \nstatic void lhsinit(void) \n{ \n    int i, j, k, m, n; \n#pragma omp for  \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        lhs[i][j][k][0][m][n] = 0.0; \n                        lhs[i][j][k][1][m][n] = 0.0; \n                        lhs[i][j][k][2][m][n] = 0.0; \n                    } \n                } \n                                                                                                                                                                                                                                                                                                                                                                                                                   "}
{"label": " \nint qu2euLoop (double* qu, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(qustep, eustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * eustep; \n      \n    trash = qu2eu(&(qu[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint qu2euLoop (double* qu, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(qustep, eustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * eustep; \n      \n    trash = qu2eu(&(qu[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": "(const float *const restrict in, const float *const restrict mask, \n                                    float *const restrict reconstructed, const size_t width, const size_t height) \n{ \n \n \n \n \n#pragma omp parallel for default(none) dt_omp_firstprivate(in, mask, reconstructed, width, height)    schedule(static) \n  for(size_t k = 0; k < height * width; k++) \n  { \n    for_each_channel(c,aligned(in,mask,reconstructed)) \n      reconstructed[4*k + c] = fmaxf(in[4*k + c] * (1.f - mask[k]), 0.f); \n  } \n} \n \n \nstatic inline void wavelets_detail ", "pred": "(const float *const restrict in, const float *const restrict mask, \n                                    float *const restrict reconstructed, const size_t width, const size_t height) \n{ \n \n \n \n \n#pragma omp parallel for default(none) dt_omp_firstprivate(in, mask, reconstructed, width, height)    schedule(static) \n  for(size_t k = 0; k < height * width; k++) \n  { \n    for_each_channel(c,aligned(in,mask,reconstructed)) \n      reconstructed[4*k + c] = fmaxf(in[4*k + c] * (1.f - mask[k]), 0.f); \n  } \n} \n \n \nstatic inline void wavelets_detail "}
{"label": " \nint eu2cuLoop (double* eu, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(eustep, custep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * custep; \n      \n    trash = eu2cu(&(eu[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint eu2cuLoop (double* eu, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(eustep, custep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * custep; \n      \n    trash = eu2cu(&(eu[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint main ( int argc, char *argv[] ) { \n \n    const double origin[3] = { 0.0, 0.0, 0.0 }; \n     \n \n     \n \n    double dim[3] = { 10.0, 10.0, 10.0 }; \n     \n \n    int nr_parts = 32680; \n     \n \n    double Temp = 100.0; \n     \n \n \n    double x[3], vtot[3] = { 0.0, 0.0, 0.0 }; \n    double epot, ekin, v2, temp, cutoff = 1.0, cellwidth; \n     \n \n    struct engine e; \n    struct particle pAr; \n    struct potential *pot_ArAr; \n     \n \n    int i, j, k, cid, pid, nr_runners = 1, nr_steps = 1000; \n    int nx, ny, nz; \n    double hx, hy, hz, w; \n    double L[] = { cutoff, cutoff, cutoff }; \n     \n \n \n    ticks tic, toc, toc_step, toc_temp; \n \n    tic = getticks(); \n \n     \n \n    if ( argc > 4 ) { \n        cellwidth = atof( argv[4] ); \n        nr_parts *= ( cellwidth * cellwidth * cellwidth ); \n        for ( k = 0 ; k < 3 ; k++ ) { \n            L[k] = cellwidth; \n            dim[k] *= cellwidth * (1.0 + DBL_EPSILON); \n        } \n    } \n    else \n        cellwidth = 1.0; \n    printf(\"main: cell width set to %22.16e.\\n\", cellwidth); \n \n     \n \n    printf(\"main: initializing the engine... \"); fflush(stdout); \n    if ( engine_init( &e, origin, dim, L, cutoff, space_periodic_full, 2, engine_flag_none )!= 0 ) { \n        printf(\"main: engine_init failed with engine_err=%i.\\n\",engine_err); \n        errs_dump(stdout); \n        return 1; \n    } \n    printf(\"done.\\n\"); fflush(stdout); \n \n     \n \n    printf(\"main: cell dimensions = [ %i, %i, %i ].\\n\", e.s.cdim[0], e.s.cdim[1], e.s.cdim[2] ); \n    printf(\"main: cell size = [ %e, %e, %e ].\\n\", e.s.h[0], e.s.h[1], e.s.h[2] ); \n    printf(\"main: cutoff set to %22.16e.\\n\", cutoff); \n    printf(\"main: nr tasks: %i.\\n\",e.s.nr_tasks); \n \n     \n \n \n \n     \n \n    if ( ( pot_ArAr = potential_create_LJ126( 0.275, 1.0, 9.5075e-06, 6.1545e-03, 1.0e-3 ) ) == NULL ) { \n        printf(\"main: potential_create_LJ126 failed with potential_err=%i.\\n\",potential_err); \n        errs_dump(stdout); \n        return 1; \n    } \n    printf(\"main: constructed ArAr-potential with %i intervals.\\n\",pot_ArAr->n); fflush(stdout); \n \n \n     \n \n    if ( ( pAr.type = engine_addtype( &e, 39.948, 0.0, \"Ar\", \"Ar\" ) ) < 0 ) { \n        printf(\"main: call to engine_addtype failed.\\n\"); \n        errs_dump(stdout); \n        return 1; \n    } \n \n     \n \n    if ( engine_addpot( &e, pot_ArAr, pAr.type, pAr.type ) < 0 ){ \n        printf(\"main: call to engine_addpot failed.\\n\"); \n        errs_dump(stdout); \n        return 1; \n    } \n \n     \n \n    srand(6178); \n    pAr.flags = PARTICLE_FLAG_NONE; \n    for ( k = 0 ; k < 3 ; k++ ) { \n        pAr.v[k] = 0.0; \n        pAr.f[k] = 0.0; \n    } \n    pAr.v[3] = 0.0; pAr.f[3] = 0.0; pAr.x[3] = 0.0; \n \n     \n \n    printf(\"main: initializing particles... \"); fflush(stdout); \n    nx = ceil( pow( nr_parts, 1.0/3 ) ); hx = dim[0] / nx; \n    ny = ceil( sqrt( ((double)nr_parts) / nx ) ); hy = dim[1] / ny; \n    nz = ceil( ((double)nr_parts) / nx / ny ); hz = dim[2] / nz; \n    for ( i = 0 ; i < nx ; i++ ) { \n        x[0] = 0.05 + i * hx; \n        for ( j = 0 ; j < ny ; j++ ) { \n            x[1] = 0.05 + j * hy; \n            for ( k = 0 ; k < nz && k + nz * ( j + ny * i ) < nr_parts ; k++ ) { \n                pAr.id = k + nz * ( j + ny * i ); \n                x[2] = 0.05 + k * hz; \n                pAr.v[0] = ((double)rand()) / RAND_MAX - 0.5; \n                pAr.v[1] = ((double)rand()) / RAND_MAX - 0.5; \n                pAr.v[2] = ((double)rand()) / RAND_MAX - 0.5; \n                temp = 0.275 / sqrt( pAr.v[0]*pAr.v[0] + pAr.v[1]*pAr.v[1] + pAr.v[2]*pAr.v[2] ); \n                pAr.v[0] *= temp; pAr.v[1] *= temp; pAr.v[2] *= temp; \n        ", "pred": " \nint main ( int argc, char *argv[] ) { \n \n    const double origin[3] = { 0.0, 0.0, 0.0 }; \n     \n \n     \n \n    double dim[3] = { 10.0, 10.0, 10.0 }; \n     \n \n    int nr_parts = 32680; \n     \n \n    double Temp = 100.0; \n     \n \n \n    double x[3], vtot[3] = { 0.0, 0.0, 0.0 }; \n    double epot, ekin, v2, temp, cutoff = 1.0, cellwidth; \n     \n \n    struct engine e; \n    struct particle pAr; \n    struct potential *pot_ArAr; \n     \n \n    int i, j, k, cid, pid, nr_runners = 1, nr_steps = 1000; \n    int nx, ny, nz; \n    double hx, hy, hz, w; \n    double L[] = { cutoff, cutoff, cutoff }; \n     \n \n \n    ticks tic, toc, toc_step, toc_temp; \n \n    tic = getticks(); \n \n     \n \n    if ( argc > 4 ) { \n        cellwidth = atof( argv[4] ); \n        nr_parts *= ( cellwidth * cellwidth * cellwidth ); \n        for ( k = 0 ; k < 3 ; k++ ) { \n            L[k] = cellwidth; \n            dim[k] *= cellwidth * (1.0 + DBL_EPSILON); \n        } \n    } \n    else \n        cellwidth = 1.0; \n    printf(\"main: cell width set to %22.16e.\\n\", cellwidth); \n \n     \n \n    printf(\"main: initializing the engine... \");\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": "at *const restrict mask, float *const restrict out, const size_t width, \n                                const size_t height) \n{ \n#pragma omp parallel for default(none) dt_omp_firstprivate(width, height, out, mask) schedule(static) \n  for(size_t k = 0; k < height * width; k++) \n  { \n    for_each_channel(c,aligned(out)) \n      out[4*k+c] = mask[k]; \n  } \n} \n \n \nstatic inline void compute_ratios(const ", "pred": "at *const restrict mask, float *const restrict out, const size_t width, \n                                const size_t height) \n{ \n#pragma omp parallel for default(none) dt_omp_firstprivate(width, height, out, mask) schedule(static) \n  for(size_t k = 0; k < height * width; k++) \n  { \n    for_each_channel(c,aligned(out)) \n      out[4*k+c] = mask[k]; \n  } \n} \n \n \nstatic inline void compute_ratios(const "}
{"label": " \nint cu2quLoop (double* cu, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(custep, qustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * qustep; \n      \n    trash = cu2qu(&(cu[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint cu2quLoop (double* cu, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(custep, qustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * qustep; \n      \n    trash = cu2qu(&(cu[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ro2quLoop (double* ro, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(rostep, qustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * qustep; \n      \n    trash = ro2qu(&(ro[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ro2quLoop (double* ro, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(rostep, qustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * qustep; \n      \n    trash = ro2qu(&(ro[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint qu2omLoop (double* qu, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(qustep, omstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * omstep; \n      \n    trash = qu2om(&(qu[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint qu2omLoop (double* qu, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(qustep, omstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * omstep; \n      \n    trash = qu2om(&(qu[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": "const restrict ratios, const float *const restrict norms, \n                                  const size_t width, const size_t height) \n{ \n  #ifdef _OPENMP \n  #pragma omp parallel for default(none)      dt_omp_firstprivate(width, height, norms, ratios)      schedule(simd:static) \n  #endif \n  for(size_t k = 0; k < height * width; k++) \n    for_each_channel(c,aligned(norms,ratios)) \n      ratios[4*k + c] = clamp_simd(ratios[4*k + c]) * norms[k]; \n} \n \nvoid tiling_callback(struct dt_iop_modul ", "pred": "const restrict ratios, const float *const restrict norms, \n                                  const size_t width, const size_t height) \n{ \n  #ifdef _OPENMP \n  #pragma omp parallel for default(none)      dt_omp_firstprivate(width, height, norms, ratios)      schedule(simd:static) \n  #endif \n  for(size_t k = 0; k < height * width; k++) \n    for_each_channel(c,aligned(norms,ratios)) \n      ratios[4*k + c] = clamp_simd(ratios[4*k + c]) * norms[k]; \n} \n \nvoid tiling_callback(struct dt_iop_modul "}
{"label": " float *const restrict in, float *const restrict out, \n                                   const dt_iop_order_iccprofile_info_t *const work_profile, \n                                   const dt_iop_filmicrgb_data_t *const data, \n                                   const dt_iop_filmic_rgb_spline_t spline, const size_t width, \n                                   const size_t height) \n{ \n#pragma omp parallel for default(none)    dt_omp_firstprivate(width, height, data, in, out, work_profile, spline)    schedule(simd : static) \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n    dt_aligned_pixel_t temp; \n \n     \n \n    for(int c = 0; c < 3; c++) \n      temp[c] = log_tonemapping_v1(fmaxf(pix_in[c], NORM_MIN), data->grey_source, data->black_source, \n                                   data->dynamic_range); \n \n     \n \n    const float lum = (work_profile) \n                         ? dt_ioppr_get_rgb_matrix_luminance(temp, work_profile->matrix_in, work_profile->lut_in, \n                                                              work_profile->unbounded_coeffs_in, \n                                                              work_profile->lutsize, work_profile->nonlinearlut) \n                          : dt_camera_rgb_luminance(temp); \n    const float desaturation = filmic_desaturate_v1(lum, data->sigma_toe, data->sigma_shoulder, data->saturation); \n \n     \n \n     \n \n     \n \n    for(int c = 0; c < 3; c++) \n      pix_out[c] = powf( \n          clamp_simd(filmic_spline(linear_saturation(temp[c], lum, desaturation), spline.M1, spline.M2, spline.M3, \n                                   spline.M4, spline.M5, spline.latitude_min, spline.latitude_max, spline.type)), \n          data->output_power); \n  } \n} \n \n \nstatic inline void filmic_split_v2_v3( ", "pred": " float *const restrict in, float *const restrict out, \n                                   const dt_iop_order_iccprofile_info_t *const work_profile, \n                                   const dt_iop_filmicrgb_data_t *const data, \n                                   const dt_iop_filmic_rgb_spline_t spline, const size_t width, \n                                   const size_t height) \n{ \n#pragma omp parallel for default(none)    dt_omp_firstprivate(width, height, data, in, out, work_profile, spline)    schedule(simd : static) \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n    dt_aligned_pixel_t temp; \n \n     \n \n    for(int c = 0; c < 3; c++) \n      temp[c] = log_tonemapping_v1(fmaxf(pix_in[c], NORM_MIN), data->grey_source, data->black_source, \n                                   data->dynamic_range); \n \n     \n \n    const float lum = (work_profile) \n                         ? dt_ioppr_get_rgb_matrix_luminance(temp, work_profile->matrix_in, work_profile->lut_in, \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": " \nint om2axLoop (double* om, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(omstep, axstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * axstep; \n      \n    trash = om2ax(&(om[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint om2axLoop (double* om, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(omstep, axstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * axstep; \n      \n    trash = om2ax(&(om[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint cu2roLoop (double* cu, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(custep, rostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * rostep; \n      \n    trash = cu2ro(&(cu[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint cu2roLoop (double* cu, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(custep, rostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * rostep; \n      \n    trash = cu2ro(&(cu[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void y_backsubstitute(void) \n{ \n    int i, j, k, m, n; \n    for (j = grid_points[1] - 2; \n        j >= 0; \n        j--) \n    { \n#pragma omp for  \n        for (i = 1; \n            i < grid_points[0] - 1; \n            i++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        rhs[i][j][k][m] = rhs[i][j][k][m] - lhs[i][j][k][2][m][n] * rhs[i][j + 1][k][n]; \n                    } \n                } \n            } \n        } \n    } \n} ", "pred": " \nstatic void y_backsubstitute(void) \n{ \n    int i, j, k, m, n; \n    for (j = grid_points[1] - 2; \n        j >= 0; \n        j--) \n    { \n#pragma omp for  \n        for (i = 1; \n            i < grid_points[0] - 1; \n            i++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        rhs[i][j][k][m] = rhs[i][j][k][m] - lhs[i][j][k][2][m][n] * rhs[i][j + 1][k][n]; \n                    } \n                } \n            } \n        } \n    } \n} "}
{"label": " \nvoid tkirmig_lop(bool adj, bool add, int nm, int nd, \n                float *modl, float *data) \n \n \n{ \n     int ih,it,icmp,icdp,itm,itp,im; \n     float cmp,cdp,tau,tau2; \n     float disx,dish_plus,dish_plus2,dish_minus,dish_minus2; \n     float vrms2,ts,tr,time,slope,tm,tp,h,wt; \n     int ompith=0; \n \n     sf_adjnull(adj,add,nm,nd,modl,data); \n     \n#pragma omp parallel for schedule(static,ompchunk)      private(ompith,ih,it,icmp,icdp,itm,itp,im,        cmp,cdp,tau,tau2,        disx,dish_plus,dish_plus2,dish_minus,dish_minus2,        vrms2,ts,tr,time,slope,tm,tp,h,wt)      shared(adj, add, nm, nd, modl, data) \n     for (ih=0; ih < nh; ih++) { \n         ompith=omp_get_thread_num(); \n#pragma omp critical \n         if (verb) sf_warning(\"ith=%d; offset %d of %d;\",ompith, ih+1,nh); \n \n         for (icmp=0; icmp < ncmp; icmp++) { \n \n             if (mask[ih][icmp]==0) continue; \n \n             cmp=cmp0+icmp*dcmp; \n \n             h = fabsf(off[ih*ncmp+icmp]); \n \n             if (adj) { \n                for (it=0; it < nt; it++) { \n                    trace[ompith][it]=data[ih*ncmp*nt+icmp*nt+it]; \n                    img[ompith][it] = 0.; \n                } \n                sf_doubint_lop(adj, false, nt, nt, img[ompith], trace[ompith]); \n             } else { \n                for (it=0; it < nt; it++) { \n                    img[ompith][it] = 0.; \n                    trace[ompith][it] = 0.; \n                } \n             } \n \n           for (icdp=0; icdp < ncdp; icdp++) { \n  \n              cdp = cdp0+icdp*dcdp; \n \n              disx=cdp-cmp; \n \n              if (fabsf(disx) > dcmp*apt) continue; \n \n              dish_plus=fabsf(disx+h); \n              dish_plus2=dish_plus*dish_plus; \n              dish_minus=fabsf(disx-h); \n              dish_minus2=dish_minus*dish_minus; \n \n              for (it=0; it < nt; it++) { \n                  im = ih*ncdp*nt+icdp*nt+it; \n                  tau = 0.5*(t0 + it*dt); \n                  tau2 = tau*tau; \n \n                  vrms2=vrms[icdp][it]*vrms[icdp][it]; \n                  ts=sqrtf(tau2+dish_plus2/vrms2); \n                  tr=sqrtf(tau2+dish_minus2/vrms2); \n                  time=ts+tr; \n \n                  if (time <= t0+(nt-1)*dt && ts!= 0. && tr!=0.) { \n \n                     slope=dish_plus/vrms2/(ts+dt)+dish_minus/vrms2/(tr+dt); \n \n                     tm=time-fabsf(slope*dcmp*aal)-dt; \n                     tp=time+fabsf(slope*dcmp*aal)+dt; \n                     itm=floorf((tm-t0)/dt); \n                     itp=floorf((tp-t0)/dt); \n                     wt=dt/(dt+tp-tm); \n                     wt*=wt; \n \n                     if (amp) wt*=tau*(tr*tr+ts*ts)/ts/tr/sqrtf(ts)/sqrtf(tr)/vrms2; \n                      \n \n \n                     if (itm>=0&&itp<nt-1) { \n                        spotw(adj,-wt,nt,t0,dt,tm,&modl[im],img[ompith]); \n                        spotw(adj,2*wt,nt,t0,dt,time,&modl[im],img[ompith]); \n                        spotw(adj,-wt,nt,t0,dt,tp,&modl[im],img[ompith]); \n                     }", "pred": " \nvoid tkirmig_lop(bool adj, bool add, int nm, int nd, \n                float *modl, float *data) \n \n \n{ \n     int ih,it,icmp,icdp,itm,itp,im; \n     float cmp,cdp,tau,tau2; \n     float disx,dish_plus,dish_plus2,dish_minus,dish_minus2; \n     float vrms2,ts,tr,time,slope,tm,tp,h,wt; \n     int ompith=0; \n \n     sf_adjnull(adj,add,nm,nd,modl,data); \n     \n#pragma omp parallel for schedule(static,ompchunk)      private(ompith,ih,it,icmp,icdp,itm,itp,im,        cmp,cdp,tau,tau2,        disx,dish_plus,dish_plus2,dish_minus,dish_minus2,        vrms2,ts,tr,time,slope,tm,tp,h,wt)      shared(adj, add, nm, nd, modl, data) \n     for (ih=0; ih < nh; ih++) { \n         ompith=omp_get_thread_num(); \n#pragma omp critical \n         if (verb) sf_warning(\"ith=%d; offset %d of %d;\",ompith, ih+1,nh); \n \n         for (icmp=0; icmp < ncmp; icmp++) { \n \n             if (mask[ih][icmp]==0) continue; \n \n             cmp=cmp0+icmp*dcmp; \n \n             h = fabsf(off[ih*ncmp+icmp]); \n \n             if (adj) { \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "}
{"label": " \nint cu2euLoop (double* cu, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(custep, eustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * eustep; \n      \n    trash = cu2eu(&(cu[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint cu2euLoop (double* cu, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(custep, eustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * eustep; \n      \n    trash = cu2eu(&(cu[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic int nn_(SparseLinear_accGradParameters)(lua_State *L) \n{ \n  long i; \n  THTensor * input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor * gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  real scale = luaL_optnumber(L, 4, 1); \n  THTensor * bias = luaT_getfieldcheckudata(L, 1, \"bias\", torch_Tensor); \n  THTensor * weight = luaT_getfieldcheckudata(L, 1, \"weight\", torch_Tensor); \n  THTensor * gradBias = luaT_getfieldcheckudata(L, 1, \"gradBias\", torch_Tensor); \n  THTensor * gradWeight = luaT_getfieldcheckudata(L, 1, \"gradWeight\", torch_Tensor); \n  real weightDecay = luaT_getfieldchecknumber(L, 1, \"weightDecay\"); \n \n  long nnz = input->size[0]; \n  long outDim = weight->size[0]; \n  long inDim = weight->size[1]; \n \n  luaL_argcheck(L, nn_(checkInput)(input), 2, \"input size must be nnz x 2\"); \n  luaL_argcheck( \n    L, nn_(checkSize1D)(gradOutput, outDim), 3, \"gradOutput size wrong\"); \n  luaL_argcheck( \n    L, nn_(checkSize2D)(gradWeight, outDim, inDim), 1, \"gradWeight size wrong\"); \n  luaL_argcheck( \n    L, nn_(checkSize1D)(gradBias, outDim), 1, \"gradBias size wrong\"); \n \n  #pragma omp parallel for private(i) schedule(static) if(outDim * nnz > 100000) \n  for(i = 0; i < nnz; i++) \n  { \n      long offset = (long)(THTensor_(get2d)(input, i, 0)) - 1; \n \n      if(offset >= 0 && offset < inDim)  \n \n      { \n          real val = scale*THTensor_(get2d)(input, i, 1); \n \n          THBlas_(axpy)(outDim, \n                        val, \n                        THTensor_(data)(gradOutput), \n                        gradOutput->stride[0], \n                        THTensor_(data)(gradWeight)+offset*gradWeight->stride[1], \n                        gradWeight->stride[0]); \n      } \n      else { \n          luaL_error(L, \"index out of bound. accGradParameters:  %ld not between 1 and %ld\", offset + 1, inDim); \n      } \n  } \n \n  THTensor_(cadd)(gradBias, gradBias, scale, gradOutput); \n \n  if(weightDecay!= 0) { \n    #pragma omp parallel for private(i) schedule(static) if(outDim * nnz > 100000) \n    for(i = 0; i < nnz; i++) { \n      long offset = (long)(THTensor_(get2d)(input, i, 0)) - 1; \n      THBlas_(axpy)(outDim, \n                    weightDecay, \n                    THTensor_(data)(weight) + offset*weight->stride[1], \n                    weight->stride[0], \n                    THTensor_(data)(gradWeight)+offset*gradWeight->stride[1], \n                    gradWeight->stride[0]); \n    } \n    THTensor_(cadd)(gradBias, gradBias, weightDecay, bias); \n  } \n \n  return 0; \n} ", "pred": " \nstatic int nn_(SparseLinear_accGradParameters)(lua_State *L) \n{ \n  long i; \n  THTensor * input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor * gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  real scale = luaL_optnumber(L, 4, 1); \n  THTensor * bias = luaT_getfieldcheckudata(L, 1, \"bias\", torch_Tensor); \n  THTensor * weight = luaT_getfieldcheckudata(L, 1, \"weight\", torch_Tensor); \n  THTensor * gradBias = luaT_getfieldcheckudata(L, 1, \"gradBias\", torch_Tensor); \n  THTensor * gradWeight = luaT_getfieldcheckudata(L, 1, \"gradWeight\", torch_Tensor); \n  real weightDecay = luaT_getfieldchecknumber(L, 1, \"weightDecay\"); \n \n  long nnz = input->size[0]; \n  long outDim = weight->size[0]; \n  long inDim = weight->size[1]; \n \n  luaL_argcheck(L, nn_(checkInput)(input), 2, \"input size must be nnz x 2\"); \n  luaL_argcheck( \n    L, nn_(checkSize1D)(gradOutput, outDim), 3, \"gradOutput size wrong\"); \n  luaL_argcheck( \n    L, nn_(checkSize2D)(gradWeight, outDim, inDim), 1, \"gradWeight size wrong\"); \n  luaL_argcheck( \n    L, nn_(checkSize1D)(gradBias, outDim), 1, \"gradBias size wrong\"); \n \n  #pragma omp parallel for private(i) schedule(static) if(outDim * nnz > 100000) \n  for(i = 0; i < nnz; i++) \n  { \n      long offset = (long)(THTensor_(get2d)(input, i, 0)) - 1; \n \n      if(offset >= 0 && offset < inDim)  \n \n      { \n          real val = scale*THTensor_(get2d)(input, i, 1);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nint ro2cuLoop (double* ro, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(rostep, custep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * custep; \n      \n    trash = ro2cu(&(ro[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ro2cuLoop (double* ro, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(rostep, custep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * custep; \n      \n    trash = ro2cu(&(ro[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " float *const restrict in, float *const restrict out, \n                                    const dt_iop_order_iccprofile_info_t *const work_profile, \n                                    const dt_iop_order_iccprofile_info_t *const export_profile, \n                                    const dt_iop_filmicrgb_data_t *const data, \n                                    const dt_iop_filmic_rgb_spline_t spline, const int variant, \n                                    const size_t width, const size_t height, const size_t ch, \n                                    const dt_iop_filmicrgb_colorscience_type_t colorscience_version, \n                                    const float display_black, const float display_white) \n{ \n   \n \n  dt_colormatrix_t input_matrix;          \n \n  dt_colormatrix_t output_matrix;         \n \n  dt_colormatrix_t export_input_matrix;   \n \n  dt_colormatrix_t export_output_matrix;  \n \n \n  const int use_output_profile = filmic_v4_prepare_matrices(input_matrix, output_matrix, export_input_matrix, \n                                                            export_output_matrix, work_profile, export_profile); \n \n  const float norm_min = exp_tonemapping_v2(0.f, data->grey_source, data->black_source, data->dynamic_range); \n  const float norm_max = exp_tonemapping_v2(1.f, data->grey_source, data->black_source, data->dynamic_range); \n \n#pragma omp parallel for default(none)                                                                            dt_omp_firstprivate(width, height, ch, data, in, out, work_profile, input_matrix, output_matrix,      variant, spline, display_white, display_black, export_input_matrix, export_output_matrix,      use_output_profile, norm_min, norm_max)         schedule(simd :static) \n  for(size_t k = 0; k < height * width * ch; k += ch) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n \n     \n \n     \n \n     \n \n     \n \n    float norm = CLAMPF(get_pixel_norm(pix_in, variant, work_profile), norm_min, norm_max); \n \n     \n \n    dt_aligned_pixel_t ratios = { 0.0f }; \n    for_each_channel(c,aligned(pix_in)) ratios[c] = pix_in[c] / norm; \n \n     \n \n    norm = log_tonemapping_v2(norm, data->grey_source, data->black_source, data->dynamic_range); \n \n     \n \n     \n \n    norm = powf(CLAMP(filmic_spline(norm, spline.M1, spline.M2, spline.M3, spline.M4, spline.M5, \n                                         spline.latitude_min, spline.latitude_max, spline.type), \n                      display_black, \n                      display_white), \n                data->output_power); \n \n     \n \n    for_each_channel(c,aligned(pix_out)) pix_out[c] = ratios[c] * norm; \n \n     \n \n    dt_aligned_pixel_t Ych_original = { 0.f }; \n    RGB_to_Ych(pix_in, input_matrix, Ych_original); \n \n     \n \n    dt_aligned_pixel_t Ych_final = { 0.f }; \n    RGB_to_Ych(pix_out, input_matrix, Ych_final); \n \n    gamut_mapping(Ych_final, Ych_original, pix_out, input_matrix, output_matrix, export_input_matrix, \n                  export_output_matrix, display_black, display_white, data->saturation, use_output_profile); \n  } \n} \n \nstatic inline void filmic_split_v4(const ", "pred": " float *const restrict in, float *const restrict out, \n                                    const dt_iop_order_iccprofile_info_t *const work_profile, \n                                    const dt_iop_order_iccprofile_info_t *const export_profile, \n                                    const dt_iop_filmicrgb_data_t *const data, \n                                    const dt_iop_filmic_rgb_spline_t spline, const int variant, \n                                    const size_t width, const size_t height, const size_t ch, \n                                    const dt_iop_filmicrgb_colorscience_type_t colorscience_version, \n                                    const float display_black, const float display_white) \n{ \n   \n \n  dt_colormatrix_t input_matrix;          \n \n  dt_colormatrix_t output_matrix;         \n \n  dt_colormatrix_t export_input_matrix;   \n \n  dt_colormatrix_t export_output_matrix;  \n \n \n  const int use_output_profile = filmic_v4_prepare_matrices(input_matrix, output_matrix, export_input_matrix, \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "}
{"label": " \nint eu2roLoop (double* eu, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(eustep, rostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * rostep; \n      \n    trash = eu2ro(&(eu[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint eu2roLoop (double* eu, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(eustep, rostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * rostep; \n      \n    trash = eu2ro(&(eu[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint cu2axLoop (double* cu, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(custep, axstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * axstep; \n      \n    trash = cu2ax(&(cu[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint cu2axLoop (double* cu, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(custep, axstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * axstep; \n      \n    trash = cu2ax(&(cu[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void compute_rhs(void) \n{ \n    int i, j, k, m; \n    double rho_inv, uijk, up1, um1, vijk, vp1, vm1, wijk, wp1, wm1; \n#pragma omp for nowait \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                rho_inv = 1.0 / u[i][j][k][0]; \n                rho_i[i][j][k] = rho_inv; \n                us[i][j][k] = u[i][j][k][1] * rho_inv; \n                vs[i][j][k] = u[i][j][k][2] * rho_inv; \n                ws[i][j][k] = u[i][j][k][3] * rho_inv; \n                square[i][j][k] = 0.5 * (u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * rho_inv; \n                qs[i][j][k] = square[i][j][k] * rho_inv; \n            } \n        } \n    } \n#pragma omp for  \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    rhs[i][j][k][m] = forcing[i][j][k][m]; \n                } \n            } \n        } \n    } \n#pragma omp for  \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                uijk = us[i][j][k]; \n                up1 = us[i + 1][j][k]; \n                um1 = us[i - 1][j][k]; \n                rhs[i][j][k][0] = rhs[i][j][k][0] + dx1tx1 * (u[i + 1][j][k][0] - 2.0 * u[i][j][k][0] + u[i - 1][j][k][0]) - tx2 * (u[i + 1][j][k][1] - u[i - 1][j][k][1]); \n                rhs[i][j][k][1] = rhs[i][j][k][1] + dx2tx1 * (u[i + 1][j][k][1] - 2.0 * u[i][j][k][1] + u[i - 1][j][k][1]) + xxcon2 * con43 * (up1 - 2.0 * uijk + um1) - tx2 * (u[i + 1][j][k][1] * up1 - u[i - 1][j][k][1] * um1 + (u[i + 1][j][k][4] - square[i + 1][j][k] - u[i - 1][j][k][4] + square[i - 1][j][k]) * c2); \n                rhs[i][j][k][2] = rhs[i][j][k][2] + dx3tx1 * (u[i + 1][j][k][2] - 2.0 * u[i][j][k][2] + u[i - 1][j][k][2]) + xxcon2 * (vs[i + 1][j][k] - 2.0 * vs[i][j][k] + vs[i - 1][j][k]) - tx2 * (u[i + 1][j][k][2] * up1 - u[i - 1][j][k][2] * um1); \n                rhs[i][j][k][3] = rhs[i][j][k][3] + dx4tx1 * (u[i + 1][j][k][3] - 2.0 * u[i][j][k][3] + u[i - 1][j][k][3]) + xxcon2 * (ws[i + 1][j][k] - 2.0 * ws[i][j][k] + ws[i - 1][j][k]) - tx2 * (u[i + 1][j][k][3] * up1 - u[i - 1][j][k][3] * um1); \n                rhs[i][j][k][4] = rhs[i][j][k][4] + dx5tx1 * (u[i + 1][j][k][4] - 2.0 * u[i][j][k][4] + u[i - 1][j][k][4]) + xxcon3 * (qs[i + 1][j][k] - 2.0", "pred": " \nstatic void compute_rhs(void) \n{ \n    int i, j, k, m; \n    double rho_inv, uijk, up1, um1, vijk, vp1, vm1, wijk, wp1, wm1; \n#pragma omp for nowait \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                rho_inv = 1.0 / u[i][j][k][0]; \n                rho_i[i][j][k] = rho_inv; \n                us[i][j][k] = u[i][j][k][1] * rho_inv; \n                vs[i][j][k] = u[i][j][k][2] * rho_inv; \n                ws[i][j][k] = u[i][j][k][3] * rho_inv; \n                square[i][j][k] = 0.5 * (u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * rho_inv; \n                qs[i][j][k] = square[i][j][k] * rho_inv;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": "pixels(const float *const restrict in, float *const restrict mask, \n                                       const float normalize, const float feathering, const size_t width, \n                                       const size_t height, const size_t ch) \n{ \n   \n \n \n  int clipped = 0; \n \n  #ifdef __SSE2__ \n     \n \n     \n \n    const unsigned int oldMode = _MM_GET_FLUSH_ZERO_MODE(); \n    _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \n  #endif \n \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(in, mask, normalize, feathering, width, height, ch)    schedule(simd:static) aligned(mask, in:64) reduction(+:clipped) \n  for(size_t k = 0; k < height * width * ch; k += ch) \n  { \n    const float pix_max = fmaxf(sqrtf(sqf(in[k]) + sqf(in[k + 1]) + sqf(in[k + 2])), 0.f); \n    const float argument = -pix_max * normalize + feathering; \n    const float weight = clamp_simd(1.0f / (1.0f + exp2f(argument))); \n    mask[k / ch] = weight; \n \n     \n \n     \n \n     \n \n     \n \n    clipped += (4.f > argument); \n  } \n \n  #ifdef __SSE2__ \n    _MM_SET_FLUSH_ZERO_MODE(oldMode); \n  #endif \n \n   \n \n  return (clipped > 9); \n} \n \n \n#pragma omp dec ", "pred": "pixels(const float *const restrict in, float *const restrict mask, \n                                       const float normalize, const float feathering, const size_t width, \n                                       const size_t height, const size_t ch) \n{ \n   \n \n \n  int clipped = 0; \n \n  #ifdef __SSE2__ \n     \n \n     \n \n    const unsigned int oldMode = _MM_GET_FLUSH_ZERO_MODE(); \n    _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \n  #endif \n \n#pragma omp parallel for simd default(none)    dt_omp_firstprivate(in, mask, normalize, feathering, width, height, ch)    schedule(simd:static) aligned(mask, in:64) reduction(+:clipped) \n  for(size_t k = 0; k < height * width * ch; k += ch) \n  { \n    const float pix_max = fmaxf(sqrtf(sqf(in[k]) + sqf(in[k + 1]) + sqf(in[k + 2])), 0.f); \n    const float argument = -pix_max * normalize + feathering; \n    const float weight = clamp_simd(1.0f / (1.0f + exp2f(argument))); \n    mask[k / ch] = weight; \n \n     \n \n     \n \n     \n \n     \n \n    clipped += (4.f > argument); \n  } \n \n  #ifdef __SSE2__ \n    _MM_SET_FLUSH_ZERO_MODE(oldMode); \n  #endif \n \n   \n \n  return (clipped > 9); \n} \n \n \n#pragma omp dec "}
{"label": " \nint ho2cuLoop (double* ho, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(hostep, custep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * custep; \n      \n    trash = ho2cu(&(ho[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ho2cuLoop (double* ho, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(hostep, custep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * custep; \n      \n    trash = ho2cu(&(ho[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint cu2omLoop (double* cu, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(custep, omstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * omstep; \n      \n    trash = cu2om(&(cu[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint cu2omLoop (double* cu, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(custep, omstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * omstep; \n      \n    trash = cu2om(&(cu[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint qu2hoLoop (double* qu, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(qustep, hostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * hostep; \n      \n    trash = qu2ho(&(qu[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint qu2hoLoop (double* qu, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(qustep, hostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * hostep; \n      \n    trash = qu2ho(&(qu[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": "(const float *const in, const float *const mask, \n                                 float *const inpainted, const float noise_level, const float threshold, \n                                 const dt_noise_distribution_t noise_distribution, \n                                 const size_t width, const size_t height) \n{ \n   \n \n   \n \n   \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(in, mask, inpainted, width, height, noise_level, noise_distribution, threshold)    schedule(simd:static) collapse(2) \n  for(size_t i = 0; i < height; i++) \n    for(size_t j = 0; j < width; j++) \n    { \n       \n \n      uint32_t DT_ALIGNED_ARRAY state[4] = { splitmix32(j + 1), splitmix32((j + 1) * (i + 3)), splitmix32(1337), splitmix32(666) }; \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n \n       \n \n      const size_t idx = i * width + j; \n      const size_t index = idx * 4; \n      const float weight = mask[idx]; \n      const float *const restrict pix_in = __builtin_assume_aligned(in + index, 16); \n      dt_aligned_pixel_t noise = { 0.f }; \n      dt_aligned_pixel_t sigma = { 0.f }; \n      const int DT_ALIGNED_ARRAY flip[4] = { TRUE, FALSE, TRUE, FALSE }; \n \n      for_each_channel(c,aligned(pix_in)) \n        sigma[c] = pix_in[c] * noise_level / threshold; \n \n       \n \n      dt_noise_generator_simd(noise_distribution, pix_in, sigma, flip, state, noise); \n \n       \n \n      float *const restrict pix_out = __builtin_assume_aligned(inpainted + index, 16); \n      for_each_channel(c,aligned(pix_in,pix_out)) \n        pix_out[c] = fmaxf(pix_in[c] * (1.0f - weight) + weight * noise[c], 0.f); \n    } \n} \n \ninline static void wavelets_rec ", "pred": "(const float *const in, const float *const mask, \n                                 float *const inpainted, const float noise_level, const float threshold, \n                                 const dt_noise_distribution_t noise_distribution, \n                                 const size_t width, const size_t height) \n{ \n   \n \n   \n \n   \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(in, mask, inpainted, width, height, noise_level, noise_distribution, threshold)    schedule(simd:static) collapse(2) \n  for(size_t i = 0; i < height; i++) \n    for(size_t j = 0; j < width; j++) \n    { \n       \n \n      uint32_t DT_ALIGNED_ARRAY state[4] = { splitmix32(j + 1), splitmix32((j + 1) * (i + 3)), splitmix32(1337), splitmix32(666) }; \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n \n       \n \n      const size_t idx = i * width + j; \n      const size_t index = idx * 4; \n      const float weight = mask[idx]; \n      const float *const restrict pix_in = __builtin_assume_aligned(in + index, 16); \n      dt_aligned_pixel_t noise = { 0.f }; \n      dt_aligned_pixel_t sigma = { 0.f }; \n      const int DT_ALIGNED_ARRAY flip[4] = { TRUE, FALSE, TRUE, FALSE }; \n \n                                                                                                                                                                                                                                                "}
{"label": " \nstatic void x_backsubstitute(void) \n{ \n    int i, j, k, m, n; \n    for (i = grid_points[0] - 2; \n        i >= 0; \n        i--) \n    { \n#pragma omp for  \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        rhs[i][j][k][m] = rhs[i][j][k][m] - lhs[i][j][k][2][m][n] * rhs[i + 1][j][k][n]; \n                    } \n                } \n            } \n        } \n    } \n} ", "pred": " \nstatic void x_backsubstitute(void) \n{ \n    int i, j, k, m, n; \n    for (i = grid_points[0] - 2; \n        i >= 0; \n        i--) \n    { \n#pragma omp for  \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        rhs[i][j][k][m] = rhs[i][j][k][m] - lhs[i][j][k][2][m][n] * rhs[i + 1][j][k][n]; \n                    } \n                } \n            } \n        } \n    } \n} "}
{"label": " \nvoid \nf3 (void) \n{ \n  int i; \n  #pragma omp for order(concurrent)  \n \n  for (i = 0; i < 64; i++) \n    t++;\t \n \n} ", "pred": " \nvoid \nf3 (void) \n{ \n  int i; \n  #pragma omp for order(concurrent)  \n \n  for (i = 0; i < 64; i++) \n    t++;\t \n \n} "}
{"label": " \nint om2roLoop (double* om, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(omstep, rostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * rostep; \n      \n    trash = om2ro(&(om[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint om2roLoop (double* om, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(omstep, rostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * rostep; \n      \n    trash = om2ro(&(om[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ax2hoLoop (double* ax, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(axstep, hostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * hostep; \n      \n    trash = ax2ho(&(ax[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ax2hoLoop (double* ax, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(axstep, hostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * hostep; \n      \n    trash = ax2ho(&(ax[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ax2cuLoop (double* ax, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(axstep, custep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * custep; \n      \n    trash = ax2cu(&(ax[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ax2cuLoop (double* ax, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(axstep, custep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * custep; \n      \n    trash = ax2cu(&(ax[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ho2quLoop (double* ho, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(hostep, qustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * qustep; \n      \n    trash = ho2qu(&(ho[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ho2quLoop (double* ho, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(hostep, qustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * qustep; \n      \n    trash = ho2qu(&(ho[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ax2omLoop (double* ax, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(axstep, omstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * omstep; \n      \n    trash = ax2om(&(ax[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ax2omLoop (double* ax, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(axstep, omstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * omstep; \n      \n    trash = ax2om(&(ax[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ho2euLoop (double* ho, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(hostep, eustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * eustep; \n      \n    trash = ho2eu(&(ho[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ho2euLoop (double* ho, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(hostep, eustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * eustep; \n      \n    trash = ho2eu(&(ho[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": "evel(const float *const restrict detail, const float *const restrict LF, \n                                             float *const restrict HF, float *const restrict texture, \n                                             const size_t width, const size_t height, const size_t ch) \n{ \n#pragma omp parallel for simd default(none) dt_omp_firstprivate(width, height, HF, LF, detail, texture)                schedule(simd                                                                                                               : static) aligned(HF, LF, detail, texture : 64) \n  for(size_t k = 0; k < height * width; k++) \n  { \n    for(size_t c = 0; c < 4; ++c) HF[4*k + c] = texture[4*k + c] = detail[4*k + c] - LF[4*k + c]; \n  } \n} \n \nstatic int get_scales(const dt_iop_ ", "pred": "evel(const float *const restrict detail, const float *const restrict LF, \n                                             float *const restrict HF, float *const restrict texture, \n                                             const size_t width, const size_t height, const size_t ch) \n{ \n#pragma omp parallel for simd default(none) dt_omp_firstprivate(width, height, HF, LF, detail, texture)                schedule(simd                                                                                                               : static) aligned(HF, LF, detail, texture : 64) \n  for(size_t k = 0; k < height * width; k++) \n  { \n    for(size_t c = 0; c < 4; ++c) HF[4*k + c] = texture[4*k + c] = detail[4*k + c] - LF[4*k + c]; \n  } \n} \n \nstatic int get_scales(const dt_iop_ "}
{"label": " \nint om2cuLoop (double* om, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(omstep, custep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * custep; \n      \n    trash = om2cu(&(om[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint om2cuLoop (double* om, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(omstep, custep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * custep; \n      \n    trash = om2cu(&(om[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void x_solve_cell(void) \n{ \n    int i, j, k, isize; \n    isize = grid_points[0] - 1; \n#pragma omp for  \n    for (j = 1; \n        j < grid_points[1] - 1; \n        j++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            binvcrhs(lhs[0][j][k][1], lhs[0][j][k][2], rhs[0][j][k]); \n        } \n    } \n    for (i = 1; \n        i < isize; \n        i++) \n    { \n#pragma omp for  \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                matvec_sub(lhs[i][j][k][0], rhs[i - 1][j][k], rhs[i][j][k]); \n                matmul_sub(lhs[i][j][k][0], lhs[i - 1][j][k][2], lhs[i][j][k][1]); \n                binvcrhs(lhs[i][j][k][1], lhs[i][j][k][2], rhs[i][j][k]); \n            } \n        } \n    } \n#pragma omp for  \n    for (j = 1; \n        j < grid_points[1] - 1; \n        j++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            matvec_sub(lhs[isize][j][k][0], rhs[isize - 1][j][k], rhs[isize][j][k]); \n            matmul_sub(lhs[isize][j][k][0], lhs[isize - 1][j][k][2], lhs[isize][j][k][1]); \n            binvrhs(lhs[i][j][k][1], rhs[i][j][k]); \n        } \n    } \n} ", "pred": " \nstatic void x_solve_cell(void) \n{ \n    int i, j, k, isize; \n    isize = grid_points[0] - 1; \n#pragma omp for  \n    for (j = 1; \n        j < grid_points[1] - 1; \n        j++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            binvcrhs(lhs[0][j][k][1], lhs[0][j][k][2], rhs[0][j][k]); \n        } \n    } \n    for (i = 1; \n        i < isize; \n        i++) \n    { \n#pragma omp for  \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                matvec_sub(lhs[i][j][k][0], rhs[i - 1][j][k], rhs[i][j][k]); \n                matmul_sub(lhs[i][j][k][0], lhs[i - 1][j][k][2], lhs[i][j][k][1]); \n                binvcrhs(lhs[i][j][k][1], lhs[i][j][k][2], rhs[i][j][k]); \n              matmul_sub(lhs[i][j][k][1], lhs[i][j][k][2], rhs[i][j][k]);            matmul_sub(lhs[i][j][k][2], lhs[i][j][k][1], rhs[i][j][k]);            matmul_sub(lhs[i][j][k][2], lhs[i][j][k][1], rhs[i][j][k]);            matmul_sub(lhs[i][j][k][2], lhs[i][j][k][1], rhs[i][j][k]);            matmul_sub(lhs[i][j][k][2], lhs[i][j][k][1], rhs[i][j][k]);            matmul_sub(lhs[i][j][k][2], lhs[i][j][k][1], rhs[i][j][k]);            matmul_sub(lhs[i][j][k]["}
{"label": " \nvoid process(struct dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, const void *const i, \n             void *const o, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_defringe_data_t *d = (dt_iop_defringe_data_t *)piece->data; \n  assert(dt_iop_module_colorspace(module) == iop_cs_Lab); \n \n  const int order = 1;  \n \n  const float sigma = fmax(0.1f, fabs(d->radius)) * roi_in->scale / piece->iscale; \n  const float Labmax[] = { 100.0f, 128.0f, 128.0f, 1.0f }; \n  const float Labmin[] = { 0.0f, -128.0f, -128.0f, 0.0f }; \n  const int ch = piece->colors; \n \n  const int radius = ceil(2.0 * ceilf(sigma)); \n \n   \n \n  int *xy_avg = NULL; \n  int *xy_artifact = NULL; \n  int *xy_small = NULL; \n \n  if(roi_out->width < 2 * radius + 1 || roi_out->height < 2 * radius + 1) goto ERROR_EXIT; \n \n  float avg_edge_chroma = 0.0; \n \n  float *const in = (float *const)i; \n  float *const out = (float *const)o; \n  int width = roi_in->width; \n  int height = roi_in->height; \n \n  dt_gaussian_t *gauss = NULL; \n  gauss = dt_gaussian_init(width, height, 4, Labmax, Labmin, sigma, order); \n  if(!gauss) \n  { \n    fprintf(stderr, \"Error allocating memory for gaussian blur in: defringe module\\n\"); \n    goto ERROR_EXIT; \n  } \n  dt_gaussian_blur_4c(gauss, in, out); \n  dt_gaussian_free(gauss); \n \n  int samples_wish = radius * radius; \n  int sampleidx_avg; \n   \n \n  if(samples_wish > 89) \n  { \n    sampleidx_avg = 12;  \n \n  } \n  else if(samples_wish > 55) \n  { \n    sampleidx_avg = 11;  \n \n  } \n  else if(samples_wish > 34) \n  { \n    sampleidx_avg = 10;  \n \n  } \n  else if(samples_wish > 21) \n  { \n    sampleidx_avg = 9; \n  } \n  else if(samples_wish > 13) \n  { \n    sampleidx_avg = 8; \n  } \n  else \n  {  \n \n    sampleidx_avg = 7; \n  } \n  const int sampleidx_small = sampleidx_avg - 1; \n \n  const int small_radius = MAX(radius, 3); \n  const int avg_radius = 24 + radius * 4; \n \n  const int samples_small = fib[sampleidx_small]; \n  const int samples_avg = fib[sampleidx_avg]; \n \n   \n \n \n   \n \n  if((xy_avg = malloc((size_t)2 * sizeof(int) * samples_avg))) \n  { \n    int *tmp = xy_avg; \n    for(int u = 0; u < samples_avg; u++) \n    { \n      int dx, dy; \n      fib_latt(&dx, &dy, avg_radius, u, sampleidx_avg); \n      *tmp++ = dx; \n      *tmp++ = dy; \n    } \n  } \n  else \n  { \n    fprintf(stderr, \"Error allocating memory for fibonacci lattice in: defringe module\\n\"); \n    goto ERROR_EXIT; \n  } \n \n  if((xy_small = malloc((size_t)2 * sizeof(int) * samples_small))) \n  { \n    int *tmp = xy_small; \n    for(int u = 0; u < samples_small; u++) \n    { \n      int dx, dy; \n      fib_latt(&dx, &dy, small_radius, u, sampleidx_small); \n      *tmp++ = dx; \n      *tmp++ = dy; \n    } \n  } \n  else \n  { \n    fprintf(stderr, \"Error allocating memory for fibonacci lattice in: defringe module\\n\"); \n    goto ERROR_EXIT; \n  } \n \n#pragma omp parallel for default(none) shared(width, height,                                                                                                d) reduction(+ : avg_edge_chroma) schedule(static) \n  for(int v = 0; v < height; v++) \n  { \n    for(int t = 0; t < width; t++) \n    { \n       \n \n       \n \n      float a = in[(size_t)v * width * ch + t * ch + 1] - out[(size_t)v * width * ch + t * ch + 1]; \n      float b = in[(size_t)v * width * ch + t * ch + 2] - out[(size_t)v * width * ch + t * ch + 2]; \n \n      float edge = (a * a + b * b);  \n \n \n       \n \n      out[(size_t)v * width * ch + t * ch + 3] = edge; \n       \n \n      if(MODE_GLOBAL_AVERAGE == d->op_mode) avg_edge_chroma += edge; \n    } \n  } \n \n  float thresh; \n  if(MODE_GLOBAL_AVERAGE == d->op_mode) \n  { \n    avg_edge_chroma = avg_edge_chroma / (width * height) + 10.0 * FLT_EPSILON; \n    thresh = fmax(0.1f, 4.0 * d->thresh * avg_edge_chroma / MAGIC_THRESHOLD_COEFF); \n  } \n  else \n  { \n     \n \n    avg_edge_chroma = MAGIC_THRESHOLD_COEFF; \n    thresh = fmax(0.1f, d->thresh); \n  } \n \n \n \n \n \n#pragma omp parallel for default(none) shared(width, height, d, xy_small, xy_avg, xy_artifact)                    firstprivate(thresh, avg_edge_chroma) schedule(guided, 32) ", "pred": " \nvoid process(struct dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, const void *const i, \n             void *const o, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_defringe_data_t *d = (dt_iop_defringe_data_t *)piece->data; \n  assert(dt_iop_module_colorspace(module) == iop_cs_Lab); \n \n  const int order = 1;  \n \n  const float sigma = fmax(0.1f, fabs(d->radius)) * roi_in->scale / piece->iscale; \n  const float Labmax[] = { 100.0f, 128.0f, 128.0f, 1.0f }; \n  const float Labmin[] = { 0.0f, -128.0f, -128.0f, 0.0f }; \n  const int ch = piece->colors; \n \n  const int radius = ceil(2.0 * ceilf(sigma)); \n \n   \n \n  int *xy_avg = NULL; \n  int *xy_artifact = NULL; \n  int *xy_small = NULL; \n \n  if(roi_out->width < 2 * radius + 1 || roi_out->height < 2 * radius + 1) goto ERROR_EXIT; \n \n  float avg_edge_chroma = 0.0; \n \n  float *const in = (float *const)i; \n  float *const out = (float *const)o; \n  int width = roi_in->width; \n  int height = roi_in->height; \n \n  dt_gaussian_t *gauss = NULL; \n  gauss = dt_gaussian_init(width, height, 4, Labmax, Labmin, sigma, order); \n  if(!gauss) \n  { \n    fprintf(stderr, \"Error allocating memory for gaussian blur in: defringe module\\n\"); \n    goto ERROR_EXIT; \n  } \n  dt_gaussian_blur_4c(gauss, in, out); \n  dt_gaussian_free(gauss); \n  dt_gaussian_free(gauss);\\n      }\\n      if(gauss->type == 0)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 0)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 1)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 1)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 1)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 1)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 1)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian_free(gauss);\\n      if(gauss->type == 2)\\n        dt_gaussian"}
{"label": " \nvoid THTensor_(copy)(THTensor *tensor, THTensor *src) \n{ \n  if (tensor == src) return; \n  ptrdiff_t tensorSize = THTensor_(nElement)(tensor); \n  ptrdiff_t srcSize = THTensor_(nElement)(src); \n  int tensorContig = THTensor_(isContiguous)(tensor); \n  int srcContig = THTensor_(isContiguous)(src); \n \n  int serial_path = 0; \n  int inOMP = omp_in_parallel(); \n  if (tensorSize == srcSize) { \n    if ( tensorContig && srcContig) { \n      real *sp = THTensor_(data)(src); \n      real *rp = THTensor_(data)(tensor); \n      #pragma omp parallel if ( (tensorSize > TH_OMP_OVERHEAD_THRESHOLD_COPY) && (!inOMP) ) \n      { \n        size_t num_threads = omp_get_num_threads(); \n        size_t tid = omp_get_thread_num(); \n        ptrdiff_t offset = tid * (tensorSize / num_threads); \n        ptrdiff_t end = (tid == num_threads - 1)? tensorSize : offset + tensorSize / num_threads; \n        ptrdiff_t len = end - offset; \n        real *tensorData = rp + offset; \n        real *srcData = sp + offset; \n        THVector_(copy)(tensorData, srcData, len); \n      } \n        THVector_(copy)(rp, sp, srcSize); \n \n \n      if ((srcSize > TH_OMP_OVERHEAD_THRESHOLD_COPY) && (!inOMP)) { \n        ptrdiff_t i; \n        #pragma omp parallel for private (i) \n        for(i=0; i<srcSize; i++){ \n          rp[i] = sp[i]; \n        } \n      } else { \n        memcpy(rp, sp, srcSize * sizeof(real)); \n      } \n      memcpy(rp, sp, srcSize * sizeof(real)); \n \n \n    } else if (THTensor_(copyTransposeValid)(tensor, src)) { \n      THTensor_(copyTranspose)(tensor, src); \n    } else { \n      if (inOMP) { \n        serial_path = 1; \n      } else { \n        TH_TENSOR_APPLY2_OMP(srcSize, tensorContig, srcContig, real, tensor, real, src, *tensor_data = *src_data;) \n      } \n      serial_path = 1; \n    } \n  } else { \n    serial_path = 1; \n  } \n \n  if (serial_path) { \n    TH_TENSOR_APPLY2(real, tensor, real, src, *tensor_data = *src_data;) \n  } \n} ", "pred": " \nvoid THTensor_(copy)(THTensor *tensor, THTensor *src) \n{ \n  if (tensor == src) return; \n  ptrdiff_t tensorSize = THTensor_(nElement)(tensor); \n  ptrdiff_t srcSize = THTensor_(nElement)(src); \n  int tensorContig = THTensor_(isContiguous)(tensor); \n  int srcContig = THTensor_(isContiguous)(src); \n \n  int serial_path = 0; \n  int inOMP = omp_in_parallel(); \n  if (tensorSize == srcSize) { \n    if ( tensorContig && srcContig) { \n      real *sp = THTensor_(data)(src); \n      real *rp = THTensor_(data)(tensor); \n      #pragma omp parallel if ( (tensorSize > TH_OMP_OVERHEAD_THRESHOLD_COPY) && (!inOMP) ) \n      { \n        size_t num_threads = omp_get_num_threads(); \n        size_t tid = omp_get_thread_num(); \n        ptrdiff_t offset = tid * (tensorSize / num_threads); \n        ptrdiff_t end = (tid == num_threads - 1)? tensorSize : offset + tensorSize / num_threads; \n        ptrdiff_t len = end - offset; \n        real *tensorData = rp + offset; \n        real *srcData = sp + offset; \n        THVector_(copy)(tensorData, srcData, len); \n      } \n        THVector_(copy)(rp, sp, srcSize); \n \n \n      if ((srcSize > TH_OMP_OVERHEAD_THRESHOLD_COPY) && (!inOMP)) { \n        ptrdiff_t i; \n        #pragma omp parallel for private (i) \n        for(i=0; i<srcSize; i++){ \n                                                                                                                                                                                                                                                                                                                                                               "}
{"label": " \nint eu2omLoop (double* eu, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(eustep, omstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * omstep; \n      \n    trash = eu2om(&(eu[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint eu2omLoop (double* eu, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(eustep, omstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * omstep; \n      \n    trash = eu2om(&(eu[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ho2axLoop (double* ho, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(hostep, axstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * axstep; \n      \n    trash = ho2ax(&(ho[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ho2axLoop (double* ho, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(hostep, axstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * axstep; \n      \n    trash = ho2ax(&(ho[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ax2euLoop (double* ax, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(axstep, eustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * eustep; \n      \n    trash = ax2eu(&(ax[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ax2euLoop (double* ax, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(axstep, eustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * eustep; \n      \n    trash = ax2eu(&(ax[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void add(void) \n{ \n    int i, j, k, m; \n#pragma omp for  \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    u[i][j][k][m] = u[i][j][k][m] + rhs[i][j][k][m]; \n                } \n            } \n        } \n    } \n} ", "pred": " \nstatic void add(void) \n{ \n    int i, j, k, m; \n#pragma omp for  \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    u[i][j][k][m] = u[i][j][k][m] + rhs[i][j][k][m]; \n                } \n            } \n        } \n    } \n} "}
{"label": "float *const restrict in, float *const restrict out, \n                                    const dt_iop_order_iccprofile_info_t *const work_profile, \n                                    const dt_iop_order_iccprofile_info_t *const export_profile, \n                                    const dt_iop_filmicrgb_data_t *const data, \n                                    const dt_iop_filmic_rgb_spline_t spline, const int variant, \n                                    const size_t width, const size_t height, const size_t ch, \n                                    const dt_iop_filmicrgb_colorscience_type_t colorscience_version, \n                                    const float display_black, const float display_white) \n \n{ \n   \n \n  dt_colormatrix_t input_matrix;          \n \n  dt_colormatrix_t output_matrix;         \n \n  dt_colormatrix_t export_input_matrix;   \n \n  dt_colormatrix_t export_output_matrix;  \n \n \n  const int use_output_profile = filmic_v4_prepare_matrices(input_matrix, output_matrix, export_input_matrix, \n                                                            export_output_matrix, work_profile, export_profile); \n#pragma omp parallel for default(none)                                                                            dt_omp_firstprivate(width, height, ch, data, in, out, work_profile, input_matrix, output_matrix,      variant, spline, display_white, display_black, export_input_matrix, export_output_matrix,      use_output_profile)        schedule(simd :static) \n  for(size_t k = 0; k < height * width * ch; k += ch) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n \n    for_each_channel(c,aligned(pix_in)) \n    { \n       \n \n      pix_out[c] = log_tonemapping_v2(pix_in[c], data->grey_source, data->black_source, data->dynamic_range); \n \n       \n \n       \n \n      pix_out[c] = powf(CLAMP(filmic_spline(pix_out[c], spline.M1, spline.M2, spline.M3, spline.M4, spline.M5, \n                                                 spline.latitude_min, spline.latitude_max, spline.type), \n                              0.f,   \n \n                              display_white), data->output_power); \n    } \n \n     \n \n    dt_aligned_pixel_t Ych_original = { 0.f }; \n    RGB_to_Ych(pix_in, input_matrix, Ych_original); \n \n     \n \n    dt_aligned_pixel_t Ych_final = { 0.f }; \n    RGB_to_Ych(pix_out, input_matrix, Ych_final); \n \n    Ych_final[1] = fminf(Ych_original[1], Ych_final[1]); \n \n    gamut_mapping(Ych_final, Ych_original, pix_out, input_matrix, output_matrix, export_input_matrix, \n                  export_output_matrix, display_black, display_white, data->saturation, use_output_profile); \n  } \n} \n \n \nstatic inline void display_mask(const f ", "pred": "float *const restrict in, float *const restrict out, \n                                    const dt_iop_order_iccprofile_info_t *const work_profile, \n                                    const dt_iop_order_iccprofile_info_t *const export_profile, \n                                    const dt_iop_filmicrgb_data_t *const data, \n                                    const dt_iop_filmic_rgb_spline_t spline, const int variant, \n                                    const size_t width, const size_t height, const size_t ch, \n                                    const dt_iop_filmicrgb_colorscience_type_t colorscience_version, \n                                    const float display_black, const float display_white) \n \n{ \n   \n \n  dt_colormatrix_t input_matrix;          \n \n  dt_colormatrix_t output_matrix;         \n \n  dt_colormatrix_t export_input_matrix;   \n \n  dt_colormatrix_t export_output_matrix;  \n \n \n  const int use_output_profile = filmic_v4_prepare_matrices(input_matrix, output_matrix, export_input_matrix, \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "}
{"label": " \nint ax2roLoop (double* ax, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(axstep, rostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * rostep; \n      \n    trash = ax2ro(&(ax[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ax2roLoop (double* ax, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(axstep, rostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * rostep; \n      \n    trash = ax2ro(&(ax[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void lhsy(void) \n{ \n    int i, j, k; \n#pragma omp for  \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                fjac[i][j][k][0][0] = 0.0; \n                fjac[i][j][k][0][1] = 0.0; \n                fjac[i][j][k][0][2] = 1.0; \n                fjac[i][j][k][0][3] = 0.0; \n                fjac[i][j][k][0][4] = 0.0; \n                fjac[i][j][k][1][0] = - (u[i][j][k][1] * u[i][j][k][2]) * tmp2; \n                fjac[i][j][k][1][1] = u[i][j][k][2] * tmp1; \n                fjac[i][j][k][1][2] = u[i][j][k][1] * tmp1; \n                fjac[i][j][k][1][3] = 0.0; \n                fjac[i][j][k][1][4] = 0.0; \n                fjac[i][j][k][2][0] = - (u[i][j][k][2] * u[i][j][k][2] * tmp2) + 0.50 * c2 * ((u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2); \n                fjac[i][j][k][2][1] = - c2 * u[i][j][k][1] * tmp1; \n                fjac[i][j][k][2][2] = (2.0 - c2) * u[i][j][k][2] * tmp1; \n                fjac[i][j][k][2][3] = - c2 * u[i][j][k][3] * tmp1; \n                fjac[i][j][k][2][4] = c2; \n                fjac[i][j][k][3][0] = - (u[i][j][k][2] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][3][1] = 0.0; \n                fjac[i][j][k][3][2] = u[i][j][k][3] * tmp1; \n                fjac[i][j][k][3][3] = u[i][j][k][2] * tmp1; \n                fjac[i][j][k][3][4] = 0.0; \n                fjac[i][j][k][4][0] = (c2 * (u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2 - c1 * u[i][j][k][4] * tmp1) * u[i][j][k][2] * tmp1; \n                fjac[i][j][k][4][1] = - c2 * u[i][j][k][1] * u[i][j][k][2] * tmp2; \n                fjac[i][j][k][4][2] = c1 * u[i][j][k][4] * tmp1 - 0.50 * c2 * ((u[i][j][k][1] * u[i][j][k][1] + 3.0 * u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2); \n                fjac[i][j][k][4][3] = - c2 * (u[i][j][k][2] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][4][4] = c1 * u[i][j][k][2] * tmp1; \n                njac[i][j][k][0][0] = 0.0; \n                njac[i][j][k][0][1] = 0.0; \n                njac[i][j][k][0][2] = 0.0; \n                njac[i][j][k][0][3] = 0.0; \n                njac[i][j][k][0][4] = 0.0; \n                njac[i][j][k][1][0] = - c3c4 * tmp2 * u[i][j][k][1]; \n                njac[i][j][k][1][1] = c3c4 * tmp1; \n                njac[i][j][k][1][2] = 0.0; \n                njac[i][j][k][1][3] = 0.0; \n                njac[i][j][k][1][4] = 0.0; ", "pred": " \nstatic void lhsy(void) \n{ \n    int i, j, k; \n#pragma omp for  \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                fjac[i][j][k][0][0] = 0.0; \n                fjac[i][j][k][0][1] = 0.0; \n                fjac[i][j][k][0][2] = 1.0; \n                fjac[i][j][k][0][3] = 0.0; \n                fjac[i][j][k][0][4] = 0.0; \n                fjac[i][j][k][1][0] = - (u[i][j][k][1] * u[i][j][k][2]) * tmp2; \n                fjac[i][j][k][1][1] = u[i][j][k][2] * tmp1; \n                fjac[i][j][k][2][2] = u[i][j][k][2];\\n                    fjac[i][j][k][3][0] = u[i][j][k][2];\\n                    fjac[i][j][k][3][1] = u[i][j][k][2];\\n                    fjac[i][j][k][4][2] = u[i][j][k][3];\\n                    fjac[i][j][k][4][3] = u[i][j][k][4];\\n                    fjac[i][j][k][5][0] = u[i][j][k][4];\\n                    fjac[i][j][k][5][1] = u[i][j][k][4];\\n                    fjac[i][j][k][6][2] = u[i][j][k][5];\\n                    fjac[i][j][k][7][3] = u[i][j][k][4];\\n                    fjac[i][j][k][8][0] = u[i][j][k][4];\\n                    fjac[i][j][k][4][1] = u[i][j][k][4];\\n                    fjac[i][j][k][4][2] = u[i][j][k][4];\\n                    fjac[i][j][k][5][3] = u[i][j][k][4];\\n                    fjac[i][j][k][6][3] = u[i][j][k][4];\\n                    fjac[i][j][k][7][4] = u[i][j][k][4];\\n                    fjac[i][j][k][8][3] = u[i][j][k][4];\\n                    fjac[i][j][k][4][1] = u[i][j][k][4];\\n                    fjac[i][j][k][4][2] = u[i][j][k][4];\\n                    fjac[i][j][k][5][3] = u[i][j][k][4];\\n                    fjac[i][j][k][6][3] = u[i][j][k][4];\\n                    fjac[i][j][k][7][3] = u[i][j][k][4];\\n                    fjac[i][j][k][8][3] = u[i][j][k][4];\\n                    fjac[i][j][k][4][1] = u[i][j][k][4];\\n                    fjac[i][j][k][4][2] = u[i][j][k][4];\\n                    fjac[i][j][k][4][3] = u[i][j][k][4];\\n                    fjac[i][j][k][5][3] = u[i][j][k][4];\\n                    fjac[i][j][k][5][4] = u[i][j][k][4];\\n                    fjac[i][j][k][6][3] = u[i][j][k][4];\\n                    fjac[i][j][k][6][4] = u[i][j][k][4];\\n                    fjac[i][j][k][7][3] = u[i][j][k][4];\\n                    fjac[i][j][k][7][4][1] = u[i][j][k][4];\\n                    fjac[i][j][k][7][4][2] = u[i][j][k][4];\\n                  "}
{"label": " \nint om2quLoop (double* om, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(omstep, qustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * qustep; \n      \n    trash = om2qu(&(om[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint om2quLoop (double* om, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(omstep, qustep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * qustep; \n      \n    trash = om2qu(&(om[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint qu2axLoop (double* qu, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(qustep, axstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * axstep; \n      \n    trash = qu2ax(&(qu[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint qu2axLoop (double* qu, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(qustep, axstep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * axstep; \n      \n    trash = qu2ax(&(qu[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nvoid \nf2 (void) \n{ \n  int i; \n  #pragma omp for simd order(concurrent)  \n \n  for (i = 0; i < 64; i++)\t\t\t \n \n    t++;\t \n \n} ", "pred": " \nvoid \nf2 (void) \n{ \n  int i; \n  #pragma omp for simd order(concurrent)  \n \n  for (i = 0; i < 64; i++)\t\t\t \n \n    t++;\t \n \n} "}
{"label": "onst float *const restrict in, float *const restrict out, \n                                       const dt_iop_order_iccprofile_info_t *const work_profile, \n                                       const dt_iop_filmicrgb_data_t *const data, \n                                       const dt_iop_filmic_rgb_spline_t spline, const int variant, \n                                       const size_t width, const size_t height, const size_t ch, \n                                       const dt_iop_filmicrgb_colorscience_type_t colorscience_version) \n{ \n \n#pragma omp parallel for default(none)                                                                            dt_omp_firstprivate(width, height, ch, data, in, out, work_profile, variant, spline, colorscience_version)         schedule(simd :static) \n  for(size_t k = 0; k < height * width * ch; k += ch) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n \n    float norm = fmaxf(get_pixel_norm(pix_in, variant, work_profile), NORM_MIN); \n \n     \n \n    dt_aligned_pixel_t ratios = { 0.0f }; \n \n    for_each_channel(c,aligned(pix_in)) \n      ratios[c] = pix_in[c] / norm; \n \n     \n \n    const float min_ratios = fminf(fminf(ratios[0], ratios[1]), ratios[2]); \n    const int sanitize = (min_ratios < 0.0f); \n \n    if(sanitize) \n      for_each_channel(c) \n        ratios[c] -= min_ratios; \n \n     \n \n    norm = log_tonemapping_v2(norm, data->grey_source, data->black_source, data->dynamic_range); \n \n     \n \n    const float desaturation = filmic_desaturate_v2(norm, data->sigma_toe, data->sigma_shoulder, data->saturation); \n \n     \n \n     \n \n    norm = powf(clamp_simd(filmic_spline(norm, spline.M1, spline.M2, spline.M3, spline.M4, spline.M5, \n                                         spline.latitude_min, spline.latitude_max, spline.type)), \n                data->output_power); \n \n     \n \n    for(int c = 0; c < 3; c++) ratios[c] = fmaxf(ratios[c] + (1.0f - ratios[c]) * (1.0f - desaturation), 0.0f); \n \n     \n \n     \n \n    if(colorscience_version == DT_FILMIC_COLORSCIENCE_V3) \n      norm /= fmaxf(get_pixel_norm(ratios, variant, work_profile), NORM_MIN); \n \n    for_each_channel(c,aligned(pix_out)) \n      pix_out[c] = ratios[c] * norm; \n \n     \n \n    const float max_pix = fmaxf(fmaxf(pix_out[0], pix_out[1]), pix_out[2]); \n    const int penalize = (max_pix > 1.0f); \n \n     \n \n    if(penalize) \n    { \n      for_each_channel(c,aligned(pix_out)) \n      { \n        ratios[c] = fmaxf(ratios[c] + (1.0f - max_pix), 0.0f); \n        pix_out[c] = clamp_simd(ratios[c] * norm); \n      } \n    } \n  } \n} \n \n \nstatic inline void filmic_desaturate_v ", "pred": "onst float *const restrict in, float *const restrict out, \n                                       const dt_iop_order_iccprofile_info_t *const work_profile, \n                                       const dt_iop_filmicrgb_data_t *const data, \n                                       const dt_iop_filmic_rgb_spline_t spline, const int variant, \n                                       const size_t width, const size_t height, const size_t ch, \n                                       const dt_iop_filmicrgb_colorscience_type_t colorscience_version) \n{ \n \n#pragma omp parallel for default(none)                                                                            dt_omp_firstprivate(width, height, ch, data, in, out, work_profile, variant, spline, colorscience_version)         schedule(simd :static) \n  for(size_t k = 0; k < height * width * ch; k += ch) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n \n    float norm = fmaxf(get_pixel_norm(pix_in, variant, work_profile), NORM_MIN); \n \n     \n \n    dt_aligned_pixel_t ratios = { 0.0f }; \n \n    for_each_color(const float *const restrict pix_in, const float *const restrict pix_out, const float *const restrict pix_out, const float *const restrict pix_in_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix_out_end, const float *const restrict pix"}
{"label": " \nstatic void z_solve_cell(void) \n{ \n    int i, j, k, ksize; \n    ksize = grid_points[2] - 1; \n#pragma omp for  \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            binvcrhs(lhs[i][j][0][1], lhs[i][j][0][2], rhs[i][j][0]); \n        } \n    } \n    for (k = 1; \n        k < ksize; \n        k++) \n    { \n#pragma omp for  \n        for (i = 1; \n            i < grid_points[0] - 1; \n            i++) \n        { \n            for (j = 1; \n                j < grid_points[1] - 1; \n                j++) \n            { \n                matvec_sub(lhs[i][j][k][0], rhs[i][j][k - 1], rhs[i][j][k]); \n                matmul_sub(lhs[i][j][k][0], lhs[i][j][k - 1][2], lhs[i][j][k][1]); \n                binvcrhs(lhs[i][j][k][1], lhs[i][j][k][2], rhs[i][j][k]); \n            } \n        } \n    } \n#pragma omp for  \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            matvec_sub(lhs[i][j][ksize][0], rhs[i][j][ksize - 1], rhs[i][j][ksize]); \n            matmul_sub(lhs[i][j][ksize][0], lhs[i][j][ksize - 1][2], lhs[i][j][ksize][1]); \n            binvrhs(lhs[i][j][ksize][1], rhs[i][j][ksize]); \n        } \n    } \n} ", "pred": " \nstatic void z_solve_cell(void) \n{ \n    int i, j, k, ksize; \n    ksize = grid_points[2] - 1; \n#pragma omp for  \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            binvcrhs(lhs[i][j][0][1], lhs[i][j][0][2], rhs[i][j][0]); \n        } \n    } \n    for (k = 1; \n        k < ksize; \n        k++) \n    { \n#pragma omp for  \n        for (i = 1; \n            i < grid_points[0] - 1; \n            i++) \n        { \n            for (j = 1; \n                j < grid_points[1] - 1; \n                j++) \n            { \n                matvec_sub(lhs[i][j][k][0], rhs[i][j][k - 1], rhs[i][j][k]); \n                matmul_sub(lhs[i][j][k][0], lhs[i][j][k - 1][2], lhs[i][j][k][1]); \n                binvcrhs(lhs[i][j][k][1], lhs[i][j][k][2], rhs[i][j][k]); \n              matmul_sub(lhs[i][j][k][1], lhs[i][j][k][2], rhs[i][j][k][1]);              matmul_sub(lhs[i][j][k][2], lhs[i][j][k][3], rhs[i][j][k][1]);             matmul_sub(lhs[i][j][k][3], lhs[i][j][k][4], rhs[i][j][k][2]);            matmul_sub(lhs[i][j][k][4], lhs[i][j][k][5], rhs[i][j][k][3]);            matmul_sub(lhs[i][j][k][4], lhs[i][j][k][5], rhs[i][j][k][4]);            matmul_sub(lhs[i][j][k][5], lhs[i][j][k][6], rhs[i][j][k][7]);           matmul"}
{"label": " \nvoid VXCgen_grid(double *out, double *coords, double *atm_coords, \n                 double *radii_table, int natm, int ngrids) \n{ \n        const size_t Ngrids = ngrids; \n        int i, j; \n        double dx, dy, dz; \n        double *atom_dist = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                for (j = 0; j < i; j++) { \n                        dx = atm_coords[i*3+0] - atm_coords[j*3+0]; \n                        dy = atm_coords[i*3+1] - atm_coords[j*3+1]; \n                        dz = atm_coords[i*3+2] - atm_coords[j*3+2]; \n                        atom_dist[i*natm+j] = 1 / sqrt(dx*dx + dy*dy + dz*dz); \n                } \n        } \n \n#pragma omp parallel private(i, j, dx, dy, dz) \n{ \n        double *_buf = malloc(sizeof(double) * ((natm*2+1)*GRIDS_BLOCK + ALIGNMENT)); \n        double *buf = (double *)((uintptr_t)(_buf + ALIGNMENT - 1) & (-(uintptr_t)(ALIGNMENT*8))); \n        double *g = buf + natm * GRIDS_BLOCK; \n        double *grid_dist = g + GRIDS_BLOCK; \n        size_t ig0, n, ngs; \n        double fac, s; \n#pragma omp for nowait schedule(static) \n        for (ig0 = 0; ig0 < Ngrids; ig0 += GRIDS_BLOCK) { \n                ngs = MIN(Ngrids-ig0, GRIDS_BLOCK); \n                for (i = 0; i < natm; i++) { \n#pragma GCC ivdep \n                for (n = 0; n < ngs; n++) { \n                        dx = coords[0*Ngrids+ig0+n] - atm_coords[i*3+0]; \n                        dy = coords[1*Ngrids+ig0+n] - atm_coords[i*3+1]; \n                        dz = coords[2*Ngrids+ig0+n] - atm_coords[i*3+2]; \n                        grid_dist[i*GRIDS_BLOCK+n] = sqrt(dx*dx + dy*dy + dz*dz); \n                        buf[i*GRIDS_BLOCK+n] = 1; \n                } } \n \n                for (i = 0; i < natm; i++) { \n                for (j = 0; j < i; j++) { \n \n                        fac = atom_dist[i*natm+j]; \n                        for (n = 0; n < ngs; n++) { \n                                g[n] = (grid_dist[i*GRIDS_BLOCK+n] - \n                                        grid_dist[j*GRIDS_BLOCK+n]) * fac; \n                        } \n                        if (radii_table!= NULL) { \n                                fac = radii_table[i*natm+j]; \n                                for (n = 0; n < ngs; n++) { \n                                        g[n] += fac * (1 - g[n]*g[n]); \n                                } \n                        } \n#pragma GCC ivdep \n                        for (n = 0; n < ngs; n++) { \n                                s = g[n]; \n                                s = (3 - s*s) * s *.5; \n                                s = (3 - s*s) * s *.5; \n                                s = ((3 - s*s) * s *.5) *.5; \n                                buf[i*GRIDS_BLOCK+n] *=.5 - s; \n                                buf[j*GRIDS_BLOCK+n] *=.5 + s; \n                        } \n                } } \n \n                for (i = 0; i < natm; i++) { \n                        for (n = 0; n <", "pred": " \nvoid VXCgen_grid(double *out, double *coords, double *atm_coords, \n                 double *radii_table, int natm, int ngrids) \n{ \n        const size_t Ngrids = ngrids; \n        int i, j; \n        double dx, dy, dz; \n        double *atom_dist = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                for (j = 0; j < i; j++) { \n                        dx = atm_coords[i*3+0] - atm_coords[j*3+0]; \n                        dy = atm_coords[i*3+1] - atm_coords[j*3+1]; \n                        dz = atm_coords[i*3+2] - atm_coords[j*3+2]; \n                        atom_dist[i*natm+j] = 1 / sqrt(dx*dx + dy*dy + dz*dz); \n                } \n        } \n \n#pragma omp parallel private(i, j, dx, dy, dz) \n{ \n        double *_buf = malloc(sizeof(double) * ((natm*2+1)*GRIDS_BLOCK + ALIGNMENT)); \n        double *buf = (double *)((uintptr_t)(_buf + ALIGNMENT - 1) & (-(uintptr_t)(ALIGNMENT*8))); \n        double *g = buf + natm * GRIDS_BLOCK; \n        double *grid_dist = g + GRIDS_BLOCK;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "}
{"label": " \nint om2hoLoop (double* om, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(omstep, hostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * hostep; \n      \n    trash = om2ho(&(om[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint om2hoLoop (double* om, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n#pragma omp parallel for    default(shared) private( i,iIn, iOut, trash) firstprivate(omstep, hostep) schedule (static) \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * hostep; \n      \n    trash = om2ho(&(om[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void initialize(void) \n{ \n    int i, j, k, m, ix, iy, iz; \n    double xi, eta, zeta, Pface[2][3][5], Pxi, Peta, Pzeta, temp[5]; \n#pragma omp for  \n    for (i = 0; \n        i < 12; \n        i++) \n    { \n        for (j = 0; \n            j < 12; \n            j++) \n        { \n            for (k = 0; \n                k < 12; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    u[i][j][k][m] = 1.0; \n                } \n            } \n        } \n    } \n#pragma omp for  \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        xi = (double) i * dnxm1; \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            eta = (double) j * dnym1; \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                zeta = (double) k * dnzm1; \n                for (ix = 0; \n                    ix < 2; \n                    ix++) \n                { \n                    exact_solution((double) ix, eta, zeta, &(Pface[ix][0][0])); \n                } \n                for (iy = 0; \n                    iy < 2; \n                    iy++) \n                { \n                    exact_solution(xi, (double) iy, zeta, &Pface[iy][1][0]); \n                } \n                for (iz = 0; \n                    iz < 2; \n                    iz++) \n                { \n                    exact_solution(xi, eta, (double) iz, &Pface[iz][2][0]); \n                } \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    Pxi = xi * Pface[1][0][m] + (1.0 - xi) * Pface[0][0][m]; \n                    Peta = eta * Pface[1][1][m] + (1.0 - eta) * Pface[0][1][m]; \n                    Pzeta = zeta * Pface[1][2][m] + (1.0 - zeta) * Pface[0][2][m]; \n                    u[i][j][k][m] = Pxi + Peta + Pzeta - Pxi * Peta - Pxi * Pzeta - Peta * Pzeta + Pxi * Peta * Pzeta; \n                } \n            } \n        } \n    } \n    i = 0; \n    xi = 0.0; \n#pragma omp for nowait \n    for (j = 0; \n        j < grid_points[1]; \n        j++) \n    { \n        eta = (double) j * dnym1; \n        for (k = 0; \n            k < grid_points[2]; \n            k++) \n        { \n            zeta = (double) k * dnzm1; \n            exact_solution(xi, eta, zeta, temp); \n            for (m = 0; \n                m < 5; \n                m++) \n            { \n                u[i][j][k][m] = temp[m]; \n            } \n        } \n    } \n    i = grid_points[0] - 1; \n    xi = 1.0; \n#pragma omp for  \n    for (j = 0; \n        j < grid_points[1]; \n        j++) \n    { \n        eta = (double) j * dnym1; \n        for (k = 0; \n            k < grid_points[2]; \n            k++)", "pred": " \nstatic void initialize(void) \n{ \n    int i, j, k, m, ix, iy, iz; \n    double xi, eta, zeta, Pface[2][3][5], Pxi, Peta, Pzeta, temp[5]; \n#pragma omp for  \n    for (i = 0; \n        i < 12; \n        i++) \n    { \n        for (j = 0; \n            j < 12; \n            j++) \n        { \n            for (k = 0; \n                k < 12; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    u[i][j][k][m] = 1.0; \n                } \n            } \n        } \n    } \n#pragma omp for  \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        xi = (double) i * dnxm1; \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            eta = (double) j * dnym1; \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "}
{"label": " \nSEXP attribute_hidden do_colsum(SEXP call, SEXP op, SEXP args, SEXP rho) \n{ \n    SEXP x, ans = R_NilValue; \n    int type; \n    Rboolean NaRm, keepNA; \n \n    checkArity(op, args); \n    x = CAR(args); args = CDR(args); \n    int n = asInteger(CAR(args)); args = CDR(args); \n    int p = asInteger(CAR(args)); args = CDR(args); \n    NaRm = asLogical(CAR(args)); \n    if (n == NA_INTEGER || n < 0) \n\terror(_(\"invalid '%s' argument\"), \"n\"); \n    if (p == NA_INTEGER || p < 0) \n\terror(_(\"invalid '%s' argument\"), \"p\"); \n    if (NaRm == NA_LOGICAL) error(_(\"invalid '%s' argument\"), \"na.rm\"); \n    keepNA =!NaRm; \n \n    int OP = PRIMVAL(op); \n    switch (type = TYPEOF(x)) { \n    case LGLSXP: break; \n    case INTSXP: break; \n    case REALSXP: break; \n    default: \n\terror(_(\"'x' must be numeric\")); \n    } \n \n    if (OP == 0 || OP == 1) {  \n \n\tPROTECT(ans = allocVector(REALSXP, p)); \n\tint nthreads; \n\t \n \n\tif (R_num_math_threads > 0) \n\t    nthreads = R_num_math_threads; \n\telse \n\t    nthreads = 1;  \n \n#pragma omp parallel for num_threads(nthreads) default(none)      firstprivate(x, ans, n, p, type, NaRm, keepNA, R_NaReal, R_NaInt, OP) \n\tfor (int j = 0; j < p; j++) { \n\t    int cnt = n, i; \n\t    LDOUBLE sum = 0.0; \n\t    switch (type) { \n\t    case REALSXP: \n\t    { \n\t\tdouble *rx = REAL(x) + (R_xlen_t)n*j; \n\t\tif (keepNA) \n\t\t    for (sum = 0., i = 0; i < n; i++) sum += *rx++; \n\t\telse { \n\t\t    for (cnt = 0, sum = 0., i = 0; i < n; i++, rx++) \n\t\t\tif (!ISNAN(*rx)) {cnt++; sum += *rx;} \n\t\t\telse if (keepNA) {sum = NA_REAL; break;}  \n \n\t\t} \n\t\tbreak; \n\t    } \n\t    case INTSXP: \n\t    { \n\t\tint *ix = INTEGER(x) + (R_xlen_t)n*j; \n\t\tfor (cnt = 0, sum = 0., i = 0; i < n; i++, ix++) \n\t\t    if (*ix!= NA_INTEGER) {cnt++; sum += *ix;} \n\t\t    else if (keepNA) {sum = NA_REAL; break;} \n\t\tbreak; \n\t    } \n\t    case LGLSXP: \n\t    { \n\t\tint *ix = LOGICAL(x) + (R_xlen_t)n*j; \n\t\tfor (cnt = 0, sum = 0., i = 0; i < n; i++, ix++) \n\t\t    if (*ix!= NA_LOGICAL) {cnt++; sum += *ix;} \n\t\t    else if (keepNA) {sum = NA_REAL; break;} \n\t\tbreak; \n\t    } \n\t    } \n\t    if (OP == 1) sum /= cnt;  \n \n\t    REAL(ans)[j] = (double) sum; \n\t} \n    } \n    else {  \n \n\tPROTECT(ans = allocVector(REALSXP, n)); \n \n\t \n \n\tint *Cnt = NULL; \n\tLDOUBLE *rans; \n\tif(n <= 10000) { \n\t    R_CheckStack2(n * sizeof(LDOUBLE)); \n\t    rans = (LDOUBLE *) alloca(n * sizeof(LDOUBLE)); \n\t    Memzero(rans, n); \n\t} else rans = Calloc(n, LDOUBLE); \n\tif (!keepNA && OP == 3) Cnt = Calloc(n, int); \n \n\tfor (int j = 0; j < p; j++) { \n\t    LDOUBLE *ra = rans; \n\t    switch (type) { \n\t    case REALSXP: \n\t    { \n\t\tdouble *rx = REAL(x) + (R_xlen_t)n * j; \n\t\tif (keepNA) \n\t\t    for (int i = 0; i < n; i++) *ra++ += *rx++; \n\t\telse \n\t\t    for (int i = 0; i < n; i++, ra++, rx++) \n\t\t\tif (!ISNAN(*rx)) { \n\t\t\t    *ra += *rx; \n\t\t\t    if (OP == 3) Cnt[i]++; \n\t\t\t} \n\t\tbreak; \n\t    } \n\t    case INTSXP: \n\t    { \n\t\tint *ix = INTEGER(x) + (R_xlen_t)n * j; \n\t\tfor (int i = 0; i < n; i++, ra++, ix++) \n\t\t    if (keepNA) { \n\t\t\tif (*ix!= NA_INTEGER) *ra += *ix; \n\t\t\telse *ra = NA_REAL; \n\t\t    } \n\t\t    else if (*ix!= NA_INTEGER) { \n\t\t\t*ra += *ix; \n\t\t\tif (OP == 3) Cnt[i]++; \n\t\t    } \n\t\tbreak; \n\t    } \n\t    case LGLSXP: \n\t    { \n\t\tint *ix = LOGICAL(x) + (R_xlen_t)n * j; \n\t\tfor (int i = 0; i < n; i++, ra++, ix++) \n\t\t    if (keepNA) { \n\t\t\tif (*ix!= NA_LOGICAL) *ra += *ix; \n\t\t\telse *ra = NA_REAL; \n\t\t    } \n\t\t    else if (*ix!= NA_LOGICAL) { \n\t\t\t*ra += *ix; \n\t\t\tif (OP == 3) Cnt[i]++; \n\t\t    } \n\t\tbreak; \n\t    } \n\t    } \n\t} \n\tif (OP == 3) { \n\t    if (keepNA) \n\t\tfor (int i = 0; i < n; i++) rans[i] /= p; \n\t    else \n\t\tfor (int i = 0; i < n; i++) rans[i] /= Cnt[i]; \n\t} \n\tfor (int i = 0; i < n; i++) REAL(ans)[i] = (double) rans[i]; \n \n\tif (!keepNA && OP == 3) Free(Cnt); \n\tif(n > 10000) Free(rans); \n    } \n \n", "pred": " \nSEXP attribute_hidden do_colsum(SEXP call, SEXP op, SEXP args, SEXP rho) \n{ \n    SEXP x, ans = R_NilValue; \n    int type; \n    Rboolean NaRm, keepNA; \n \n    checkArity(op, args); \n    x = CAR(args); args = CDR(args); \n    int n = asInteger(CAR(args)); args = CDR(args); \n    int p = asInteger(CAR(args)); args = CDR(args); \n    NaRm = asLogical(CAR(args)); \n    if (n == NA_INTEGER || n < 0) \n\terror(_(\"invalid '%s' argument\"), \"n\"); \n    if (p == NA_INTEGER || p < 0) \n\terror(_(\"invalid '%s' argument\"), \"p\"); \n    if (NaRm == NA_LOGICAL) error(_(\"invalid '%s' argument\"), \"na.rm\"); \n    keepNA =!NaRm; \n \n    int OP = PRIMVAL(op); \n    switch (type = TYPEOF(x)) { \n    case LGLSXP: break; \n    case INTSXP: break; \n    case REALSXP: break; \n    default: \n\terror(_(\"'x' must be numeric\")); \n    } \n \n    if (OP == 0 || OP == 1) {  \n \n\tPROTECT(ans = allocVector(REALSXP, p)); \n\tint nthreads; \n\t \n \n\tif (R_num_math_threads > 0) \n\t    nthreads = R_num_math_threads; \n\telse \n\t    nthreads = 1;  \n \n#pragma omp parallel for num_threads(nthreads) default(none)      firstprivate(x, ans, n, p, type, NaRm, keepNA, R_NaReal, R_NaInt, OP) \n\tfor (int j = 0; j < p; j++) { \n\t    int cnt = n, i; \n\t    LDOUBLE sum = 0.0; \n\t    switch (type) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": " \nstatic void Hull(const Image *image,const ssize_t x_offset, \n  const ssize_t y_offset,const size_t columns,const size_t rows, \n  const int polarity,Quantum *restrict f,Quantum *restrict g) \n{ \n  register Quantum \n    *p, \n    *q, \n    *r, \n    *s; \n \n  ssize_t \n    y; \n \n  assert(f!= (Quantum *) NULL); \n  assert(g!= (Quantum *) NULL); \n  p=f+(columns+2); \n  q=g+(columns+2); \n  r=p+(y_offset*(columns+2)+x_offset); \n  #pragma omp parallel for schedule(static,4)      magick_threads(image,image,1,1) \n  for (y=0; y < (ssize_t) rows; y++) \n  { \n    register ssize_t \n      i, \n      x; \n \n    SignedQuantum \n      v; \n \n    i=(2*y+1)+y*columns; \n    if (polarity > 0) \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) p[i]; \n        if ((SignedQuantum) r[i] >= (v+ScaleCharToQuantum(2))) \n          v+=ScaleCharToQuantum(1); \n        q[i]=(Quantum) v; \n        i++; \n      } \n    else \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) p[i]; \n        if ((SignedQuantum) r[i] <= (v-ScaleCharToQuantum(2))) \n          v-=ScaleCharToQuantum(1); \n        q[i]=(Quantum) v; \n        i++; \n      } \n  } \n  p=f+(columns+2); \n  q=g+(columns+2); \n  r=q+(y_offset*(columns+2)+x_offset); \n  s=q-(y_offset*(columns+2)+x_offset); \n  #pragma omp parallel for schedule(static,4)      magick_threads(image,image,1,1) \n  for (y=0; y < (ssize_t) rows; y++) \n  { \n    register ssize_t \n      i, \n      x; \n \n    SignedQuantum \n      v; \n \n    i=(2*y+1)+y*columns; \n    if (polarity > 0) \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) q[i]; \n        if (((SignedQuantum) s[i] >= (v+ScaleCharToQuantum(2))) && \n            ((SignedQuantum) r[i] > v)) \n          v+=ScaleCharToQuantum(1); \n        p[i]=(Quantum) v; \n        i++; \n      } \n    else \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) q[i]; \n        if (((SignedQuantum) s[i] <= (v-ScaleCharToQuantum(2))) && \n            ((SignedQuantum) r[i] < v)) \n          v-=ScaleCharToQuantum(1); \n        p[i]=(Quantum) v; \n        i++; \n      } \n  } \n} ", "pred": " \nstatic void Hull(const Image *image,const ssize_t x_offset, \n  const ssize_t y_offset,const size_t columns,const size_t rows, \n  const int polarity,Quantum *restrict f,Quantum *restrict g) \n{ \n  register Quantum \n    *p, \n    *q, \n    *r, \n    *s; \n \n  ssize_t \n    y; \n \n  assert(f!= (Quantum *) NULL); \n  assert(g!= (Quantum *) NULL); \n  p=f+(columns+2); \n  q=g+(columns+2); \n  r=p+(y_offset*(columns+2)+x_offset); \n  #pragma omp parallel for schedule(static,4)      magick_threads(image,image,1,1) \n  for (y=0; y < (ssize_t) rows; y++) \n  { \n    register ssize_t \n      i, \n      x; \n \n    SignedQuantum \n      v; \n \n    i=(2*y+1)+y*columns; \n    if (polarity > 0) \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) p[i]; \n        if ((SignedQuantum) r[i] >= (v+ScaleCharToQuantum(2))) \n          v+=ScaleCharToQuantum(1); \n        q[i]=(Quantum) v; \n        i++; \n      } \n    else \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) p[i]; \n        if ((SignedQuantum) r[i] <= (v-ScaleCharToQuantum(2))) \n          v-=ScaleCharToQuantum(1); \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "}
{"label": " \nMagickExport MagickBooleanType DrawGradientImage(Image *image, \n  const DrawInfo *draw_info,ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  const GradientInfo \n    *gradient; \n \n  const SegmentInfo \n    *gradient_vector; \n \n  double \n    length; \n \n  MagickBooleanType \n    status; \n \n  PixelInfo \n    zero; \n \n  PointInfo \n    point; \n \n  RectangleInfo \n    bounding_box; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(draw_info!= (const DrawInfo *) NULL); \n  gradient=(&draw_info->gradient); \n  gradient_vector=(&gradient->gradient_vector); \n  point.x=gradient_vector->x2-gradient_vector->x1; \n  point.y=gradient_vector->y2-gradient_vector->y1; \n  length=sqrt(point.x*point.x+point.y*point.y); \n  bounding_box=gradient->bounding_box; \n  status=MagickTrue; \n  GetPixelInfo(image,&zero); \n  image_view=AcquireAuthenticCacheView(image,exception); \n  #pragma omp parallel for schedule(static,4) shared(status)      magick_threads(image,image,1,1) \n  for (y=bounding_box.y; y < (ssize_t) bounding_box.height; y++) \n  { \n    PixelInfo \n      composite, \n      pixel; \n \n    double \n      alpha, \n      offset; \n \n    register Quantum \n      *restrict q; \n \n    register ssize_t \n      i, \n      x; \n \n    ssize_t \n      j; \n \n    if (status == MagickFalse) \n      continue; \n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception); \n    if (q == (Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    pixel=zero; \n    composite=zero; \n    offset=GetStopColorOffset(gradient,0,y); \n    if (gradient->type!= RadialGradient) \n      offset/=length; \n    for (x=bounding_box.x; x < (ssize_t) bounding_box.width; x++) \n    { \n      GetPixelInfoPixel(image,q,&pixel); \n      switch (gradient->spread) \n      { \n        case UndefinedSpread: \n        case PadSpread: \n        { \n          if ((x!= (ssize_t) ceil(gradient_vector->x1-0.5)) || \n              (y!= (ssize_t) ceil(gradient_vector->y1-0.5))) \n            { \n              offset=GetStopColorOffset(gradient,x,y); \n              if (gradient->type!= RadialGradient) \n                offset/=length; \n            } \n          for (i=0; i < (ssize_t) gradient->number_stops; i++) \n            if (offset < gradient->stops[i].offset) \n              break; \n          if ((offset < 0.0) || (i == 0)) \n            composite=gradient->stops[0].color; \n          else \n            if ((offset > 1.0) || (i == (ssize_t) gradient->number_stops)) \n              composite=gradient->stops[gradient->number_stops-1].color; \n            else \n              { \n                j=i; \n                i--; \n                alpha=(offset-gradient->stops[i].offset)/ \n                  (gradient->stops[j].offset-gradient->stops[i].offset); \n                CompositePixelInfoBlend(&gradient->stops[i].color,1.0-alpha, \n                  &gradient->stops[j].color,alpha,&composite); \n              } \n          break; \n        } \n        case ReflectSpread: \n        { \n          if ((x!= (ssize_t) ceil(gradient_vector->x1-0.5)) || \n              (y!= (ssize_t) ceil(gradient_vector->y1-0.5))) \n            { \n              offset=GetStopColorOffset(gradient,x,y); \n              if (gradient->type!= RadialGradient) \n                offset/=length; \n            } \n          if (offset < 0.0) \n            offset=(-offset); \n          if ((ssize_t) fmod(offset,2.0) == 0) \n            offset=fmod(offset,1.0); \n          else \n            offset=1.0-fmod(offset,1.0); \n          for (i=0; i < (ssize_t) gradient->number_stops; i++) \n            if (offset < gradient->stops[i].offset) \n              break; \n          if (i == 0) \n            composite=gradient->stops[0].color; \n          else \n            if (i == (ssize_t) gradient->number_stops) \n ", "pred": " \nMagickExport MagickBooleanType DrawGradientImage(Image *image, \n  const DrawInfo *draw_info,ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  const GradientInfo \n    *gradient; \n \n  const SegmentInfo \n    *gradient_vector; \n \n  double \n    length; \n \n  MagickBooleanType \n    status; \n \n  PixelInfo \n    zero; \n \n  PointInfo \n    point; \n \n  RectangleInfo \n    bounding_box; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(draw_info!= (const DrawInfo *) NULL); \n  gradient=(&draw_info->gradient); \n  gradient_vector=(&gradient->gradient_vector); \n  point.x=gradient_vector->x2-gradient_vector->x1; \n  point.y=gradient_vector->y2-gradient_vector->y1; \n  length=sqrt(point.x*point.x+point.y*point.y); \n  bounding_box=gradient->bounding_box; \n  status=MagickTrue; \n  GetPixelInfo(image,&zero); \n  image_view=AcquireAuthenticCacheView(image,exception); \n  #pragma omp parallel for schedule(static,4) shared(status)      magick_threads(image,image,1,1) \n  for (y=bounding_box.y; y < (ssize_t) bounding_box.height; y++) \n  { \n    PixelInfo \n      composite, \n      pixel; \n \n    double \n      alpha, \n      offset; \n \n    register Quantum \n      *restrict q; \n \n    register ssize_t \n      i, \n      x;\\n    register ssize_t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o, \n             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int ch = piece->colors; \n \n  const dt_dev_pixelpipe_display_mask_t mask_display = piece->pipe->mask_display; \n  char *str = dt_conf_get_string(\"channel_display\"); \n  const int fcolor =!strcmp(str, \"false color\"); \n  g_free(str); \n \n  if((mask_display & DT_DEV_PIXELPIPE_DISPLAY_CHANNEL) && (mask_display & DT_DEV_PIXELPIPE_DISPLAY_ANY) && fcolor) \n  { \n    const float yellow[3] = { 1.0f, 1.0f, 0.0f }; \n#pragma omp parallel for default(none) schedule(static) \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)i) + (size_t)ch * k * roi_out->width; \n      uint8_t *out = ((uint8_t *)o) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++, in += ch, out += ch) \n      { \n        const float alpha = (mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK)? in[3] : 0.0f; \n        float colors[3]; \n        false_color(in[1], mask_display, colors); \n        for(int c = 0; c < 3; c++) \n        { \n          const float value = colors[c] * (1.0f - alpha) + yellow[c] * alpha; \n          out[2 - c] = ((uint8_t)(CLAMP(((uint32_t)255.0f * value), 0x0, 0xff))); \n        } \n      } \n    } \n  } \n  else if((mask_display & DT_DEV_PIXELPIPE_DISPLAY_CHANNEL) && (mask_display & DT_DEV_PIXELPIPE_DISPLAY_ANY)) \n  { \n    const float yellow[3] = { 1.0f, 1.0f, 0.0f }; \n#pragma omp parallel for default(none) schedule(static) \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)i) + (size_t)ch * k * roi_out->width; \n      uint8_t *out = ((uint8_t *)o) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++, in += ch, out += ch) \n      { \n        float alpha = (mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK)? in[3] : 0.0f; \n        for(int c = 0; c < 3; c++) \n        { \n          const float value = in[1] * (1.0f - alpha) + yellow[c] * alpha; \n          out[2 - c] = ((uint8_t)(CLAMP(((uint32_t)255.0f * value), 0x0, 0xff))); \n        } \n      } \n    } \n  } \n  else if(mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) \n  { \n    const float yellow[3] = { 1.0f, 1.0f, 0.0f }; \n#pragma omp parallel for default(none) schedule(static) \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)i) + (size_t)ch * k * roi_out->width; \n      uint8_t *out = ((uint8_t *)o) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++, in += ch, out += ch) \n      { \n        const float gray = 0.3f * in[0] + 0.59f * in[1] + 0.11f * in[2]; \n        const float alpha = in[3]; \n        for(int c = 0; c < 3; c++) \n        { \n          const float value = gray * (1.0f - alpha) + yellow[c] * alpha; \n          out[2 - c] = ((uint8_t)(CLAMP(((uint32_t)255.0f * value), 0x0, 0xff))); \n        } \n      } \n    } \n  } \n  else \n  { \n#pragma omp parallel for default(none) schedule(static) \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)i) + (size_t)ch * k * roi_out->width; \n      uint8_t *out = ((uint8_t *)o) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++, in += ch, out += ch) \n      { \n        for(int c = 0; c < 3; c++) out[2 - c] = ((uint8_t)(CLAMP(((uint32_t)255.0f * in[c]), 0x0, 0xff))); \n      } \n    } \n  } \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o, \n             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int ch = piece->colors; \n \n  const dt_dev_pixelpipe_display_mask_t mask_display = piece->pipe->mask_display; \n  char *str = dt_conf_get_string(\"channel_display\"); \n  const int fcolor =!strcmp(str, \"false color\"); \n  g_free(str); \n \n  if((mask_display & DT_DEV_PIXELPIPE_DISPLAY_CHANNEL) && (mask_display & DT_DEV_PIXELPIPE_DISPLAY_ANY) && fcolor) \n  { \n    const float yellow[3] = { 1.0f, 1.0f, 0.0f }; \n#pragma omp parallel for default(none) schedule(static) \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)i) + (size_t)ch * k * roi_out->width; \n      uint8_t *out = ((uint8_t *)o) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++, in += ch, out += ch) \n      { \n        const float alpha = (mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK)? in[3] : 0.0f; \n        float colors[3]; \n        false_color(in[1], mask_display, colors); \n        for(int c = 0; c < 3; c++) \n        { \n          const float value = colors[c] * (1.0f - alpha) + yellow[c] * alpha; \n          out[2 - c] = 0.0f;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o, \n             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_lowlight_data_t *d = (dt_iop_lowlight_data_t *)(piece->data); \n  const int ch = piece->colors; \n \n   \n \n  const float c = 0.5f; \n  const float threshold = 0.01f; \n \n   \n \n  float Lab_sw[3] = { 100.0f, 0, -d->blueness }; \n  float XYZ_sw[3]; \n \n  dt_Lab_to_XYZ(Lab_sw, XYZ_sw); \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(ch, i, o, roi_out, threshold, c)    shared(d, XYZ_sw)    schedule(static) \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    float *in = (float *)i + ch * k; \n    float *out = (float *)o + ch * k; \n    float XYZ[3], XYZ_s[3]; \n    float V; \n    float w; \n \n    dt_Lab_to_XYZ(in, XYZ); \n \n     \n \n    if(XYZ[0] > threshold) \n    { \n       \n \n      V = XYZ[1] * (1.33f * (1.0f + (XYZ[1] + XYZ[2]) / XYZ[0]) - 1.68f); \n    } \n    else \n    { \n       \n \n      V = XYZ[1] * (1.33f * (1.0f + (XYZ[1] + XYZ[2]) / threshold) - 1.68f); \n    } \n \n     \n \n    V = fminf(1.0f, fmaxf(0.0f, c * V)); \n \n     \n \n    w = lookup(d->lut, in[0] / 100.f); \n \n    XYZ_s[0] = V * XYZ_sw[0]; \n    XYZ_s[1] = V * XYZ_sw[1]; \n    XYZ_s[2] = V * XYZ_sw[2]; \n \n    XYZ[0] = w * XYZ[0] + (1.0f - w) * XYZ_s[0]; \n    XYZ[1] = w * XYZ[1] + (1.0f - w) * XYZ_s[1]; \n    XYZ[2] = w * XYZ[2] + (1.0f - w) * XYZ_s[2]; \n \n    dt_XYZ_to_Lab(XYZ, out); \n \n    out[3] = in[3]; \n  } \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o, \n             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_lowlight_data_t *d = (dt_iop_lowlight_data_t *)(piece->data); \n  const int ch = piece->colors; \n \n   \n \n  const float c = 0.5f; \n  const float threshold = 0.01f; \n \n   \n \n  float Lab_sw[3] = { 100.0f, 0, -d->blueness }; \n  float XYZ_sw[3]; \n \n  dt_Lab_to_XYZ(Lab_sw, XYZ_sw); \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(ch, i, o, roi_out, threshold, c)    shared(d, XYZ_sw)    schedule(static) \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    float *in = (float *)i + ch * k; \n    float *out = (float *)o + ch * k; \n    float XYZ[3], XYZ_s[3]; \n    float V; \n    float w; \n \n    dt_Lab_to_XYZ(in, XYZ); \n \n     \n \n    if(XYZ[0] > threshold) \n    { \n       \n \n      V = XYZ[1] * (1.33f * (1.0f + (XYZ[1] + XYZ[2]) / XYZ[0]) - 1.68f); \n    } \n    else \n    { \n       \n \n      V = XYZ[1] * (1.33f * (1.0f + (XYZ[1] + XYZ[2]) / threshold) - 1.68f);                                                                                                                                                                                                                                                                                                           "}
{"label": " \nstatic int _gradient_get_mask(const dt_iop_module_t *const module, const dt_dev_pixelpipe_iop_t *const piece, \n                              dt_masks_form_t *const form, \n                              float **buffer, int *width, int *height, int *posx, int *posy) \n{ \n  double start2 = 0.0; \n  if(darktable.unmuted & DT_DEBUG_PERF) start2 = dt_get_wtime(); \n   \n \n  if(!_gradient_get_area(module, piece, form, width, height, posx, posy)) return 0; \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n  { \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] gradient area took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n    start2 = dt_get_wtime(); \n  } \n \n   \n \n  dt_masks_point_gradient_t *gradient = (dt_masks_point_gradient_t *)((form->points)->data); \n \n   \n \n  const int w = *width; \n  const int h = *height; \n  const int px = *posx; \n  const int py = *posy; \n  const int grid = 8; \n  const int gw = (w + grid - 1) / grid + 1; \n  const int gh = (h + grid - 1) / grid + 1; \n \n  float *points = dt_alloc_align_float((size_t)2 * gw * gh); \n  if(points == NULL) return 0; \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(grid, gh, gw, px, py)    shared(points) schedule(static) collapse(2) \n#pragma omp parallel for shared(points) \n  for(int j = 0; j < gh; j++) \n    for(int i = 0; i < gw; i++) \n    { \n      points[(j * gw + i) * 2] = (grid * i + px); \n      points[(j * gw + i) * 2 + 1] = (grid * j + py); \n    } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n  { \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] gradient draw took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n    start2 = dt_get_wtime(); \n  } \n \n   \n \n  if(!dt_dev_distort_backtransform_plus(module->dev, piece->pipe, module->iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, points, (size_t)gw * gh)) \n  { \n    dt_free_align(points); \n    return 0; \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n  { \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] gradient transform took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n    start2 = dt_get_wtime(); \n  } \n \n   \n \n  const float wd = piece->pipe->iwidth; \n  const float ht = piece->pipe->iheight; \n  const float hwscale = 1.0f / sqrtf(wd * wd + ht * ht); \n  const float ihwscale = 1.0f / hwscale; \n  const float v = (-gradient->rotation / 180.0f) * M_PI; \n  const float sinv = sinf(v); \n  const float cosv = cosf(v); \n  const float xoffset = cosv * gradient->anchor[0] * wd + sinv * gradient->anchor[1] * ht; \n  const float yoffset = sinv * gradient->anchor[0] * wd - cosv * gradient->anchor[1] * ht; \n  const float compression = fmaxf(gradient->compression, 0.001f); \n  const float normf = 1.0f / compression; \n  const float curvature = gradient->curvature; \n  const dt_masks_gradient_states_t state = gradient->state; \n \n  const int lutmax = ceilf(4 * compression * ihwscale); \n  const int lutsize = 2 * lutmax + 2; \n  float *lut = dt_alloc_align_float((size_t)lutsize); \n  if(lut == NULL) \n  { \n    dt_free_align(points); \n    return 0; \n  } \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(lutsize, lutmax, hwscale, state, normf, compression)    shared(lut) schedule(static) \n#pragma omp parallel for shared(points) \n  for(int n = 0; n < lutsize; n++) \n  { \n    const float distance = (n - lutmax) * hwscale; \n    const float value = 0.5f + 0.5f * ((state == DT_MASKS_GRADIENT_STATE_LINEAR)? normf * distance: erff(distance / compression)); \n    lut[n] = (value < 0.0f)? 0.0f : ((value > 1.0f)? 1.0f : value); \n  } \n \n   \n \n  float *clut = lut + lutmax; \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(gh, gw, sinv, cosv, xoffset, yoffset, hwscale, ihwscale, curvature, compression)    shared(points, clut) schedule(static) collapse(2) \n#pragma omp parallel for shared(points) \n  for(int j = 0; j < gh; j++) \n  { \n    for(int i = 0; i < gw; i++) \n    { \n      const float x = points[(j * gw + i) * 2]; \n      const float y = points[(j * gw + i) * 2 + 1]; \n \n      const float x0 = (cosv * x + sinv * y - xoffset) * hwscale; \n      const float y0 = (sinv * x - cosv * y - yoffset) * hwscale; \n \n      const float distance = y0 - curvature * x0 * x0; \n \n      points[(j * gw + i) * 2] = (distance <= -4.0f * compression)? 0.0f : \n                                    ((distance >= 4.0f * compression)? 1.0f : dt_gradient_lookup(clut, distance * ihwscale)); \n    } \n  } \n \n  dt_free_align(lut); \n \n   \n \n  float *const bufptr = *buffer", "pred": " \nstatic int _gradient_get_mask(const dt_iop_module_t *const module, const dt_dev_pixelpipe_iop_t *const piece, \n                              dt_masks_form_t *const form, \n                              float **buffer, int *width, int *height, int *posx, int *posy) \n{ \n  double start2 = 0.0; \n  if(darktable.unmuted & DT_DEBUG_PERF) start2 = dt_get_wtime(); \n   \n \n  if(!_gradient_get_area(module, piece, form, width, height, posx, posy)) return 0; \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n  { \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] gradient area took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n    start2 = dt_get_wtime(); \n  } \n \n   \n \n  dt_masks_point_gradient_t *gradient = (dt_masks_point_gradient_t *)((form->points)->data); \n \n   \n \n  const int w = *width; \n  const int h = *height; \n  const int px = *posx; \n  const int py = *posy; \n  const int grid = 8; \n  const int gw = (w + grid - 1) / grid + 1; \n  const int gh = (h + grid - 1) / grid + 1; \n \n  float *points = dt_alloc_align_float((size_t)2 * gw * gh); \n  if(points == NULL) return 0; \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(grid, gh, gw, px, py)    shared(points) schedule(static) collapse(2) \n#pragma omp parallel for shared(points) \n  for(int j = 0; j < gh; j++)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         "}
{"label": " \nMagickExport Image *ShadeImage(const Image *image,const MagickBooleanType gray, \n  const double azimuth,const double elevation,ExceptionInfo *exception) \n{ \n#define ShadeImageTag  \"Shade/Image\" \n \n  CacheView \n    *image_view, \n    *shade_view; \n \n  Image \n    *linear_image, \n    *shade_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PrimaryInfo \n    light; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  linear_image=CloneImage(image,0,0,MagickTrue,exception); \n  shade_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if ((linear_image == (Image *) NULL) || (shade_image == (Image *) NULL)) \n    { \n      if (linear_image!= (Image *) NULL) \n        linear_image=DestroyImage(linear_image); \n      if (shade_image!= (Image *) NULL) \n        shade_image=DestroyImage(shade_image); \n      return((Image *) NULL); \n    } \n  if (SetImageStorageClass(shade_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&shade_image->exception); \n      linear_image=DestroyImage(linear_image); \n      shade_image=DestroyImage(shade_image); \n      return((Image *) NULL); \n    } \n   \n \n  light.x=(double) QuantumRange*cos(DegreesToRadians(azimuth))* \n    cos(DegreesToRadians(elevation)); \n  light.y=(double) QuantumRange*sin(DegreesToRadians(azimuth))* \n    cos(DegreesToRadians(elevation)); \n  light.z=(double) QuantumRange*sin(DegreesToRadians(elevation)); \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireVirtualCacheView(linear_image,exception); \n  shade_view=AcquireAuthenticCacheView(shade_image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(linear_image,shade_image,linear_image->rows,1) \n  for (y=0; y < (ssize_t) linear_image->rows; y++) \n  { \n    MagickRealType \n      distance, \n      normal_distance, \n      shade; \n \n    PrimaryInfo \n      normal; \n \n    register const PixelPacket \n      *restrict p, \n      *restrict s0, \n      *restrict s1, \n      *restrict s2; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,-1,y-1,linear_image->columns+2,3, \n      exception); \n    q=QueueCacheViewAuthenticPixels(shade_view,0,y,shade_image->columns,1, \n      exception); \n    if ((p == (PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n     \n \n    normal.z=2.0*(double) QuantumRange;   \n \n    s0=p+1; \n    s1=s0+image->columns+2; \n    s2=s1+image->columns+2; \n    for (x=0; x < (ssize_t) linear_image->columns; x++) \n    { \n       \n \n      normal.x=(double) (GetPixelIntensity(linear_image,s0-1)+ \n        GetPixelIntensity(linear_image,s1-1)+ \n        GetPixelIntensity(linear_image,s2-1)- \n        GetPixelIntensity(linear_image,s0+1)- \n        GetPixelIntensity(linear_image,s1+1)- \n        GetPixelIntensity(linear_image,s2+1)); \n      normal.y=(double) (GetPixelIntensity(linear_image,s2-1)+ \n        GetPixelIntensity(linear_image,s2)+ \n        GetPixelIntensity(linear_image,s2+1)- \n        GetPixelIntensity(linear_image,s0-1)- \n        GetPixelIntensity(linear_image,s0)- \n        GetPixelIntensity(linear_image,s0+1)); \n      if ((normal.x == 0.0) && (normal.y == 0.0)) \n        shade=light.z; \n      else \n        { \n          shade=0.0; \n          distance=normal.x*light.x+normal.y*light.y+normal.z*light.z; \n          if (distance > MagickEpsilon) \n            { \n              normal_distance=normal.x*normal.x+normal.y*normal.y+normal.z* \n                normal.z; \n              if (normal_distance > (MagickEpsilon*MagickEpsilon)) \n                shade=distance/sqrt((double) normal_distance); \n            } \n        } \n      if (gray!= MagickFalse) \n        { \n          SetPixelRed(q,shade); \n          SetPixelGreen(q,shade); \n          SetPixelBlue(q,shade); \n        } \n      else \n        { \n          SetPixelRed(q,ClampToQuantum(QuantumScale*shade*GetPixelRed(s1))); \n          Set", "pred": " \nMagickExport Image *ShadeImage(const Image *image,const MagickBooleanType gray, \n  const double azimuth,const double elevation,ExceptionInfo *exception) \n{ \n#define ShadeImageTag  \"Shade/Image\" \n \n  CacheView \n    *image_view, \n    *shade_view; \n \n  Image \n    *linear_image, \n    *shade_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PrimaryInfo \n    light; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  linear_image=CloneImage(image,0,0,MagickTrue,exception); \n  shade_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if ((linear_image == (Image *) NULL) || (shade_image == (Image *) NULL)) \n    { \n      if (linear_image!= (Image *) NULL) \n        linear_image=DestroyImage(linear_image); \n      if (shade_image!= (Image *) NULL) \n        shade_image=DestroyImage(shade_image); \n      return((Image *) NULL); \n    } \n  if (SetImageStorageClass(shade_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&shade_image->exception); \n      linear_image=DestroyImage(linear_image); \n      shade_image=DestroyImage(shade_image); \n      return((Image *) NULL); \n    } \n   \n \n  light.x=(double) QuantumRange*cos(Degrees);\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\"}
{"label": " \nMagickExport Image *AdaptiveBlurImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  ExceptionInfo *exception) \n{ \n#define AdaptiveBlurImageTag  \"Convolve/Image\" \n#define MagickSigma  (fabs(sigma) < MagickEpsilon? MagickEpsilon : sigma) \n \n  CacheView \n    *blur_view, \n    *edge_view, \n    *image_view; \n \n  double \n    **kernel, \n    normalize; \n \n  Image \n    *blur_image, \n    *edge_image, \n    *gaussian_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    j, \n    k, \n    u, \n    v, \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  blur_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if (blur_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (fabs(sigma) <= MagickEpsilon) \n    return(blur_image); \n  if (SetImageStorageClass(blur_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&blur_image->exception); \n      blur_image=DestroyImage(blur_image); \n      return((Image *) NULL); \n    } \n   \n \n  edge_image=EdgeImage(image,radius,exception); \n  if (edge_image == (Image *) NULL) \n    { \n      blur_image=DestroyImage(blur_image); \n      return((Image *) NULL); \n    } \n  (void) LevelImage(edge_image,\"20%,95%\"); \n  gaussian_image=BlurImage(edge_image,radius,sigma,exception); \n  if (gaussian_image!= (Image *) NULL) \n    { \n      edge_image=DestroyImage(edge_image); \n      edge_image=gaussian_image; \n    } \n  (void) LevelImage(edge_image,\"10%,95%\"); \n   \n \n  width=GetOptimalKernelWidth2D(radius,sigma); \n  kernel=(double **) MagickAssumeAligned(AcquireAlignedMemory((size_t) width, \n    sizeof(*kernel))); \n  if (kernel == (double **) NULL) \n    { \n      edge_image=DestroyImage(edge_image); \n      blur_image=DestroyImage(blur_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  (void) ResetMagickMemory(kernel,0,(size_t) width*sizeof(*kernel)); \n  for (i=0; i < (ssize_t) width; i+=2) \n  { \n    kernel[i]=(double *) MagickAssumeAligned(AcquireAlignedMemory((size_t) \n      (width-i),(width-i)*sizeof(**kernel))); \n    if (kernel[i] == (double *) NULL) \n      break; \n    normalize=0.0; \n    j=(ssize_t) (width-i)/2; \n    k=0; \n    for (v=(-j); v <= j; v++) \n    { \n      for (u=(-j); u <= j; u++) \n      { \n        kernel[i][k]=(double) (exp(-((double) u*u+v*v)/(2.0*MagickSigma* \n          MagickSigma))/(2.0*MagickPI*MagickSigma*MagickSigma)); \n        normalize+=kernel[i][k]; \n        k++; \n      } \n    } \n    kernel[i][(k-1)/2]+=(1.0-normalize); \n    if (sigma < MagickEpsilon) \n      kernel[i][(k-1)/2]=1.0; \n  } \n  if (i < (ssize_t) width) \n    { \n      for (i-=2; i >= 0; i-=2) \n        kernel[i]=(double *) RelinquishAlignedMemory(kernel[i]); \n      kernel=(double **) RelinquishAlignedMemory(kernel); \n      edge_image=DestroyImage(edge_image); \n      blur_image=DestroyImage(blur_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(image,&bias); \n  SetMagickPixelPacketBias(image,&bias); \n  image_view=AcquireVirtualCacheView(image,exception); \n  edge_view=AcquireVirtualCacheView(edge_image,exception); \n  blur_view=AcquireAuthenticCacheView(blur_image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,blur_image,blur_image->rows,1) \n  for (y=0; y < (ssize_t) blur_image->rows; y++) \n  { \n    register const IndexPacket \n      *restrict indexes; \n \n    register const PixelPacket \n      *restrict p, \n      *restrict r; \n \n    register IndexPacket \n      *restrict blur_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    r=GetCacheViewVirtualPixels(edge_view,0,y,edge_image->columns,1,exception); \n    q=QueueCacheViewAuthenticPixels(blur_view,0,y,blur_image->columns,1, \n      exception); \n    if ((r == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    blur_indexes=GetCacheViewAuthenticIndexQueue(blur_view); \n    for (x=0; x < (ssize_", "pred": " \nMagickExport Image *AdaptiveBlurImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  ExceptionInfo *exception) \n{ \n#define AdaptiveBlurImageTag  \"Convolve/Image\" \n#define MagickSigma  (fabs(sigma) < MagickEpsilon? MagickEpsilon : sigma) \n \n  CacheView \n    *blur_view, \n    *edge_view, \n    *image_view; \n \n  double \n    **kernel, \n    normalize; \n \n  Image \n    *blur_image, \n    *edge_image, \n    *gaussian_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    j, \n    k, \n    u, \n    v, \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  blur_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if (blur_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (fabs(sigma) <= MagickEpsilon) \n    return(blur_image); \n  if (SetImageStorageClass(blur_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&blur_image->exception); \n      blur_image=DestroyImage(blur_image); \n      return((Image *) NULL); \n    }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": " \nstatic PyObject *__pyx_pf_3GPy_4util_17choleskies_cython_6backprop_gradient_par(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_dL, __Pyx_memviewslice __pyx_v_L) { \n  __Pyx_memviewslice __pyx_v_dL_dK = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_v_N; \n  int __pyx_v_k; \n  int __pyx_v_j; \n  int __pyx_v_i; \n  PyObject *__pyx_r = NULL; \n  __Pyx_RefNannyDeclarations \n  PyObject *__pyx_t_1 = NULL; \n  PyObject *__pyx_t_2 = NULL; \n  PyObject *__pyx_t_3 = NULL; \n  PyObject *__pyx_t_4 = NULL; \n  __Pyx_memviewslice __pyx_t_5 = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_t_6; \n  long __pyx_t_7; \n  int __pyx_t_8; \n  long __pyx_t_9; \n  long __pyx_t_10; \n  long __pyx_t_11; \n  long __pyx_t_12; \n  int __pyx_t_13; \n  Py_ssize_t __pyx_t_14; \n  Py_ssize_t __pyx_t_15; \n  Py_ssize_t __pyx_t_16; \n  Py_ssize_t __pyx_t_17; \n  Py_ssize_t __pyx_t_18; \n  Py_ssize_t __pyx_t_19; \n  int __pyx_t_20; \n  int __pyx_t_21; \n  int __pyx_lineno = 0; \n  const char *__pyx_filename = NULL; \n  int __pyx_clineno = 0; \n  __Pyx_RefNannySetupContext(\"backprop_gradient_par\", 0); \n \n   \n \n  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_2); \n  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_tril); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_3); \n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; \n  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_dL, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_2); \n  __pyx_t_4 = NULL; \n  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) { \n    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3); \n    if (likely(__pyx_t_4)) { \n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3); \n      __Pyx_INCREF(__pyx_t_4); \n      __Pyx_INCREF(function); \n      __Pyx_DECREF_SET(__pyx_t_3, function); \n    } \n  } \n  __pyx_t_1 = (__pyx_t_4)? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2); \n  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0; \n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; \n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_1); \n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; \n  __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_t_1, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; \n  __pyx_v_dL_dK = __pyx_t_5; \n  __pyx_t_5.memview = NULL; \n  __pyx_t_5.data = NULL; \n \n   \n \n  __pyx_v_N = (__pyx_v_L.shape[0]); \n \n   \n \n  { \n      #ifdef WITH_THREAD \n      PyThreadState *_save; \n      Py_UNBLOCK_THREADS \n      __Pyx_FastGIL_Remember(); \n      #endif \n       \n { \n \n         \n \n        for (__pyx_t_6 = (__pyx_v_N - 1); __pyx_t_6 > -1; __pyx_t_6-=1) { \n          __pyx_v_k = __pyx_t_6; \n \n           \n \n          { \n              #if ((defined(__APPLE__) || defined(__OSX__)) && (defined(__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))))) \n                  #undef likely \n                  #undef unlikely \n                  #define likely(x)   (x) \n                  #define unlikely(x) (x) \n              #endif \n              #ifdef _OPENMP \n              #pragma omp parallel  private(__pyx_t_10, __pyx_t_11, __pyx_t_12, __pyx_t_13, __pyx_t_14, __pyx_t_15, __pyx", "pred": " \nstatic PyObject *__pyx_pf_3GPy_4util_17choleskies_cython_6backprop_gradient_par(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_dL, __Pyx_memviewslice __pyx_v_L) { \n  __Pyx_memviewslice __pyx_v_dL_dK = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_v_N; \n  int __pyx_v_k; \n  int __pyx_v_j; \n  int __pyx_v_i; \n  PyObject *__pyx_r = NULL; \n  __Pyx_RefNannyDeclarations \n  PyObject *__pyx_t_1 = NULL; \n  PyObject *__pyx_t_2 = NULL; \n  PyObject *__pyx_t_3 = NULL; \n  PyObject *__pyx_t_4 = NULL; \n  __Pyx_memviewslice __pyx_t_5 = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_t_6; \n  long __pyx_t_7; \n  int __pyx_t_8; \n  long __pyx_t_9; \n  long __pyx_t_10; \n  long __pyx_t_11; \n  long __pyx_t_12; \n  int __pyx_t_13; \n  Py_ssize_t __pyx_t_14; \n  Py_ssize_t __pyx_t_15; \n  Py_ssize_t __pyx_t_16; \n  Py_ssize_t __pyx_t_17; \n  Py_ssize_t __pyx_t_18; \n  Py_ssize_t __pyx_t_19; \n  int __pyx_t_20; \n  int __pyx_t_21; \n  int __pyx_lineno = 0; \n  const char *__pyx_filename = NULL; \n  int __pyx_clineno = 0; \n  __Pyx_RefNannySetupContext(\"backprop_gradient_par\", 0); \n \n   \n \n  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_test);\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nstatic MagickBooleanType DrawPolygonPrimitive(Image *image, \n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info, \n  ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    fill, \n    status; \n \n  double \n    mid; \n \n  PolygonInfo \n    **restrict polygon_info; \n \n  register EdgeInfo \n    *p; \n \n  register ssize_t \n    i; \n \n  SegmentInfo \n    bounds; \n \n  ssize_t \n    start, \n    stop, \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(draw_info!= (DrawInfo *) NULL); \n  assert(draw_info->signature == MagickSignature); \n  assert(primitive_info!= (PrimitiveInfo *) NULL); \n  if (primitive_info->coordinates == 0) \n    return(MagickTrue); \n  polygon_info=AcquirePolygonThreadSet(draw_info,primitive_info); \n  if (polygon_info == (PolygonInfo **) NULL) \n    return(MagickFalse); \n  if (0) \n    DrawBoundingRectangles(image,draw_info,polygon_info[0],exception); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    begin draw-polygon\"); \n  fill=(primitive_info->method == FillToBorderMethod) || \n    (primitive_info->method == FloodfillMethod)? MagickTrue : MagickFalse; \n  mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0; \n  bounds=polygon_info[0]->edges[0].bounds; \n  for (i=1; i < (ssize_t) polygon_info[0]->number_edges; i++) \n  { \n    p=polygon_info[0]->edges+i; \n    if (p->bounds.x1 < bounds.x1) \n      bounds.x1=p->bounds.x1; \n    if (p->bounds.y1 < bounds.y1) \n      bounds.y1=p->bounds.y1; \n    if (p->bounds.x2 > bounds.x2) \n      bounds.x2=p->bounds.x2; \n    if (p->bounds.y2 > bounds.y2) \n      bounds.y2=p->bounds.y2; \n  } \n  bounds.x1-=(mid+1.0); \n  bounds.x1=bounds.x1 < 0.0? 0.0 : (size_t) ceil(bounds.x1-0.5) >= \n    image->columns? (double) image->columns-1 : bounds.x1; \n  bounds.y1-=(mid+1.0); \n  bounds.y1=bounds.y1 < 0.0? 0.0 : (size_t) ceil(bounds.y1-0.5) >= \n    image->rows? (double) image->rows-1 : bounds.y1; \n  bounds.x2+=(mid+1.0); \n  bounds.x2=bounds.x2 < 0.0? 0.0 : (size_t) floor(bounds.x2+0.5) >= \n    image->columns? (double) image->columns-1 : bounds.x2; \n  bounds.y2+=(mid+1.0); \n  bounds.y2=bounds.y2 < 0.0? 0.0 : (size_t) floor(bounds.y2+0.5) >= \n    image->rows? (double) image->rows-1 : bounds.y2; \n  status=MagickTrue; \n  image_view=AcquireAuthenticCacheView(image,exception); \n  if (primitive_info->coordinates == 1) \n    { \n       \n \n      start=(ssize_t) ceil(bounds.y1-0.5); \n      stop=(ssize_t) floor(bounds.y2+0.5); \n      #pragma omp parallel for schedule(static,4) shared(status)          magick_threads(image,image,1,1) \n      for (y=start; y <= stop; y++) \n      { \n        MagickBooleanType \n          sync; \n \n        PixelInfo \n          pixel; \n \n        register ssize_t \n          x; \n \n        register Quantum \n          *restrict q; \n \n        ssize_t \n          start, \n          stop; \n \n        if (status == MagickFalse) \n          continue; \n        start=(ssize_t) ceil(bounds.x1-0.5); \n        stop=(ssize_t) floor(bounds.x2+0.5); \n        x=start; \n        q=GetCacheViewAuthenticPixels(image_view,x,y,(size_t) (stop-x+1),1, \n          exception); \n        if (q == (Quantum *) NULL) \n          { \n            status=MagickFalse; \n            continue; \n          } \n        GetPixelInfo(image,&pixel); \n        for ( ; x <= stop; x++) \n        { \n          if ((x == (ssize_t) ceil(primitive_info->point.x-0.5)) && \n              (y == (ssize_t) ceil(primitive_info->point.y-0.5))) \n            { \n              (void) GetStrokeColor(draw_info,x,y,&pixel,exception); \n              SetPixelInfoPixel(image,&pixel,q); \n            } \n          q+=GetPixelChannels(image); \n        } \n        sync=SyncCacheViewAuthenticPixels(image_view,exception); \n        if (sync == MagickFalse) \n          status=MagickFalse; \n      } \n      image_view=DestroyCacheView(image_view); \n      polygon_info=DestroyPolygonThreadSet(polygon_info); ", "pred": " \nstatic MagickBooleanType DrawPolygonPrimitive(Image *image, \n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info, \n  ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    fill, \n    status; \n \n  double \n    mid; \n \n  PolygonInfo \n    **restrict polygon_info; \n \n  register EdgeInfo \n    *p; \n \n  register ssize_t \n    i; \n \n  SegmentInfo \n    bounds; \n \n  ssize_t \n    start, \n    stop, \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(draw_info!= (DrawInfo *) NULL); \n  assert(draw_info->signature == MagickSignature); \n  assert(primitive_info!= (PrimitiveInfo *) NULL); \n  if (primitive_info->coordinates == 0) \n    return(MagickTrue); \n  polygon_info=AcquirePolygonThreadSet(draw_info,primitive_info); \n  if (polygon_info == (PolygonInfo **) NULL) \n    return(MagickFalse); \n  if (0) \n    DrawBoundingRectangles(image,draw_info,polygon_info[0],exception); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    begin draw-polygon\"); \n  fill=(primitive_info->method == FillToBorderMethod) || \n    (primitive_info->method == FloodfillMethod)? MagickTrue : MagickFalse; \n  mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0; \n  bounds=polygon_info[0]->edges[0].bounds; \n  for (i=1; i < (ssize_t) polygon_info->bounds_count; i++) {\\n      if (draw_info->signature == MagickSignature)\\n        if (draw_info->signature == MagickSignature)\\n          if (draw_info->signature == MagickSignature)\\n            if (draw_info->signature == MagickSignature)\\n              if (draw_info->signature == MagickSignature)\\n               if (draw_info->signature == MagickSignature)\\n                if (draw_info->signature == MagickSignature)\\n                  if (draw_info->signature == MagickSignature)\\n                  if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n                    if (draw_info->signature == MagickSignature)\\n    "}
{"label": " \nstatic int _gradient_get_mask_roi(const dt_iop_module_t *const module, const dt_dev_pixelpipe_iop_t *const piece, \n                                  dt_masks_form_t *const form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start2 = 0.0; \n  if(darktable.unmuted & DT_DEBUG_PERF) start2 = dt_get_wtime(); \n   \n \n  const dt_masks_point_gradient_t *gradient = (dt_masks_point_gradient_t *)(form->points->data); \n \n   \n \n  const int w = roi->width; \n  const int h = roi->height; \n  const int px = roi->x; \n  const int py = roi->y; \n  const float iscale = 1.0f / roi->scale; \n  const int grid = CLAMP((10.0f*roi->scale + 2.0f) / 3.0f, 1, 4); \n  const int gw = (w + grid - 1) / grid + 1; \n  const int gh = (h + grid - 1) / grid + 1; \n \n  float *points = dt_alloc_align_float((size_t)2 * gw * gh); \n  if(points == NULL) return 0; \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(iscale, gh, gw, py, px, grid)    shared(points) schedule(static) collapse(2) \n#pragma omp parallel for shared(points) \n  for(int j = 0; j < gh; j++) \n    for(int i = 0; i < gw; i++) \n    { \n \n      const size_t index = (size_t)j * gw + i; \n      points[index * 2] = (grid * i + px) * iscale; \n      points[index * 2 + 1] = (grid * j + py) * iscale; \n    } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n  { \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] gradient draw took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n    start2 = dt_get_wtime(); \n  } \n \n   \n \n  if(!dt_dev_distort_backtransform_plus(module->dev, piece->pipe, module->iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, points, \n                                        (size_t)gw * gh)) \n  { \n    dt_free_align(points); \n    return 0; \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n  { \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] gradient transform took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n    start2 = dt_get_wtime(); \n  } \n \n   \n \n  const float wd = piece->pipe->iwidth; \n  const float ht = piece->pipe->iheight; \n  const float hwscale = 1.0f / sqrtf(wd * wd + ht * ht); \n  const float ihwscale = 1.0f / hwscale; \n  const float v = (-gradient->rotation / 180.0f) * M_PI; \n  const float sinv = sinf(v); \n  const float cosv = cosf(v); \n  const float xoffset = cosv * gradient->anchor[0] * wd + sinv * gradient->anchor[1] * ht; \n  const float yoffset = sinv * gradient->anchor[0] * wd - cosv * gradient->anchor[1] * ht; \n  const float compression = fmaxf(gradient->compression, 0.001f); \n  const float normf = 1.0f / compression; \n  const float curvature = gradient->curvature; \n  const dt_masks_gradient_states_t state = gradient->state; \n \n  const int lutmax = ceilf(4 * compression * ihwscale); \n  const int lutsize = 2 * lutmax + 2; \n  float *lut = dt_alloc_align_float((size_t)lutsize); \n  if(lut == NULL) \n  { \n    dt_free_align(points); \n    return 0; \n  } \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(lutsize, lutmax, hwscale, state, normf, compression)    shared(lut) schedule(static) \n#pragma omp parallel for shared(points) \n  for(int n = 0; n < lutsize; n++) \n  { \n    const float distance = (n - lutmax) * hwscale; \n    const float value = 0.5f + 0.5f * ((state == DT_MASKS_GRADIENT_STATE_LINEAR)? normf * distance: erff(distance / compression)); \n    lut[n] = (value < 0.0f)? 0.0f : ((value > 1.0f)? 1.0f : value); \n  } \n \n   \n \n  float *clut = lut + lutmax; \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(gh, gw, sinv, cosv, xoffset, yoffset, hwscale, ihwscale, curvature, compression)    shared(points, clut) schedule(static) collapse(2) \n#pragma omp parallel for shared(points) \n  for(int j = 0; j < gh; j++) \n  { \n    for(int i = 0; i < gw; i++) \n    { \n      const size_t index = (size_t)j * gw + i; \n      const float x = points[index * 2]; \n      const float y = points[index * 2 + 1]; \n \n      const float x0 = (cosv * x + sinv * y - xoffset) * hwscale; \n      const float y0 = (sinv * x - cosv * y - yoffset) * hwscale; \n \n      const float distance = y0 - curvature * x0 * x0; \n \n      points[index * 2] = (distance <= -4.0f * compression)? 0.0f : ((distance >= 4.0f * compression)? 1.0f : dt_gradient_lookup(clut, distance * ihwscale)); \n    } \n  } \n \n  dt_free_align(lut); \n \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(h, w, grid, gw)    shared(buffer, points) schedule(simd:static) \n#pragma omp parallel for shared(points, buffer) \n  for(int j = 0; j < h; j++) \n  { \n    const int jj = j % grid; \n    const int mj = j /", "pred": " \nstatic int _gradient_get_mask_roi(const dt_iop_module_t *const module, const dt_dev_pixelpipe_iop_t *const piece, \n                                  dt_masks_form_t *const form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start2 = 0.0; \n  if(darktable.unmuted & DT_DEBUG_PERF) start2 = dt_get_wtime(); \n   \n \n  const dt_masks_point_gradient_t *gradient = (dt_masks_point_gradient_t *)(form->points->data); \n \n   \n \n  const int w = roi->width; \n  const int h = roi->height; \n  const int px = roi->x; \n  const int py = roi->y; \n  const float iscale = 1.0f / roi->scale; \n  const int grid = CLAMP((10.0f*roi->scale + 2.0f) / 3.0f, 1, 4); \n  const int gw = (w + grid - 1) / grid + 1; \n  const int gh = (h + grid - 1) / grid + 1; \n \n  float *points = dt_alloc_align_float((size_t)2 * gw * gh); \n  if(points == NULL) return 0; \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(iscale, gh, gw, py, px, grid)    shared(points) schedule(static) collapse(2) \n#pragma omp parallel for shared(points) \n  for(int j = 0; j < gh; j++) \n    for(int i = 0; i < gw; i++) \n    { \n \n      const size_t index = (size_t)j * gw + i; \n      points[index * 2] = (grid * i + px) * iscale; \n      points[index * 2 + 1] = (grid * j + py) * iscale; \n    } \n \n  if(darktable.unmuted & DT_DEBUG_PERF)  points[index * 2 + 1] = dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt_get_wtime() * dt"}
{"label": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n  const int ch = piece->colors; \n  const int gamutcheck = (d->mode == DT_PROFILE_GAMUTCHECK); \n  const size_t npixels = (size_t)roi_out->width * roi_out->height; \n  float *const restrict out = (float *)ovoid; \n \n  if(d->type == DT_COLORSPACE_LAB) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, ch); \n  } \n  else if(!isnan(d->cmatrix[0][0])) \n  { \n    const float *const restrict in = (const float *const)ivoid; \n    const __m128 m0 = _mm_set_ps(0.0f, d->cmatrix[2][0], d->cmatrix[1][0], d->cmatrix[0][0]); \n    const __m128 m1 = _mm_set_ps(0.0f, d->cmatrix[2][1], d->cmatrix[1][1], d->cmatrix[0][1]); \n    const __m128 m2 = _mm_set_ps(0.0f, d->cmatrix[2][2], d->cmatrix[1][2], d->cmatrix[0][2]); \n \n \n \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(ch, npixels, m0, m1, m2, in, out)         schedule(static) \n    for(int j = 0; j < ch * npixels; j += ch) \n    { \n      const __m128 xyz = dt_Lab_to_XYZ_sse2(_mm_load_ps(in + j)); \n      const __m128 t = ((m0 * _mm_shuffle_ps(xyz, xyz, _MM_SHUFFLE(0, 0, 0, 0))) + \n                        ((m1 * _mm_shuffle_ps(xyz, xyz, _MM_SHUFFLE(1, 1, 1, 1))) + \n                         (m2 * _mm_shuffle_ps(xyz, xyz, _MM_SHUFFLE(2, 2, 2, 2))))); \n      _mm_stream_ps(out + j, t); \n    } \n    _mm_sfence(); \n \n    process_fastpath_apply_tonecurves(self, piece, ivoid, ovoid, roi_in, roi_out); \n  } \n  else \n  { \n     \n \n    const __m128 outofgamutpixel = _mm_set_ps(0.0f, 1.0f, 1.0f, 0.0f); \n#pragma omp parallel for default(none)      dt_omp_firstprivate(ch, d, ivoid, gamutcheck, outofgamutpixel, out, roi_out)      schedule(static) \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)ch * k * roi_out->width; \n      float *outp = out + (size_t)ch * k * roi_out->width; \n \n      cmsDoTransform(d->xform, in, outp, roi_out->width); \n \n      if(gamutcheck) \n      { \n        for(int j = 0; j < roi_out->width; j++) \n        { \n          const __m128 pixel = _mm_load_ps(outp + 4*j); \n          __m128 ingamut = _mm_cmplt_ps(pixel, _mm_set_ps(-FLT_MAX, 0.0f, 0.0f, 0.0f)); \n \n          ingamut = _mm_or_ps(_mm_unpacklo_ps(ingamut, ingamut), _mm_unpackhi_ps(ingamut, ingamut)); \n          ingamut = _mm_or_ps(_mm_unpacklo_ps(ingamut, ingamut), _mm_unpackhi_ps(ingamut, ingamut)); \n \n          const __m128 result \n              = _mm_or_ps(_mm_and_ps(ingamut, outofgamutpixel), _mm_andnot_ps(ingamut, pixel)); \n          _mm_stream_ps(outp + 4*j, result); \n        } \n      } \n    } \n    _mm_sfence(); \n  } \n \n  if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out->width, roi_out->height); \n} ", "pred": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n  const int ch = piece->colors; \n  const int gamutcheck = (d->mode == DT_PROFILE_GAMUTCHECK); \n  const size_t npixels = (size_t)roi_out->width * roi_out->height; \n  float *const restrict out = (float *)ovoid; \n \n  if(d->type == DT_COLORSPACE_LAB) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, ch); \n  } \n  else if(!isnan(d->cmatrix[0][0])) \n  { \n    const float *const restrict in = (const float *const)ivoid; \n    const __m128 m0 = _mm_set_ps(0.0f, d->cmatrix[2][0], d->cmatrix[1][0], d->cmatrix[0][0]); \n    const __m128 m1 = _mm_set_ps(0.0f, d->cmatrix[2][1], d->cmatrix[1][1], d->cmatrix[0][1]); \n    const __m128 m2 = _mm_set_ps(0.0f, d->cmatrix[2][2], d->cmatrix[1][2], d->cmatrix[0][2]); \n \n \n \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(ch, npixels, m0, m1, m2, in, out)         schedule(static) \n    for(int j = 0; j < ch * npixels; j += ch) \n    { \n      const __m128 x0 = _mm_set_ps(0.0f, d->cmatrix[3][0], d->cmatrix[3][0], d->cmatrix[3][1]);    const __m128 x1 = _mm_set_ps(0.0f, d->cmatrix[3][1], d->cmatrix[3][2], d->cmatrix[3][3]);    const __m128 x2 = _mm_set_ps(0.0f, d->cmatrix[3][3], d->cmatrix[3][4], d->cmatrix[3][5]);    const __m128 x3 = _mm_set_ps(0.0f, d->cmatrix[3][4], d->cmatrix[3][5], d->cmatrix[3][6]);   const __m128 x4 = _mm_set_ps(0.0f, d->cmatrix[3][6], d->cmatrix[3][7], d->cmatrix[3][8]);   const __m128 x5 = _mm_set_ps(0.0f, d->cmatrix[3][7], d->cmatrix[3][8], d->cmatrix[3][9]);   const __m128 x6 = _mm_set_ps(0.0f, d->cmatrix[3][8], d->cmatrix[3][10], d->cmatrix[3][11]);   const __m128 x7 = _mm_set_ps(0.0f, d->cmatrix[3][12], d->cmatrix[3][13], d->cmatrix[3][14], d->cmatrix[3][15]);   const __m128 x4 = _mm_set_ps(0.0f, d->cmatrix[3][13], d->cmatrix[3][14], d->cmatrix[3][15], d->cmatrix[3][16]);   const __m128 x5 = _mm_set_ps(0.0f, d->cmatrix[3][13], d->cmatrix[3][14], d->cmatrix[3][15], d->cmatrix[3][16]);   const __m128 x6 = _mm_set_ps(0.0f, d->cmatrix[3][13], d->cmatrix[3][14], d->cmatrix[3][15], d->cmatrix[3][16]);   const __m128 x7 = _mm_set_ps(0.0f, d->cmatrix[3][13], d->cmatrix[3][14], d->cmatrix[3][15], d->cmatrix[3][16]);   const __m128 x8 = _mm_set_ps(0.0f, d->cmatrix[3][13], d->cmatrix[3][14], d->cmatrix[3][15], d->cmatrix[3][16]);   const __m128 x9 = _mm_set_ps(0.0f, d->cmatrix[3][13], d->cmatrix[3][14], d->cmatrix[3][15], d->cmatrix[3][16]);   const __m128 x10 = _mm_set_ps(0.0f, d->cmatrix[3][13], d->cmatrix[3][14], d->cmatrix[3][15], d->cmatrix[3][16]);   const __m128 x11 = _mm_set_ps(0.0f, d->cmatrix[3][13], d->cmatrix[3][14], d->cmatrix[3][15], d->cmatrix[3][16]);   const __m128 x12 = _mm_set_ps(0.0f, d->cmatrix[3][13], d->cmatrix[3][14], d->cmatrix[3][15], d->cmatrix[3][16]);   const __m128 x13 = _mm"}
{"label": " \nstatic void process_fastpath_apply_tonecurves(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                              const void *const ivoid, void *const ovoid, \n                                              const dt_iop_roi_t *const roi_in, \n                                              const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n \n  if(!isnan(d->cmatrix[0][0])) \n  { \n    const size_t npixels = (size_t)roi_out->width * roi_out->height; \n    float *const restrict out = (float *const)ovoid; \n     \n \n \n     \n \n    if((d->lut[0][0] >= 0.0f) && (d->lut[1][0] >= 0.0f) && (d->lut[2][0] >= 0.0f)) \n    {  \n \n#pragma omp parallel for default(none)        dt_omp_firstprivate(d, out, npixels)        schedule(static) \n      for(size_t k = 0; k < 4 * npixels; k += 4) \n      { \n        for(int c = 0; c < 3; c++) \n        { \n          out[k + c] = (out[k + c] < 1.0f)? lerp_lut(d->lut[c], out[k + c]) \n                                           : dt_iop_eval_exp(d->unbounded_coeffs[c], out[k + c]); \n        } \n      } \n    } \n    else if((d->lut[0][0] >= 0.0f) || (d->lut[1][0] >= 0.0f) || (d->lut[2][0] >= 0.0f)) \n    {  \n \n#pragma omp parallel for default(none)        dt_omp_firstprivate(d, out, npixels)        schedule(static) \n      for(size_t k = 0; k < 4 * npixels; k += 4) \n      { \n        for(int c = 0; c < 3; c++) \n        { \n          if(d->lut[c][0] >= 0.0f) \n          { \n            out[k + c] = (out[k + c] < 1.0f)? lerp_lut(d->lut[c], out[k + c]) \n                                             : dt_iop_eval_exp(d->unbounded_coeffs[c], out[k + c]); \n          } \n        } \n      } \n    } \n  } \n} ", "pred": " \nstatic void process_fastpath_apply_tonecurves(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                              const void *const ivoid, void *const ovoid, \n                                              const dt_iop_roi_t *const roi_in, \n                                              const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n \n  if(!isnan(d->cmatrix[0][0])) \n  { \n    const size_t npixels = (size_t)roi_out->width * roi_out->height; \n    float *const restrict out = (float *const)ovoid; \n     \n \n \n     \n \n    if((d->lut[0][0] >= 0.0f) && (d->lut[1][0] >= 0.0f) && (d->lut[2][0] >= 0.0f)) \n    {  \n \n#pragma omp parallel for default(none)        dt_omp_firstprivate(d, out, npixels)        schedule(static) \n      for(size_t k = 0; k < 4 * npixels; k += 4) \n      { \n        for(int c = 0; c < 3; c++) \n        { \n          out[k + c] = (out[k + c] < 1.0f)? lerp_lut(d->lut[c], out[k + c]) \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": " \nMagickExport Image *FilterImageChannel(const Image *image, \n  const ChannelType channel,const KernelInfo *kernel,ExceptionInfo *exception) \n{ \n#define FilterImageTag  \"Filter/Image\" \n \n  CacheView \n    *filter_view, \n    *image_view; \n \n  Image \n    *filter_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  MagickRealType \n    *filter_kernel; \n \n  register ssize_t \n    i; \n \n  ssize_t \n    y; \n \n  clBeginPerfMarkerAMD(__FUNCTION__,\"\"); \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  if ((kernel->width % 2) == 0) \n    ThrowImageException(OptionError,\"KernelWidthMustBeAnOddNumber\"); \n \n \n \n  if (image->debug!= MagickFalse) \n    { \n      char \n        format[MaxTextExtent], \n        *message; \n \n      register const double \n        *k; \n \n      ssize_t \n        u, \n        v; \n \n      (void) LogMagickEvent(TransformEvent,GetMagickModule(), \n        \"  FilterImage with %.20gx%.20g kernel:\",(double) kernel->width,(double) \n        kernel->height); \n      message=AcquireString(\"\"); \n      k=kernel->values; \n      for (v=0; v < (ssize_t) kernel->height; v++) \n      { \n        *message='\\0'; \n        (void) FormatLocaleString(format,MaxTextExtent,\"%.20g: \",(double) v); \n        (void) ConcatenateString(&message,format); \n        for (u=0; u < (ssize_t) kernel->width; u++) \n        { \n          (void) FormatLocaleString(format,MaxTextExtent,\"%g \",*k++); \n          (void) ConcatenateString(&message,format); \n        } \n        (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"%s\",message); \n      } \n      message=DestroyString(message); \n    } \n \n  filter_image=AccelerateConvolveImageChannel(image,channel,kernel,exception); \n  if (filter_image!= NULL)  \n  { \n    clEndPerfMarkerAMD(); \n    return(filter_image); \n  } \n \n \n  filter_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (filter_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(filter_image,DirectClass) == MagickFalse) \n  { \n    InheritException(exception,&filter_image->exception); \n    filter_image=DestroyImage(filter_image); \n    return((Image *) NULL); \n  } \n \n   \n \n  filter_kernel=(MagickRealType *) MagickAssumeAligned(AcquireAlignedMemory( \n    kernel->width,kernel->width*sizeof(*filter_kernel))); \n  if (filter_kernel == (MagickRealType *) NULL) \n    { \n      filter_image=DestroyImage(filter_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  for (i=0; i < (ssize_t) (kernel->width*kernel->width); i++) \n    filter_kernel[i]=(MagickRealType) kernel->values[i]; \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(image,&bias); \n  SetMagickPixelPacketBias(image,&bias); \n  image_view=AcquireVirtualCacheView(image,exception); \n  filter_view=AcquireAuthenticCacheView(filter_image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,filter_image,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    MagickBooleanType \n      sync; \n \n    register const IndexPacket \n      *restrict indexes; \n \n    register const PixelPacket \n      *restrict p; \n \n    register IndexPacket \n      *restrict filter_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) (kernel->width-1)/2L),y- \n      (ssize_t) ((kernel->height-1)/2L),image->columns+kernel->width, \n      kernel->height,exception); \n    q=GetCacheViewAuthenticPixels(filter_view,0,y,filter_image->columns,1, \n      exception); \n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewVirtualIndexQueue(image_view); \n    filter_indexes=GetCacheViewAuthenticIndexQueue(filter_view); \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      DoublePixelPacket \n        pixel; \n \n      register const MagickRealType \n        *restrict k; \n \n      register const PixelPacket \n        *restrict kernel_pixels; \n \n      register ssize_t \n        u; \n \n      ssize_t \n        v; \n \n      pixel.red=bias.red; \n      pixel.green=bias.green; \n      pixel.blue=bias.blue; \n      pixel.opacity=bias.opacity; \n      pixel.index=bias.index; \n      k=filter_kernel;", "pred": " \nMagickExport Image *FilterImageChannel(const Image *image, \n  const ChannelType channel,const KernelInfo *kernel,ExceptionInfo *exception) \n{ \n#define FilterImageTag  \"Filter/Image\" \n \n  CacheView \n    *filter_view, \n    *image_view; \n \n  Image \n    *filter_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  MagickRealType \n    *filter_kernel; \n \n  register ssize_t \n    i; \n \n  ssize_t \n    y; \n \n  clBeginPerfMarkerAMD(__FUNCTION__,\"\"); \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  if ((kernel->width % 2) == 0) \n    ThrowImageException(OptionError,\"KernelWidthMustBeAnOddNumber\"); \n \n \n \n  if (image->debug!= MagickFalse) \n    { \n      char \n        format[MaxTextExtent], \n        *message; \n \n      register const double \n        *k; \n \n      ssize_t \n        u, \n        v; \n \n      (void) LogMagickEvent(TransformEvent,GetMagickModule(), \n        \"  FilterImage with %.20gx%.20g kernel:\",(double) kernel->width,(double) \n        kernel->height); \n      message=AcquireString(\"\"); \n      k=kernel->values; \n      for (v=0; v < (ssize_t) u)\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   "}
{"label": " \nMagickExport Image *RadialBlurImageChannel(const Image *image, \n  const ChannelType channel,const double angle,ExceptionInfo *exception) \n{ \n  CacheView \n    *blur_view, \n    *image_view; \n \n  Image \n    *blur_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  MagickRealType \n    blur_radius, \n    *cos_theta, \n    offset, \n    *sin_theta, \n    theta; \n \n  PointInfo \n    blur_center; \n \n  register ssize_t \n    i; \n \n  size_t \n    n; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  blur_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (blur_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(blur_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&blur_image->exception); \n      blur_image=DestroyImage(blur_image); \n      return((Image *) NULL); \n    } \n  blur_center.x=(double) (image->columns-1)/2.0; \n  blur_center.y=(double) (image->rows-1)/2.0; \n  blur_radius=hypot(blur_center.x,blur_center.y); \n  n=(size_t) fabs(4.0*DegreesToRadians(angle)*sqrt((double) blur_radius)+2UL); \n  theta=DegreesToRadians(angle)/(MagickRealType) (n-1); \n  cos_theta=(MagickRealType *) AcquireQuantumMemory((size_t) n, \n    sizeof(*cos_theta)); \n  sin_theta=(MagickRealType *) AcquireQuantumMemory((size_t) n, \n    sizeof(*sin_theta)); \n  if ((cos_theta == (MagickRealType *) NULL) || \n      (sin_theta == (MagickRealType *) NULL)) \n    { \n      blur_image=DestroyImage(blur_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  offset=theta*(MagickRealType) (n-1)/2.0; \n  for (i=0; i < (ssize_t) n; i++) \n  { \n    cos_theta[i]=cos((double) (theta*i-offset)); \n    sin_theta[i]=sin((double) (theta*i-offset)); \n  } \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(image,&bias); \n  image_view=AcquireVirtualCacheView(image,exception); \n  blur_view=AcquireAuthenticCacheView(blur_image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,blur_image,blur_image->rows,1) \n  for (y=0; y < (ssize_t) blur_image->rows; y++) \n  { \n    register const IndexPacket \n      *restrict indexes; \n \n    register IndexPacket \n      *restrict blur_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    q=GetCacheViewAuthenticPixels(blur_view,0,y,blur_image->columns,1, \n      exception); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    blur_indexes=GetCacheViewAuthenticIndexQueue(blur_view); \n    for (x=0; x < (ssize_t) blur_image->columns; x++) \n    { \n      MagickPixelPacket \n        qixel; \n \n      MagickRealType \n        normalize, \n        radius; \n \n      PixelPacket \n        pixel; \n \n      PointInfo \n        center; \n \n      register ssize_t \n        i; \n \n      size_t \n        step; \n \n      center.x=(double) x-blur_center.x; \n      center.y=(double) y-blur_center.y; \n      radius=hypot((double) center.x,center.y); \n      if (radius == 0) \n        step=1; \n      else \n        { \n          step=(size_t) (blur_radius/radius); \n          if (step == 0) \n            step=1; \n          else \n            if (step >= n) \n              step=n-1; \n        } \n      normalize=0.0; \n      qixel=bias; \n      if (((channel & OpacityChannel) == 0) || (image->matte == MagickFalse)) \n        { \n          for (i=0; i < (ssize_t) n; i+=(ssize_t) step) \n          { \n            (void) GetOneCacheViewVirtualPixel(image_view,(ssize_t) \n              (blur_center.x+center.x*cos_theta[i]-center.y*sin_theta[i]+0.5), \n              (ssize_t) (blur_center.y+center.x*sin_theta[i]+center.y* \n              cos_theta[i]+0.5),&pixel,exception); \n            qixel.red+=pixel.red; \n            qixel.green+=pixel.green; \n            qixel", "pred": " \nMagickExport Image *RadialBlurImageChannel(const Image *image, \n  const ChannelType channel,const double angle,ExceptionInfo *exception) \n{ \n  CacheView \n    *blur_view, \n    *image_view; \n \n  Image \n    *blur_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  MagickRealType \n    blur_radius, \n    *cos_theta, \n    offset, \n    *sin_theta, \n    theta; \n \n  PointInfo \n    blur_center; \n \n  register ssize_t \n    i; \n \n  size_t \n    n; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  blur_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (blur_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(blur_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&blur_image->exception); \n      blur_image=DestroyImage(blur_image); \n      return((Image *) NULL); \n    } \n  blur_center.x=(double) (image->columns-1)/2.0; \n  blur_center.y=(double) (image->rows-1)/2.0; \n  blur_radius=hypot(blur_center.x,blur_center.y); \n  n=(size_t) fabs(4.0*DegreesToRadians(angle)*sqrt((double) blur_radius));                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nMagickExport Image *SelectiveBlurImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  const double threshold,ExceptionInfo *exception) \n{ \n#define SelectiveBlurImageTag  \"SelectiveBlur/Image\" \n \n  CacheView \n    *blur_view, \n    *image_view, \n    *luminance_view; \n \n  double \n    *kernel; \n \n  Image \n    *blur_image, \n    *luminance_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    center, \n    j, \n    u, \n    v, \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  width=GetOptimalKernelWidth1D(radius,sigma); \n  kernel=(double *) MagickAssumeAligned(AcquireAlignedMemory((size_t) width, \n    width*sizeof(*kernel))); \n  if (kernel == (double *) NULL) \n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n  j=(ssize_t) (width-1)/2; \n  i=0; \n  for (v=(-j); v <= j; v++) \n  { \n    for (u=(-j); u <= j; u++) \n      kernel[i++]=(double) (exp(-((double) u*u+v*v)/(2.0*MagickSigma* \n        MagickSigma))/(2.0*MagickPI*MagickSigma*MagickSigma)); \n  } \n  if (image->debug!= MagickFalse) \n    { \n      char \n        format[MaxTextExtent], \n        *message; \n \n      register const double \n        *k; \n \n      ssize_t \n        u, \n        v; \n \n      (void) LogMagickEvent(TransformEvent,GetMagickModule(), \n        \"  SelectiveBlurImage with %.20gx%.20g kernel:\",(double) width,(double) \n        width); \n      message=AcquireString(\"\"); \n      k=kernel; \n      for (v=0; v < (ssize_t) width; v++) \n      { \n        *message='\\0'; \n        (void) FormatLocaleString(format,MaxTextExtent,\"%.20g: \",(double) v); \n        (void) ConcatenateString(&message,format); \n        for (u=0; u < (ssize_t) width; u++) \n        { \n          (void) FormatLocaleString(format,MaxTextExtent,\"%+f \",*k++); \n          (void) ConcatenateString(&message,format); \n        } \n        (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"%s\",message); \n      } \n      message=DestroyString(message); \n    } \n  blur_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (blur_image == (Image *) NULL) \n    { \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      return((Image *) NULL); \n    } \n  if (SetImageStorageClass(blur_image,DirectClass) == MagickFalse) \n    { \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      InheritException(exception,&blur_image->exception); \n      blur_image=DestroyImage(blur_image); \n      return((Image *) NULL); \n    } \n  luminance_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (luminance_image == (Image *) NULL) \n    { \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      blur_image=DestroyImage(blur_image); \n      return((Image *) NULL); \n    } \n  status=TransformImageColorspace(luminance_image,GRAYColorspace); \n  if (status == MagickFalse) \n    { \n      InheritException(exception,&luminance_image->exception); \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      blur_image=DestroyImage(blur_image); \n      luminance_image=DestroyImage(luminance_image); \n      return((Image *) NULL); \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  center=(ssize_t) ((image->columns+width)*((width-1)/2L)+((width-1)/2L)); \n  GetMagickPixelPacket(image,&bias); \n  SetMagickPixelPacketBias(image,&bias); \n  image_view=AcquireVirtualCacheView(image,exception); \n  luminance_view=AcquireVirtualCacheView(luminance_image,exception); \n  blur_view=AcquireAuthenticCacheView(blur_image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,blur_image,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    double \n      gamma; \n \n    MagickBooleanType \n      sync; \n \n    register const IndexPacket \n      *restrict indexes; \n \n    register const PixelPacket \n      *restrict l, \n      *restrict p; \n \n    register IndexPacket \n      *restrict blur_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) (width-1)/2L),y-(ssize_t) \n      ((width-1)/2L),image->columns+width,width,exception); \n    l=GetCacheViewVirtualPixels(luminance_view,-((ssize_t) (width-", "pred": " \nMagickExport Image *SelectiveBlurImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  const double threshold,ExceptionInfo *exception) \n{ \n#define SelectiveBlurImageTag  \"SelectiveBlur/Image\" \n \n  CacheView \n    *blur_view, \n    *image_view, \n    *luminance_view; \n \n  double \n    *kernel; \n \n  Image \n    *blur_image, \n    *luminance_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    center, \n    j, \n    u, \n    v, \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  width=GetOptimalKernelWidth1D(radius,sigma); \n  kernel=(double *) MagickAssumeAligned(AcquireAlignedMemory((size_t) width, \n    width*sizeof(*kernel))); \n  if (kernel == (double *) NULL) \n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n  j=(ssize_t) (width-1)/2; \n  i=0; \n  for (v=(-j); v <= j; v++) \n  { \n    for (u=(-j); u <= j; u++) \n      kernel[i++]=(double) (exp(-((double) u*u+v*v)/(2.0*MagickSigma* \n        MagickSigma))/(2.0*MagickPI/2.0*MagickSigma);\\t}\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "}
{"label": " \nMagickExport Image *SpreadImage(const Image *image,const double radius, \n  ExceptionInfo *exception) \n{ \n#define SpreadImageTag  \"Spread/Image\" \n \n  CacheView \n    *image_view, \n    *spread_view; \n \n  Image \n    *spread_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  RandomInfo \n    **restrict random_info; \n \n  size_t \n    width; \n \n  ssize_t \n    y; \n \n  unsigned long \n    key; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  spread_image=CloneImage(image,image->columns,image->rows,MagickTrue, \n    exception); \n  if (spread_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(spread_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&spread_image->exception); \n      spread_image=DestroyImage(spread_image); \n      return((Image *) NULL); \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(spread_image,&bias); \n  width=GetOptimalKernelWidth1D(radius,0.5); \n  random_info=AcquireRandomInfoThreadSet(); \n  image_view=AcquireVirtualCacheView(image,exception); \n  spread_view=AcquireAuthenticCacheView(spread_image,exception); \n  key=GetRandomSecretKey(random_info[0]); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,spread_image,spread_image->rows,key == ~0UL) \n  for (y=0; y < (ssize_t) spread_image->rows; y++) \n  { \n    const int \n      id = GetOpenMPThreadId(); \n \n    MagickPixelPacket \n      pixel; \n \n    register IndexPacket \n      *restrict indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    q=QueueCacheViewAuthenticPixels(spread_view,0,y,spread_image->columns,1, \n      exception); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewAuthenticIndexQueue(spread_view); \n    pixel=bias; \n    for (x=0; x < (ssize_t) spread_image->columns; x++) \n    { \n      (void) InterpolateMagickPixelPacket(image,image_view, \n        UndefinedInterpolatePixel,(double) x+width*(GetPseudoRandomValue( \n        random_info[id])-0.5),(double) y+width*(GetPseudoRandomValue( \n        random_info[id])-0.5),&pixel,exception); \n      SetPixelPacket(spread_image,&pixel,q,indexes+x); \n      q++; \n    } \n    if (SyncCacheViewAuthenticPixels(spread_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        #pragma omp critical (MagickCore_SpreadImage) \n        proceed=SetImageProgress(image,SpreadImageTag,progress++,image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  } \n  spread_view=DestroyCacheView(spread_view); \n  image_view=DestroyCacheView(image_view); \n  random_info=DestroyRandomInfoThreadSet(random_info); \n  if (status == MagickFalse) \n    spread_image=DestroyImage(spread_image); \n  return(spread_image); \n} ", "pred": " \nMagickExport Image *SpreadImage(const Image *image,const double radius, \n  ExceptionInfo *exception) \n{ \n#define SpreadImageTag  \"Spread/Image\" \n \n  CacheView \n    *image_view, \n    *spread_view; \n \n  Image \n    *spread_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  RandomInfo \n    **restrict random_info; \n \n  size_t \n    width; \n \n  ssize_t \n    y; \n \n  unsigned long \n    key; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  spread_image=CloneImage(image,image->columns,image->rows,MagickTrue, \n    exception); \n  if (spread_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(spread_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&spread_image->exception); \n      spread_image=DestroyImage(spread_image); \n      return((Image *) NULL); \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(spread_image,&bias); \n  width=GetOptimalKernelWidth1D(radius,0.5); \n  random_info=AcquireRandomInfoThreadSet(); \n  image_view=AcquireVirtualCacheView(image,exception); \n  spread_view=AcquireAuthenticCacheView(spread_image,exception); \n  key=GetRandomSecretKey(random_info[0]); \n  #pragma omp parallel for schedule(static,4) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return; \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n  const int gamutcheck = (d->mode == DT_PROFILE_GAMUTCHECK); \n  const size_t npixels = (size_t)roi_out->width * roi_out->height; \n  float *const restrict out = (float *)ovoid; \n \n  if(d->type == DT_COLORSPACE_LAB) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, piece->colors); \n  } \n  else if(!isnan(d->cmatrix[0][0])) \n  { \n    const float *const restrict in = (const float *const)ivoid; \n    dt_colormatrix_t cmatrix; \n    transpose_3xSSE(d->cmatrix, cmatrix); \n \n \n \n \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(in, out, npixels)      shared(cmatrix)      schedule(static) \n    for(size_t k = 0; k < (size_t)4 * npixels; k += 4) \n    { \n      dt_aligned_pixel_t xyz; \n      dt_Lab_to_XYZ(in + k, xyz); \n      dt_aligned_pixel_t rgb;  \n \n      dt_apply_transposed_color_matrix(xyz, cmatrix, rgb); \n      copy_pixel(out + k, rgb); \n    } \n \n    process_fastpath_apply_tonecurves(self, piece, in, out, roi_in, roi_out); \n  } \n  else \n  { \n \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(d, gamutcheck, ivoid, out, roi_out)      schedule(static) \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)4 * k * roi_out->width; \n      float *const restrict outp = out + (size_t)4 * k * roi_out->width; \n \n      cmsDoTransform(d->xform, in, outp, roi_out->width); \n \n      if(gamutcheck) \n      { \n        for(int j = 0; j < roi_out->width; j++) \n        { \n          if(outp[4*j+0] < 0.0f || outp[4*j+1] < 0.0f || out[4*j+2] < 0.0f) \n          { \n            outp[4*j+0] = 0.0f; \n            outp[4*j+1] = 1.0f; \n            outp[4*j+2] = 1.0f; \n          } \n        } \n      } \n    } \n  } \n \n  if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) \n    dt_iop_alpha_copy(ivoid, ovoid, roi_out->width, roi_out->height); \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return; \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n  const int gamutcheck = (d->mode == DT_PROFILE_GAMUTCHECK); \n  const size_t npixels = (size_t)roi_out->width * roi_out->height; \n  float *const restrict out = (float *)ovoid; \n \n  if(d->type == DT_COLORSPACE_LAB) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, piece->colors); \n  } \n  else if(!isnan(d->cmatrix[0][0])) \n  { \n    const float *const restrict in = (const float *const)ivoid; \n    dt_colormatrix_t cmatrix; \n    transpose_3xSSE(d->cmatrix, cmatrix); \n \n \n \n \n \n#pragma omp parallel for default(none)      dt_omp_firstprivate(in, out, npixels)      shared(cmatrix)      schedule(static) \n    for(size_t k = 0; k < (size_t)4 * npixels; k += 4) \n    { \n      dt_aligned_pixel_t xyz; \n      dt_Lab_to_XYZ(in + k, xyz); \n      dt_palette_t *palette;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": "matrix_t *data) \n{ \n\tnv_matrix_t *dists = nv_matrix_alloc(data->m, k);\t \n\tint i, j; \n\tint threads = nv_omp_procs(); \n \n\tif (data->m == 0) { \n\t\tnv_matrix_free(&dists); \n\t\treturn; \n\t} \n\tnv_vector_copy(means, 0, data, nv_rand_index(data->m)); \n\tj = 0; \n#pragma omp parallel for num_threads(threads) \n\tfor (i = 0; i < data->m; ++i) { \n\t\tNV_MAT_V(dists, j, i) = nv_euclidean2(means, j, data, i); \n\t} \n\t \n\tfor (j = 0; j < k - 1; ++j) { \n\t\tfloat max_v = -FLT_MAX; \n\t\tint max_i = -1; \n \n#pragma omp parallel for num_threads(threads) \n\t\tfor (i = 0; i < data->m; ++i) { \n\t\t\tNV_MAT_V(dists, j, i) = nv_euclidean2(means, j, data, i); \n\t\t} \n\t\tfor (i = 0; i < data->m; ++i) { \n\t\t\tfloat min_dist = FLT_MAX; \n\t\t\tint l; \n\t\t\tfor (l = 0; l <= j; ++l) { \n\t\t\t\tif (min_dist > NV_MAT_V(dists, l, i)) { \n\t\t\t\t\tmin_dist = NV_MAT_V(dists, l, i); \n\t\t\t\t} \n\t\t\t} \n\t\t\tif (min_dist > max_v) { \n\t\t\t\tmax_v = min_dist; \n\t\t\t\tmax_i = i; \n\t\t\t} \n\t\t} \n\t\tnv_vector_copy(means, j + 1, data, max_i); \n\t} \n\tnv_matrix_free(&dists); \n} \n \nvoid \nnv_kmeans_init_rand(nv_matrix_t *means) \n{ \n\tint j; \n\tfor (j = 0 ", "pred": "matrix_t *data) \n{ \n\tnv_matrix_t *dists = nv_matrix_alloc(data->m, k);\t \n\tint i, j; \n\tint threads = nv_omp_procs(); \n \n\tif (data->m == 0) { \n\t\tnv_matrix_free(&dists); \n\t\treturn; \n\t} \n\tnv_vector_copy(means, 0, data, nv_rand_index(data->m)); \n\tj = 0; \n#pragma omp parallel for num_threads(threads) \n\tfor (i = 0; i < data->m; ++i) { \n\t\tNV_MAT_V(dists, j, i) = nv_euclidean2(means, j, data, i); \n\t} \n\t \n\tfor (j = 0; j < k - 1; ++j) { \n\t\tfloat max_v = -FLT_MAX; \n\t\tint max_i = -1; \n \n#pragma omp parallel for num_threads(threads) \n\t\tfor (i = 0; i < data->m; ++i) { \n\t\t\tNV_MAT_V(dists, j, i) = nv_euclidean2(means, j, data, i); \n\t\t} \n\t\tfor (i = 0; i < data->m; ++i) { \n\t\t\tfloat min_dist = FLT_MAX; \n\t\t\tint l; \n\t\t\tfor (l = 0; l <= j; ++l) { \n\t\t\t\tif (min_dist > NV_MAT_V(dists, l, i)) { \n\t\t\t\t\tmin_dist = NV_MAT_V(dists, l, i); \n\t\t\t\t} \n\t\t\t} \n\t\t\tif (min_dist > max_v) { \n\t\t\t\tmax_v = min_dist; \n\t\t\t\tmax_i = i; \n\t\t\t} \n\t\t} \n\t\tnv_vector_copy(means, j + 1, data, max_i); \n\t} \n\tnv_matrix_free(&dists); \n} \n \nvoid \nnv_kmeans_init_rand(nv_matrix_t *means) \n{ \n\tint j; \n\t_t *c_u"}
{"label": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_sharpen_data_t *const data = (dt_iop_sharpen_data_t *)piece->data; \n  const int ch = piece->colors; \n  const int rad = MIN(MAXR, ceilf(data->radius * roi_in->scale / piece->iscale)); \n   \n \n   \n \n  if(rad == 0 || \n     (roi_out->width < 2 * rad + 1 || roi_out->height < 2 * rad + 1)) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, ch); \n    return; \n  } \n \n  float *restrict tmp; \n  if (!dt_iop_alloc_image_buffers(self, roi_in, roi_out, 1, &tmp, 0)) \n  { \n    dt_iop_copy_image_roi(ovoid, ivoid, ch, roi_in, roi_out, TRUE); \n    return; \n  } \n \n  const int wd = 2 * rad + 1; \n  const int wd4 = (wd & 3)? (wd >> 2) + 1 : wd >> 2; \n \n  const size_t mat_size = (size_t)4 * wd4; \n  float *const mat = dt_alloc_align_float(mat_size); \n  memset(mat, 0, sizeof(float) * mat_size); \n \n  const float sigma2 = (1.0f / (2.5 * 2.5)) * (data->radius * roi_in->scale / piece->iscale) \n                       * (data->radius * roi_in->scale / piece->iscale); \n  float weight = 0.0f; \n \n   \n \n  for(int l = -rad; l <= rad; l++) weight += mat[l + rad] = expf(-l * l / (2.f * sigma2)); \n  for(int l = -rad; l <= rad; l++) mat[l + rad] /= weight; \n \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(ch, ivoid, mat, rad, roi_in, roi_out, tmp, wd4)    schedule(static) \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    const float *in = ((float *)ivoid) + (size_t)ch * (j * roi_in->width + rad); \n    float *out = tmp + (size_t)j * roi_out->width + rad; \n    int i; \n    for(i = rad; i < roi_out->width - wd4 * 4 + rad; i++) \n    { \n      const float *inp = in - ch * rad; \n      __attribute__((aligned(64))) float sum[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; \n      __m128 msum = _mm_setzero_ps(); \n \n      for(int k = 0; k < wd4 * 4; k += 4, inp += 4 * ch) \n      { \n        msum = _mm_add_ps( \n            msum, _mm_mul_ps(_mm_load_ps(mat + k), _mm_set_ps(inp[3 * ch], inp[2 * ch], inp[ch], inp[0]))); \n      } \n      _mm_store_ps(sum, msum); \n      *out = sum[0] + sum[1] + sum[2] + sum[3]; \n      out++; \n      in += ch; \n    } \n    for(; i < roi_out->width - rad; i++) \n    { \n      const float *inp = in - ch * rad; \n      const float *m = mat; \n      float sum = 0.0f; \n      for(int k = -rad; k <= rad; k++, m++, inp += ch) \n      { \n        sum += *m * *inp; \n      } \n      *out = sum; \n      out++; \n      in += ch; \n    } \n  } \n  _mm_sfence(); \n \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(ch, mat, ovoid, rad, roi_in, roi_out, tmp, wd4)    schedule(static) \n  for(int j = rad; j < roi_out->height - wd4 * 4 + rad; j++) \n  { \n    const float *in = tmp + (size_t)j * roi_in->width; \n    float *out = ((float *)ovoid) + (size_t)ch * j * roi_out->width; \n \n    const int step = roi_in->width; \n \n    __attribute__((aligned(64))) float sum[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      const float *inp = in - step * rad; \n      __m128 msum = _mm_setzero_ps(); \n \n      for(int k = 0; k < wd4 * 4; k += 4, inp += step * 4) \n      { \n        msum = _mm_add_ps(msum, _mm_mul_ps(_mm_load_ps(mat + k), \n                                           _mm_set_ps(inp[3 * step], inp[2 * step], inp[step], inp[0]))); \n      } \n      _mm_store_ps(sum, msum); \n      *out = sum[0] + sum[1] + sum[2] + sum[3]; \n      out += ch; \n      in++; \n    } \n  } \n#pragma omp parallel for default(none)    dt_omp_firstprivate(ch, ivoid, mat, ovoid, rad, roi_in, roi_out, tmp, wd4)    schedule(static) \n  for(int j = roi_out->height - wd4 * 4 + rad; j < roi_out->height - rad; j++) \n  { \n    const float *in = tmp + (size_t)j * roi_in->width; \n    float *out = ((float *)ovoid) + (size_t)ch * j * roi_out->width; \n    const int", "pred": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_sharpen_data_t *const data = (dt_iop_sharpen_data_t *)piece->data; \n  const int ch = piece->colors; \n  const int rad = MIN(MAXR, ceilf(data->radius * roi_in->scale / piece->iscale)); \n   \n \n   \n \n  if(rad == 0 || \n     (roi_out->width < 2 * rad + 1 || roi_out->height < 2 * rad + 1)) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, ch); \n    return; \n  } \n \n  float *restrict tmp; \n  if (!dt_iop_alloc_image_buffers(self, roi_in, roi_out, 1, &tmp, 0)) \n  { \n    dt_iop_copy_image_roi(ovoid, ivoid, ch, roi_in, roi_out, TRUE); \n    return; \n  } \n \n  const int wd = 2 * rad + 1; \n  const int wd4 = (wd & 3)? (wd >> 2) + 1 : wd >> 2; \n \n  const size_t mat_size = (size_t)4 * wd4; \n  float *const mat = dt_alloc_align_float(mat_size); \n  memset(mat, 0, sizeof(float) * mat_size); \n \n  const float sigma2 = (1.0f / (2.5 * 2.5)) * (data->radius * roi_in->scale / piece->iscale) \n                       * (data->radius * roi_in->scale / piece->iscale); \n  float weight = 0.0f; \n  const float weight_in = 1.0f;  const float weight_in = 1.0f;  const float weight_in_in = 1.0f;  const float weight_in_in = 1.0f;  const float weight_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_in_in = 1.0f;  const float weight_in_"}
{"label": " \nint <ompts:testcode:functionname>omp_parallel_reduction</ompts:testcode:functionname>(FILE * logFile){ \n\t<ompts:orphan:vars> \n    int sum; \n\tint known_sum; \n\tdouble dsum; \n\tdouble dknown_sum; \n\tdouble dt=0.5;\t\t\t\t \n \n\tdouble rounding_error= 1.E-9; \n#define DOUBLE_DIGITS 20\t\t \n \n\tint diff; \n\tdouble ddiff; \n\tint product; \n\tint known_product; \n#define MAX_FACTOR 10 \n#define KNOWN_PRODUCT 3628800\t \n \n\tint logic_and; \n\tint logic_or; \n\tint bit_and; \n\tint bit_or; \n\tint exclusiv_bit_or; \n\tint logics[LOOPCOUNT]; \n\tint i; \n\tdouble dpt; \n\tint result; \n</ompts:orphan:vars> \n    sum =0; \n    dsum=0; \n    product=1; \n\tlogic_and=1; \n\tlogic_or=0; \n\tbit_and=1; \n\tbit_or=0; \n\texclusiv_bit_or=0; \n    result=0; \n\tdt = 1./3.; \n\tknown_sum = (LOOPCOUNT*(LOOPCOUNT+1))/2; \n<ompts:orphan> \n#pragma omp parallel for schedule(dynamic,1) private(i) <ompts:check>reduction(+:sum)</ompts:check><ompts:crosscheck></ompts:crosscheck> \n\tfor (i=1;i<=LOOPCOUNT;i++) \n\t{ \n\t\tsum=sum+i; \n\t} \n \n\tif(known_sum!=sum) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in sum with integers: Result was %d instead of %d\\n\",sum,known_sum);  \n\t} \n \n\tdiff = (LOOPCOUNT*(LOOPCOUNT+1))/2; \n#pragma omp parallel for schedule(dynamic,1) private(i) <ompts:check>reduction(-:diff)</ompts:check><ompts:crosscheck></ompts:crosscheck> \n\tfor (i=1;i<=LOOPCOUNT;++i) \n\t{ \n\t\tdiff=diff-i; \n\t} \n \n\tif(diff!= 0) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in difference with integers: Result was %d instead of 0.\\n\",diff); \n\t} \n \n\t \n \n\tdsum=0; \n\tdpt=1; \n\tfor (i=0;i<DOUBLE_DIGITS;++i) \n\t{ \n\t\tdpt*=dt; \n\t} \n\tdknown_sum = (1-dpt)/(1-dt); \n#pragma omp parallel for schedule(dynamic,1) private(i) <ompts:check>reduction(+:dsum)</ompts:check><ompts:crosscheck></ompts:crosscheck> \n\tfor (i=0;i<DOUBLE_DIGITS;++i) \n\t{ \n\t\tdsum += pow(dt,i); \n\t} \n \n\tif( fabs(dsum-dknown_sum) > rounding_error ) \n\t{ \n\t\tresult++;  \n\t\tfprintf(logFile,\"Error in sum with doubles: Result was %f instead of %f (Difference: %E)\\n\",dsum,dknown_sum, dsum-dknown_sum); \n\t} \n \n\tdpt=1; \n \n\tfor (i=0;i<DOUBLE_DIGITS;++i) \n\t{ \n\t\tdpt*=dt; \n\t} \n\tfprintf(logFile,\"\\n\"); \n\tddiff = (1-dpt)/(1-dt); \n#pragma omp parallel for schedule(dynamic,1) private(i) <ompts:check>reduction(-:ddiff)</ompts:check><ompts:crosscheck></ompts:crosscheck> \n\tfor (i=0;i<DOUBLE_DIGITS;++i) \n\t{ \n\t\tddiff -= pow(dt,i); \n\t} \n\tif( fabs(ddiff) > rounding_error) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in Difference with doubles: Result was %E instead of 0.0\\n\",ddiff); \n\t} \n \n#pragma omp parallel for schedule(dynamic,1) private(i) <ompts:check>reduction(*:product)</ompts:check><ompts:crosscheck></ompts:crosscheck> \n\tfor(i=1;i<=MAX_FACTOR;i++) \n\t{ \n\t\tproduct *= i; \n\t} \n \n\tknown_product = KNOWN_PRODUCT; \n\tif(known_product!= product) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in Product with integers: Result was %d instead of %d\\n\\n\",product,known_product); \n\t} \n \n\tfor(i=0;i<LOOPCOUNT;i++) \n\t{ \n\t\tlogics[i]=1; \n\t} \n \n#pragma omp parallel for schedule(dynamic,1) private(i) <ompts:check>reduction(&&:logic_and)</ompts:check><ompts:crosscheck></ompts:crosscheck> \n\tfor(i=0;i<LOOPCOUNT;++i) \n\t{ \n\t\tlogic_and = (logic_and && logics[i]); \n\t} \n\tif(!logic_and) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in logic AND part 1.\\n\"); \n\t} \n \n\tlogic_and = 1; \n\tlogics[LOOPCOUNT/2]=0; \n \n#pragma omp parallel for schedule(dynamic,1) private(i) <ompts:check>reduction(&&:logic_and)</ompts:check><ompts:crosscheck></ompts:crosscheck> \n\tfor(i=0;i<LOOPCOUNT;++i) \n\t{ \n\t\tlogic_and = logic_and && logics[i]; \n\t} \n\tif(logic_and) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in logic AND part 2.\\n\"); \n\t} \n \n\tfor(i=0;i<LOOPCOUNT;i++) \n\t{ \n\t\tlogics[i]=0; \n\t} \n \n#pragma omp parallel for schedule(dynamic,1) private(i) <ompts:check>reduction(||:logic_or)</ompts:check><ompts:crosscheck></ompts:crosscheck> \n\tfor(i=0;i<LOOPCOUNT;++i) \n\t{ \n\t\tlogic_or = logic_or || logics[i]; \n\t} \n\tif(logic_or) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in logic OR part 1.\\n\"); \n\t} \n\tlogic_or = 0; \n\tlogics[LOOPCOUNT/2]=1; \n \n#pragma omp parallel for schedule(dynamic,1) private(i) <ompts:check>reduction(||:logic_or)</ompts:check><ompts:crosscheck></ompts:crosscheck> \n\tfor(i=0", "pred": " \nint <ompts:testcode:functionname>omp_parallel_reduction</ompts:testcode:functionname>(FILE * logFile){ \n\t<ompts:orphan:vars> \n    int sum; \n\tint known_sum; \n\tdouble dsum; \n\tdouble dknown_sum; \n\tdouble dt=0.5;\t\t\t\t \n \n\tdouble rounding_error= 1.E-9; \n#define DOUBLE_DIGITS 20\t\t \n \n\tint diff; \n\tdouble ddiff; \n\tint product; \n\tint known_product; \n#define MAX_FACTOR 10 \n#define KNOWN_PRODUCT 3628800\t \n \n\tint logic_and; \n\tint logic_or; \n\tint bit_and; \n\tint bit_or; \n\tint exclusiv_bit_or; \n\tint logics[LOOPCOUNT]; \n\tint i; \n\tdouble dpt; \n\tint result; \n</ompts:orphan:vars> \n    sum =0; \n    dsum=0; \n    product=1; \n\tlogic_and=1; \n\tlogic_or=0; \n\tbit_and=1; \n\tbit_or=0; \n\texclusiv_bit_or=0; \n    result=0; \n\tdt = 1./3.; \n\tknown_sum = (LOOPCOUNT*(LOOPCOUNT+1))/2; \n<ompts:orphan> \n#pragma omp parallel for schedule(dynamic,1) private(i) <ompts:check>reduction(+:sum)</ompts:check><ompts:crosscheck></ompts:crosscheck> \n\tfor (i=1;i<=LOOPCOUNT;i++) \n\t{ \n\t\tsum=sum+i; \n\t} \n \n\tif(known_sum!=sum) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in sum with integers: Result was %d instead of %d\\n\",sum,known_sum);  \n\t} \n \n\tdiff = (LOOPCOUNT*(LOOPCOUNT+1))/2; \n#pragma omp parallel for schedule(dynamic,1) private(i) <\\n    sum,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " \nMagickExport MagickBooleanType DrawAffineImage(Image *image, \n  const Image *source,const AffineMatrix *affine,ExceptionInfo *exception) \n{ \n  AffineMatrix \n    inverse_affine; \n \n  CacheView \n    *image_view, \n    *source_view; \n \n  MagickBooleanType \n    status; \n \n  PixelInfo \n    zero; \n \n  PointInfo \n    extent[4], \n    min, \n    max, \n    point; \n \n  register ssize_t \n    i; \n \n  SegmentInfo \n    edge; \n \n  ssize_t \n    start, \n    stop, \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(source!= (const Image *) NULL); \n  assert(source->signature == MagickSignature); \n  assert(affine!= (AffineMatrix *) NULL); \n  extent[0].x=0.0; \n  extent[0].y=0.0; \n  extent[1].x=(double) source->columns-1.0; \n  extent[1].y=0.0; \n  extent[2].x=(double) source->columns-1.0; \n  extent[2].y=(double) source->rows-1.0; \n  extent[3].x=0.0; \n  extent[3].y=(double) source->rows-1.0; \n  for (i=0; i < 4; i++) \n  { \n    point=extent[i]; \n    extent[i].x=point.x*affine->sx+point.y*affine->ry+affine->tx; \n    extent[i].y=point.x*affine->rx+point.y*affine->sy+affine->ty; \n  } \n  min=extent[0]; \n  max=extent[0]; \n  for (i=1; i < 4; i++) \n  { \n    if (min.x > extent[i].x) \n      min.x=extent[i].x; \n    if (min.y > extent[i].y) \n      min.y=extent[i].y; \n    if (max.x < extent[i].x) \n      max.x=extent[i].x; \n    if (max.y < extent[i].y) \n      max.y=extent[i].y; \n  } \n   \n \n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse) \n    return(MagickFalse); \n  status=MagickTrue; \n  edge.x1=MagickMax(min.x,0.0); \n  edge.y1=MagickMax(min.y,0.0); \n  edge.x2=MagickMin(max.x,(double) image->columns-1.0); \n  edge.y2=MagickMin(max.y,(double) image->rows-1.0); \n  inverse_affine=InverseAffineMatrix(affine); \n  GetPixelInfo(image,&zero); \n  start=(ssize_t) ceil(edge.y1-0.5); \n  stop=(ssize_t) floor(edge.y2+0.5); \n  source_view=AcquireVirtualCacheView(source,exception); \n  image_view=AcquireAuthenticCacheView(image,exception); \n  #pragma omp parallel for schedule(static,4) shared(status)      magick_threads(source,image,1,1) \n  for (y=start; y <= stop; y++) \n  { \n    PixelInfo \n      composite, \n      pixel; \n \n    PointInfo \n      point; \n \n    register ssize_t \n      x; \n \n    register Quantum \n      *restrict q; \n \n    SegmentInfo \n      inverse_edge; \n \n    ssize_t \n      x_offset; \n \n    inverse_edge=AffineEdge(source,&inverse_affine,(double) y,&edge); \n    if (inverse_edge.x2 < inverse_edge.x1) \n      continue; \n    q=GetCacheViewAuthenticPixels(image_view,(ssize_t) ceil(inverse_edge.x1- \n      0.5),y,(size_t) (floor(inverse_edge.x2+0.5)-ceil(inverse_edge.x1-0.5)+1), \n      1,exception); \n    if (q == (Quantum *) NULL) \n      continue; \n    pixel=zero; \n    composite=zero; \n    x_offset=0; \n    for (x=(ssize_t) ceil(inverse_edge.x1-0.5); x <= (ssize_t) floor(inverse_edge.x2+0.5); x++) \n    { \n      point.x=(double) x*inverse_affine.sx+y*inverse_affine.ry+ \n        inverse_affine.tx; \n      point.y=(double) x*inverse_affine.rx+y*inverse_affine.sy+ \n        inverse_affine.ty; \n      (void) InterpolatePixelInfo(source,source_view,UndefinedInterpolatePixel, \n        point.x,point.y,&pixel,exception); \n      GetPixelInfoPixel(image,q,&composite); \n      CompositePixelInfoOver(&pixel,pixel.alpha,&composite,composite.alpha, \n        &composite); \n      SetPixelInfoPixel(image,&composite,q); \n      x_offset++; \n      q+=GetPixelChannels(image); \n    } \n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse) \n      status=MagickFalse; \n  } \n  source_view=DestroyCacheView(source_view); \n  image_view=DestroyCacheView(image_view); \n  return(status); \n} ", "pred": " \nMagickExport MagickBooleanType DrawAffineImage(Image *image, \n  const Image *source,const AffineMatrix *affine,ExceptionInfo *exception) \n{ \n  AffineMatrix \n    inverse_affine; \n \n  CacheView \n    *image_view, \n    *source_view; \n \n  MagickBooleanType \n    status; \n \n  PixelInfo \n    zero; \n \n  PointInfo \n    extent[4], \n    min, \n    max, \n    point; \n \n  register ssize_t \n    i; \n \n  SegmentInfo \n    edge; \n \n  ssize_t \n    start, \n    stop, \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(source!= (const Image *) NULL); \n  assert(source->signature == MagickSignature); \n  assert(affine!= (AffineMatrix *) NULL); \n  extent[0].x=0.0; \n  extent[0].y=0.0; \n  extent[1].x=(double) source->columns-1.0; \n  extent[1].y=0.0; \n  extent[2].x=(double) source->columns-1.0; \n  extent[2].y=(double) source->rows-1.0; \n  extent[3].x=0.0; \n  extent[3].y=(double) source->rows-1.0; \n  for (i=0; i < 4; i++) \n  { \n    point=extent[i]; \n    extent[i].x=point.x*affine->sx+point.y*affine->ry+affine->tx; \n    extent[i].y=point.x*affine->rx+point.y*affine->sy+affine->ty; \n  } \n  min=extent[0]; \n  max=extent[0]; \n  for (i=1; i < (int)min; i++) {\\n      if (min+i < 0) min=min+i;\\n      if (min+i < 0) max=min+i;\\n    }\\n    if (min+i < 0) max=min+i;\\n  }\\n}\\n\\nvoid\\nImage_Convert(Image *image, const PixelInfo *source, const PixelInfo *target, const PixelInfo *source_mask)\\n{\\n  const PixelInfo *target_mask = source->target_mask;\\n  const PixelInfo *target_mask = source->target_mask;\\n  const PixelInfo *target_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask = source->target_mask_mask;\\n  const PixelInfo *target_mask_mask_mask"}
{"label": " \nMagickExport Image *MotionBlurImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  const double angle,ExceptionInfo *exception) \n{ \n#define BlurImageTag  \"Blur/Image\" \n \n  CacheView \n    *blur_view, \n    *image_view; \n \n  double \n    *kernel; \n \n  Image \n    *blur_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  OffsetInfo \n    *offset; \n \n  PointInfo \n    point; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  width=GetOptimalKernelWidth1D(radius,sigma); \n  kernel=GetMotionBlurKernel(width,sigma); \n  if (kernel == (double *) NULL) \n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n  offset=(OffsetInfo *) AcquireQuantumMemory(width,sizeof(*offset)); \n  if (offset == (OffsetInfo *) NULL) \n    { \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  blur_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (blur_image == (Image *) NULL) \n    { \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      offset=(OffsetInfo *) RelinquishMagickMemory(offset); \n      return((Image *) NULL); \n    } \n  if (SetImageStorageClass(blur_image,DirectClass) == MagickFalse) \n    { \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      offset=(OffsetInfo *) RelinquishMagickMemory(offset); \n      InheritException(exception,&blur_image->exception); \n      blur_image=DestroyImage(blur_image); \n      return((Image *) NULL); \n    } \n  point.x=(double) width*sin(DegreesToRadians(angle)); \n  point.y=(double) width*cos(DegreesToRadians(angle)); \n  for (i=0; i < (ssize_t) width; i++) \n  { \n    offset[i].x=(ssize_t) ceil((double) (i*point.y)/hypot(point.x,point.y)-0.5); \n    offset[i].y=(ssize_t) ceil((double) (i*point.x)/hypot(point.x,point.y)-0.5); \n  } \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(image,&bias); \n  image_view=AcquireVirtualCacheView(image,exception); \n  blur_view=AcquireAuthenticCacheView(blur_image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,blur_image,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    register IndexPacket \n      *restrict blur_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    q=GetCacheViewAuthenticPixels(blur_view,0,y,blur_image->columns,1, \n      exception); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    blur_indexes=GetCacheViewAuthenticIndexQueue(blur_view); \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      MagickPixelPacket \n        qixel; \n \n      PixelPacket \n        pixel; \n \n      register const IndexPacket \n        *restrict indexes; \n \n      register double \n        *restrict k; \n \n      register ssize_t \n        i; \n \n      k=kernel; \n      qixel=bias; \n      if (((channel & OpacityChannel) == 0) || (image->matte == MagickFalse)) \n        { \n          for (i=0; i < (ssize_t) width; i++) \n          { \n            (void) GetOneCacheViewVirtualPixel(image_view,x+offset[i].x,y+ \n              offset[i].y,&pixel,exception); \n            qixel.red+=(*k)*pixel.red; \n            qixel.green+=(*k)*pixel.green; \n            qixel.blue+=(*k)*pixel.blue; \n            qixel.opacity+=(*k)*pixel.opacity; \n            if (image->colorspace == CMYKColorspace) \n              { \n                indexes=GetCacheViewVirtualIndexQueue(image_view); \n                qixel.index+=(*k)*(*indexes); \n              } \n            k++; \n          } \n          if ((channel & RedChannel)!= 0) \n            SetPixelRed(q,ClampToQuantum(qixel.red)); \n          if ((channel & GreenChannel)!= 0) \n            SetPixelGreen(q,ClampToQuantum(qixel.green)); \n          if ((channel & BlueChannel)!= 0) \n            SetPixelBlue(q,ClampToQuantum(qixel.blue)); \n          if ((channel & OpacityChannel)!= 0) \n            SetPixelOpacity(q,ClampToQuantum(qixel.opacity)); \n  ", "pred": " \nMagickExport Image *MotionBlurImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  const double angle,ExceptionInfo *exception) \n{ \n#define BlurImageTag  \"Blur/Image\" \n \n  CacheView \n    *blur_view, \n    *image_view; \n \n  double \n    *kernel; \n \n  Image \n    *blur_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  OffsetInfo \n    *offset; \n \n  PointInfo \n    point; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  width=GetOptimalKernelWidth1D(radius,sigma); \n  kernel=GetMotionBlurKernel(width,sigma); \n  if (kernel == (double *) NULL) \n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n  offset=(OffsetInfo *) AcquireQuantumMemory(width,sizeof(*offset)); \n  if (offset == (OffsetInfo *) NULL) \n    { \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  blur_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (blur_image == (Image *) NULL) \n    { \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      offset=(OffsetInfo *) RelinquishMagickMemory(offset); \n      return((Image *) NULL); \n    } \n{\"username=(Image *) RelinquishMagickMemory(image,0,0,MagickTrue,exception);\\n      if (image->signature == MagickSignature)\\n        ThrowImageException(ResourceLimitError,\\\"MemoryAllocationFailed\\\");\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"}
{"label": " \nstatic int nn_(Sqrt_updateGradInput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor *gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  THTensor *output = luaT_getfieldcheckudata(L, 1, \"output\", torch_Tensor); \n  THTensor *gradInput = luaT_getfieldcheckudata(L, 1, \"gradInput\", torch_Tensor); \n \n  THTensor_(resizeAs)(gradInput, input); \n \n  if (output->nDimension == 1 ||  \n     !THTensor_(isContiguous)(output) ||  \n     !THTensor_(isContiguous)(gradOutput) || \n     !THTensor_(isContiguous)(gradInput)) \n  { \n    TH_TENSOR_APPLY3(real, gradInput, real, gradOutput, real, output,                       *gradInput_data = ((*output_data == 0.0)? 0.0 :                                          (0.5 * (*gradOutput_data / *output_data)));); \n  } \n  else \n  { \n    real* gradOutput_data = THTensor_(data)(gradOutput); \n    real* gradInput_data  = THTensor_(data)(gradInput); \n    real* output_data     = THTensor_(data)(output); \n    long i; \n#pragma omp parallel for private(i) \n    for(i = 0; i < THTensor_(nElement)(output); i++) \n      if (output_data[i] == 0.0) { \n        gradInput_data[i] = 0.0; \n      } else { \n        gradInput_data[i] = 0.5 * (gradOutput_data[i] / output_data[i]); \n      } \n  } \n  return 1; \n} ", "pred": " \nstatic int nn_(Sqrt_updateGradInput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor *gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  THTensor *output = luaT_getfieldcheckudata(L, 1, \"output\", torch_Tensor); \n  THTensor *gradInput = luaT_getfieldcheckudata(L, 1, \"gradInput\", torch_Tensor); \n \n  THTensor_(resizeAs)(gradInput, input); \n \n  if (output->nDimension == 1 ||  \n     !THTensor_(isContiguous)(output) ||  \n     !THTensor_(isContiguous)(gradOutput) || \n     !THTensor_(isContiguous)(gradInput)) \n  { \n    TH_TENSOR_APPLY3(real, gradInput, real, gradOutput, real, output,                       *gradInput_data = ((*output_data == 0.0)? 0.0 :                                          (0.5 * (*gradOutput_data / *output_data)));); \n  } \n  else \n  { \n    real* gradOutput_data = THTensor_(data)(gradOutput); \n    real* gradInput_data  = THTensor_(data)(gradInput); \n    real* output_data     = THTensor_(data)(output); \n    long i; \n#pragma omp parallel for private(i) \n    for(i = 0; i < THTensor_(nElement)(output); i++) \n      if (output_data[i] == 0.0) { \n        gradInput_data[i] = 0.0; \n      } else { \n        gradInput_data[i] = 0.5 * (gradOutput_data[i] / output_data[i]); \n      } \n  } \n  return 1;\\n  "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_sharpen_data_t *const data = (dt_iop_sharpen_data_t *)piece->data; \n  const int ch = piece->colors; \n  const int rad = MIN(MAXR, ceilf(data->radius * roi_in->scale / piece->iscale)); \n   \n \n   \n \n  if(rad == 0 || \n     (roi_out->width < 2 * rad + 1 || roi_out->height < 2 * rad + 1)) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, ch); \n    return; \n  } \n \n  float *restrict tmp; \n  if (!dt_iop_alloc_image_buffers(self, roi_in, roi_out, 1, &tmp, 0)) \n  { \n    dt_iop_copy_image_roi(ovoid, ivoid, ch, roi_in, roi_out, TRUE); \n    return; \n  } \n \n  const int wd = 2 * rad + 1; \n  const int wd4 = (wd & 3)? (wd >> 2) + 1 : wd >> 2; \n \n  const size_t mat_size = (size_t)4 * wd4; \n  float *const mat = dt_alloc_align_float(mat_size); \n  memset(mat, 0, sizeof(float) * mat_size); \n \n  const float sigma2 = (1.0f / (2.5 * 2.5)) * (data->radius * roi_in->scale / piece->iscale) \n                       * (data->radius * roi_in->scale / piece->iscale); \n  float weight = 0.0f; \n \n   \n \n  for(int l = -rad; l <= rad; l++) weight += mat[l + rad] = expf(-l * l / (2.f * sigma2)); \n  for(int l = -rad; l <= rad; l++) mat[l + rad] /= weight; \n \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(ch, ivoid, mat, rad, roi_in, roi_out, tmp, wd4)    schedule(static) \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    const float *in = ((float *)ivoid) + (size_t)ch * (j * roi_in->width + rad); \n    float *out = tmp + (size_t)j * roi_out->width + rad; \n    int i; \n    for(i = rad; i < roi_out->width - wd4 * 4 + rad; i++) \n    { \n      const float *inp = in - ch * rad; \n      __attribute__((aligned(64))) float sum[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; \n \n      for(int k = 0; k < wd4 * 4; k += 4, inp += 4 * ch) \n      { \n        for(int c = 0; c < 4; c++) \n        { \n          sum[c] += ((mat[k + c]) * (inp[ch * c])); \n        } \n      } \n      *out = sum[0] + sum[1] + sum[2] + sum[3]; \n      out++; \n      in += ch; \n    } \n    for(; i < roi_out->width - rad; i++) \n    { \n      const float *inp = in - ch * rad; \n      const float *m = mat; \n      float sum = 0.0f; \n      for(int k = -rad; k <= rad; k++, m++, inp += ch) \n      { \n        sum += *m * *inp; \n      } \n      *out = sum; \n      out++; \n      in += ch; \n    } \n  } \n \n \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(ch, mat, ovoid, rad, roi_in, roi_out, tmp, wd4)    schedule(static) \n  for(int j = rad; j < roi_out->height - wd4 * 4 + rad; j++) \n  { \n    const float *in = tmp + (size_t)j * roi_in->width; \n    float *out = ((float *)ovoid) + (size_t)ch * j * roi_out->width; \n \n    const int step = roi_in->width; \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      const float *inp = in - step * rad; \n      __attribute__((aligned(64))) float sum[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; \n \n      for(int k = 0; k < wd4 * 4; k += 4, inp += step * 4) \n      { \n        for(int c = 0; c < 4; c++) \n        { \n          sum[c] += ((mat[k + c]) * (inp[step * c])); \n        } \n      } \n      *out = sum[0] + sum[1] + sum[2] + sum[3]; \n      out += ch; \n      in++; \n    } \n  } \n#pragma omp parallel for default(none)    dt_omp_firstprivate(ch, mat, ovoid, rad, roi_in, roi_out, tmp, wd4)    schedule(static) \n  for(int j = roi_out->height - wd4 * 4 + rad; j < roi_out->height - rad; j++) \n  { \n    const float *in = tmp + (size_t)j * roi_in->width; \n    float *out = ((float *)ovoid) + (size_t)ch * j * roi_out->width; \n    const int step = roi_in->width; \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      const float *inp = in - step * rad; \n      const float *m = mat; \n      float sum = 0.0f; \n      for(int k = -rad; k <= rad; k++, m++, inp += step) sum += *m * *inp; \n      *out = sum; \n      out += ch; \n  ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_sharpen_data_t *const data = (dt_iop_sharpen_data_t *)piece->data; \n  const int ch = piece->colors; \n  const int rad = MIN(MAXR, ceilf(data->radius * roi_in->scale / piece->iscale)); \n   \n \n   \n \n  if(rad == 0 || \n     (roi_out->width < 2 * rad + 1 || roi_out->height < 2 * rad + 1)) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, ch); \n    return; \n  } \n \n  float *restrict tmp; \n  if (!dt_iop_alloc_image_buffers(self, roi_in, roi_out, 1, &tmp, 0)) \n  { \n    dt_iop_copy_image_roi(ovoid, ivoid, ch, roi_in, roi_out, TRUE); \n    return; \n  } \n \n  const int wd = 2 * rad + 1; \n  const int wd4 = (wd & 3)? (wd >> 2) + 1 : wd >> 2; \n \n  const size_t mat_size = (size_t)4 * wd4; \n  float *const mat = dt_alloc_align_float(mat_size); \n  memset(mat, 0, sizeof(float) * mat_size); \n \n  const float sigma2 = (1.0f / (2.5 * 2.5)) * (data->radius * roi_in->scale / piece->iscale) \n                       * (data->radius * roi_in->scale / piece->iscale); \n  float weight = 0.0f; \n \n   \n \n  for(int i = 0; i < n; i++) {\\n        const float * const mat_ptr = dt_alloc_align_float(mat_size);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "}
{"label": " \nint main(int argc, char **argv) \n{ \n    int i, j, k; \n    int n = 2048; \n    int size, myid; \n \n      init_array(); \n     \n    MPI_Status stat; \n    int *argcVar = NULL; \n    char ***argvVar = NULL; \n    MPI_Init(argcVar, argvVar); \n    MPI_Comm_size(MPI_COMM_WORLD, &size); \n    MPI_Comm_rank(MPI_COMM_WORLD, &myid); \n    const int FTAG = 0; \n    const int ATAG = 1; \n    const int RTAG = 2; \n    const int WTAG = 3; \n    const int SWTAG = 4; \n    const int FRTAG = 5; \n    const int FWTAG = 6; \n    double timeStart = MPI_Wtime(); \n    double timeFinish; \n    int coordVector0[2]; \n    int partSize, offset; \n    for (i = 1; \n        i < n; \n        i++) \n    { \n        (partSize = (((i - (0))) / (size - 1)) > 0? ((((i - (0))) / (size - 1)) / 2) : 1); \n        if (myid == 0) \n        { \n            int followIN = 0; \n            int killed = 0; \n            for (int to = 1; \n                to < size; \n                ++to) \n            { \n                if ((followIN + partSize) < i) \n                { \n                    MPI_Send(&followIN, 1, MPI_INT, to, ATAG, MPI_COMM_WORLD); \n                    MPI_Send(&partSize, 1, MPI_INT, to, ATAG, MPI_COMM_WORLD); \n                    MPI_Send(&alpha, 1, MPI_DOUBLE, to, ATAG, MPI_COMM_WORLD); \n                    MPI_Send(&B[followIN], partSize * (2048), MPI_DOUBLE, to, ATAG, MPI_COMM_WORLD); \n                } \n                else \n                    if ((i - followIN) > 0) \n                    { \n                        (partSize = i - followIN); \n                        MPI_Send(&followIN, 1, MPI_INT, to, ATAG, MPI_COMM_WORLD); \n                        MPI_Send(&partSize, 1, MPI_INT, to, ATAG, MPI_COMM_WORLD); \n                        MPI_Send(&alpha, 1, MPI_DOUBLE, to, ATAG, MPI_COMM_WORLD); \n                        MPI_Send(&B[followIN], partSize * (2048), MPI_DOUBLE, to, ATAG, MPI_COMM_WORLD); \n                    } \n                    else \n                    { \n                        MPI_Send(&offset, 1, MPI_INT, to, FTAG, MPI_COMM_WORLD); \n                        killed++; \n                    } \n                followIN += partSize; \n            } \n            while (killed!= size - 1) \n            { \n                MPI_Recv(&partSize, 1, MPI_INT, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &stat); \n                int source = stat.MPI_SOURCE; \n                if (stat.MPI_TAG == RTAG) \n                { \n                    switch (partSize) \n                    { \n                        case 0 :  \n                        MPI_Send(&alpha, 1, MPI_DOUBLE, source, RTAG, MPI_COMM_WORLD); \n                        break; \n                        case 1 :  \n                        MPI_Recv(&coordVector0, 2, MPI_INT, source, RTAG, MPI_COMM_WORLD, &stat); \n                        MPI_Send(&B[coordVector0[0]][coordVector0[1]], 1, MPI_DOUBLE, source, RTAG, MPI_COMM_WORLD); \n                        break; \n                        case 2 :  \n                        MPI_Recv(&coordVector0, 2, MPI_INT, source, RTAG, MPI_COMM_WORLD, &stat); \n                        MPI_Send(&A[coordVector0[0]][coordVector0[1]], 1, MPI_DOUBLE, source, RTAG, MPI_COMM_WORLD); \n                        break; \n         ", "pred": " \nint main(int argc, char **argv) \n{ \n    int i, j, k; \n    int n = 2048; \n    int size, myid; \n \n      init_array(); \n     \n    MPI_Status stat; \n    int *argcVar = NULL; \n    char ***argvVar = NULL; \n    MPI_Init(argcVar, argvVar); \n    MPI_Comm_size(MPI_COMM_WORLD, &size); \n    MPI_Comm_rank(MPI_COMM_WORLD, &myid); \n    const int FTAG = 0; \n    const int ATAG = 1; \n    const int RTAG = 2; \n    const int WTAG = 3; \n    const int SWTAG = 4; \n    const int FRTAG = 5; \n    const int FWTAG = 6; \n    double timeStart = MPI_Wtime(); \n    double timeFinish; \n    int coordVector0[2]; \n    int partSize, offset; \n    for (i = 1; \n        i < n; \n        i++) \n    { \n        (partSize = (((i - (0))) / (size - 1)) > 0? ((((i - (0))) / (size - 1)) / 2) : 1); \n        if (myid == 0) \n        { \n            int followIN = 0; \n            int killed = 0; \n            for (int to = 1; \n                to < size; \n                ++to) \n            { \n                if ((followIN + partSize) < i) \n                { \n                    MPI_Status_chg(MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MPI_STATIC_CHM, MP"}
{"label": " \nMagickExport Image *AdaptiveSharpenImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  ExceptionInfo *exception) \n{ \n#define AdaptiveSharpenImageTag  \"Convolve/Image\" \n#define MagickSigma  (fabs(sigma) < MagickEpsilon? MagickEpsilon : sigma) \n \n  CacheView \n    *sharp_view, \n    *edge_view, \n    *image_view; \n \n  double \n    **kernel, \n    normalize; \n \n  Image \n    *sharp_image, \n    *edge_image, \n    *gaussian_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    j, \n    k, \n    u, \n    v, \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  sharp_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (sharp_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (fabs(sigma) <= MagickEpsilon) \n    return(sharp_image); \n  if (SetImageStorageClass(sharp_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&sharp_image->exception); \n      sharp_image=DestroyImage(sharp_image); \n      return((Image *) NULL); \n    } \n   \n \n  edge_image=EdgeImage(image,radius,exception); \n  if (edge_image == (Image *) NULL) \n    { \n      sharp_image=DestroyImage(sharp_image); \n      return((Image *) NULL); \n    } \n  (void) LevelImage(edge_image,\"20%,95%\"); \n  gaussian_image=BlurImage(edge_image,radius,sigma,exception); \n  if (gaussian_image!= (Image *) NULL) \n    { \n      edge_image=DestroyImage(edge_image); \n      edge_image=gaussian_image; \n    } \n  (void) LevelImage(edge_image,\"10%,95%\"); \n   \n \n  width=GetOptimalKernelWidth2D(radius,sigma); \n  kernel=(double **) MagickAssumeAligned(AcquireAlignedMemory((size_t) width, \n    sizeof(*kernel))); \n  if (kernel == (double **) NULL) \n    { \n      edge_image=DestroyImage(edge_image); \n      sharp_image=DestroyImage(sharp_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  (void) ResetMagickMemory(kernel,0,(size_t) width*sizeof(*kernel)); \n  for (i=0; i < (ssize_t) width; i+=2) \n  { \n    kernel[i]=(double *) MagickAssumeAligned(AcquireAlignedMemory((size_t) \n      (width-i),(width-i)*sizeof(**kernel))); \n    if (kernel[i] == (double *) NULL) \n      break; \n    normalize=0.0; \n    j=(ssize_t) (width-i-1)/2; \n    k=0; \n    for (v=(-j); v <= j; v++) \n    { \n      for (u=(-j); u <= j; u++) \n      { \n        kernel[i][k]=(double) (-exp(-((double) u*u+v*v)/(2.0*MagickSigma* \n          MagickSigma))/(2.0*MagickPI*MagickSigma*MagickSigma)); \n        normalize+=kernel[i][k]; \n        k++; \n      } \n    } \n    kernel[i][(k-1)/2]=(double) ((-2.0)*normalize); \n    if (sigma < MagickEpsilon) \n      kernel[i][(k-1)/2]=1.0; \n  } \n  if (i < (ssize_t) width) \n    { \n      for (i-=2; i >= 0; i-=2) \n        kernel[i]=(double *) RelinquishAlignedMemory(kernel[i]); \n      kernel=(double **) RelinquishAlignedMemory(kernel); \n      edge_image=DestroyImage(edge_image); \n      sharp_image=DestroyImage(sharp_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(image,&bias); \n  SetMagickPixelPacketBias(image,&bias); \n  image_view=AcquireVirtualCacheView(image,exception); \n  edge_view=AcquireVirtualCacheView(edge_image,exception); \n  sharp_view=AcquireAuthenticCacheView(sharp_image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,sharp_image,sharp_image->rows,1) \n  for (y=0; y < (ssize_t) sharp_image->rows; y++) \n  { \n    register const IndexPacket \n      *restrict indexes; \n \n    register const PixelPacket \n      *restrict p, \n      *restrict r; \n \n    register IndexPacket \n      *restrict sharp_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    r=GetCacheViewVirtualPixels(edge_view,0,y,edge_image->columns,1,exception); \n    q=QueueCacheViewAuthenticPixels(sharp_view,0,y,sharp_image->columns,1, \n      exception); \n    if ((r == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    sharp_indexes=GetCacheViewAuthenticIndexQueue(sharp_view); \n    for (x=0; x < (ssize_t) sharp_image->columns; x++) \n  ", "pred": " \nMagickExport Image *AdaptiveSharpenImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  ExceptionInfo *exception) \n{ \n#define AdaptiveSharpenImageTag  \"Convolve/Image\" \n#define MagickSigma  (fabs(sigma) < MagickEpsilon? MagickEpsilon : sigma) \n \n  CacheView \n    *sharp_view, \n    *edge_view, \n    *image_view; \n \n  double \n    **kernel, \n    normalize; \n \n  Image \n    *sharp_image, \n    *edge_image, \n    *gaussian_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    j, \n    k, \n    u, \n    v, \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  sharp_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (sharp_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (fabs(sigma) <= MagickEpsilon) \n    return(sharp_image); \n  if (SetImageStorageClass(sharp_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&sharp_image->exception); \n      sharp_image=DestroyImage(sharp_image); \n      return((Image *) NULL); \n    } \n   \n \n  edge_image=DestroyImage(sharp_image);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "}
{"label": " \nstatic int _gradient_get_points(dt_develop_t *dev, float x, float y, float rotation, float curvature, \n                                float **points, int *points_count) \n{ \n  *points = NULL; \n  *points_count = 0; \n \n  const float wd = dev->preview_pipe->iwidth; \n  const float ht = dev->preview_pipe->iheight; \n  const float scale = sqrtf(wd * wd + ht * ht); \n  const float distance = 0.1f * fminf(wd, ht); \n \n  const float v = (-rotation / 180.0f) * M_PI; \n  const float cosv = cosf(v); \n  const float sinv = sinf(v); \n \n  const int count = sqrtf(wd * wd + ht * ht) + 3; \n  *points = dt_alloc_align_float((size_t)2 * count); \n  if(*points == NULL) return 0; \n \n   \n \n  (*points)[0] = x * wd; \n  (*points)[1] = y * ht; \n \n   \n \n  const float v1 = (-(rotation - 90.0f) / 180.0f) * M_PI; \n  const float x1 = x * wd + distance * cosf(v1); \n  const float y1 = y * ht + distance * sinf(v1); \n  (*points)[2] = x1; \n  (*points)[3] = y1; \n  const float v2 = (-(rotation + 90.0f) / 180.0f) * M_PI; \n  const float x2 = x * wd + distance * cosf(v2); \n  const float y2 = y * ht + distance * sinf(v2); \n  (*points)[4] = x2; \n  (*points)[5] = y2; \n \n  const int nthreads = omp_get_max_threads(); \n  size_t c_padded_size; \n  uint32_t *pts_count = dt_calloc_perthread(nthreads, sizeof(uint32_t), &c_padded_size); \n  float *const restrict pts = dt_alloc_align_float((size_t)2 * count * nthreads); \n \n   \n \n  const float xstart = fabsf(curvature) > 1.0f? -sqrtf(1.0f / fabsf(curvature)) : -1.0f; \n  const float xdelta = -2.0f * xstart / (count - 3); \n \n \n \n#pragma omp parallel for default(none)                                                                            dt_omp_firstprivate(nthreads, pts, pts_count, count, cosv, sinv, xstart, xdelta, curvature, scale, x, y, wd,                           ht, c_padded_size, points) schedule(static) if(count > 100) \n  for(int i = 3; i < count; i++) \n  { \n    const float xi = xstart + (i - 3) * xdelta; \n    const float yi = curvature * xi * xi; \n    const float xii = (cosv * xi + sinv * yi) * scale; \n    const float yii = (sinv * xi - cosv * yi) * scale; \n    const float xiii = xii + x * wd; \n    const float yiii = yii + y * ht; \n \n     \n \n     \n \n    if(!(xiii < -wd || xiii > 2 * wd || yiii < -ht || yiii > 2 * ht)) \n    { \n      const int thread = omp_get_thread_num(); \n      uint32_t *tcount = dt_get_perthread(pts_count, c_padded_size); \n      pts[(thread * count) + *tcount * 2]     = xiii; \n      pts[(thread * count) + *tcount * 2 + 1] = yiii; \n      (*tcount)++; \n    } \n  } \n \n  *points_count = 3; \n  for(int thread = 0; thread < nthreads; thread++) \n  { \n    const uint32_t tcount = *(uint32_t *)dt_get_bythread(pts_count, c_padded_size, thread); \n    for(int k = 0; k < tcount; k++) \n    { \n      (*points)[(*points_count) * 2]     = pts[(thread * count) + k * 2]; \n      (*points)[(*points_count) * 2 + 1] = pts[(thread * count) + k * 2 + 1]; \n      (*points_count)++; \n    } \n  } \n \n  dt_free_align(pts_count); \n  dt_free_align(pts); \n \n   \n \n  if(dt_dev_distort_transform(dev, *points, *points_count)) return 1; \n \n   \n \n  dt_free_align(*points); \n  *points = NULL; \n  *points_count = 0; \n  return 0; \n} ", "pred": " \nstatic int _gradient_get_points(dt_develop_t *dev, float x, float y, float rotation, float curvature, \n                                float **points, int *points_count) \n{ \n  *points = NULL; \n  *points_count = 0; \n \n  const float wd = dev->preview_pipe->iwidth; \n  const float ht = dev->preview_pipe->iheight; \n  const float scale = sqrtf(wd * wd + ht * ht); \n  const float distance = 0.1f * fminf(wd, ht); \n \n  const float v = (-rotation / 180.0f) * M_PI; \n  const float cosv = cosf(v); \n  const float sinv = sinf(v); \n \n  const int count = sqrtf(wd * wd + ht * ht) + 3; \n  *points = dt_alloc_align_float((size_t)2 * count); \n  if(*points == NULL) return 0; \n \n   \n \n  (*points)[0] = x * wd; \n  (*points)[1] = y * ht; \n \n   \n \n  const float v1 = (-(rotation - 90.0f) / 180.0f) * M_PI; \n  const float x1 = x * wd + distance * cosf(v1); \n  const float y1 = y * ht + distance * sinf(v1); \n  (*points)[2] = x1; \n  (*points)[3] = y1; \n  const float v2 = (-(rotation + 90.0f) / 180.0f) * M_PI; \n  const float x2 = x * wd + distance * cosf(v2); \n  const float y2 = y * ht + distance * sinf(v2); \n  (*points)[4] = x2; \n  (*points)[5] = y2; \n \n  const int nthreads = omp_get_max_threads(); \n  size_t c_padded_size; \n  uint32_t *pts_count = dt_calloc_perthread(nthreads, sizeof(uint32_t), &c_padded_size); \n  const float *pts = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_c = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_d = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_c = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_d = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_c = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n    const float *pts_e_e_e = dt_alloc_align_float((size_t)c_padded_size, 0.0f);\\n  "}
{"label": " \nMagickExport Image *UnsharpMaskImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  const double gain,const double threshold,ExceptionInfo *exception) \n{ \n#define SharpenImageTag  \"Sharpen/Image\" \n \n  CacheView \n    *image_view, \n    *unsharp_view; \n \n  Image \n    *unsharp_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  MagickRealType \n    quantum_threshold; \n \n  ssize_t \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  unsharp_image=BlurImageChannel(image,channel &~ SyncChannels,radius,sigma, \n    exception); \n  if (unsharp_image == (Image *) NULL) \n    return((Image *) NULL); \n  quantum_threshold=(MagickRealType) QuantumRange*threshold; \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(image,&bias); \n  image_view=AcquireVirtualCacheView(image,exception); \n  unsharp_view=AcquireAuthenticCacheView(unsharp_image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,unsharp_image,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    DoublePixelPacket \n      pixel; \n \n    register const IndexPacket \n      *restrict indexes; \n \n    register const PixelPacket \n      *restrict p; \n \n    register IndexPacket \n      *restrict unsharp_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    q=GetCacheViewAuthenticPixels(unsharp_view,0,y,unsharp_image->columns,1, \n      exception); \n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewVirtualIndexQueue(image_view); \n    unsharp_indexes=GetCacheViewAuthenticIndexQueue(unsharp_view); \n    pixel.red=bias.red; \n    pixel.green=bias.green; \n    pixel.blue=bias.blue; \n    pixel.opacity=bias.opacity; \n    pixel.index=bias.index; \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      if ((channel & RedChannel)!= 0) \n        { \n          pixel.red=GetPixelRed(p)-(MagickRealType) GetPixelRed(q); \n          if (fabs(2.0*pixel.red) < quantum_threshold) \n            pixel.red=(MagickRealType) GetPixelRed(p); \n          else \n            pixel.red=(MagickRealType) GetPixelRed(p)+(pixel.red*gain); \n          SetPixelRed(q,ClampToQuantum(pixel.red)); \n        } \n      if ((channel & GreenChannel)!= 0) \n        { \n          pixel.green=GetPixelGreen(p)-(MagickRealType) q->green; \n          if (fabs(2.0*pixel.green) < quantum_threshold) \n            pixel.green=(MagickRealType) GetPixelGreen(p); \n          else \n            pixel.green=(MagickRealType) GetPixelGreen(p)+(pixel.green*gain); \n          SetPixelGreen(q,ClampToQuantum(pixel.green)); \n        } \n      if ((channel & BlueChannel)!= 0) \n        { \n          pixel.blue=GetPixelBlue(p)-(MagickRealType) q->blue; \n          if (fabs(2.0*pixel.blue) < quantum_threshold) \n            pixel.blue=(MagickRealType) GetPixelBlue(p); \n          else \n            pixel.blue=(MagickRealType) GetPixelBlue(p)+(pixel.blue*gain); \n          SetPixelBlue(q,ClampToQuantum(pixel.blue)); \n        } \n      if ((channel & OpacityChannel)!= 0) \n        { \n          pixel.opacity=GetPixelOpacity(p)-(MagickRealType) q->opacity; \n          if (fabs(2.0*pixel.opacity) < quantum_threshold) \n            pixel.opacity=(MagickRealType) GetPixelOpacity(p); \n          else \n            pixel.opacity=GetPixelOpacity(p)+(pixel.opacity*gain); \n          SetPixelOpacity(q,ClampToQuantum(pixel.opacity)); \n        } \n      if (((channel & IndexChannel)!= 0) && \n          (image->colorspace == CMYKColorspace)) \n        { \n          pixel.index=GetPixelIndex(indexes+x)-(MagickRealType) \n            GetPixelIndex(unsharp_indexes+x); \n          if (fabs(2.0*pixel.index) < quantum_threshold) \n            pixel.index=(MagickRealType) GetPixelIndex(indexes+x); \n          else \n            pixel.index=(MagickRealType) GetPixelIndex(indexes+x)+ \n              (pixel.index*gain); \n          SetPixelIndex(unsharp_indexes+x,ClampToQuantum(pixel.index));", "pred": " \nMagickExport Image *UnsharpMaskImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  const double gain,const double threshold,ExceptionInfo *exception) \n{ \n#define SharpenImageTag  \"Sharpen/Image\" \n \n  CacheView \n    *image_view, \n    *unsharp_view; \n \n  Image \n    *unsharp_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  MagickRealType \n    quantum_threshold; \n \n  ssize_t \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  unsharp_image=BlurImageChannel(image,channel &~ SyncChannels,radius,sigma, \n    exception); \n  if (unsharp_image == (Image *) NULL) \n    return((Image *) NULL); \n  quantum_threshold=(MagickRealType) QuantumRange*threshold; \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(image,&bias); \n  image_view=AcquireVirtualCacheView(image,exception); \n  unsharp_view=AcquireAuthenticCacheView(unsharp_image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,unsharp_image,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    DoublePixelPacket \n      pixel; \n \n    register const IndexPacket \n      *restrict indexes; \n \n    register const PixelPacket \n      *restrict p; \n \n    register IndexPacket \n      *restrict p_restrict p;\\n    register const PixelPacket      *restrict p_restrict p;\\n    register const PixelPacket       *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelPacket        *restrict p_restrict p;\\n    register const PixelP"}
{"label": " \nint main (int argc, char* argv[])  \n{ \n     \n \n    char* corUnit; \n    char* unit; \n \n    int zoSize, dataSize, tNumRed; \n    float *zo, *zoSq, *semb, *data; \n    int *count; \n    int iv, is, ir, ip, forDataInd, it, tInd, dataInd, indZO; \n    float vel, shotPos, curOffset, halfOffset, fabsOffset, offsetSq; \n    float curPos, l0, forA, t0, a, t, forLim, limitLeft, limitRight; \n    float bef, aft, sample, sampleSq, sqSample, curSemb; \n    int ic, iw, ts, ind, totalCount, offset, vwhalf; \n \n \n \n    sf_init (argc,argv); \n \n \n \n    dataFile = sf_input (\"in\"); \n     \n \n    outFile  = sf_output(\"out\"); \n     \n \n \n    if ( NULL!= sf_getstring(\"aux\") ) { \n\t \n  \n\tauxFile  = sf_output (\"aux\"); \n    } else { \n\tsf_error (\"Need output: partial zero-offset sections\"); \n    } \n \n     \n \n \n    if (!sf_histint   (dataFile, \"n1\", &tNum_)   ) sf_error (\"Need n1= in input\"); \n    if (!sf_histfloat (dataFile, \"d1\", &tStep_)  ) sf_error (\"Need d1= in input\"); \n    if (!sf_histfloat (dataFile, \"o1\", &tStart_) ) sf_error (\"Need o1= in input\"); \n \n    if (!sf_histint   (dataFile, \"n2\", &recNum_)   ) sf_error (\"Need n2= in input\"); \n    if (!sf_histfloat (dataFile, \"d2\", &recStep_)  ) sf_error (\"Need d2= in input\"); \n    if (!sf_histfloat (dataFile, \"o2\", &recStart_) ) sf_error (\"Need o2= in input\"); \n \n    if (!sf_histint   (dataFile, \"n3\", &shotNum_)   ) sf_error (\"Need n3= in input\"); \n    if (!sf_histfloat (dataFile, \"d3\", &shotStep_)  ) sf_error (\"Need d3= in input\"); \n    if (!sf_histfloat (dataFile, \"o3\", &shotStart_) ) sf_error (\"Need o3= in input\"); \n \n \n \n \n \n \n \n \n\t \n     \n \n     \n \n \n \n \n \n     \n \n    corUnit = (char*) \"m\"; unit = sf_histstring (dataFile, \"unit2\"); if (!unit) sf_error (\"unit2 in data file is not defined\"); \n    if ( strcmp (corUnit, unit) ) { recStep_ *= 1000; recStart_ *= 1000; } \n     \n \n    corUnit = (char*) \"m\"; unit = sf_histstring (dataFile, \"unit3\"); if (!unit) sf_error (\"unit3 in data file is not defined\"); \n    if ( strcmp (corUnit, unit) ) { shotStep_ *= 1000; shotStart_ *= 1000; } \n \n     \n \n     \n \n \n \n \n    if (!sf_getfloat (\"po\",    &pStart_) ) pStart_ = shotStart_; \n     \n \n    if (!sf_getint (\"pn\", &pNum_) ) pNum_ = recNum_; \n     \n \n    if (!pNum_) {sf_warning (\"vn value is changed to 1\"); pNum_ = recNum_;} \n    if (!sf_getfloat (\"pd\",    &pStep_) ) pStep_ = recStep_; \n     \n \n    if (!pStep_) {sf_warning (\"pd value is changed to 50\"); pStep_ = recStep_;} \n \n \n    if (!sf_getint (\"vn\",    &vNum_) ) vNum_ = 1; \n     \n \n    if (!vNum_) {sf_warning (\"vn value is changed to 1\"); vNum_ = 1;} \n    if (!sf_getfloat (\"vo\",    &vStart_) ) vStart_ = 1500; \n     \n \n    if (!vStart_) {sf_warning (\"vn value is changed to 1500\"); vStart_ = 1500.0;} \n    if (!sf_getfloat (\"vd\",    &vStep_) ) vStep_ = 50; \n     \n \n    if (!vStep_) {sf_warning (\"vd value is changed to 50\"); vStep_ = 50.f;} \n \n    if (!sf_getint (\"wh\",   &wh_) )   wh_ = 11; \n     \n \n    if (!wh_) {sf_warning (\"vertical window size is changed to 1\"); wh_ = 1;} \n \n    sf_putint    (outFile, \"n1\", tNum_); \n    sf_putint    (outFile, \"n2\", pNum_); \n    sf_putint    (outFile, \"n3\", vNum_); \n    sf_putfloat  (outFile, \"d1\", tStep_);  \n    sf_putfloat  (outFile, \"d2\", pStep_); \n    sf_putint    (outFile, \"d3\", vStep_); \n    sf_putfloat  (outFile, \"o1\", tStart_);  \n    sf_putfloat  (outFile, \"o2\", pStart_); \n    sf_putfloat  (outFile, \"o3\", vStart_); \n    sf_putstring (outFile, \"label1\", \"time\"); sf_putstring(outFile, \"label2\", \"inline\"); sf_putstring(outFile, \"label3\", \"velocity\"); \n    sf_putstring(outFile, \"unit3\", \"m/s\"); \n \n    sf_putint    (auxFile, \"n1\", tNum_); \n    sf_putint    (auxFile, \"n2\", pNum_); \n    sf_putint    (auxFile, \"n3\", vNum_); \n    sf_putfloat  (auxFile, \"d1\", tStep_);  \n    sf_putfloat  (auxFile, \"d2\", pStep_); \n    sf_putint    (auxFile, \"d3\", vStep_); \n    sf_putfloat  (auxFile, \"o1\", tStart_);  \n    sf_putfloat  (auxFile, \"o2\", pStart_); \n    sf_putfloat  (auxFile, \"o3\", vStart_); \n    sf_putstring (auxFile, \"label1\", \"time\"); sf_putstring (auxFile, \"label2\", \"inline\"); sf_putstring (auxFile, \"label3\", \"velocity\"); \n    sf_putstring (auxFile, \"unit3\", \"m/s\"); \n \n    zoSize", "pred": " \nint main (int argc, char* argv[])  \n{ \n     \n \n    char* corUnit; \n    char* unit; \n \n    int zoSize, dataSize, tNumRed; \n    float *zo, *zoSq, *semb, *data; \n    int *count; \n    int iv, is, ir, ip, forDataInd, it, tInd, dataInd, indZO; \n    float vel, shotPos, curOffset, halfOffset, fabsOffset, offsetSq; \n    float curPos, l0, forA, t0, a, t, forLim, limitLeft, limitRight; \n    float bef, aft, sample, sampleSq, sqSample, curSemb; \n    int ic, iw, ts, ind, totalCount, offset, vwhalf; \n \n \n \n    sf_init (argc,argv); \n \n \n \n    dataFile = sf_input (\"in\"); \n     \n \n    outFile  = sf_output(\"out\"); \n     \n \n \n    if ( NULL!= sf_getstring(\"aux\") ) { \n\t \n  \n\tauxFile  = sf_output (\"aux\"); \n    } else { \n\tsf_error (\"Need output: partial zero-offset sections\"); \n    } \n \n     \n \n \n    if (!sf_histint   (dataFile, \"n1\", &tNum_)   ) sf_error (\"Need n1= in input\"); \n    if (!sf_histfloat (dataFile, \"d1\", &tStep_)  ) sf_error (\"Need d1= in input\"); \n    if (!sf_histfloat (dataFile, \"o1\", &tStart_) ) sf_error (\"Need o1= in input\"); \n \n    if (!sf_histint   (dataFile, \"n2\", &recNum_)   ) sf_error (\"Need n2= in input\"); \n    if (!sf_histfloat (dataFile, \"d2\", &recStep_)  ) sf_error (\"Need d2= in input\"); \n    if (!sf_histfloat (dataFile,(d1), &recStep_) ) sf_errorIncrease                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": " \nvoid THNN_(SpatialAdaptiveAveragePooling_updateOutput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *output, \n          int owidth, \n          int oheight) \n{ \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  long nslices; \n  long iheight; \n  long iwidth; \n \n  long istride_d; \n  long istride_h; \n  long istride_w; \n  long istride_b; \n \n  real *input_data; \n  real *output_data; \n \n \n  THNN_ARGCHECK(input->nDimension == 3 || input->nDimension == 4, 2, input, \n\t\t\"3D or 4D (batch mode) tensor expected for input, but got: %s\"); \n \n  if (input->nDimension == 4) \n  { \n    istride_b = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n   \n \n  nslices = input->size[dimh-1]; \n  iheight = input->size[dimh]; \n  iwidth = input->size[dimw]; \n   \n \n  istride_d = input->stride[dimh-1]; \n  istride_h = input->stride[dimh]; \n  istride_w = input->stride[dimw]; \n \n   \n \n  if (input->nDimension == 3) \n  { \n    THTensor_(resize3d)(output, nslices, oheight, owidth); \n \n    input_data = THTensor_(data)(input); \n    output_data = THTensor_(data)(output); \n \n    THNN_(SpatialAdaptiveAveragePooling_updateOutput_frame)(input_data, output_data, \n                                                      nslices, \n                                                      iwidth, iheight, \n                                                      owidth, oheight, \n                                                      istride_w,istride_h, \n                                                      istride_d); \n  } \n  else \n  { \n    long p; \n \n    THTensor_(resize4d)(output, nbatch, nslices, oheight, owidth); \n \n    input_data = THTensor_(data)(input); \n    output_data = THTensor_(data)(output); \n \n#pragma omp parallel for private(p) \n    for (p = 0; p < nbatch; p++) \n    { \n      THNN_(SpatialAdaptiveAveragePooling_updateOutput_frame)(input_data+p*istride_b, output_data+p*nslices*owidth*oheight, \n                                                        nslices, \n                                                        iwidth, iheight, \n                                                        owidth, oheight, \n                                                        istride_w,istride_h, \n                                                        istride_d); \n    } \n  } \n} ", "pred": " \nvoid THNN_(SpatialAdaptiveAveragePooling_updateOutput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *output, \n          int owidth, \n          int oheight) \n{ \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  long nslices; \n  long iheight; \n  long iwidth; \n \n  long istride_d; \n  long istride_h; \n  long istride_w; \n  long istride_b; \n \n  real *input_data; \n  real *output_data; \n \n \n  THNN_ARGCHECK(input->nDimension == 3 || input->nDimension == 4, 2, input, \n\t\t\"3D or 4D (batch mode) tensor expected for input, but got: %s\"); \n \n  if (input->nDimension == 4) \n  { \n    istride_b = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n   \n \n  nslices = input->size[dimh-1]; \n  iheight = input->size[dimh]; \n  iwidth = input->size[dimw]; \n   \n \n  istride_d = input->stride[dimh-1]; \n  istride_h = input->stride[dimh]; \n  istride_w = input->stride[dimw]; \n \n   \n \n  if (input->nDimension == 3) \n  { \n    THTensor_(resize3d)(output, nslices, oheight, owidth); \n \n    input_data = THTensor_(data)(input); \n    output_data = THTensor_(data)(output); \n \n    THNN_(SpatialAdaptiveAveragePooling_updateOutput_frame)(input_data, output_data, \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n\tputs(\"\\e[0;34m==>\\e[0m Reading in values from the matrix files...\"); \n \n\tdouble matrix1[MATRIX_SIZE][MATRIX_SIZE], \n\t       matrix2[MATRIX_SIZE][MATRIX_SIZE], \n\t       real_product[MATRIX_SIZE][MATRIX_SIZE], \n\t       calc_product[MATRIX_SIZE][MATRIX_SIZE]; \n \n\t{ \n\t\tFILE *matrix1_file = fopen(MATRIX_1, \"r\"), \n\t\t     *matrix2_file = fopen(MATRIX_2, \"r\"), \n\t\t     *product_file = fopen(PRODUCT,  \"r\"); \n \n\t\tfor (int i = 0; i < MATRIX_SIZE; ++i) \n\t\t{ \n\t\t\tfor (int j = 0; j < MATRIX_SIZE; ++j) \n\t\t\t{ \n\t\t\t\tfscanf(matrix1_file, \"%lf\", &matrix1[i][j]); \n\t\t\t\tfscanf(matrix2_file, \"%lf\", &matrix2[i][j]); \n\t\t\t\tfscanf(product_file, \"%lf\", &real_product[i][j]); \n\t\t\t} \n\t\t} \n \n\t\tfclose(matrix1_file); \n\t\tfclose(matrix2_file); \n\t\tfclose(product_file); \n\t} \n \n\tint block_size  = 4; \n \n\tif (argc > 1) \n\t{ \n\t\tblock_size = atoi(argv[1]); \n \n\t\tif (MATRIX_SIZE % block_size!= 0) \n\t\t{ \n\t\t\tprintf(\"\\e[0;31m==> %d Block size is not divisible into the matrix\\n\", block_size); \n\t\t\texit(1); \n\t\t} \n\t} \n \n\tint trials = 1; \n \n\tif (argc > 2) \n\t{ \n\t\ttrials = atoi(argv[2]); \n\t} \n \n\tlong long execution_times[trials]; \n \n\tprintf(\"\\e[0;34m==>\\e[0m Running %d block matrix multiplcation trials...\\n\", trials); \n \n\tfor (int trial = 0; trial < trials; ++trial) \n\t{ \n\t\t \n \n\t\tmemset(calc_product, 0, sizeof(calc_product[0][0]) * MATRIX_SIZE * MATRIX_SIZE); \n \n\t\tstruct timeval time_start; \n\t\tstruct timeval time_end; \n \n\t\tgettimeofday(&time_start, NULL); \n \n\t\t \n \n\t\tfor (int i = 0; i < MATRIX_SIZE; i += block_size) \n\t\t{ \n\t\t\tfor (int j = 0; j < MATRIX_SIZE; j += block_size) \n\t\t\t{ \n    #pragma omp parallel for collapse(2) \n\t\t\t\tfor (int x = 0; x < block_size; ++x) \n\t\t\t\t{ \n\t\t\t\t\tfor (int y = 0; y < block_size; ++y) \n\t\t\t\t\t{ \n\t\t\t\t\t\tfor (int k = 0; k < MATRIX_SIZE; ++k) \n\t\t\t\t\t\t{ \n       #pragma omp critical \n\t\t\t\t\t\t\tcalc_product[i + x][j + y] += matrix1[i + x][k] * matrix2[k][j + y]; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t} \n \n\t\tgettimeofday(&time_end, NULL); \n \n\t\t \n \n\t\texecution_times[trial] = 1000000LL \n\t\t\t* (time_end.tv_sec  - time_start.tv_sec) \n\t\t\t+ (time_end.tv_usec - time_start.tv_usec); \n \n\t\t \n \n\t\tfor (int i = 0; i < MATRIX_SIZE; ++i) \n\t\t{ \n\t\t\tfor (int j = 0; j < MATRIX_SIZE; ++j) \n\t\t\t{ \n\t\t\t\tif (fabs(calc_product[i][j] - real_product[i][j]) > 0.001) \n\t\t\t\t{ \n\t\t\t\t\tprintf(\"%dx%d: %lf expected. Was %lf\\n\", i, j, real_product[i][j], calc_product[i][j]); \n\t\t\t\t\tputs(\"\\e[0;31m==> Calculated product differs from real product!\"); \n\t\t\t\t\texit(1); \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t} \n \n\tlong long min = INT_MAX, \n\t          avg = 0; \n \n\tfor (int i = 0; i < trials; ++i) \n\t{ \n\t\tif (execution_times[i] < min) \n\t\t{ \n\t\t\tmin = execution_times[i]; \n\t\t} \n \n\t\tavg += execution_times[i]; \n\t} \n \n\tprintf(\"avg: %lld\\n\", avg / trials); \n\tprintf(\"min: %lld\\n\", min); \n \n\tputs(\"\\e[0;32m==>\\e[0m All calculated product matches real product\"); \n \n\treturn 0; \n} ", "pred": " \nint main(int argc, char *argv[]) \n{ \n\tputs(\"\\e[0;34m==>\\e[0m Reading in values from the matrix files...\"); \n \n\tdouble matrix1[MATRIX_SIZE][MATRIX_SIZE], \n\t       matrix2[MATRIX_SIZE][MATRIX_SIZE], \n\t       real_product[MATRIX_SIZE][MATRIX_SIZE], \n\t       calc_product[MATRIX_SIZE][MATRIX_SIZE]; \n \n\t{ \n\t\tFILE *matrix1_file = fopen(MATRIX_1, \"r\"), \n\t\t     *matrix2_file = fopen(MATRIX_2, \"r\"), \n\t\t     *product_file = fopen(PRODUCT,  \"r\"); \n \n\t\tfor (int i = 0; i < MATRIX_SIZE; ++i) \n\t\t{ \n\t\t\tfor (int j = 0; j < MATRIX_SIZE; ++j) \n\t\t\t{ \n\t\t\t\tfscanf(matrix1_file, \"%lf\", &matrix1[i][j]); \n\t\t\t\tfscanf(matrix2_file, \"%lf\", &matrix2[i][j]); \n\t\t\t\tfscanf(product_file, \"%lf\", &real_product[i][j]); \n\t\t\t} \n\t\t} \n \n\t\tfclose(matrix1_file); \n\t\tfclose(matrix2_file); \n\t\tfclose(product_file); \n\t} \n \n\tint block_size  = 4; \n \n\tif (argc > 1) \n\t{ \n\t\tblock_size = atoi(argv[1]); \n \n\t\tif (MATRIX_SIZE % block_size!= 0) \n\t\t{ \n\t\t\tprintf(\"\\e[0;31m==> %d Block size is not divisible into the matrix\\n\", block_size); \n\t\t\texit(1); \n\t\t} \n\t} \n \n\tint trials = 1; \n \n\tif (argc > 2) \n\t{ \n\t\ttrials = atoi(argv[2]); \n\t} \n \n\tlong long execution_times[trials]; \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "}
{"label": " \nint main() \n{ \n    int i; \n    int s = 0; \n    int t = 0; \n    int d = 0; \n    float e = 0.0f; \n    float f = 0.0f; \n \n#pragma omp simd for reduction(+:s,t)  \n    for(i=0; i<100; i++) \n    { \n        s += (i+1); \n        f += (i+1.0f); \n    } \n \n#pragma omp simd for reduction(-:d, e)  \n    for(i=0; i<100; i++) \n    { \n        d -= (i+1); \n        e -= (i+1.0f); \n    } \n \n    printf(\"%d %f %d %f\\n\", s, f, d, e); \n \n    if ((s!= 5050) || (f!= 5050.0f) \n            || (d!= -5050) || (e!= -5050.0f)) \n        return 1; \n \n    return 0; \n} ", "pred": " \nint main() \n{ \n    int i; \n    int s = 0; \n    int t = 0; \n    int d = 0; \n    float e = 0.0f; \n    float f = 0.0f; \n \n#pragma omp simd for reduction(+:s,t)  \n    for(i=0; i<100; i++) \n    { \n        s += (i+1); \n        f += (i+1.0f); \n    } \n \n#pragma omp simd for reduction(-:d, e)  \n    for(i=0; i<100; i++) \n    { \n        d -= (i+1); \n        e -= (i+1.0f); \n    } \n \n    printf(\"%d %f %d %f\\n\", s, f, d, e); \n \n    if ((s!= 5050) || (f!= 5050.0f) \n            || (d!= -5050) || (e!= -5050.0f)) \n        return 1; \n \n    return 0; \n} "}
{"label": " \nvoid symmetrize_complex(complex double* rhoR_b, complex double* rhoR_a, int* op, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n#pragma omp parallel \n{ \n  int x,y,z; \n \n  #pragma omp for schedule(static) \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z) % nz + nz) % nz; \n            rhoR_b[x*ny*nz + y*nz + z] += rhoR_a[x_p*ny*nz + y_p*nz + z_p]; \n        } \n} \n} ", "pred": " \nvoid symmetrize_complex(complex double* rhoR_b, complex double* rhoR_a, int* op, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n#pragma omp parallel \n{ \n  int x,y,z; \n \n  #pragma omp for schedule(static) \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z) % nz + nz) % nz; \n            rhoR_b[x*ny*nz + y*nz + z] += rhoR_a[x_p*ny*nz + y_p*nz + z_p]; \n        } \n} \n} "}
{"label": " \nvoid set_grid_ptrs( GridPoint * energy_grid, NuclideGridPoint ** nuclide_grids, \n                    int n_isotopes, int n_gridpoints ){ \n\t \n\tprintf(\"Assigning pointers to Unionized Energy Grid...\\n\"); \n\t \n #pragma omp parallel for default(none)   shared( energy_grid, nuclide_grids, n_isotopes, n_gridpoints ) \n\tfor( int i = 0; i < n_isotopes * n_gridpoints ; i++ ) \n\t{ \n\t\tdouble quarry = energy_grid[i].energy; \n\t\tif( INFO && omp_get_thread_num() == 0 && i % 200 == 0 ) \n\t\t\tprintf(\"\\rAligning Unionized Grid...(%.0lf%% complete)\", \n\t\t\t       100.0 * (double) i / (n_isotopes*n_gridpoints / \n\t\t\t\t                         omp_get_num_threads())     ); \n\t\tfor( int j = 0; j < n_isotopes; j++ ) \n\t\t{ \n\t\t\t \n \n\t\t\t \n \n\t\t\tenergy_grid[i].xs_ptrs[j] =  \n\t\t\t\tbinary_search( nuclide_grids[j], quarry, n_gridpoints); \n\t\t} \n\t} \n\tprintf(\"\\n\"); \n \n\t \n \n\t \n \n} ", "pred": " \nvoid set_grid_ptrs( GridPoint * energy_grid, NuclideGridPoint ** nuclide_grids, \n                    int n_isotopes, int n_gridpoints ){ \n\t \n\tprintf(\"Assigning pointers to Unionized Energy Grid...\\n\"); \n\t \n #pragma omp parallel for default(none)   shared( energy_grid, nuclide_grids, n_isotopes, n_gridpoints ) \n\tfor( int i = 0; i < n_isotopes * n_gridpoints ; i++ ) \n\t{ \n\t\tdouble quarry = energy_grid[i].energy; \n\t\tif( INFO && omp_get_thread_num() == 0 && i % 200 == 0 ) \n\t\t\tprintf(\"\\rAligning Unionized Grid...(%.0lf%% complete)\", \n\t\t\t       100.0 * (double) i / (n_isotopes*n_gridpoints / \n\t\t\t\t                         omp_get_num_threads())     ); \n\t\tfor( int j = 0; j < n_isotopes; j++ ) \n\t\t{ \n\t\t\t \n \n\t\t\t \n \n\t\t\tenergy_grid[i].xs_ptrs[j] =  \n\t\t\t\tbinary_search( nuclide_grids[j], quarry, n_gridpoints); \n\t\t} \n\t} \n\tprintf(\"\\n\"); \n \n\t \n \n\t \n \n} "}
{"label": " \nint sasa(const int n_frames, const int n_atoms, const float* xyzlist, \n         const float* atom_radii, const int n_sphere_points, \n         const int* atom_mapping, const int n_groups, float* out) \n{ \n   \n \n \n  int i, j; \n \n   \n \n  int* wb1; \n  float* wb2; \n  float* outframe; \n  float* outframebuffer; \n \n   \n \n  float* sphere_points = (float*) malloc(n_sphere_points*3*sizeof(float)); \n  generate_sphere_points(sphere_points, n_sphere_points); \n \n  #pragma omp parallel private(wb1, wb2, outframebuffer, outframe) \n  { \n \n   \n \n  wb1 = (int*) malloc(n_atoms*sizeof(int)); \n  wb2 = (float*) malloc(3*n_sphere_points*sizeof(float)); \n  outframebuffer = (float*) calloc(n_atoms, sizeof(float)); \n \n  #pragma omp for \n  for (i = 0; i < n_frames; i++) { \n    asa_frame(xyzlist + i*n_atoms*3, n_atoms, atom_radii, sphere_points, \n\t      n_sphere_points, wb1, wb2, outframebuffer); \n    outframe = out + (n_groups * i); \n    for (j = 0; j < n_atoms; j++) { \n        outframe[atom_mapping[j]] += outframebuffer[j]; \n    } \n  } \n \n  free(wb1); \n  free(wb2); \n  free(outframebuffer); \n  }  \n \n \n  free(sphere_points); \n  return 1; \n} ", "pred": " \nint sasa(const int n_frames, const int n_atoms, const float* xyzlist, \n         const float* atom_radii, const int n_sphere_points, \n         const int* atom_mapping, const int n_groups, float* out) \n{ \n   \n \n \n  int i, j; \n \n   \n \n  int* wb1; \n  float* wb2; \n  float* outframe; \n  float* outframebuffer; \n \n   \n \n  float* sphere_points = (float*) malloc(n_sphere_points*3*sizeof(float)); \n  generate_sphere_points(sphere_points, n_sphere_points); \n \n  #pragma omp parallel private(wb1, wb2, outframebuffer, outframe) \n  { \n \n   \n \n  wb1 = (int*) malloc(n_atoms*sizeof(int)); \n  wb2 = (float*) malloc(3*n_sphere_points*sizeof(float)); \n  outframebuffer = (float*) calloc(n_atoms, sizeof(float)); \n \n  #pragma omp for \n  for (i = 0; i < n_frames; i++) { \n    asa_frame(xyzlist + i*n_atoms*3, n_atoms, atom_radii, sphere_points, \n\t      n_sphere_points, wb1, wb2, outframebuffer); \n    outframe = out + (n_groups * i); \n    for (j = 0; j < n_atoms; j++) { \n        outframe[atom_mapping[j]] += outframebuffer[j]; \n    } \n  } \n \n  free(wb1); \n  free(wb2); \n  free(outframebuffer); \n  }  \n \n \n  free(sphere_points); \n  return 1; \n} "}
{"label": " \nstatic void THNN_(SpatialAdaptiveAveragePooling_updateGradInput_frame)( \n          real *gradInput_p, \n          real *gradOutput_p, \n          long nslices, \n          long iwidth, \n          long iheight, \n          long owidth, \n          long oheight) \n{ \n  long k; \n#pragma omp parallel for private(k) \n  for (k = 0; k < nslices; k++) \n  { \n    real *gradInput_p_k = gradInput_p + k*iwidth*iheight; \n    real *gradOutput_p_k = gradOutput_p + k*owidth*oheight; \n \n     \n \n    long i, j; \n    for(i = 0; i < oheight; i++) \n    { \n      int y_start = START_IND(i, oheight, iheight); \n      int y_end   = END_IND(i, oheight, iheight); \n      int kH = y_end-y_start; \n \n      for(j = 0; j < owidth; j++) \n      { \n \n        int x_start = START_IND(j, owidth, iwidth); \n        int x_end   = END_IND(j, owidth, iwidth); \n        int kW = x_end-x_start; \n \n        int x,y; \n        for(y = y_start; y < y_end; y++) \n        { \n          for(x = x_start; x < x_end; x++) \n          { \n             \n \n            gradInput_p_k[y*iwidth + x] += gradOutput_p_k[i*owidth + j] / kW / kH; \n          } \n        } \n      } \n    } \n  } \n} ", "pred": " \nstatic void THNN_(SpatialAdaptiveAveragePooling_updateGradInput_frame)( \n          real *gradInput_p, \n          real *gradOutput_p, \n          long nslices, \n          long iwidth, \n          long iheight, \n          long owidth, \n          long oheight) \n{ \n  long k; \n#pragma omp parallel for private(k) \n  for (k = 0; k < nslices; k++) \n  { \n    real *gradInput_p_k = gradInput_p + k*iwidth*iheight; \n    real *gradOutput_p_k = gradOutput_p + k*owidth*oheight; \n \n     \n \n    long i, j; \n    for(i = 0; i < oheight; i++) \n    { \n      int y_start = START_IND(i, oheight, iheight); \n      int y_end   = END_IND(i, oheight, iheight); \n      int kH = y_end-y_start; \n \n      for(j = 0; j < owidth; j++) \n      { \n \n        int x_start = START_IND(j, owidth, iwidth); \n        int x_end   = END_IND(j, owidth, iwidth); \n        int kW = x_end-x_start; \n \n        int x,y; \n        for(y = y_start; y < y_end; y++) \n        { \n          for(x = x_start; x < x_end; x++) \n          { \n             \n \n            gradInput_p_k[y*iwidth + x] += gradOutput_p_k[i*owidth + j] / kW;                                               "}
{"label": " \n__attribute__((noinline)) int foo( \n        int * __restrict__ __attribute__((__aligned__(VECTOR_SIZE))) b, \n        int N) \n{ \n    int i,j; \n \n    int tmp = 0.0f; \n \n#pragma omp simd for simd_reduction(+:tmp) nowait \n        for(i=0; i<(N-16); i++) \n        { \n            tmp += b[i] * \n \n                (((b[i+1] + \n                  b[i+2] * \n                   b[i+3]) + \n \n                    (b[i+4] + \n                     b[i+5] * \n                      b[i+6]) * \n \n                       ((b[i+7] + \n                        b[i+8] * \n                         b[i+9]) + \n \n                          (b[i+10] + \n                           b[i+11] * \n                            b[i+12]) * \n \n                             (b[i+13] + \n                              b[i+14] * \n                               b[i+15])))); \n        } \n \n    return tmp; \n} ", "pred": " \n__attribute__((noinline)) int foo( \n        int * __restrict__ __attribute__((__aligned__(VECTOR_SIZE))) b, \n        int N) \n{ \n    int i,j; \n \n    int tmp = 0.0f; \n \n#pragma omp simd for simd_reduction(+:tmp) nowait \n        for(i=0; i<(N-16); i++) \n        { \n            tmp += b[i] * \n \n                (((b[i+1] + \n                  b[i+2] * \n                   b[i+3]) + \n \n                    (b[i+4] + \n                     b[i+5] * \n                      b[i+6]) * \n \n                       ((b[i+7] + \n                        b[i+8] * \n                         b[i+9]) + \n \n                          (b[i+10] + \n                           b[i+11] * \n                            b[i+12]) * \n \n                             (b[i+13] + \n                                                                                                    "}
{"label": " \nvoid symmetrize_ft_complex(complex double* rhoR_b, complex double* rhoR_a, int* op, double* ft, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n  int ft_x = (int)(ft[0] * nx); \n  int ft_y = (int)(ft[1] * ny); \n  int ft_z = (int)(ft[2] * nz); \n \n#pragma omp parallel \n{ \n  int x,y,z; \n \n  #pragma omp for schedule(static) \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z + ft_x) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z + ft_y) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z + ft_z) % nz + nz) % nz; \n            rhoR_b[x*ny*nz + y*nz + z] += rhoR_a[x_p*ny*nz + y_p*nz + z_p]; \n        } \n} \n} ", "pred": " \nvoid symmetrize_ft_complex(complex double* rhoR_b, complex double* rhoR_a, int* op, double* ft, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n  int ft_x = (int)(ft[0] * nx); \n  int ft_y = (int)(ft[1] * ny); \n  int ft_z = (int)(ft[2] * nz); \n \n#pragma omp parallel \n{ \n  int x,y,z; \n \n  #pragma omp for schedule(static) \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z + ft_x) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z + ft_y) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z + ft_z) % nz + nz) % nz; \n            rhoR_b[x*ny*nz + y*nz + z] += rhoR_a[x_p*ny*nz + y_p*nz + z_p]; \n        } \n} \n} "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 32; \n  tile_size[3] = 512; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=Nt-1;t1++) { \n    lbp=ceild(t1+1,2); \n    ubp=min(floord(4*Nt+Nz-9,8),floord(4*t1+Nz-2,8)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(ceild(t1-6,8),ceild(8*t2-Nz-19,32));t3<=min(floord(4*Nt+Ny-9,32),floord(4*t1+Ny-1,32));t3++) { \n        for (t4=max(max(ceild(t1-126,128),ceild(8*t2-Nz-499,512)),ceild(32*t3-Ny-499,512));t4<=min(min(floord(4*Nt+Nx-9,512),floord(4*t1+Nx-1,512)),floord(32*t3+Nx+19,512));t4++) { \n          for (t5=max(max(max(max(0,ceild(8*t2-Nz+5,4)),ceild(32*t3-Ny+5,4)),ceild(512*t4-Nx+5,4)),t1);t5<=min(min(min(Nt-1,t1+1),8*t3+6),128*t4+126);t5++) { \n            for (t6=max(max(8*t2,4*t5+4),-8*t1+8*t2+8*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(32*t3,4*t5+4);t7<=min(32*t3+31,4*t5+Ny-5);t7++) { \n                lbv=max(512*t4,4*t5+4); \n                ubv=min(512*t4+511,4*t5+Nx-5); \n#pragma ivdep \n#pragma vector always \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((2.0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 32; \n  tile_size[3] = 8;   tile_size[4] = 32;   tile_size[5] = 32;   tile_size[6] = 32;   tile_size[7] = 32;   tile_size[8] = 32;   tile_size[9] = 32;   tile_size[10] = 32;   tile_size[11] = 32;   tile_size[12] = 32;   tile_size[13] = 32;   tile_size[14] = 32;   tile_size[15] = 32;   tile_size[16] = 32;   tile_size[17] = 32;   tile_size[18] = 32;   tile_size[19] = 32;   tile_size[20] = 32;   tile_size[21] = 32;   tile_size[22] = 32;   tile_size[23] = 32;   tile_size[24] = 32;   tile_size[25] = 32;   tile_size[26] = 32;   tile_size[27] = 32;   tile_size[28] = 32;   tile_size[29] = 32;   tile_size[30] = 32;   tile_size[31] = 32;   tile_size[32] = 32;   tile_size[33] = 32;   tile_size[34] = 32;   tile_size[35] = 32;   tile_size[36] = 32;   tile_size[37] = 32;   tile_size[38] = 32;   tile_size[39] = 32;   tile_size[40] = 32;   tile_size[41] = 32;   tile_size[42] = 32;   tile_size[43] = 32;   tile_size[44] = 32;   tile_size[45] = 32;   tile_size[46] = 32;   tile_size[47] = 32;   tile_size[48] = 32;   tile_size[49] = 32;   tile_size[50] = 32;   tile_size[51] = 32;   tile_size[52] = 32;   tile_size[53] = 32;   tile_size[54] = 32;   tile_size[55] = 32;   tile_size[56] = 32;   tile_size[57] = 32;   tile_size[58] = 32;   tile_size[59] = 32;   tile_size[60] = 32;   tile_size[61] = 32;   tile_size[62] = 32;   tile_size[63] = 32;   tile_size[64] = 32;   tile_size[65] = 32;   tile_size[66] = 32;   tile_size[67] = 32;   tile_size[68] = 32;   tile_size[69] = 32;   tile_size[70] = 32;   tile_size[72] = 32;   tile_size[73] = 32;   tile_size[73] = 32;   tile_size[74] = 32;   tile_size[75] = 32;   tile_size[76] = 32;   tile_size[77] = 32;   tile_size[78] = 32;   tile_size[78] = 32;   tile_size[79] = 32;   tile_size[80] = 32;   tile_size[81] = 32;   tile_size[81] = 32;   tile_size[82] = 32;   tile_size[83] = 32;   tile_size[83] = 32;   tile_size[84] = 32;   tile_size[85] = 32;   tile_size[86] = 32;   tile_size[86] = 32;   tile_size[87] = 32;   tile_size[88] = 32;   tile_size[89] = 32;   tile_size[90] = 32;   tile_size[91] = 32;   tile_size[92] = 32;   tile_size[93] = 32;   tile_size[93] = 32;   tile_size[93] = 32;   tile_size[94] = 32;   tile_size[95] = 32;   tile_size[96] = 32;   tile_size[96] = 32;   tile_size[97] = 32;   tile_size[98] = 32;   tile_size[99] = 32;   tile_size[100] = 32;   tile_size[101] = 32;   tile_size[102] = 32;   tile_size[103] = 32;   tile_size[104] = 32;   tile_size[105] = 32;   tile_size[106] = 32;   tile_size[106] = 32;   tile_size[107] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size[109] = 32;   tile_size"}
{"label": " \nstatic void \nmatch_domain (const char *fn1, const char *fn2, \n              definitions_ty *definitions, message_list_ty *refmlp, \n              message_list_ty *resultmlp, \n              struct statistics *stats, unsigned int *processed) \n{ \n  message_ty *header_entry; \n  unsigned long int nplurals; \n  const struct expression *plural_expr; \n  char *untranslated_plural_msgstr; \n  struct plural_distribution distribution; \n  struct search_result { message_ty *found; bool fuzzy; } *search_results; \n  size_t j; \n \n  header_entry = \n    message_list_search (definitions_current_list (definitions), NULL, \"\"); \n  extract_plural_expression (header_entry? header_entry->msgstr : NULL, \n                             &plural_expr, &nplurals); \n  untranslated_plural_msgstr = XNMALLOC (nplurals, char); \n  memset (untranslated_plural_msgstr, '\\0', nplurals); \n \n   \n \n  { \n     \n \n    void (*old_po_xerror) (int, const struct message_ty *, const char *, size_t, \n                           size_t, int, const char *) \n      = po_xerror; \n    po_xerror = silent_xerror; \n \n    if (check_plural_eval (plural_expr, nplurals, header_entry, \n                           &distribution) > 0) \n      { \n        distribution.expr = NULL; \n        distribution.often = NULL; \n        distribution.often_length = 0; \n        distribution.histogram = NULL; \n      } \n \n    po_xerror = old_po_xerror; \n  } \n \n   \n \n  search_results = XNMALLOC (refmlp->nitems, struct search_result); \n  { \n    long int nn = refmlp->nitems; \n    long int jj; \n \n     \n \n    #ifdef _OPENMP \n     #pragma omp parallel for schedule(dynamic) \n    #endif \n    for (jj = 0; jj < nn; jj++) \n      { \n        message_ty *refmsg = refmlp->item[jj]; \n        message_ty *defmsg; \n \n         \n \n        if (!quiet && verbosity_level <= 1 && *processed % DOT_FREQUENCY == 0) \n          fputc ('.', stderr); \n        #ifdef _OPENMP \n         #pragma omp atomic \n        #endif \n        (*processed)++; \n \n         \n \n        defmsg = \n          definitions_search (definitions, refmsg->msgctxt, refmsg->msgid); \n        if (defmsg!= NULL) \n          { \n            search_results[jj].found = defmsg; \n            search_results[jj].fuzzy = false; \n          } \n        else if (!is_header (refmsg) \n                  \n \n                 && use_fuzzy_matching \n                 && ((defmsg = \n                        definitions_search_fuzzy (definitions, \n                                                  refmsg->msgctxt, \n                                                  refmsg->msgid))!= NULL)) \n          { \n            search_results[jj].found = defmsg; \n            search_results[jj].fuzzy = true; \n          } \n        else \n          search_results[jj].found = NULL; \n      } \n  } \n \n  for (j = 0; j < refmlp->nitems; j++) \n    { \n      message_ty *refmsg = refmlp->item[j]; \n \n       \n \n      if (search_results[j].found!= NULL &&!search_results[j].fuzzy) \n        { \n          message_ty *defmsg = search_results[j].found; \n           \n \n          message_ty *mp = \n            message_merge (defmsg, refmsg, false, &distribution); \n \n           \n \n          if (!(for_msgfmt \n                && (mp->msgstr[0] == '\\0'  \n \n                    || (mp->is_fuzzy &&!is_header (mp)))))  \n \n            { \n              message_list_append (resultmlp, mp); \n \n               \n \n              defmsg->used = 1; \n            } \n \n          stats->merged++; \n        } \n      else if (!is_header (refmsg)) \n        { \n           \n \n          if (search_results[j].found!= NULL && search_results[j].fuzzy) \n            { \n              message_ty *defmsg = search_results[j].found; \n              message_ty *mp; \n \n              if (verbosity_level > 1) \n              ", "pred": " \nstatic void \nmatch_domain (const char *fn1, const char *fn2, \n              definitions_ty *definitions, message_list_ty *refmlp, \n              message_list_ty *resultmlp, \n              struct statistics *stats, unsigned int *processed) \n{ \n  message_ty *header_entry; \n  unsigned long int nplurals; \n  const struct expression *plural_expr; \n  char *untranslated_plural_msgstr; \n  struct plural_distribution distribution; \n  struct search_result { message_ty *found; bool fuzzy; } *search_results; \n  size_t j; \n \n  header_entry = \n    message_list_search (definitions_current_list (definitions), NULL, \"\"); \n  extract_plural_expression (header_entry? header_entry->msgstr : NULL, \n                             &plural_expr, &nplurals); \n  untranslated_plural_msgstr = XNMALLOC (nplurals, char); \n  memset (untranslated_plural_msgstr, '\\0', nplurals); \n \n   \n \n  { \n     \n \n    void (*old_po_xerror) (int, const struct message_ty *, const char *, size_t, \n                           size_t, int, const char *) \n      = po_xerror; \n    po_xerror = silent_xerror; \n \n    if (check_plural_eval (plural_expr, nplurals, header_entry, \n                           &distribution) > 0) \n      { \n        distribution.expr = NULL; \n        distribution.often = NULL; \n        distribution.often_length = 0; \n        distribution.histogram = NULL;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \nvoid THNN_(SpatialAdaptiveAveragePooling_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput) \n{ \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  int nslices; \n  int iheight; \n  int iwidth; \n  int oheight; \n  int owidth; \n  real *gradInput_data; \n  real *gradOutput_data; \n \n   \n \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n \n   \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(zero)(gradInput); \n \n  if (input->nDimension == 4) { \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n   \n \n  nslices = input->size[dimh-1]; \n  iheight = input->size[dimh]; \n  iwidth = input->size[dimw]; \n  oheight = gradOutput->size[dimh]; \n  owidth = gradOutput->size[dimw]; \n \n   \n \n  gradInput_data = THTensor_(data)(gradInput); \n  gradOutput_data = THTensor_(data)(gradOutput); \n \n   \n \n  if (input->nDimension == 3) \n  { \n    THNN_(SpatialAdaptiveAveragePooling_updateGradInput_frame)(gradInput_data, gradOutput_data, \n                                                         nslices, \n                                                         iwidth, iheight, \n                                                         owidth, oheight); \n  } \n  else \n  { \n    long p; \n#pragma omp parallel for private(p) \n    for (p = 0; p < nbatch; p++) \n    { \n      THNN_(SpatialAdaptiveAveragePooling_updateGradInput_frame)(gradInput_data+p*nslices*iwidth*iheight, gradOutput_data+p*nslices*owidth*oheight, \n                                                           nslices, \n                                                           iwidth, iheight, \n                                                           owidth, oheight); \n    } \n  } \n \n   \n \n  THTensor_(free)(gradOutput); \n} ", "pred": " \nvoid THNN_(SpatialAdaptiveAveragePooling_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput) \n{ \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  int nslices; \n  int iheight; \n  int iwidth; \n  int oheight; \n  int owidth; \n  real *gradInput_data; \n  real *gradOutput_data; \n \n   \n \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n \n   \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(zero)(gradInput); \n \n  if (input->nDimension == 4) { \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n   \n \n  nslices = input->size[dimh-1]; \n  iheight = input->size[dimh]; \n  iwidth = input->size[dimw]; \n  oheight = gradOutput->size[dimh]; \n  owidth = gradOutput->size[dimw]; \n \n   \n \n  gradInput_data = THTensor_(data)(gradInput); \n  gradOutput_data = THTensor_(data)(gradOutput); \n \n   \n \n  if (input->nDimension == 3) \n  { \n    THNN_(SpatialAdaptiveAveragePooling_updateGradInput_frame)(gradInput_data, gradOutput_data, \n                                                         nslices, \n                                                         iwidth, iheight, \n                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \nvoid symmetrize_ft(double* rhoR_b, double* rhoR_a, int* op, double* ft, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n  int ft_x = (int)(ft[0] * nx); \n  int ft_y = (int)(ft[1] * ny); \n  int ft_z = (int)(ft[2] * nz); \n \n#pragma omp parallel \n{ \n  int x,y,z; \n \n  #pragma omp for schedule(static) \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z + ft_x) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z + ft_y) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z + ft_z) % nz + nz) % nz; \n            rhoR_b[x*ny*nz + y*nz + z] += rhoR_a[x_p*ny*nz + y_p*nz + z_p]; \n        } \n} \n} ", "pred": " \nvoid symmetrize_ft(double* rhoR_b, double* rhoR_a, int* op, double* ft, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n  int ft_x = (int)(ft[0] * nx); \n  int ft_y = (int)(ft[1] * ny); \n  int ft_z = (int)(ft[2] * nz); \n \n#pragma omp parallel \n{ \n  int x,y,z; \n \n  #pragma omp for schedule(static) \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z + ft_x) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z + ft_y) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z + ft_z) % nz + nz) % nz; \n            rhoR_b[x*ny*nz + y*nz + z] += rhoR_a[x_p*ny*nz + y_p*nz + z_p]; \n        } \n} \n} "}
{"label": " \nvoid symmetrize(double* rhoR_b, double* rhoR_a, int* op, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n#pragma omp parallel \n{ \n  int x,y,z; \n \n  #pragma omp for schedule(static) \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z) % nz + nz) % nz; \n            rhoR_b[x*ny*nz + y*nz + z] += rhoR_a[x_p*ny*nz + y_p*nz + z_p]; \n        } \n} \n} ", "pred": " \nvoid symmetrize(double* rhoR_b, double* rhoR_a, int* op, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n#pragma omp parallel \n{ \n  int x,y,z; \n \n  #pragma omp for schedule(static) \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z) % nz + nz) % nz; \n            rhoR_b[x*ny*nz + y*nz + z] += rhoR_a[x_p*ny*nz + y_p*nz + z_p]; \n        } \n} \n} "}
{"label": "void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n    void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const float *const in  = (float *)ivoid; \n  float *const out = (float *)ovoid; \n  const int ch = piece->colors; \n  dt_iop_basecurve_data_t *const d = (dt_iop_basecurve_data_t *)(piece->data); \n \n   \n \n  if(d->exposure_fusion) \n  { \n     \n \n    const int wd = roi_in->width, ht = roi_in->height; \n    int num_levels = 8; \n    float **col  = malloc(num_levels * sizeof(float*)); \n    float **comb = malloc(num_levels * sizeof(float*)); \n    int w = wd, h = ht; \n    const int rad = MIN(wd, ceilf(256 * roi_in->scale / piece->iscale)); \n    int step = 1; \n    for(int k=0;k<num_levels;k++) \n    { \n       \n \n      col[k]  = dt_alloc_align(64, sizeof(float)*4ul*w*h); \n      comb[k] = dt_alloc_align(64, sizeof(float)*4ul*w*h); \n      memset(comb[k], 0, sizeof(float)*4*w*h); \n      w = (w-1)/2+1; h = (h-1)/2+1; \n      step *= 2; \n      if(step > rad || w < 4 || h < 4) \n      { \n        num_levels = k+1; \n        break; \n      } \n    } \n \n    for(int e=0;e<d->exposure_fusion+1;e++) \n    {  \n \n       \n \n      apply_ev_and_curve( \n          in, col[0], wd, ht, \n          powf(2.0f, d->exposure_stops * e), \n          d->table, d->unbounded_coeffs); \n \n       \n \n      compute_features(col[0], wd, ht); \n \n       \n \n      w = wd; h = ht; \n      gauss_reduce(col[0], col[1], out, w, h); \n#pragma omp parallel for default(none) shared(col) schedule(static) \n      for(size_t k=0;k<4ul*wd*ht;k+=4) \n        col[0][k+3] *=.1f + sqrtf(out[k]*out[k] + out[k+1]*out[k+1] + out[k+2]*out[k+2]); \n \n \n \n \n      for(size_t k=0;k<4ul*w*h;k+=4) \n        col[0][k+e] = col[0][k+3]; \n \n \n \n \n      for(size_t k=0;k<4ul*w*h;k+=4) \n        comb[0][k+e] = col[0][k+3]; \n      continue; \n \n      for(int k=1;k<num_levels;k++) \n      { \n        gauss_reduce(col[k-1], col[k], 0, w, h); \n        w = (w-1)/2+1; h = (h-1)/2+1; \n      } \n \n       \n \n      for(int k=num_levels-1;k>=0;k--) \n      { \n        w = wd; h = ht; \n        for(int i=0;i<k;i++) { w = (w-1)/2+1; h = (h-1)/2+1; } \n         \n \n        if(k!=num_levels-1) \n          gauss_expand(col[k+1], out, w, h); \n#pragma omp parallel for default(none) shared(col,comb,w,h,num_levels,k) schedule(static) \n        for(int j=0;j<h;j++) for(int i=0;i<w;i++) \n        { \n          const size_t x = 4ul*(w*j+i); \n           \n \n          if(k == num_levels-1)  \n \n            ; \n            for(int c=0;c<3;c++) \n              comb[k][x+c] += col[k][x+3] * col[k][x+c]; \n          else  \n \n            for(int c=0;c<3;c++) comb[k][x+c] += \n              col[k][x+3] * (col[k][x+c] - out[x+c]); \n          comb[k][x+3] += col[k][x+3]; \n        } \n      } \n    } \n \n \n     \n \n    for(int k=num_levels-1;k>=0;k--) \n    { \n      w = wd; h = ht; \n      for(int i=0;i<k;i++) { w = (w-1)/2+1; h = (h-1)/2+1;} \n \n       \n \n#pragma omp parallel for default(none) shared(comb,w,h,k) schedule(static) \n      for(size_t i=0;i<(size_t)4*w*h;i+=4) \n        if(comb[k][i+3] > 1e-8f) \n          for(int c=0;c<3;c++) comb[k][i+c] /= comb[k][i+3]; \n \n      if(k < num_levels-1) \n      {  \n \n        gauss_expand(comb[k+1], out, w, h); \n#pragma omp parallel for default(none) shared(comb,w,h,k) schedule(static) \n        for(int j=0;j<h;j++) for(int i", "pred": "void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n    void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const float *const in  = (float *)ivoid; \n  float *const out = (float *)ovoid; \n  const int ch = piece->colors; \n  dt_iop_basecurve_data_t *const d = (dt_iop_basecurve_data_t *)(piece->data); \n \n   \n \n  if(d->exposure_fusion) \n  { \n     \n \n    const int wd = roi_in->width, ht = roi_in->height; \n    int num_levels = 8; \n    float **col  = malloc(num_levels * sizeof(float*)); \n    float **comb = malloc(num_levels * sizeof(float*)); \n    int w = wd, h = ht; \n    const int rad = MIN(wd, ceilf(256 * roi_in->scale / piece->iscale)); \n    int step = 1; \n    for(int k=0;k<num_levels;k++) \n    { \n       \n \n      col[k]  = dt_alloc_align(64, sizeof(float)*4ul*w*h); \n      comb[k] = dt_alloc_align(64, sizeof(float)*4ul*w*h); \n      memset(comb[k], 0, sizeof(float)*4*w*h); \n      w = (w-1)/2+1; h = (h-1)/2+1; \n      step *= 2; \n      if(step > rad || w < 4 || h < 4) \n      { \n        num_levels = k+1; \n        break; \n      } \n    } \n \n    for(int e=0;e<d->exposure_fusion+1;e++)\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "}
{"label": " \nint main(int argc, char** argv) { \n    int i, j; \n    int n = Y; \n     \n     \n \n    init_array(); \n     \n     \n#pragma omp parallel for private (j) schedule(static) check \n    for (i = 0; i < n; i++) \n        for (j = 0; j < n; j++) \n            x1[i] = x1[i] + A[i][j] * y_1[j]; \n#pragma omp parallel for private (j) schedule(static) check \n    for (i = 0; i < n; i++) \n        for (j = 0; j < n; j++) \n            x2[i] = x2[i] + A[j][i] * y_2[j]; \n     \n    double total = 0; \n    for(int y=0; y<n; ++y){ \n        total+= x2[y]; \n    } \n    printf(\"Total: %f\\n\",total); \n     \n     \n     \n     \n    return 0; \n} ", "pred": " \nint main(int argc, char** argv) { \n    int i, j; \n    int n = Y; \n     \n     \n \n    init_array(); \n     \n     \n#pragma omp parallel for private (j) schedule(static) check \n    for (i = 0; i < n; i++) \n        for (j = 0; j < n; j++) \n            x1[i] = x1[i] + A[i][j] * y_1[j]; \n#pragma omp parallel for private (j) schedule(static) check \n    for (i = 0; i < n; i++) \n        for (j = 0; j < n; j++) \n            x2[i] = x2[i] + A[j][i] * y_2[j]; \n     \n    double total = 0; \n    for(int y=0; y<n; ++y){ \n        total+= x2[y]; \n    } \n    printf(\"Total: %f\\n\",total); \n     \n     \n     \n     \n    return 0; \n} "}
{"label": " \nint space_shuffle ( struct space *s ) { \n \n    int k, cid, pid, delta[3]; \n    FPTYPE h[3]; \n    struct space_cell *c, *c_dest; \n    struct particle *p; \n     \n     \n \n    for ( k = 0 ; k < 3 ; k++ ) \n        h[k] = s->h[k]; \n \n    #pragma omp parallel for schedule(static), private(cid,c,pid,p,k,delta,c_dest) \n    for ( cid = 0 ; cid < s->nr_marked ; cid++ ) { \n        c = &(s->cells[ s->cid_marked[cid] ]); \n        pid = 0; \n        while ( pid < c->count ) { \n \n            p = &( c->parts[pid] ); \n            for ( k = 0 ; k < 3 ; k++ ) \n                delta[k] = __builtin_isgreaterequal( p->x[k], h[k] ) - __builtin_isless( p->x[k], 0.0 ); \n \n             \n \n            if ( ( delta[0]!= 0 ) || ( delta[1]!= 0 ) || ( delta[2]!= 0 ) ) { \n                for ( k = 0 ; k < 3 ; k++ ) \n                    p->x[k] -= delta[k] * h[k]; \n                c_dest = &( s->cells[ space_cellid( s, \n                    (c->loc[0] + delta[0] + s->cdim[0]) % s->cdim[0],  \n                    (c->loc[1] + delta[1] + s->cdim[1]) % s->cdim[1],  \n                    (c->loc[2] + delta[2] + s->cdim[2]) % s->cdim[2] ) ] ); \n \n\t            if ( c_dest->flags & cell_flag_marked ) { \n                    pthread_mutex_lock(&c_dest->cell_mutex); \n                    space_cell_add_incomming( c_dest, p ); \n\t                pthread_mutex_unlock(&c_dest->cell_mutex); \n                    s->celllist[ p->id ] = c_dest; \n                    } \n                else { \n                    s->partlist[ p->id ] = NULL; \n                    s->celllist[ p->id ] = NULL; \n                    } \n \n                s->celllist[ p->id ] = c_dest; \n                c->count -= 1; \n                if ( pid < c->count ) { \n                    c->parts[pid] = c->parts[c->count]; \n                    s->partlist[ c->parts[pid].id ] = &( c->parts[pid] ); \n                    } \n                } \n            else \n                pid += 1; \n            } \n        } \n \n     \n \n    return space_err_ok; \n \n    } ", "pred": " \nint space_shuffle ( struct space *s ) { \n \n    int k, cid, pid, delta[3]; \n    FPTYPE h[3]; \n    struct space_cell *c, *c_dest; \n    struct particle *p; \n     \n     \n \n    for ( k = 0 ; k < 3 ; k++ ) \n        h[k] = s->h[k]; \n \n    #pragma omp parallel for schedule(static), private(cid,c,pid,p,k,delta,c_dest) \n    for ( cid = 0 ; cid < s->nr_marked ; cid++ ) { \n        c = &(s->cells[ s->cid_marked[cid] ]); \n        pid = 0; \n        while ( pid < c->count ) { \n \n            p = &( c->parts[pid] ); \n            for ( k = 0 ; k < 3 ; k++ ) \n                delta[k] = __builtin_isgreaterequal( p->x[k], h[k] ) - __builtin_isless( p->x[k], 0.0 ); \n \n             \n \n            if ( ( delta[0]!= 0 ) || ( delta[1]!= 0 ) || ( delta[2]!= 0 ) ) { \n                for ( k = 0 ; k < 3 ; k++ ) \n                    p->x[k] -= delta[k] * h[k]; \n                c_dest = &( s->cells[ space_cellid( s, \n                    (c->loc[0] + delta[0] + s->cdim[0]) % s->cdim[0],  \n                    (c->loc[1] + c->loc[1] + c->loc[2]), c->loc[2] );\\n                        if ( c->loc[1] == 0 ) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": "void mexFunction(int nlhs,mxArray *plhs[],int nrhs,const mxArray *prhs[]) \n{ \n    int sens_i,sens_j,index_i; \n    float *r_i,*r_ik,*S,*H,*M; \n    double *X_d,*S_d,*H_d,*M_d; \n    neighbour *emb_dist,*k_nn; \n     \n    const int n_samples=(int)mxGetM(prhs[0]); \n    const int n_sensors=(int)mxGetN(prhs[0]); \n    const int k=(int)mxGetScalar(prhs[1]); \n    const int m=(int)mxGetScalar(prhs[2]); \n    const int tau=(int)mxGetScalar(prhs[3]); \n    const int W=(int)mxGetScalar(prhs[4]); \n    const int n_states=n_samples-(m-1)*tau; \n    const int n_indexes=n_sensors*n_sensors; \n     \n    X_d=(double*)mxGetPr(prhs[0]); \n     \n    emb_dist=(neighbour*)mxMalloc(n_states*n_states*n_sensors*sizeof(neighbour)); \n    k_nn=(neighbour*)mxMalloc(n_states*k*n_sensors*sizeof(neighbour)); \n    r_i=(float*)mxMalloc(n_states*n_sensors*sizeof(float)); \n    r_ik=(float*)mxMalloc(n_states*n_sensors*sizeof(float)); \n     \n    init_knn(n_sensors,n_states,k,k_nn); \n \n    omp_set_num_threads(omp_get_num_procs()); \n    #pragma omp parallel private(sens_i) shared(m,tau,n_states,k,W) \n    { \n        #pragma omp for \n        for(sens_i=0;sens_i<n_sensors;sens_i++) \n            build_emb_dist(m,tau,n_states,k,W, \n                    emb_dist+sens_i*n_states*n_states, \n                    r_i+sens_i*n_states, \n                    r_ik+sens_i*n_states, \n                    k_nn+sens_i*n_states*k, \n                    X_d+sens_i*n_samples); \n    } \n \n    S=(float*)mxMalloc(n_indexes*sizeof(float)); \n    H=(float*)mxMalloc(n_indexes*sizeof(float)); \n    M=(float*)mxMalloc(n_indexes*sizeof(float)); \n \n     \n    for(sens_i=0;sens_i<n_sensors;sens_i++) \n    { \n        #pragma omp parallel private(sens_j) shared(sens_i,n_sensors,n_states,k) \n        { \n        #pragma omp for \n        for(sens_j=0;sens_j<n_sensors;sens_j++) \n        { \n            build_SHM_indexes(sens_i,sens_j,n_sensors,n_states,k, \n                    emb_dist+sens_i*n_states*n_states, \n                    k_nn+sens_j*k*n_states, \n                    r_ik+sens_i*n_states, \n                    r_i+sens_i*n_states, \n                    S,H,M); \n        } \n        } \n    } \n \n    mxFree(emb_dist); \n    mxFree(k_nn); \n    mxFree(r_i); \n    mxFree(r_ik); \n     \n    plhs[0]=mxCreateDoubleMatrix(n_sensors,n_sensors,mxREAL); \n    plhs[1]=mxCreateDoubleMatrix(n_sensors,n_sensors,mxREAL); \n    plhs[2]=mxCreateDoubleMatrix(n_sensors,n_sensors,mxREAL); \n \n    #pragma omp parallel sections private(index_i) \n    { \n        #pragma omp section \n        { \n        S_d=(double*)mxGetPr(plhs[0]); \n        for(index_i=0;index_i<n_indexes;index_i++) \n            S_d[index_i]=(double)S[index_i]; \n        } \n         \n        #pragma omp section \n        { \n            H_d=(double*)mxGetPr(plhs[1]); \n            for(index_i=0;index_i<n_indexes;index_i++) \n                H_d[index_i]=(double)H[index_i]; \n        } \n         \n        #pragma omp section \n        { \n            M_d=(double*)mxGetPr(plhs[2]); \n            for(index_i=0;index_i<n_indexes;index_i++) \n                M_d[index_i]=(double)M[index_i]; \n        } \n         \n    } \n     \n    mxFree(S); \n    mxFree(H); \n    mxFree(M); \n     \n} \n ", "pred": "void mexFunction(int nlhs,mxArray *plhs[],int nrhs,const mxArray *prhs[]) \n{ \n    int sens_i,sens_j,index_i; \n    float *r_i,*r_ik,*S,*H,*M; \n    double *X_d,*S_d,*H_d,*M_d; \n    neighbour *emb_dist,*k_nn; \n     \n    const int n_samples=(int)mxGetM(prhs[0]); \n    const int n_sensors=(int)mxGetN(prhs[0]); \n    const int k=(int)mxGetScalar(prhs[1]); \n    const int m=(int)mxGetScalar(prhs[2]); \n    const int tau=(int)mxGetScalar(prhs[3]); \n    const int W=(int)mxGetScalar(prhs[4]); \n    const int n_states=n_samples-(m-1)*tau; \n    const int n_indexes=n_sensors*n_sensors; \n     \n    X_d=(double*)mxGetPr(prhs[0]); \n     \n    emb_dist=(neighbour*)mxMalloc(n_states*n_states*n_sensors*sizeof(neighbour)); \n    k_nn=(neighbour*)mxMalloc(n_states*k*n_sensors*sizeof(neighbour)); \n    r_i=(float*)mxMalloc(n_states*n_sensors*sizeof(float)); \n    r_ik=(float*)mxMalloc(n_states*n_sensors*sizeof(float)); \n     \n    init_knn(n_sensors,n_states,k,k_nn); \n \n    omp_set_num_threads(omp_get_num_procs()); \n    #pragma omp parallel private(sens_i) shared(m,tau,n_states,k,W) \n    { \n        #pragma omp for \n        for(int i=0;i<(int)mxGetPr(prhs[0]);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nint main(int argc, char* argv[]) \n{ \n    int n[SF_MAX_DIM], dim; \n    int n1, n2, nn, nw; \n    int iw; \n    float d1, d2, o1, o2, ow, dw; \n    sf_file in, out, ref; \n    bool inv; \n    int curv, mtd, niter; \n    float x0, maxoff, mu, eta, rfreq, t1, t2; \n    char buf[8]; \n    void *h; \n \n    sf_complex **ibuf, **obuf, **rbuf=NULL; \n \n    sf_init(argc, argv); \n \n    in  = sf_input(\"in\");\t \n \n    out = sf_output(\"out\");\t \n \n \n    if (SF_COMPLEX!= sf_gettype(in))  \n\tsf_error(\"FX input need complex type\"); \n \n    dim = sf_filedims(in,n); \n    if(dim<2) sf_error(\"input dim should >= 2\"); \n    nw = n[dim-1]; \n    if(dim == 2 ) nn=1; \n    else { \n\tnn = n[1]; \n\tfor(n1=2; n1<dim-1; n1++) nn *= n[n1]; \n    } \n    n1 = n[0]; \n \n    sprintf(buf,\"o%d\",dim); \n    if (!sf_histfloat(in, buf, &ow)) sf_error(\"No o%d= in input\", dim); \n    sprintf(buf,\"d%d\",dim); \n    if (!sf_histfloat(in, buf,&dw)) sf_error(\"No d%d= in input\", dim); \n \n    if (!sf_histfloat(in,\"o1\",&o1)) sf_error(\"No o1= in input\"); \n    if (!sf_histfloat(in,\"d1\",&d1)) sf_error(\"No d1= in input\"); \n \n    if (!sf_getint(\"curv\",&curv)) curv=0; \n     \n \n    if (!sf_getbool(\"inv\",&inv)) inv=false; \n     \n \n    if (!sf_getint(\"mtd\",&mtd)) mtd=0; \n     \n \n    if(mtd>0) \n    { \n\tif (!sf_getfloat(\"mu\",&mu)) mu=0.05;  \n\t \n \n    } \n    if(mtd>1) \n    { \n\tif (!sf_getfloat(\"eta\",&eta)) eta=0.05;  \n\t \n \n\tif (!sf_getint(\"niter\",&niter)) niter=5;  \n\t \n \n    } \n    if(mtd>2) \n    { \n\tref = sf_input(\"ref\"); \n\t \n \n    } else { \n\tref = NULL; \n    } \n \n \n    if (!sf_getint(\"np\",&n2)) n2=0;  \n     \n \n    if (!sf_getfloat(\"op\",&o2)) o2=0;  \n     \n \n    if (!sf_getfloat(\"dp\",&d2)) d2=0;  \n     \n \n \n\tif(inv) \n\t{ \n\t\tt1 = fabs(o2+d2*(n2-1)); \n\t\tt2 = fabs(o2); \n\t\tmaxoff=(t1>t2?t1:t2);   \n\t}else{ \n\t\tt1 = fabs(o1+d1*(n1-1)); \n\t\tt2 = fabs(o1); \n\t\tmaxoff=(t1>t2?t1:t2);   \n\t} \n \n \n    if (!sf_getfloat(\"x0\",&x0)) x0 = maxoff;  \n     \n \n \n \n    if(n2 <= 0) sf_error(\"np should larger than 0\"); \n    sf_putint  (out, \"n1\", n2); \n    sf_putfloat(out, \"o1\", o2); \n    sf_putfloat(out, \"d1\", d2); \n \n    ibuf = sf_complexalloc2(n1, nn); \n    obuf = sf_complexalloc2(n2, nn); \n \n    if(inv) \n    {\t \n\th =\tsf_frt_init(mtd, curv, \n\t\t\t    o2/x0, d2/x0, n2, \t \n \n\t\t\t    o1, d1, n1\t\t\t\t \n \n\t    ); \n    }else{ \n\th =\tsf_frt_init(mtd, curv, \n\t\t\t    o1/x0, d1/x0, n1, \t \n \n\t\t\t    o2, d2, n2\t\t\t\t \n \n\t    ); \n\tif(mtd == 3) \n\t{ \n\t    sprintf(buf,\"o%d\",dim); \n\t    if (!sf_histfloat(ref, buf, &rfreq))  \n\t\tsf_error(\"No o%d= in input\", dim); \n\t    sf_complexread(ibuf[0], n1*nn, ref); \n\t    rbuf = sf_complexalloc2(n2, nn); \n\t    sf_fhrt(h, rfreq, ibuf, rbuf, nn, mu, eta, niter); \n\t    sf_fhrt_reg(rbuf, n2, nn, mu, eta); \n\t} \n    } \n \n#pragma omp parallel for  ordered            schedule(dynamic,5)               private(iw)                   \n    for(iw=0; iw<nw; iw++) \n    { \n\tsf_complexread(ibuf[0], n1*nn, in); \n\tif(inv)\t \n\t    sf_ifart(h, ow+dw*iw, ibuf, obuf, nn); \n\telse \n\t{ \n\t    switch(mtd) \n\t    { \n\t\tcase 1: \n\t\t    sf_firt(h, ow+dw*iw, ibuf, obuf, nn, mu); \n\t\t    break; \n\t\tcase 2: \n\t\t    sf_fhrt(h, ow+dw*iw, ibuf, obuf, nn, mu, eta, niter); \n\t\t    break; \n\t\tcase 3: \n\t\t    sf_fcrt(h, ow+dw*iw, ibuf, obuf, rbuf, nn); \n\t\t    break; \n\t\tdefault: \n\t\t    sf_fart(h, ow+dw*iw, ibuf, obuf, nn); \n\t\t    break; \n\t    } \n\t} \n \n\tsf_complexwrite(obuf[0], n", "pred": " \nint main(int argc, char* argv[]) \n{ \n    int n[SF_MAX_DIM], dim; \n    int n1, n2, nn, nw; \n    int iw; \n    float d1, d2, o1, o2, ow, dw; \n    sf_file in, out, ref; \n    bool inv; \n    int curv, mtd, niter; \n    float x0, maxoff, mu, eta, rfreq, t1, t2; \n    char buf[8]; \n    void *h; \n \n    sf_complex **ibuf, **obuf, **rbuf=NULL; \n \n    sf_init(argc, argv); \n \n    in  = sf_input(\"in\");\t \n \n    out = sf_output(\"out\");\t \n \n \n    if (SF_COMPLEX!= sf_gettype(in))  \n\tsf_error(\"FX input need complex type\"); \n \n    dim = sf_filedims(in,n); \n    if(dim<2) sf_error(\"input dim should >= 2\"); \n    nw = n[dim-1]; \n    if(dim == 2 ) nn=1; \n    else { \n\tnn = n[1]; \n\tfor(n1=2; n1<dim-1; n1++) nn *= n[n1]; \n    } \n    n1 = n[0]; \n \n    sprintf(buf,\"o%d\",dim); \n    if (!sf_histfloat(in, buf, &ow)) sf_error(\"No o%d= in input\", dim); \n    sprintf(buf,\"d%d\",dim); \n    if (!sf_histfloat(in, buf,&dw)) sf_error(\"No d%d= in input\", dim); \n \n    if (!sf_histfloat(in,\"o1\",&o1)) sf_error(\"No o1= in input\"); \n    if (!sf_histfloat(in,\"d1\",&d1)) sf_error(\"No d1= in input\"); \n \n    if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      }\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_errorpins(in, n);\\n      if (!sf_histfloat(in, buf, &ow)) sf_error"}
{"label": " \nstatic void THNN_(SpatialAdaptiveAveragePooling_updateOutput_frame)( \n          real *input_p, \n          real *output_p, \n          long nslices, \n          long iwidth, \n          long iheight, \n          long owidth, \n          long oheight, \n          long stridew, \n          long strideh, \n          long strided) \n{ \n  long k; \n#pragma omp parallel for private(k) \n  for (k = 0; k < nslices; k++) \n  { \n     \n \n    long i, j; \n    for(i = 0; i < oheight; i++) \n    { \n      int y_start = START_IND(i, oheight, iheight); \n      int y_end   = END_IND(i, oheight, iheight); \n      int kH = y_end-y_start; \n \n      for(j = 0; j < owidth; j++) \n      { \n \n        int x_start = START_IND(j, owidth, iwidth); \n        int x_end   = END_IND(j, owidth, iwidth); \n        int kW = x_end-x_start; \n \n         \n \n        real *ip = input_p   + k*strided + y_start*strideh + x_start*stridew; \n        real *op = output_p  + k*owidth*oheight + i*owidth + j; \n \n         \n \n        real sum = 0; \n        int x,y; \n        for(y = 0; y < kH; y++) \n        { \n          for(x = 0; x < kW; x++) \n          { \n            real val = *(ip + y*strideh + x*stridew); \n            sum += val; \n          } \n        } \n \n         \n \n        *op = sum / kW / kH; \n      } \n    } \n  } \n} ", "pred": " \nstatic void THNN_(SpatialAdaptiveAveragePooling_updateOutput_frame)( \n          real *input_p, \n          real *output_p, \n          long nslices, \n          long iwidth, \n          long iheight, \n          long owidth, \n          long oheight, \n          long stridew, \n          long strideh, \n          long strided) \n{ \n  long k; \n#pragma omp parallel for private(k) \n  for (k = 0; k < nslices; k++) \n  { \n     \n \n    long i, j; \n    for(i = 0; i < oheight; i++) \n    { \n      int y_start = START_IND(i, oheight, iheight); \n      int y_end   = END_IND(i, oheight, iheight); \n      int kH = y_end-y_start; \n \n      for(j = 0; j < owidth; j++) \n      { \n \n        int x_start = START_IND(j, owidth, iwidth); \n        int x_end   = END_IND(j, owidth, iwidth); \n        int kW = x_end-x_start; \n \n         \n \n        real *ip = input_p   + k*strided + y_start*strideh + x_start*stridew; \n        real *op = output_p  + k*owidth*oheight + i*owidth + j; \n \n         \n \n        real sum = 0; \n        int x,y; \n        for(y = 0; y < kH; y++) \n        { \nn                                                                                                                                                              "}
{"label": " \nvoid x_solve() \n{ \n  int i, j, k, m, n, isize; \n \n   \n \n   \n \n \n  if (timeron) timer_start(t_xsolve); \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n  isize = grid_points[0]-1; \n \n   \n \n   \n \n   \n \n  #pragma omp parallel for default(shared) shared(isize) private(i,j,k,m,n) \n  for (k = 1; k <= grid_points[2]-2; k++) { \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      for (i = 0; i <= isize; i++) { \n        tmp1 = rho_i[k][j][i]; \n        tmp2 = tmp1 * tmp1; \n        tmp3 = tmp1 * tmp2; \n         \n \n         \n \n         \n \n        fjac[i][0][0] = 0.0; \n        fjac[i][1][0] = 1.0; \n        fjac[i][2][0] = 0.0; \n        fjac[i][3][0] = 0.0; \n        fjac[i][4][0] = 0.0; \n \n        fjac[i][0][1] = -(u[k][j][i][1] * tmp2 * u[k][j][i][1]) \n          + c2 * qs[k][j][i]; \n        fjac[i][1][1] = ( 2.0 - c2 ) * ( u[k][j][i][1] / u[k][j][i][0] ); \n        fjac[i][2][1] = - c2 * ( u[k][j][i][2] * tmp1 ); \n        fjac[i][3][1] = - c2 * ( u[k][j][i][3] * tmp1 ); \n        fjac[i][4][1] = c2; \n \n        fjac[i][0][2] = - ( u[k][j][i][1]*u[k][j][i][2] ) * tmp2; \n        fjac[i][1][2] = u[k][j][i][2] * tmp1; \n        fjac[i][2][2] = u[k][j][i][1] * tmp1; \n        fjac[i][3][2] = 0.0; \n        fjac[i][4][2] = 0.0; \n \n        fjac[i][0][3] = - ( u[k][j][i][1]*u[k][j][i][3] ) * tmp2; \n        fjac[i][1][3] = u[k][j][i][3] * tmp1; \n        fjac[i][2][3] = 0.0; \n        fjac[i][3][3] = u[k][j][i][1] * tmp1; \n        fjac[i][4][3] = 0.0; \n \n        fjac[i][0][4] = ( c2 * 2.0 * square[k][j][i] - c1 * u[k][j][i][4] ) \n          * ( u[k][j][i][1] * tmp2 ); \n        fjac[i][1][4] = c1 *  u[k][j][i][4] * tmp1  \n          - c2 * ( u[k][j][i][1]*u[k][j][i][1] * tmp2 + qs[k][j][i] ); \n        fjac[i][2][4] = - c2 * ( u[k][j][i][2]*u[k][j][i][1] ) * tmp2; \n        fjac[i][3][4] = - c2 * ( u[k][j][i][3]*u[k][j][i][1] ) * tmp2; \n        fjac[i][4][4] = c1 * ( u[k][j][i][1] * tmp1 ); \n \n        njac[i][0][0] = 0.0; \n        njac[i][1][0] = 0.0; \n        njac[i][2][0] = 0.0; \n        njac[i][3][0] = 0.0; \n        njac[i][4][0] = 0.0; \n \n        njac[i][0][1] = - con43 * c3c4 * tmp2 * u[k][j][i][1]; \n        njac[i][1][1] =   con43 * c3c4 * tmp1; \n        njac[i][2][1] =   0.0; \n        njac[i][3][1] =   0.0; \n        njac[i][4][1] =   0.0; \n \n        njac[i][0][2] = - c3c4 * tmp2 * u[k][j][i][2]; \n        njac[i][1][2] =   0.0; \n        njac[i][2][2] =   c3c4 * tmp1; \n        njac[i][3][2] =   0.0; \n        njac[i][4][2] =   0.0; \n \n        njac[i][0][3] = - c3c4 * tmp2 * u[k][j][i][3]; \n        njac[i][1][3] =   0.0; \n        njac[i][2][3] =   0.0; \n        njac[i][3][3] =   c3c4 * tmp1; \n        njac[i][4][3] =   0.0; \n \n        njac[i][0][4] = - ( con43 * c3c4 \n            - c1345 ) * tmp3 * (u[k][j][i][1]*u[k][j][i][1]) \n          - ( c3c4 - c1345 ) * tmp3 * (u[k][j][i][2]*u[k][j][i][2]) \n          - ( c3c4 - c1345 ) * tmp3 * (u[k][j][i][3]*u[k][j][i][3]) \n          - c1345 * tmp2 * u[k][j][i][4]; \n \n    ", "pred": " \nvoid x_solve() \n{ \n  int i, j, k, m, n, isize; \n \n   \n \n   \n \n \n  if (timeron) timer_start(t_xsolve); \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n  isize = grid_points[0]-1; \n \n   \n \n   \n \n   \n \n  #pragma omp parallel for default(shared) shared(isize) private(i,j,k,m,n) \n  for (k = 1; k <= grid_points[2]-2; k++) { \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      for (i = 0; i <= isize; i++) { \n        tmp1 = rho_i[k][j][i]; \n        tmp2 = tmp1 * tmp1; \n        tmp3 = tmp1 * tmp2; \n         \n \n         \n \n         \n \n        fjac[i][0][0] = 0.0; \n        fjac[i][1][0] = 1.0; \n        fjac[i][2][0] = 0.0; \n        fjac[i][3][0] = 0.0; \n        fjac[i][4][0] = 0.0; \n \n        fjac[i][0][1] = -(u[k][j][i][1] * tmp2 * u[k][j][i][1]) \n          + c2 * qs[k][j][i]; \n        fjac[i][1][1] = ( 2.0 - c2 ) * ( u[k][j][i][1] / u[k][j][i][0] ); \n        fjac[i][2][1] = - c2 * ( u[k][j][i][2] * tmp1 );\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": " \nint test_loop_outer2(test_data *td) { \n \n     int i; \n \n     int count; \n \n     test_xrtm_data *test_xrtm; \n \n     test_xrtm_data **test_xrtm_array; \n \n     count = list_count(&td->test_xrtm_list); \n \n     test_xrtm_array = malloc(count * sizeof(test_xrtm_data *)); \n \n     i = 0; \n     list_for_each(&td->test_xrtm_list, test_xrtm) { \n          test_xrtm_array[i] = test_xrtm; \n          ++i; \n     } \n#pragma omp parallel \n{ \n#pragma omp for \n     for (i = 0; i < count; ++i) { \n \n \n          if (test_loop_inner(td, i, test_xrtm_array[i])) { \n               fprintf(stderr, \"ERROR: test_loop_inner()\\n\"); \n               exit(1); \n          } \n     } \n} \n \n     free(test_xrtm_array); \n \n     return 0; \n} ", "pred": " \nint test_loop_outer2(test_data *td) { \n \n     int i; \n \n     int count; \n \n     test_xrtm_data *test_xrtm; \n \n     test_xrtm_data **test_xrtm_array; \n \n     count = list_count(&td->test_xrtm_list); \n \n     test_xrtm_array = malloc(count * sizeof(test_xrtm_data *)); \n \n     i = 0; \n     list_for_each(&td->test_xrtm_list, test_xrtm) { \n          test_xrtm_array[i] = test_xrtm; \n          ++i; \n     } \n#pragma omp parallel \n{ \n#pragma omp for \n     for (i = 0; i < count; ++i) { \n \n \n          if (test_loop_inner(td, i, test_xrtm_array[i])) { \n               fprintf(stderr, \"ERROR: test_loop_inner()\\n\"); \n               exit(1); \n          } \n     } \n} \n \n     free(test_xrtm_array); \n \n     return 0; \n} "}
{"label": " \nint space_shuffle_local ( struct space *s ) { \n \n    int k, cid, pid, delta[3]; \n    FPTYPE h[3]; \n    struct space_cell *c, *c_dest; \n    struct particle *p; \n     \n     \n \n    for ( k = 0 ; k < 3 ; k++ ) \n        h[k] = s->h[k]; \n \n    #pragma omp parallel for schedule(static), private(cid,c,pid,p,k,delta,c_dest) \n    for ( cid = 0 ; cid < s->nr_real ; cid++ ) { \n        c = &(s->cells[ s->cid_real[cid] ]); \n        pid = 0; \n        while ( pid < c->count ) { \n \n            p = &( c->parts[pid] ); \n            for ( k = 0 ; k < 3 ; k++ ) \n                delta[k] = __builtin_isgreaterequal( p->x[k], h[k] ) - __builtin_isless( p->x[k], 0.0 ); \n \n             \n \n            if ( ( delta[0]!= 0 ) || ( delta[1]!= 0 ) || ( delta[2]!= 0 ) ) { \n             \n                for ( k = 0 ; k < 3 ; k++ ) \n                    p->x[k] -= delta[k] * h[k]; \n                c_dest = &( s->cells[ space_cellid( s, \n                    (c->loc[0] + delta[0] + s->cdim[0]) % s->cdim[0],  \n                    (c->loc[1] + delta[1] + s->cdim[1]) % s->cdim[1],  \n                    (c->loc[2] + delta[2] + s->cdim[2]) % s->cdim[2] ) ] ); \n \n\t            if ( c_dest->flags & cell_flag_marked ) { \n                    pthread_mutex_lock(&c_dest->cell_mutex); \n                    space_cell_add_incomming( c_dest, p ); \n\t                pthread_mutex_unlock(&c_dest->cell_mutex); \n                    s->celllist[ p->id ] = c_dest; \n                    } \n                else { \n                    s->partlist[ p->id ] = NULL; \n                    s->celllist[ p->id ] = NULL; \n                    } \n                s->celllist[ p->id ] = c_dest; \n                 \n                c->count -= 1; \n                if ( pid < c->count ) { \n                    c->parts[pid] = c->parts[c->count]; \n                    s->partlist[ c->parts[pid].id ] = &( c->parts[pid] ); \n                    } \n                } \n            else \n                pid += 1; \n            } \n        } \n \n     \n \n    return space_err_ok; \n \n    } ", "pred": " \nint space_shuffle_local ( struct space *s ) { \n \n    int k, cid, pid, delta[3]; \n    FPTYPE h[3]; \n    struct space_cell *c, *c_dest; \n    struct particle *p; \n     \n     \n \n    for ( k = 0 ; k < 3 ; k++ ) \n        h[k] = s->h[k]; \n \n    #pragma omp parallel for schedule(static), private(cid,c,pid,p,k,delta,c_dest) \n    for ( cid = 0 ; cid < s->nr_real ; cid++ ) { \n        c = &(s->cells[ s->cid_real[cid] ]); \n        pid = 0; \n        while ( pid < c->count ) { \n \n            p = &( c->parts[pid] ); \n            for ( k = 0 ; k < 3 ; k++ ) \n                delta[k] = __builtin_isgreaterequal( p->x[k], h[k] ) - __builtin_isless( p->x[k], 0.0 ); \n \n             \n \n            if ( ( delta[0]!= 0 ) || ( delta[1]!= 0 ) || ( delta[2]!= 0 ) ) { \n             \n                for ( k = 0 ; k < 3 ; k++ ) \n                    p->x[k] -= delta[k] * h[k]; \n                c_dest = &( s->cells[ space_cellid( s, \n                    (c->loc[0] + delta[0] + s->cdim[0]) % s->cdim[0],  \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           "}
{"label": " \nstatic void process_lch_xtrans(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                               void *const ovoid, const dt_iop_roi_t *const roi_in, \n                               const dt_iop_roi_t *const roi_out, const float clip) \n{ \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(clip, ivoid, ovoid, roi_in, roi_out, xtrans)    schedule(static) \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    float *out = (float *)ovoid + (size_t)roi_out->width * j; \n    float *in = (float *)ivoid + (size_t)roi_in->width * j; \n \n     \n \n     \n \n     \n \n    int cl = 0; \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n       \n \n      cl = (cl << 1) & 6; \n      if(j >= 2 && j <= roi_out->height - 3) \n      { \n        cl |= (in[-roi_in->width] > clip) | (in[0] > clip) | (in[roi_in->width] > clip); \n      } \n \n      if(i < 2 || i > roi_out->width - 3 || j < 2 || j > roi_out->height - 3) \n      { \n         \n \n        out[0] = MIN(clip, in[0]); \n      } \n      else \n      { \n         \n \n        int clipped = (in[0] > clip); \n        if(!clipped) \n        { \n          clipped = cl; \n          if(clipped) \n          { \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n            for(int offset_j = -2; offset_j <= 0; offset_j++) \n            { \n              for(int offset_i = -2; offset_i <= 0; offset_i++) \n              { \n                if(clipped) \n                { \n                  clipped = 0; \n                  for(int jj = offset_j; jj <= offset_j + 2; jj++) \n                  { \n                    for(int ii = offset_i; ii <= offset_i + 2; ii++) \n                    { \n                      const float val = in[(ssize_t)jj * roi_in->width + ii]; \n                      clipped = (clipped || (val > clip)); \n                    } \n                  } \n                } \n              } \n            } \n          } \n        } \n \n        if(clipped) \n        { \n          float mean[3] = { 0.0f, 0.0f, 0.0f }; \n          int cnt[3] = { 0, 0, 0 }; \n          float RGBmax[3] = { -FLT_MAX, -FLT_MAX, -FLT_MAX }; \n \n          for(int jj = -1; jj <= 1; jj++) \n          { \n            for(int ii = -1; ii <= 1; ii++) \n            { \n              const float val = in[(ssize_t)jj * roi_in->width + ii]; \n              const int c = FCxtrans(j+jj, i+ii, roi_in, xtrans); \n              mean[c] += val; \n              cnt[c]++; \n              RGBmax[c] = MAX(RGBmax[c], val); \n            } \n          } \n \n          const float Ro = MIN(mean[0]/cnt[0], clip); \n          const float Go = MIN(mean[1]/cnt[1], clip); \n          const float Bo = MIN(mean[2]/cnt[2], clip); \n \n          const float R = RGBmax[0]; \n          const float G = RGBmax[1]; \n          const float B = RGBmax[2]; \n \n          const float L = (R + G + B) / 3.0f; \n \n          float C = SQRT3 * (R - G); \n          float H = 2.0f * B - G - R; \n \n          const float Co = SQRT3 * (Ro - Go); \n          const float Ho = 2.0f * Bo - Go - Ro; \n \n          if(R!= G && G!= B) \n          { \n            const float ratio = sqrtf((Co * Co", "pred": " \nstatic void process_lch_xtrans(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                               void *const ovoid, const dt_iop_roi_t *const roi_in, \n                               const dt_iop_roi_t *const roi_out, const float clip) \n{ \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(clip, ivoid, ovoid, roi_in, roi_out, xtrans)    schedule(static) \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    float *out = (float *)ovoid + (size_t)roi_out->width * j; \n    float *in = (float *)ivoid + (size_t)roi_in->width * j; \n \n     \n \n     \n \n     \n \n    int cl = 0; \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n       \n \n      cl = (cl << 1) & 6; \n      if(j >= 2 && j <= roi_out->height - 3) \n      { \n        cl |= (in[-roi_in->width] > clip) | (in[0] > clip) | (in[roi_in->width] > clip); \n      } \n \n      if(i < 2 || i > roi_out->width - 3 || j < 2 || j > roi_out->height - 3) \n      { \n         \n \n        out[0] = MIN(clip, in[0]); \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         "}
{"label": " \nvoid update_gauge(const double step, hamiltonian_field_t * const hf) { \n  double atime, etime; \n  atime = gettime(); \n  MG_update_gauge(step); \n \n#define static \n#pragma omp parallel \n  { \n  int i,mu; \n  static su3 v,w; \n  su3 *z; \n  static su3adj deriv; \n  su3adj *xm; \n#pragma pomp inst begin(updategauge) \n \n#undef static \n \n#pragma omp for \n  for(i = 0; i < VOLUME; i++) {  \n    for(mu = 0; mu < 4; mu++){ \n       \n \n      xm = &hf->momenta[i][mu]; \n      z = &hf->gaugefield[i][mu]; \n      _su3adj_assign_const_times_su3adj(deriv, step, *xm); \n      exposu3(&w,&deriv); \n      restoresu3(&v,&w); \n      _su3_times_su3(w, v, *z); \n      restoresu3(&v,&w); \n      _su3_assign(*z, v); \n    } \n  } \n \n  }  \n \n   \n   \n \n  xchange_gauge(hf->gaugefield); \n   \n   \n \n  convert_32_gauge_field(g_gauge_field_32, hf->gaugefield, VOLUMEPLUSRAND + g_dbw2rand); \n   \n   \n \n  hf->update_gauge_copy = 1; \n  g_update_gauge_copy = 1; \n  g_update_gauge_copy_32 = 1; \n \n  etime = gettime(); \n  if(g_debug_level > 1 && g_proc_id == 0) { \n    printf(\"# Time gauge update: %e s\\n\", etime-atime);  \n  }  \n  return; \n#pragma pomp inst end(updategauge) \n} ", "pred": " \nvoid update_gauge(const double step, hamiltonian_field_t * const hf) { \n  double atime, etime; \n  atime = gettime(); \n  MG_update_gauge(step); \n \n#define static \n#pragma omp parallel \n  { \n  int i,mu; \n  static su3 v,w; \n  su3 *z; \n  static su3adj deriv; \n  su3adj *xm; \n#pragma pomp inst begin(updategauge) \n \n#undef static \n \n#pragma omp for \n  for(i = 0; i < VOLUME; i++) {  \n    for(mu = 0; mu < 4; mu++){ \n       \n \n      xm = &hf->momenta[i][mu]; \n      z = &hf->gaugefield[i][mu]; \n      _su3adj_assign_const_times_su3adj(deriv, step, *xm); \n      exposu3(&w,&deriv); \n      restoresu3(&v,&w); \n      _su3_times_su3(w, v, *z); \n      restoresu3(&v,&w); \n      _su3_assign(*z, v); \n    } \n  } \n \n  }  \n \n   \n   \n \n  xchange_gauge(hf->gaugefield); \n   \n   \n \n  convert_32_gauge_field(g_gauge_field_32, hf->gaugefield, VOLUMEPLUSRAND + g_dbw2rand); \n   \n   \n \n  hf->update_gauge_copy = 1; \n  g_update_gauge_copy = 1; \n  g_update_gauge_copy_32 = 1; \n \n  etime = gettime(); \n  if(g_debug_level > 1 && g_proc_id == 0) { \n    printf(\"# Time gauge update: %e s\\n\", etime-atime);  \n  }  \n  return; \n{\"\\n               "}
{"label": " \nint __interpolate_interp2d_gsl(int nx, const double *x, \n                               int ny, const double *y, \n                               int nxy, const double *v, \n                               int nxq, const double *xq, \n                               int nyq, const double *yq, \n                               int nxyq, double *vq, \n                               enum interp2d_type_enum method, \n                               bool lqpts_grid) \n{ \n    const char *fcnm = \"__interpolate_interp2d_gsl\\0\"; \n    gsl_interp_accel *xacc, *yacc; \n    gsl_interp2d *work; \n    double *xs, *ys, xint, xmax, xmin, yint, ymax, ymin; \n    int gsl_err, ierr, indx, ix, ixq, iy, iyq, jndx; \n     \n \n    xs = NULL; \n    ys = NULL; \n     \n \n    ierr =-1; \n    if (nx < 2 || ny < 2 || nxy!= nx*ny) \n    { \n        if (nx < 1){log_errorF(\"%s: Error no data points in x!\\n\", fcnm);} \n        if (ny < 1){log_errorF(\"%s: Error no data points in y!\\n\", fcnm);} \n        if (method!= NEAREST2D){ \n            log_errorF(\"%s: Insufficient number of points in x!\\n\", fcnm); \n        } \n        if (nxy!= nx*ny){ \n            log_errorF(\"%s: Error size of v is inconsistent (%d!= %d x %d)\\n\", \n                        fcnm, nxy, nx, ny); \n        } \n        goto ERROR;  \n    } \n    if (nxq < 1 || nyq < 1) \n    { \n        if (nxq < 1){log_errorF(\"%s: Error x interp points\\n\", fcnm);} \n        if (nyq < 1){log_errorF(\"%s: Error y interp points\\n\", fcnm);} \n        goto ERROR; \n    } \n    if (lqpts_grid){ \n        if (nxyq!= nxq*nyq){ \n            log_errorF(\"%s: Size of vq is inconstient (%d!= %d x %d)\\n\", \n                       fcnm, nxyq, nxq, nyq); \n            goto ERROR; \n        } \n    }else{ \n        if (nxyq!= nxq || nxyq!= nyq){ \n            log_errorF(\"%s: Size of vq is inconsitent (%d, %d!= %d\\n\", \n                       fcnm, nxq, nyq, nxyq); \n            goto ERROR; \n        } \n    } \n    ierr =-2; \n    if (x  == NULL ||  y == NULL ||  v == NULL || \n        xq == NULL || yq == NULL || vq == NULL) \n    { \n        if (x == NULL){log_errorF(\"%s: Error x null pointer!\\n\", fcnm);} \n        if (y == NULL){log_errorF(\"%s: Error y null pointer!\\n\", fcnm);} \n        if (v == NULL){log_errorF(\"%s: Error v null pointer!\\n\", fcnm);} \n        if (xq == NULL){log_errorF(\"%s: Error xq null pointer!\\n\", fcnm);} \n        if (yq == NULL){log_errorF(\"%s: Error yq null pointer!\\n\", fcnm);} \n        if (vq == NULL){log_errorF(\"%s: Error vq null pointer!\\n\", fcnm);} \n        goto ERROR;  \n    } \n    ierr =-3; \n    if (method == NEAREST2D) \n    { \n        if (nxy < 1){ \n            log_errorF(\"%s: Too few points %d for nearest neighbor interp\\n\", \n                       fcnm); \n            goto ERROR;  \n        } \n    } \n    else if (method == BILINEAR) \n    { \n        if (nxy < gsl_interp2d_bilinear->min_size){ \n            log_errorF(\"%s: Too few points %d for bilinear interp\\n\", \n                       fcnm, nxy); \n            goto ERROR;  \n        } \n    } \n    else if (method == BICUBIC) \n    { \n        if (nxy < gsl_interp2d_bicubic->min_size){ \n            log_errorF(\"%s: Too few points %d for bicubic interp\\n\", \n                       fcnm, nxy); \n            goto ERROR; \n        }  \n    } \n    else \n    { \n        ierr =-4; \n        log_errorF(\"%s: Invalid interpolation type\\n\", fcnm); \n        goto ERROR; \n    } \n     \n \n    ierr =-5; \n", "pred": " \nint __interpolate_interp2d_gsl(int nx, const double *x, \n                               int ny, const double *y, \n                               int nxy, const double *v, \n                               int nxq, const double *xq, \n                               int nyq, const double *yq, \n                               int nxyq, double *vq, \n                               enum interp2d_type_enum method, \n                               bool lqpts_grid) \n{ \n    const char *fcnm = \"__interpolate_interp2d_gsl\\0\"; \n    gsl_interp_accel *xacc, *yacc; \n    gsl_interp2d *work; \n    double *xs, *ys, xint, xmax, xmin, yint, ymax, ymin; \n    int gsl_err, ierr, indx, ix, ixq, iy, iyq, jndx; \n     \n \n    xs = NULL; \n    ys = NULL; \n     \n \n    ierr =-1; \n    if (nx < 2 || ny < 2 || nxy!= nx*ny) \n    { \n        if (nx < 1){log_errorF(\"%s: Error no data points in x!\\n\", fcnm);} \n        if (ny < 1){log_errorF(\"%s: Error no data points in y!\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \nvoid selectionSort(int* A, int n){ \n\t \n\tfor(int startpos =0; startpos < n; startpos++){ \n\t\t \n \n\t\tstruct Compare max; \n         \n \n        max.val = A[startpos]; \n        max.index = startpos; \n \n         \n \n        #pragma omp parallel for reduction(maximum:max) \n\t\tfor(int i=startpos +1; i< n; ++i){ \n\t\t\tif(A[i] > max.val){ \n\t\t\t\tmax.val = A[i]; \n\t\t\t\tmax.index = i; \n\t\t\t} \n\t\t} \n \n\t\tswap(&A[startpos], &A[max.index]); \n\t} \n} ", "pred": " \nvoid selectionSort(int* A, int n){ \n\t \n\tfor(int startpos =0; startpos < n; startpos++){ \n\t\t \n \n\t\tstruct Compare max; \n         \n \n        max.val = A[startpos]; \n        max.index = startpos; \n \n         \n \n        #pragma omp parallel for reduction(maximum:max) \n\t\tfor(int i=startpos +1; i< n; ++i){ \n\t\t\tif(A[i] > max.val){ \n\t\t\t\tmax.val = A[i]; \n\t\t\t\tmax.index = i; \n\t\t\t} \n\t\t} \n \n\t\tswap(&A[startpos], &A[max.index]); \n\t} \n} "}
{"label": " \nstatic void THNN_(VolumetricMaxPooling_updateOutput_frame)( \n          real *input_p, \n          real *output_p, \n          real *indz_p, \n          long nslices, \n          long itime, \n          long iwidth, \n          long iheight, \n          long otime, \n          long owidth, \n          long oheight, \n          int kT, \n          int kW, \n          int kH, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH) \n{ \n  long k; \n#pragma omp parallel for private(k) \n  for (k = 0; k < nslices; k++) \n  { \n     \n \n    long i, j, ti; \n    for (ti = 0; ti < otime; ti++) \n    { \n      for (i = 0; i < oheight; i++) \n      { \n        for (j = 0; j < owidth; j++) \n        { \n           \n \n \n          long start_t = ti * dT - pT; \n          long start_h = i * dH - pH; \n          long start_w = j * dW - pW; \n \n          long kernel_t = fminf(kT, kT + start_t); \n          long kernel_h = fminf(kH, kH + start_h); \n          long kernel_w = fminf(kW, kW + start_w); \n \n          start_t = fmaxf(start_t, 0); \n          start_h = fmaxf(start_h, 0); \n          start_w = fmaxf(start_w, 0); \n \n          real *ip = input_p + k * itime * iwidth * iheight \n            + start_t * iwidth * iheight + start_h * iwidth + start_w; \n          real *op = output_p + k * otime * owidth * oheight \n            + ti * owidth * oheight + i * owidth + j; \n          real *indzp = indz_p + k * otime * owidth * oheight \n            + ti * owidth * oheight + i * owidth + j; \n \n           \n \n          real maxval = -THInf; \n          int x,y,z; \n          int mx, my, mz; \n \n          for (z = 0; z < kernel_t; z++) \n          { \n            for (y = 0; y < kernel_h; y++) \n            { \n              for (x = 0; x < kernel_w; x++) \n              { \n                if ((start_t + z < itime) && (start_h + y < iheight) && (start_w + x < iwidth)) \n                { \n                  real val = *(ip + z * iwidth * iheight + y * iwidth + x); \n                  if (val > maxval) \n                  { \n                    maxval = val; \n                     \n \n                    mz = z + (kT - kernel_t); \n                    my = y + (kH - kernel_h); \n                    mx = x + (kW - kernel_w); \n                  } \n                } \n              } \n            } \n          } \n \n           \n \n          ((unsigned char*)(indzp))[0] = mz; \n          ((unsigned char*)(indzp))[1] = my; \n          ((unsigned char*)(indzp))[2] = mx; \n          ((unsigned char*)(indzp))[3] = 0; \n \n           \n \n          *op = maxval; \n        } \n      } \n    } \n  } \n} ", "pred": " \nstatic void THNN_(VolumetricMaxPooling_updateOutput_frame)( \n          real *input_p, \n          real *output_p, \n          real *indz_p, \n          long nslices, \n          long itime, \n          long iwidth, \n          long iheight, \n          long otime, \n          long owidth, \n          long oheight, \n          int kT, \n          int kW, \n          int kH, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH) \n{ \n  long k; \n#pragma omp parallel for private(k) \n  for (k = 0; k < nslices; k++) \n  { \n     \n \n    long i, j, ti; \n    for (ti = 0; ti < otime; ti++) \n    { \n      for (i = 0; i < oheight; i++) \n      { \n        for (j = 0; j < owidth; j++) \n        { \n           \n \n \n          long start_t = ti * dT - pT; \n          long start_h = i * dH - pH; \n          long start_w = j * dW - pW; \n \n          long kernel_t = fminf(kT, kT + start_t); \n          long kernel_h = fminf(kH, kT + start_t);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": " \nint test_omp_for_schedule_guided() \n{ \n  int * tids; \n  int * chunksizes; \n  int notout; \n  int maxiter; \n  int threads; \n  int i; \n  int result; \n \n  tids = (int *) malloc (sizeof (int) * (CFSMAX_SIZE + 1)); \n  maxiter = 0; \n  result = 1; \n  notout = 1; \n \n   \n \n  #pragma omp parallel \n  { \n    #pragma omp single \n    { \n      threads = omp_get_num_threads(); \n    } \n  } \n \n   \n \n  if (threads < 2) { \n    omp_set_num_threads(2); \n    threads = 2; \n  } \n \n   \n \n  #pragma omp parallel shared(tids,maxiter) \n  {   \n \n    double count; \n    int tid; \n    int j; \n \n    tid = omp_get_thread_num (); \n \n    #pragma omp for nowait schedule(guided) \n    for(j = 0; j < CFSMAX_SIZE; ++j) { \n      count = 0.; \n      #pragma omp flush(maxiter) \n      if (j > maxiter) { \n        #pragma omp critical \n        { \n          maxiter = j; \n        } \n      } \n       \n \n      #pragma omp flush(maxiter,notout) \n      while (notout && (count < MAX_TIME) && (maxiter == j)) { \n        #pragma omp flush(maxiter,notout) \n        my_sleep (SLEEPTIME); \n        count += SLEEPTIME; \n        printf(\".\"); \n      } \n      if (count > 0.) printf(\" waited %lf s\\n\", count); \n       \n \n      tids[j] = tid; \n      printf(\"%d finished by %d\\n\",j,tid); \n    }  \n \n    notout = 0; \n    #pragma omp flush(maxiter,notout) \n  }  \n \n \n   \n \n  { \n    int determined_chunksize = 1; \n    int last_threadnr = tids[0]; \n    int global_chunknr = 0; \n    int openwork = CFSMAX_SIZE; \n    int expected_chunk_size; \n    int* local_chunknr = (int*)malloc(threads * sizeof(int)); \n    double c = 1; \n \n    for (i = 0; i < threads; i++) \n      local_chunknr[i] = 0; \n \n    tids[CFSMAX_SIZE] = -1; \n \n     \n \n     \n \n    for(i = 1; i <= CFSMAX_SIZE; ++i) { \n      if (last_threadnr==tids[i]) { \n        determined_chunksize++; \n      } else { \n         \n \n        global_chunknr++; \n        local_chunknr[last_threadnr]++; \n        last_threadnr = tids[i]; \n        determined_chunksize = 1; \n      } \n    } \n     \n \n    chunksizes = (int*)malloc(global_chunknr * sizeof(int)); \n \n     \n \n    global_chunknr = 0; \n    determined_chunksize = 1; \n    last_threadnr = tids[0]; \n    for (i = 1; i <= CFSMAX_SIZE; ++i) { \n       \n \n      if (last_threadnr == tids[i]) { \n        determined_chunksize++; \n      } else { \n        chunksizes[global_chunknr] = determined_chunksize; \n        global_chunknr++; \n        local_chunknr[last_threadnr]++; \n        last_threadnr = tids[i]; \n        determined_chunksize = 1; \n      } \n    } \n \n    fprintf(stderr, \"found\\texpected\\tconstant\\n\"); \n \n     \n \n    expected_chunk_size = openwork / threads; \n    c = (double) chunksizes[0] / expected_chunk_size; \n \n    for (i = 0; i < global_chunknr; i++) { \n       \n \n      if (expected_chunk_size > 1) \n        expected_chunk_size = c * openwork / threads; \n      fprintf(stderr, \"%8d\\t%8d\\t%lf\\n\", chunksizes[i], \n        expected_chunk_size, c * chunksizes[i]/expected_chunk_size); \n       \n \n      if (abs (chunksizes[i] - expected_chunk_size) >= 2) { \n        result = 0; \n        fprintf(stderr, \"Chunksize differed from expected \" \n          \"value: %d instead of %d\\n\", chunksizes[i], \n          expected_chunk_size); \n        return 0; \n      }  \n \n \n      if (expected_chunk_size - chunksizes[i] < 0) \n        fprintf(stderr, \"Chunksize did not decrease: %d\" \n          \" instead of %d\\n\", chunksizes[i],expected_chunk_size); \n \n       \n \n      openwork -= chunksizes[i]; \n    } \n  } \n  return result; \n} ", "pred": " \nint test_omp_for_schedule_guided() \n{ \n  int * tids; \n  int * chunksizes; \n  int notout; \n  int maxiter; \n  int threads; \n  int i; \n  int result; \n \n  tids = (int *) malloc (sizeof (int) * (CFSMAX_SIZE + 1)); \n  maxiter = 0; \n  result = 1; \n  notout = 1; \n \n   \n \n  #pragma omp parallel \n  { \n    #pragma omp single \n    { \n      threads = omp_get_num_threads(); \n    } \n  } \n \n   \n \n  if (threads < 2) { \n    omp_set_num_threads(2); \n    threads = 2; \n  } \n \n   \n \n  #pragma omp parallel shared(tids,maxiter) \n  {   \n \n    double count; \n    int tid; \n    int j; \n \n    tid = omp_get_thread_num (); \n \n    #pragma omp for nowait schedule(guided) \n    for(j = 0; j < CFSMAX_SIZE; ++j) { \n      count = 0.; \n      #pragma omp flush(maxiter) \n      if (j > maxiter) { \n        #pragma omp critical \n        { \n          maxiter = j; \n        } \n      } \n       \n \n      #pragma omp flush(maxiter,notout) \n      while (notout && (count < MAX_TIME) && (maxiter == j)) { \n        #pragma omp flush(maxiter,notout) \n        my_sleep (SLEEPTIME); \n        count += SLEEPTIME; \n        printf(\".\"); \n      } \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": "t main(int argc, char *argv[]) \n{ \n    struct pngquant_options options = { \n       .floyd = 1.f,  \n \n    }; \n    options.liq = liq_attr_create(); \n \n    if (!options.liq) { \n        fputs(\"SSE-capable CPU is required for this build.\\n\", stderr); \n        return WRONG_ARCHITECTURE; \n    } \n \n    unsigned int error_count=0, skipped_count=0, file_count=0; \n    pngquant_error latest_error=SUCCESS; \n    const char *newext = NULL, *output_file_path = NULL; \n \n    fix_obsolete_options(argc, argv); \n \n    int opt; \n    do { \n        opt = getopt_long(argc, argv, \"Vvqfhs:Q:o:\", long_options, NULL); \n        switch (opt) { \n            case 'v': \n                options.verbose = true; \n                break; \n            case 'q': \n                options.verbose = false; \n                break; \n \n            case arg_floyd: \n                options.floyd = optarg? atof(optarg) : 1.0; \n                if (options.floyd < 0 || options.floyd > 1.f) { \n                    fputs(\"--floyd argument must be in 0..1 range\\n\", stderr); \n                    return INVALID_ARGUMENT; \n                } \n                break; \n            case arg_ordered: options.floyd = 0; break; \n \n            case 'f': options.force = true; break; \n            case arg_no_force: options.force = false; break; \n \n            case arg_ext: newext = optarg; break; \n            case 'o': \n                if (output_file_path) { \n                    fputs(\"--output option can be used only once\\n\", stderr); \n                    return INVALID_ARGUMENT; \n                } \n                output_file_path = optarg; break; \n \n            case arg_iebug: \n                 \n \n                liq_set_min_opacity(options.liq, 238); \n                options.ie_mode = true; \n                break; \n \n            case arg_transbug: \n                liq_set_last_index_transparent(options.liq, true); \n                break; \n \n            case arg_skip_larger: \n                options.skip_if_larger = true; \n                break; \n \n            case 's': \n                { \n                    int speed = atoi(optarg); \n                    if (speed >= 10) { \n                        options.fast_compression = true; \n                    } \n                    if (speed == 11) { \n                        options.floyd = 0; \n                        speed = 10; \n                    } \n                    if (LIQ_OK!= liq_set_speed(options.liq, speed)) { \n                        fputs(\"Speed should be between 1 (slow) and 11 (fast).\\n\", stderr); \n                        return INVALID_ARGUMENT; \n                    } \n                } \n                break; \n \n            case 'Q': \n                if (!parse_quality(optarg, options.liq, &options.min_quality_limit)) { \n                    fputs(\"Quality should be in format min-max where min and max are numbers in range 0-100.\\n\", stderr); \n                    return INVALID_ARGUMENT; \n                } \n                break; \n \n            case arg_posterize: \n                if (LIQ_OK!= liq_set_min_posterization(options.liq, atoi(optarg))) { \n                    fputs(\"Posterization should be number of bits in range 0-4.\\n\", stderr); \n                    return INVALID_ARGUMENT; \n                } \n                break; \n \n            case arg_map: \n                { \n                    png24_image tmp = {}; \n      ", "pred": "t main(int argc, char *argv[]) \n{ \n    struct pngquant_options options = { \n       .floyd = 1.f,  \n \n    }; \n    options.liq = liq_attr_create(); \n \n    if (!options.liq) { \n        fputs(\"SSE-capable CPU is required for this build.\\n\", stderr); \n        return WRONG_ARCHITECTURE; \n    } \n \n    unsigned int error_count=0, skipped_count=0, file_count=0; \n    pngquant_error latest_error=SUCCESS; \n    const char *newext = NULL, *output_file_path = NULL; \n \n    fix_obsolete_options(argc, argv); \n \n    int opt; \n    do { \n        opt = getopt_long(argc, argv, \"Vvqfhs:Q:o:\", long_options, NULL); \n        switch (opt) { \n            case 'v': \n                options.verbose = true; \n                break; \n            case 'q': \n                options.verbose = false; \n                break; \n \n            case arg_floyd: \n                options.floyd = optarg? atof(optarg) : 1.0; \n                if (options.floyd < 0 || options.floyd > 1.f) { \n                    fputs(\"--floyd argument must be in 0..1 range\\n\", stderr); \n                    return INVALID_ARGUMENT; \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  dt_iop_highlights_data_t *data = (dt_iop_highlights_data_t *)piece->data; \n \n  const float clip \n      = data->clip * fminf(piece->pipe->dsc.processed_maximum[0], \n                           fminf(piece->pipe->dsc.processed_maximum[1], piece->pipe->dsc.processed_maximum[2])); \n   \n \n  if(!filters) \n  { \n    process_clip(piece, ivoid, ovoid, roi_in, roi_out, clip); \n    for(int k=0;k<3;k++) \n      piece->pipe->dsc.processed_maximum[k] \n          = fminf(piece->pipe->dsc.processed_maximum[0], \n                  fminf(piece->pipe->dsc.processed_maximum[1], piece->pipe->dsc.processed_maximum[2])); \n    return; \n  } \n \n  switch(data->mode) \n  { \n    case DT_IOP_HIGHLIGHTS_INPAINT:  \n \n    { \n      const float clips[4] = { 0.987 * data->clip * piece->pipe->dsc.processed_maximum[0], \n                               0.987 * data->clip * piece->pipe->dsc.processed_maximum[1], \n                               0.987 * data->clip * piece->pipe->dsc.processed_maximum[2], clip }; \n \n      if(filters == 9u) \n      { \n        const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n#pragma omp parallel for default(none)          dt_omp_firstprivate(clips, filters, ivoid, ovoid, roi_in, roi_out,                              xtrans)          schedule(static) \n        for(int j = 0; j < roi_out->height; j++) \n        { \n          interpolate_color_xtrans(ivoid, ovoid, roi_in, roi_out, 0, 1, j, clips, xtrans, 0); \n          interpolate_color_xtrans(ivoid, ovoid, roi_in, roi_out, 0, -1, j, clips, xtrans, 1); \n        } \n#pragma omp parallel for default(none)          dt_omp_firstprivate(clips, filters, ivoid, ovoid, roi_in, roi_out,                              xtrans)          schedule(static) \n        for(int i = 0; i < roi_out->width; i++) \n        { \n          interpolate_color_xtrans(ivoid, ovoid, roi_in, roi_out, 1, 1, i, clips, xtrans, 2); \n          interpolate_color_xtrans(ivoid, ovoid, roi_in, roi_out, 1, -1, i, clips, xtrans, 3); \n        } \n      } \n      else \n      { \n#pragma omp parallel for default(none)          dt_omp_firstprivate(clips, filters, ivoid, ovoid, roi_out)          shared(data, piece)          schedule(static) \n        for(int j = 0; j < roi_out->height; j++) \n        { \n          interpolate_color(ivoid, ovoid, roi_out, 0, 1, j, clips, filters, 0); \n          interpolate_color(ivoid, ovoid, roi_out, 0, -1, j, clips, filters, 1); \n        } \n \n \n \n#pragma omp parallel for default(none)          dt_omp_firstprivate(clips, filters, ivoid, ovoid, roi_out)          shared(data, piece)          schedule(static) \n        for(int i = 0; i < roi_out->width; i++) \n        { \n          interpolate_color(ivoid, ovoid, roi_out, 1, 1, i, clips, filters, 2); \n          interpolate_color(ivoid, ovoid, roi_out, 1, -1, i, clips, filters, 3); \n        } \n      } \n      break; \n    } \n    case DT_IOP_HIGHLIGHTS_LCH: \n      if(filters == 9u) \n        process_lch_xtrans(self, piece, ivoid, ovoid, roi_in, roi_out, clip); \n      else \n        process_lch_bayer(self, piece, ivoid, ovoid, roi_in, roi_out, clip); \n      break; \n    default: \n    case DT_IOP_HIGHLIGHTS_CLIP: \n      process_clip(piece, ivoid, ovoid, roi_in, roi_out, clip); \n      break; \n  } \n \n   \n \n  const float m = fmaxf(fmaxf(piece->pipe->dsc.processed_maximum[0], piece->pipe->dsc.processed_maximum[1]), \n                        piece->pipe->dsc.processed_maximum[2]); \n  for(int k = 0; k < 3; k++) piece->pipe->dsc.processed_maximum[k] = m; \n \n  if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out->width, roi_out->height); \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  dt_iop_highlights_data_t *data = (dt_iop_highlights_data_t *)piece->data; \n \n  const float clip \n      = data->clip * fminf(piece->pipe->dsc.processed_maximum[0], \n                           fminf(piece->pipe->dsc.processed_maximum[1], piece->pipe->dsc.processed_maximum[2])); \n   \n \n  if(!filters) \n  { \n    process_clip(piece, ivoid, ovoid, roi_in, roi_out, clip); \n    for(int k=0;k<3;k++) \n      piece->pipe->dsc.processed_maximum[k] \n          = fminf(piece->pipe->dsc.processed_maximum[0], \n                  fminf(piece->pipe->dsc.processed_maximum[1], piece->pipe->dsc.processed_maximum[2])); \n    return; \n  } \n \n  switch(data->mode) \n  { \n    case DT_IOP_HIGHLIGHTS_INPAINT:  \n \n    { \n      const float clips[4] = { 0.987 * data->clip * piece->pipe->dsc.processed_maximum[0], \n                               0.987 * data->clip * piece->pipe->dsc.processed_maximum[1], \n                               0.987 * data->clip * piece->pipe->dsc.processed_maximum[2],                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nstatic void process_lch_bayer(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                              void *const ovoid, const dt_iop_roi_t *const roi_in, \n                              const dt_iop_roi_t *const roi_out, const float clip) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(clip, filters, ivoid, ovoid, roi_out)    schedule(static) collapse(2) \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      float *const out = (float *)ovoid + (size_t)roi_out->width * j + i; \n      const float *const in = (float *)ivoid + (size_t)roi_out->width * j + i; \n \n      if(i == roi_out->width - 1 || j == roi_out->height - 1) \n      { \n         \n \n        out[0] = MIN(clip, in[0]); \n      } \n      else \n      { \n        int clipped = 0; \n \n         \n \n        float R = 0.0f, Gmin = FLT_MAX, Gmax = -FLT_MAX, B = 0.0f; \n        for(int jj = 0; jj <= 1; jj++) \n        { \n          for(int ii = 0; ii <= 1; ii++) \n          { \n            const float val = in[(size_t)jj * roi_out->width + ii]; \n \n            clipped = (clipped || (val > clip)); \n \n            const int c = FC(j + jj + roi_out->y, i + ii + roi_out->x, filters); \n            switch(c) \n            { \n              case 0: \n                R = val; \n                break; \n              case 1: \n                Gmin = MIN(Gmin, val); \n                Gmax = MAX(Gmax, val); \n                break; \n              case 2: \n                B = val; \n                break; \n            } \n          } \n        } \n \n        if(clipped) \n        { \n          const float Ro = MIN(R, clip); \n          const float Go = MIN(Gmin, clip); \n          const float Bo = MIN(B, clip); \n \n          const float L = (R + Gmax + B) / 3.0f; \n \n          float C = SQRT3 * (R - Gmax); \n          float H = 2.0f * B - Gmax - R; \n \n          const float Co = SQRT3 * (Ro - Go); \n          const float Ho = 2.0f * Bo - Go - Ro; \n \n          if(R!= Gmax && Gmax!= B) \n          { \n            const float ratio = sqrtf((Co * Co + Ho * Ho) / (C * C + H * H)); \n            C *= ratio; \n            H *= ratio; \n          } \n \n          float RGB[3] = { 0.0f, 0.0f, 0.0f }; \n \n           \n \n          RGB[0] = L - H / 6.0f + C / SQRT12; \n          RGB[1] = L - H / 6.0f - C / SQRT12; \n          RGB[2] = L + H / 3.0f; \n \n          out[0] = RGB[FC(j + roi_out->y, i + roi_out->x, filters)]; \n        } \n        else \n        { \n          out[0] = in[0]; \n        } \n      } \n    } \n  } \n} ", "pred": " \nstatic void process_lch_bayer(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                              void *const ovoid, const dt_iop_roi_t *const roi_in, \n                              const dt_iop_roi_t *const roi_out, const float clip) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n \n#pragma omp parallel for default(none)    dt_omp_firstprivate(clip, filters, ivoid, ovoid, roi_out)    schedule(static) collapse(2) \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      float *const out = (float *)ovoid + (size_t)roi_out->width * j + i; \n      const float *const in = (float *)ivoid + (size_t)roi_out->width * j + i; \n \n      if(i == roi_out->width - 1 || j == roi_out->height - 1) \n      { \n         \n \n        out[0] = MIN(clip, in[0]); \n      } \n      else \n      { \n        int clipped = 0; \n \n         \n \n        float R = 0.0f, Gmin = FLT_MAX, Gmax = -FLT_MAX, B = 0.0f; \n        for(int jj = 0; jj <= 1; jj++) \n        { \n          for(int ii = 0; ii <= 1; ii++) \n          { \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "}
{"label": " \nvoid \nprocess (struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, void *ivoid, void *ovoid, const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out) \n{ \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n  const int ch = piece->colors; \n \n  if(d->cmatrix[0]!= -0.666f) \n  { \n     \n \n     \n \n    #pragma omp parallel for schedule(static) default(none) shared(roi_in,roi_out, ivoid, ovoid) \n    for(int j=0; j<roi_out->height; j++) \n    { \n \n      float *in  = (float*)ivoid + ch*roi_in->width *j; \n      float *out = (float*)ovoid + ch*roi_out->width*j; \n      const __m128 m0 = _mm_set_ps(0.0f,d->cmatrix[6],d->cmatrix[3],d->cmatrix[0]); \n      const __m128 m1 = _mm_set_ps(0.0f,d->cmatrix[7],d->cmatrix[4],d->cmatrix[1]); \n      const __m128 m2 = _mm_set_ps(0.0f,d->cmatrix[8],d->cmatrix[5],d->cmatrix[2]); \n   \n      for(int i=0; i<roi_out->width; i++, in+=ch, out+=ch ) \n      { \n        const __m128 xyz = dt_Lab_to_XYZ_SSE(_mm_load_ps(in)); \n        const __m128 t = _mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(xyz,xyz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m1,_mm_shuffle_ps(xyz,xyz,_MM_SHUFFLE(1,1,1,1))),_mm_mul_ps(m2,_mm_shuffle_ps(xyz,xyz,_MM_SHUFFLE(2,2,2,2))))); \n \n        _mm_stream_ps(out,t); \n      } \n    } \n    _mm_sfence(); \n     \n \n    #pragma omp parallel for schedule(static) default(none) shared(roi_in,roi_out, ivoid, ovoid) \n    for(int j=0; j<roi_out->height; j++) \n    { \n \n      float *in  = (float*)ivoid + ch*roi_in->width *j; \n      float *out = (float*)ovoid + ch*roi_out->width*j; \n   \n      for(int i=0; i<roi_out->width; i++, in+=ch, out+=ch ) \n      { \n        for(int i=0; i<3; i++)  \n          if (d->lut[i][0] >= 0.0f) \n          { \n            out[i] = (out[i] < 1.0f)? lerp_lut(d->lut[i], out[i]) : dt_iop_eval_exp(d->unbounded_coeffs[i], out[i]); \n          } \n      } \n    } \n  } \n  else \n  { \n    float *in  = (float*)ivoid; \n    float *out = (float*)ovoid; \n     \n \n \n     \n \n    int rowsize=roi_out->width*3; \n \n     \n \n \n    #pragma omp parallel for schedule(static) default(none) shared(out, roi_out, in, d, rowsize) \n    for (int k=0; k<roi_out->height; k++) \n    { \n      float Lab[rowsize]; \n      float rgb[rowsize]; \n \n      const int m=(k*(roi_out->width*ch)); \n      for (int l=0; l<roi_out->width; l++) \n      { \n        int li=3*l,ii=ch*l; \n        Lab[li+0] = in[m+ii+0]; \n        Lab[li+1] = in[m+ii+1]; \n        Lab[li+2] = in[m+ii+2]; \n      } \n \n       \n \n      cmsDoTransform (d->xform[dt_get_thread_num()], Lab, rgb, roi_out->width); \n \n      for (int l=0; l<roi_out->width; l++) \n      { \n        int oi=ch*l, ri=3*l; \n        out[m+oi+0] = rgb[ri+0]; \n        out[m+oi+1] = rgb[ri+1]; \n        out[m+oi+2] = rgb[ri+2]; \n      } \n    } \n  } \n} ", "pred": " \nvoid \nprocess (struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, void *ivoid, void *ovoid, const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out) \n{ \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n  const int ch = piece->colors; \n \n  if(d->cmatrix[0]!= -0.666f) \n  { \n     \n \n     \n \n    #pragma omp parallel for schedule(static) default(none) shared(roi_in,roi_out, ivoid, ovoid) \n    for(int j=0; j<roi_out->height; j++) \n    { \n \n      float *in  = (float*)ivoid + ch*roi_in->width *j; \n      float *out = (float*)ovoid + ch*roi_out->width*j; \n      const __m128 m0 = _mm_set_ps(0.0f,d->cmatrix[6],d->cmatrix[3],d->cmatrix[0]); \n      const __m128 m1 = _mm_set_ps(0.0f,d->cmatrix[7],d->cmatrix[4],d->cmatrix[1]); \n      const __m128 m2 = _mm_set_ps(0.0f,d->cmatrix[8],d->cmatrix[5],d->cmatrix[2]); \n   \n      for(int i=0; i<roi_out->width; i++, in+=ch, out+=ch ) \n      { \n        const __m128 xyz = dt_Lab_to_XYZ_SSE(_mm_load_ps(in)); \n        const __m128 t = _mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(xyz,xyz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(zz,zz,_MM_SHUFFLE"}
{"label": " \nvoid proceed_nbux(){ \n  const double rU = 1/86400.0, rV = 6/86400.0, rE = 1/900.0, Du = 2.3e-10, Dv = 6.1e-11; \n  const double dt = 200, dx = 0.001; \n \n#pragma omp for collapse (2) \n    for (int x=1;x<NX-1;x+=2) { \n \n      for (int y=1;y<NY-1;++y) { \n        for (int z=1;z<NZ-1;++z) { \n          double U0=U_mem[x][y][z]; \n          double V0=V_mem[x][y][z]; \n          double U0_1=U_mem[x+1][y][z]; \n          double V0_1=V_mem[x+1][y][z]; \n          double  eat = rE * U0 * V0*V0; \n          double  eat_1 = rE * U0_1 * V0_1*V0_1; \n          double dU_dt = - eat + rU * (1-U0) + Du/(dx*dx) * laplacian(U_mem,x,y,z); \n          double dV_dt =   eat - rV * V0     + Dv/(dx*dx) * laplacian(V_mem,x,y,z); \n          double dU_dt_1 = - eat_1 + rU * (1-U0_1) + Du/(dx*dx) * laplacian(U_mem,x+1,y,z); \n          double dV_dt_1 =   eat_1 - rV * V0_1     + Dv/(dx*dx) * laplacian(V_mem,x+1,y,z); \n          U_mem2[x][y][z] = U0 + dt * dU_dt; \n          V_mem2[x][y][z] = V0 + dt * dV_dt; \n          U_mem2[x+1][y][z] = U0_1 + dt * dU_dt_1; \n          V_mem2[x+1][y][z] = V0_1 + dt * dV_dt_1; \n        } \n      } \n    } \n} ", "pred": " \nvoid proceed_nbux(){ \n  const double rU = 1/86400.0, rV = 6/86400.0, rE = 1/900.0, Du = 2.3e-10, Dv = 6.1e-11; \n  const double dt = 200, dx = 0.001; \n \n#pragma omp for collapse (2) \n    for (int x=1;x<NX-1;x+=2) { \n \n      for (int y=1;y<NY-1;++y) { \n        for (int z=1;z<NZ-1;++z) { \n          double U0=U_mem[x][y][z]; \n          double V0=V_mem[x][y][z]; \n          double U0_1=U_mem[x+1][y][z]; \n          double V0_1=V_mem[x+1][y][z]; \n          double  eat = rE * U0 * V0*V0; \n          double  eat_1 = rE * U0_1 * V0_1*V0_1; \n          double dU_dt = - eat + rU * (1-U0) + Du/(dx*dx) * laplacian(U_mem,x,y,z); \n          double dV_dt =   eat - rV * V0     + Dv/(dx*dx) * laplacian(V_mem,x,y,z); \n          double dU_dt_1 = - eat_1 + rU * (1-U0_1) + Du/(dx*dx) * laplacian(U_mem,x+1,y,z); \n          double dV_dt_1 =   eat_1 - rV * V0_1     + Dv/(dx*dx) * laplacian(V_mem,x+1,y,z); \n          U_mem2[x][y][z] = U0 + dt * dU_dt;\\n                                                                                                                                            "}
{"label": " \nstatic void THNN_(VolumetricMaxPooling_updateGradInput_frame)( \n          real *gradInput_p, \n          real *gradOutput_p, \n          real *indz_p, \n          long nslices, \n          long itime, \n          long iwidth, \n          long iheight, \n          long otime, \n          long owidth, \n          long oheight, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH) \n{ \n  long k; \n#pragma omp parallel for private(k) \n  for (k = 0; k < nslices; k++) \n  { \n    real *gradInput_p_k  = gradInput_p  + k * itime * iwidth * iheight; \n    real *gradOutput_p_k = gradOutput_p + k * otime * owidth * oheight; \n    real *indz_p_k = indz_p + k * otime * owidth * oheight; \n \n     \n \n    long ti, i, j; \n    for (ti = 0; ti < otime; ti++) \n    { \n      for (i = 0; i < oheight; i++) \n      { \n        for (j = 0; j < owidth; j++) \n        { \n           \n \n          real * indzp = &indz_p_k[ti * oheight * owidth + i * owidth + j]; \n          long maxti = ((unsigned char*)(indzp))[0] + ti * dT - pT; \n          long maxi  = ((unsigned char*)(indzp))[1] + i * dH - pH; \n          long maxj  = ((unsigned char*)(indzp))[2] + j * dW - pW; \n \n           \n \n          gradInput_p_k[maxti * iheight * iwidth + maxi * iwidth + maxj] += \n            gradOutput_p_k[ti * oheight * owidth + i * owidth + j]; \n        } \n      } \n    } \n  } \n} ", "pred": " \nstatic void THNN_(VolumetricMaxPooling_updateGradInput_frame)( \n          real *gradInput_p, \n          real *gradOutput_p, \n          real *indz_p, \n          long nslices, \n          long itime, \n          long iwidth, \n          long iheight, \n          long otime, \n          long owidth, \n          long oheight, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH) \n{ \n  long k; \n#pragma omp parallel for private(k) \n  for (k = 0; k < nslices; k++) \n  { \n    real *gradInput_p_k  = gradInput_p  + k * itime * iwidth * iheight; \n    real *gradOutput_p_k = gradOutput_p + k * otime * owidth * oheight; \n    real *indz_p_k = indz_p + k * otime * owidth * oheight; \n \n     \n \n    long ti, i, j; \n    for (ti = 0; ti < otime; ti++) \n    { \n      for (i = 0; i < oheight; i++) \n      { \n        for (j = 0; j < owidth; j++) \n        { \n           \n \n          real * indzp = &indz_p_k[ti * oheight * owidth + i * owidth + j]; \n          long maxti = ((unsigned char*)(indzp))[0] + ti * dT - pT;\\n                                                                                                                                                                                                "}
{"label": " \nvoid \nbar (void) \n{ \n  int *r06 = baz (), *r07 = baz (), *r08 = baz (), *r09 = baz (); \n  int *r10 = baz (), *r11 = baz (), *r12 = baz (); \n  int *r25 = baz (), *r26 = baz (), *r27 = baz (), *r28 = baz (), *r29 = baz (); \n   \n \n   \n \n  #pragma omp for simd reduction(+:r03[1:5]) \n  for (int i = 0; i < 64; i++) \n    r03[1]++; \n   \n \n   \n \n  #pragma omp master taskloop reduction(+:r04[1:6]) default(none) \n  for (int i = 0; i < 64; i++) \n    r04[1]++; \n   \n \n   \n \n   \n \n  #pragma omp master taskloop simd reduction(+:r05[1:7]) default(none) \n  for (int i = 0; i < 64; i++) \n    r05[1]++; \n   \n \n  #pragma omp parallel for simd reduction(+:r07[1:9]) default(none) \n  for (int i = 0; i < 64; i++) \n    r07[1]++; \n   \n \n   \n \n  #pragma omp parallel master reduction(+:r09[1:11]) default(none) \n  r09[1]++; \n   \n \n   \n \n  #pragma omp parallel master taskloop reduction(+:r10[1:12]) default(none) \n  for (int i = 0; i < 64; i++) \n    r10[1]++; \n   \n \n   \n \n   \n \n  #pragma omp parallel master taskloop simd reduction(+:r11[1:13]) default(none) \n  for (int i = 0; i < 64; i++) \n    r11[1]++; \n   \n \n  #pragma omp parallel sections reduction(+:r12[1:14]) default(none) \n  { \n    r12[1]++; \n    #pragma omp section \n    r12[1]++; \n  } \n   \n \n   \n \n   \n \n   \n \n  #pragma omp target parallel reduction(+:r13[1:15]) default(none) defaultmap(none) \n  r13[1]++; \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  #pragma omp target parallel for simd reduction(+:r15[1:17]) default(none) defaultmap(none) \n  for (int i = 0; i < 64; i++) \n    r15[1]++; \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  #pragma omp target teams reduction(+:r17[1:19]) default(none) defaultmap(none) \n  r17[1]++; \n   \n \n   \n \n   \n \n   \n \n   \n \n  #pragma omp target teams distribute reduction(+:r18[1:20]) default(none) defaultmap(none) \n  for (int i = 0; i < 64; i++) \n    r18[1]++; \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  #pragma omp target teams distribute parallel for simd reduction(+:r20[1:22]) default(none) defaultmap(none) \n  for (int i = 0; i < 64; i++) \n    r20[1]++; \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  #pragma omp target teams distribute simd reduction(+:r21[1:23]) default(none) defaultmap(none) \n  for (int i = 0; i < 64; i++) \n    r21[1]++; \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  #pragma omp target simd reduction(+:r23[1:25]) defaultmap(none) \n  for (int i = 0; i < 64; i++) \n    r23[1]++; \n   \n \n   \n \n  #pragma omp taskloop simd reduction(+:r24[1:26]) default(none) \n  for (int i = 0; i < 64; i++) \n    r24[1]++; \n   \n \n   \n \n  #pragma omp teams distribute reduction(+:r25[1:27]) default(none) \n  for (int i = 0; i < 64; i++) \n    r25[1]++; \n   \n \n   \n \n   \n \n   \n \n   \n \n  #pragma omp teams distribute parallel for simd reduction(+:r27[1:29]) default(none) \n  for (int i = 0; i < 64; i++) \n    r27[1]++; \n   \n \n   \n \n   \n \n  #pragma omp teams distribute simd reduction(+:r28[1:30]) default(none) \n  for (int i = 0; i < 64; i++) \n    r28[1]++; \n  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(r29\\\\)\" \"gimple\" } } * \n \n  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r29 \\\\+ 4\" \"gimple\" } } * \n \n  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(r29\\\\)\" \"gimple\" } } * \n \n  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r29 \\\\+ 4\" \"gimple\" } } * \n \n  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r29 \\\\+ 4\" \"gimple\" } } * \n \n  #pragma omp teams loop reduction(+:r29[1:31]) default(none) \n  for (int i = 0; i < 64; i++) \n    r29[1]++; \n} ", "pred": " \nvoid \nbar (void) \n{ \n  int *r06 = baz (), *r07 = baz (), *r08 = baz (), *r09 = baz (); \n  int *r10 = baz (), *r11 = baz (), *r12 = baz (); \n  int *r25 = baz (), *r26 = baz (), *r27 = baz (), *r28 = baz (), *r29 = baz (); \n   \n \n   \n \n  #pragma omp for simd reduction(+:r03[1:5]) \n  for (int i = 0; i < 64; i++) \n    r03[1]++; \n   \n \n   \n \n  #pragma omp master taskloop reduction(+:r04[1:6]) default(none) \n  for (int i = 0; i < 64; i++) \n    r04[1]++; \n   \n \n   \n \n   \n \n  #pragma omp master taskloop simd reduction(+:r05[1:7]) default(none) \n  for (int i = 0; i < 64; i++) \n    r05[1]++; \n   \n \n  #pragma omp parallel for simd reduction(+:r07[1:9]) default(none) \n  for (int i = 0; i < 64; i++) \n    r07[1]++; \n   \n \n   \n \n  #pragma omp parallel master reduction(+:r09[1:11]) default(none) \n  r09[1]++; \n   \n \n   \n \n  #pragma omp parallel master taskloop reduction(+:r10[1:12]) default(none) \n  for (int i = 0; i < 64; i++) \n    r10[1]++; \n   \n \n   \n \n   \n \n  #pragma omp parallel master taskloop simd reduction(+:r11[1:13]) default(none) \n  for (int i = 0; i < 64; i++) \n    r11[1]++; \n   \n \n  #pragma omp parallel sections reduction(+:r12[1:14]) default(none) \n  { \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "}
{"label": " \nvoid neighbors_extern(FLOAT_TYPE * Xtest, \n\t\tint nXtest, \n\t\tint dXtest, \n\t\tFLOAT_TYPE * distances, \n\t\tint ndistances, \n\t\tint ddistances, \n\t\tint *indices, \n\t\tint nindices, \n\t\tint dindices, \n\t\tKD_TREE_RECORD *kdtree_record, \n\t\tKD_TREE_PARAMETERS *params) { \n \n\tint i, j; \n\tint K = params->n_neighbors; \n \n\t \n \n#pragma omp parallel for \n\tfor (i = 0; i < nXtest; i++) { \n\t\tFLOAT_TYPE *tpattern = Xtest + i * dXtest; \n\t\tkd_tree_query_tree_sequential(tpattern, distances + i * K, \n\t\t\t\tindices + i * K, K, kdtree_record); \n\t} \n \n\tchar *XI = kdtree_record->XI; \n\tint size_elt = dXtest * sizeof(FLOAT_TYPE) + sizeof(int); \n \n\t \n \n\t \n \n\tfor (i = 0; i < nXtest; i++) { \n\t\tfor (j = 0; j < K; j++) { \n \n\t\t\tint index_in_tree = indices[i * K + j]; \n\t\t\tindices[i * K + j] = *((int *) (XI + index_in_tree * size_elt + dXtest * sizeof(FLOAT_TYPE))); \n\t\t\tdistances[i * K + j] = sqrt(distances[i * K + j]); \n \n\t\t} \n\t} \n \n} ", "pred": " \nvoid neighbors_extern(FLOAT_TYPE * Xtest, \n\t\tint nXtest, \n\t\tint dXtest, \n\t\tFLOAT_TYPE * distances, \n\t\tint ndistances, \n\t\tint ddistances, \n\t\tint *indices, \n\t\tint nindices, \n\t\tint dindices, \n\t\tKD_TREE_RECORD *kdtree_record, \n\t\tKD_TREE_PARAMETERS *params) { \n \n\tint i, j; \n\tint K = params->n_neighbors; \n \n\t \n \n#pragma omp parallel for \n\tfor (i = 0; i < nXtest; i++) { \n\t\tFLOAT_TYPE *tpattern = Xtest + i * dXtest; \n\t\tkd_tree_query_tree_sequential(tpattern, distances + i * K, \n\t\t\t\tindices + i * K, K, kdtree_record); \n\t} \n \n\tchar *XI = kdtree_record->XI; \n\tint size_elt = dXtest * sizeof(FLOAT_TYPE) + sizeof(int); \n \n\t \n \n\t \n \n\tfor (i = 0; i < nXtest; i++) { \n\t\tfor (j = 0; j < K; j++) { \n \n\t\t\tint index_in_tree = indices[i * K + j]; \n\t\t\tindices[i * K + j] = *((int *) (XI + index_in_tree * size_elt + dXtest * sizeof(FLOAT_TYPE))); \n\t\t\tdistances[i * K + j] = sqrt(distances[i * K + j]); \n \n\t\t} \n\t} \n \n} "}
{"label": " namespace generic { \n \n \n \nvoid intDriver (const int NUM, const double t, const double t_end, \n                const double *pr_global, double *y_global) \n{ \n    int tid; \n    #pragma omp parallel for shared(y_global, pr_global) private(tid) \n    for (tid = 0; tid < NUM; ++tid) { \n \n         \n \n        double y_local[NSP]; \n        double pr_local = pr_global[tid]; \n \n         \n \n \n        for (int i = 0; i < NSP; i++) \n        { \n            y_local[i] = y_global[tid + i * NUM]; \n        } \n \n         \n \n        check_error(tid, integrate (t, t_end, pr_local, y_local)); \n \n         \n \n \n        for (int i = 0; i < NSP; i++) \n        { \n            y_global[tid + i * NUM] = y_local[i]; \n        } \n \n    }  \n \n \n}  \n \n \n } ", "pred": " namespace generic { \n \n \n \nvoid intDriver (const int NUM, const double t, const double t_end, \n                const double *pr_global, double *y_global) \n{ \n    int tid; \n    #pragma omp parallel for shared(y_global, pr_global) private(tid) \n    for (tid = 0; tid < NUM; ++tid) { \n \n         \n \n        double y_local[NSP]; \n        double pr_local = pr_global[tid]; \n \n         \n \n \n        for (int i = 0; i < NSP; i++) \n        { \n            y_local[i] = y_global[tid + i * NUM]; \n        } \n \n         \n \n        check_error(tid, integrate (t, t_end, pr_local, y_local)); \n \n         \n \n \n        for (int i = 0; i < NSP; i++) \n        { \n            y_global[tid + i * NUM] = y_local[i]; \n        } \n \n    }  \n \n \n}  \n \n \n } "}
{"label": " \nvoid \nfoo (void) \n{ \n   \n \n   \n \n   \n \n  #pragma omp distribute parallel for simd reduction(+:r01[1:3]) default(none) \n  for (int i = 0; i < 64; i++) \n    r01[1]++; \n   \n \n   \n \n  #pragma omp distribute simd reduction(+:r02[1:4]) \n  for (int i = 0; i < 64; i++) \n    r02[1]++; \n} ", "pred": " \nvoid \nfoo (void) \n{ \n   \n \n   \n \n   \n \n  #pragma omp distribute parallel for simd reduction(+:r01[1:3]) default(none) \n  for (int i = 0; i < 64; i++) \n    r01[1]++; \n   \n \n   \n \n  #pragma omp distribute simd reduction(+:r02[1:4]) \n  for (int i = 0; i < 64; i++) \n    r02[1]++; \n} "}
{"label": " \nvoid CLASS green_equilibrate(float thresh) \n \n{   \n\t \n \n\tstatic const int border=8; \n\tstatic const int border2=16; \n\tstatic const int v1=TS, v2=2*TS, v3=3*TS,  \n p1=-TS+1, p2=-2*TS+2, p3=-3*TS+3, m1=TS+1, m2=2*TS+2, m3=3*TS+3; \n\t \n \n \n\tint top, left;  \n \n\tif(half_size) return; \n \n\tint verbose=1; \n\t \n\tstatic const float eps=1.0;\t \n \n\t \n \n\t \n \n\tstatic const float diffthresh=0.25;  \n \n \n\tdouble dt; \n\tclock_t t1, t2; \n\t \n\t \n \n\t \n\t \n \n\tif (verbose) fprintf(stderr,_(\"Green equilibration v1 OMP [E.Martinec] %1.3f...\\n\"),thresh);\t \n\t \n\t \n\t \n\tt1 = clock(); \n#pragma omp parallel \n{\t\t \n\tint top,left; \n\t\t\tchar\t\t*buffer;\t\t\t \n \n\t\t\tfloat         (*cfa);\t\t \n \n\t\t\tfloat         (*checker);\t\t\t \n \n\t\t\tfloat         (*gvar);\t\t\t \n \n\t\t\tfloat         (*gdiffv);\t\t\t \n \n\t\t\tfloat         (*gdiffh);\t\t\t \n \n\t\t\t \n\t\t\t \n \n\t\t\tbuffer = (char *) calloc((5*sizeof(float)+sizeof(int))*TS*TS,1); \n\t\t\t \n \n\t\t\tmemset(buffer,0,5*sizeof(float)*TS*TS); \n\t\t\t \n\t\t\tcfa         = (float (*))\t\tbuffer; \n\t\t\tchecker\t\t= (float (*))\t\t\t(buffer +\tsizeof(float)*TS*TS); \n\t\t\tgvar\t\t= (float (*))\t\t\t(buffer +\t2*sizeof(float)*TS*TS); \n\t\t\tgdiffv\t\t= (float (*))\t\t\t(buffer +\t3*sizeof(float)*TS*TS); \n\t\t\tgdiffh\t\t= (float (*))\t\t\t(buffer +\t4*sizeof(float)*TS*TS); \n\t \n \n\t \n\t \n \n\t \n\t \n \n\t \n \n \n \n#pragma omp for schedule(dynamic) nowait  \n\tfor (top=0; top < height-border; top += TS-border2) \n\t\tfor (left=0; left < width-border; left += TS-border2) { \n\t\t\tint bottom = MIN( top+TS,height); \n\t\t\tint right  = MIN(left+TS, width); \n\t\t\tint numrows = bottom - top; \n\t\t\tint numcols = right - left; \n\t\t\t \n\t\t\tint row, col; \n\t\t\tint rr, cc, c, indx; \n\t\t\tint vote1, vote2; \n\t\t\t \n\t\t\tfloat val1; \n\t\t\t \n\t\t\tfloat gin, gse, gsw, gne, gnw, wtse, wtsw, wtne, wtnw; \n\t\t\tfloat gu, gd, gl, gr; \n\t\t\tfloat mcorr, pcorr; \n\t\t\tfloat ginterp; \n\t\t\tfloat diffvarh, diffvarv, hvwt; \n\t\t\t \n \n\t\t\t \n \n\t\t\tfor (rr=0; rr < numrows; rr++) \n\t\t\t\tfor (row=rr+top, cc=0; cc < numcols; cc++) { \n\t\t\t\t\tcol = cc+left; \n\t\t\t\t\tcfa[rr*TS+cc] = image[row*width+col][FC(row,col)]; \n \n \n \n\t\t\t\t} \n\t\t\t \n\t\t\t \n \n\t\t\t \n\t\t\tfor (rr=2; rr < numrows-2; rr++) \n\t\t\t\t \n \n\t\t\t\tfor (indx=rr*TS+2; indx < rr*TS+numcols-2; indx++) { \n\t\t\t\t\t \n\t\t\t\t\tif (FC(rr,indx)&1) { \n\t\t\t\t\t\tpcorr = (cfa[indx+p1]-cfa[indx])*(cfa[indx-p1]-cfa[indx]); \n\t\t\t\t\t\tmcorr = (cfa[indx+m1]-cfa[indx])*(cfa[indx-m1]-cfa[indx]); \n\t\t\t\t\t\t \n\t\t\t\t\t\tif (pcorr>0 && mcorr>0) {checker[indx]=1;} else {checker[indx]=0;} \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n \n\t\t\t\t\t} else { \n\t\t\t\t\t\tgu=cfa[indx-v1]+0.5*(cfa[indx]-cfa[indx-v2]); \n\t\t\t\t\t\tgd=cfa[indx+v1]+0.5*(cfa[indx]-cfa[indx+v2]); \n\t\t\t\t\t\tgl=cfa[indx-1]+0.5*(cfa[indx]-cfa[indx-2]); \n\t\t\t\t\t\tgr=cfa[indx+1]+0.5*(cfa[indx]-cfa[indx+2]); \n\t\t\t\t\t\t \n\t\t\t\t\t\tgdiffh[indx] = SQR((gl-gr)/(eps+gl+gr)); \n\t\t\t\t\t\tgdiffv[indx] = SQR((gu-gd)/(eps+gu+gd)); \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t\t\t\t \n \n\t\t\t \n\t\t\t \n \n\t\t\tfor (rr=6; rr < numrows-6; rr++) \n\t\t\t\tfor (cc=7-(FC(rr,2)&1), indx=rr*TS+cc; cc < numcols-6; cc+=2, indx+=2) { \n\t\t\t\t\tif (checker[indx]) { \n\t\t\t\t\t\t \n\t\t\t\t\t\tdiffvarh = eps+(gdiffh[indx-v1]+gdiffh[indx-1]+gdiffh[indx+1]+gdiffh[indx+v1]); \n\t\t\t\t\t\tdiffvarv = eps+(gdiffv[indx-v1]+gdiffv[indx-1]+gdiffv[indx+1]+gdiffv[indx+v1]); \n\t\t\t\t\t\thvwt = fabs(diffvarv-diffvarh)/(diffvarv+diffvarh); \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\t\t\t\t\t\tvote1=(checker[indx-v2]+checker[indx-2]+checker[indx+2]+checker[indx+v2]); \n\t\t\t\t\t\tvote2=(checker[indx-m1]+checker[indx+p1]+checker[indx-p1]+checker[indx+m1]); \n\t\t\t\t\t\tif (vote1>0 && vote2>0 && hvwt<diffthresh) { \n\t\t\t", "pred": " \nvoid CLASS green_equilibrate(float thresh) \n \n{   \n\t \n \n\tstatic const int border=8; \n\tstatic const int border2=16; \n\tstatic const int v1=TS, v2=2*TS, v3=3*TS,  \n p1=-TS+1, p2=-2*TS+2, p3=-3*TS+3, m1=TS+1, m2=2*TS+2, m3=3*TS+3; \n\t \n \n \n\tint top, left;  \n \n\tif(half_size) return; \n \n\tint verbose=1; \n\t \n\tstatic const float eps=1.0;\t \n \n\t \n \n\t \n \n\tstatic const float diffthresh=0.25;  \n \n \n\tdouble dt; \n\tclock_t t1, t2; \n\t \n\t \n \n\t \n\t \n \n\tif (verbose) fprintf(stderr,_(\"Green equilibration v1 OMP [E.Martinec] %1.3f...\\n\"),thresh);\t \n\t \n\t \n\t \n\tt1 = clock(); \n#pragma omp parallel \n{\t\t \n\tint top,left; \n\t\t\tchar\t\t*buffer;\t\t\t \n \n\t\t\tfloat         (*cfa);\t\t \n \n\t\t\tfloat         (*checker);\t\t\t \n \n\t\t\tfloat         (*gvar);\t\t\t \n \n\t\t\tfloat         (*gdiffv);\t\t\t \n \n\t\t\tfloat         (*gdiffh);\t\t\t \n \n\t\t\t \n\t\t\t \n \n\t\t\tbuffer = (char *) calloc((5*sizeof(float)+sizeof(int))*TS*TS,1); \n\t\t\t \n \n\t\t\tmemset(buffer,0,5*sizeof(float)*TS*TS); \n\t\t\t \n\t\t\tcfa         = (float (*))\t\tbuffer; \n\t\t\tchecker\t\t= (float (*))\t\t\t(buffer +\tsizeof(float)*TS*TS); \n{\"username(\\\"/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test"}
{"label": " \nint main(int argc, const char** argv) \n{ \n \n     \n \n    if (argc > 1 &&!strcmp(argv[1], \"-c\")) \n    { \n        char data_file_name[] = \"data/data_labdarugas.txt\"; \n \n         \n \n        uint32_t rows_count = get_file_rows_count(data_file_name); \n        const uint32_t events_count = rows_count; \n \n         \n \n        event_t events[events_count]; \n \n         \n \n        const uint32_t buffer_size = 255; \n        char buffer[buffer_size]; \n        FILE* fp = fopen(data_file_name, \"r\"); \n        uint32_t event_counter = 0; \n        while(fgets(buffer, buffer_size, (FILE*) fp)) \n        { \n            uint32_t min; \n            char day[10]; \n            char time[10]; \n            char title[200]; \n \n            strcpy(events[event_counter].no, strtok (buffer, \"\\t\")); \n            min = atoi(strtok (NULL, \"\\t\")); \n            min+=0; \n            strcpy(title, strtok (NULL, \"\\t\")); \n            events[event_counter].odds[0] = strtod(strtok (NULL, \"\\t\"), NULL); \n            events[event_counter].odds[1] = strtod(strtok (NULL, \"\\t\"), NULL); \n            events[event_counter].odds[2] = strtod(strtok (NULL, \"\\t\"), NULL); \n            strcpy(day, strtok (NULL, \"\\t\")); \n            strcpy(time, strtok (NULL, \"\\t\")); \n            events[event_counter].hash = odds_to_hash(events[event_counter].odds); \n \n             \n \n \n            event_counter++; \n        } \n \n        fclose(fp); \n \n \n         \n \n        for (uint32_t i = 0; i < events_count; ++i) \n        { \n            for (uint32_t j = i + 1; j < events_count; ++j) \n            { \n                if (events[i].hash > events[j].hash) \n                { \n                    event_t a = events[i]; \n                    events[i] = events[j]; \n                    events[j] = a; \n                } \n            } \n        } \n \n         \n \n        uint32_t counter = 0; \n        uint32_t count = 0; \n        for (uint32_t i = 0; i < events_count; i++) \n        { \n            if (0 == events[i].odds[0] || 0 == events[i].odds[1] || 0 == events[i].odds[2]) \n            { \n                continue; \n            } \n \n            if (0 == i || (0 < i && ((events[i-1].hash!= events[i].hash) || (events[i-1].hash == events[i].hash && counter < 2)))) \n            { \n                 \n \n                printf(\"%u\\n\", events[i].hash); \n \n                 \n \n \n                count++; \n                counter++; \n                continue; \n            } \n \n            counter = 0; \n        } \n    } \n \n     \n \n    if (argc > 2 &&!strcmp(argv[1], \"-s\")) \n    { \n         \n \n        char data_file_name[] = \"data/d\"; \n \n         \n \n        uint32_t rows_count = get_file_rows_count(data_file_name); \n        const uint32_t odds_count = rows_count; \n \n         \n \n        odd_t odds[odds_count]; \n \n         \n \n        const uint32_t buffer_size = 255; \n        char buffer[buffer_size]; \n        FILE* fp = fopen(data_file_name, \"r\"); \n        uint32_t odd_counter = 0; \n        while(fgets(buffer, buffer_size, (FILE*) fp)) \n        { \n            odds[odd_counter].hash = atoi(buffer); \n            hash_to_odds(odds[odd_counter].hash, &odds[odd_counter].odds); \n \n             \n \n \n            odd_counter++; \n        } \n \n        fclose(fp); \n \n         \n \n        uint32_t index = atoi(argv[2]); \n         \n \n \n         \n \n         \n \n         \n \n \n         \n \n        simplex_init(); \n ", "pred": " \nint main(int argc, const char** argv) \n{ \n \n     \n \n    if (argc > 1 &&!strcmp(argv[1], \"-c\")) \n    { \n        char data_file_name[] = \"data/data_labdarugas.txt\"; \n \n         \n \n        uint32_t rows_count = get_file_rows_count(data_file_name); \n        const uint32_t events_count = rows_count; \n \n         \n \n        event_t events[events_count]; \n \n         \n \n        const uint32_t buffer_size = 255; \n        char buffer[buffer_size]; \n        FILE* fp = fopen(data_file_name, \"r\"); \n        uint32_t event_counter = 0; \n        while(fgets(buffer, buffer_size, (FILE*) fp)) \n        { \n            uint32_t min; \n            char day[10]; \n            char time[10]; \n            char title[200]; \n \n            strcpy(events[event_counter].no, strtok (buffer, \"\\t\")); \n            min = atoi(strtok (NULL, \"\\t\")); \n            min+=0; \n            strcpy(title, strtok (NULL, \"\\t\")); \n            events[event_counter].odds[0] = strtod(strtok (NULL, \"\\t\"), NULL); \n            events[event_counter].odds[1] = strtod(strtok (NULL, \"\\t\"), NULL); \n            events[event_counter].evens[0] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[1] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[2] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[3] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[4] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[5] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[6] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[7] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[8] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[9] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[10] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[11] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[12] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[13] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[14] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[15] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[16] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[17] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[18] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[19] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[20] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[21] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[22] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[23] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[24] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[25] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[26] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[27] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[28] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[29] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[30] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[31] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[32] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[33] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[34] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[36] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[37] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[38] = strtod(strtok (NULL,\\t), NULL);            events[event_counter].evens[39"}
{"label": " \nvoid THNN_(VolumetricMaxPooling_updateOutput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *output, \n          THTensor *indices, \n          int kT, \n          int kW, \n          int kH, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH, \n          bool ceilMode) \n{ \n  long nslices; \n  long itime; \n  long iheight; \n  long iwidth; \n  long otime; \n  long oheight; \n  long owidth; \n  real *input_data; \n  real *output_data; \n  real *indices_data; \n \n  THArgCheck(input->nDimension == 4 || input->nDimension == 5, 2, \n    \"4D or 5D (batch-mode) tensor expected\" \n  ); \n \n  int dimN = 0; \n  int dimt = 1; \n  int dimh = 2; \n  int dimw = 3; \n \n  if (input->nDimension == 5) \n  { \n    dimN++; \n    dimt++; \n    dimh++; \n    dimw++; \n  } \n \n  THArgCheck(input->size[dimw] >= kW && input->size[dimh] >= kH && input->size[dimt] >= kT, 2, \n    \"input image smaller than kernel size\" \n  ); \n \n  THArgCheck(kT/2 >= pT && kW/2 >= pW && kH/2 >= pH, 2, \n    \"pad should be smaller than half of kernel size\" \n  ); \n \n   \n \n  nslices = input->size[dimN]; \n  itime   = input->size[dimt]; \n  iheight = input->size[dimh]; \n  iwidth  = input->size[dimw]; \n  if (ceilMode) \n  { \n    otime   = (int)(ceil((float)(itime   - kT + 2 * pT) / dT) + 1); \n    oheight = (int)(ceil((float)(iheight - kH + 2 * pH) / dH) + 1); \n    owidth  = (int)(ceil((float)(iwidth  - kW + 2 * pW) / dW) + 1); \n  } \n  else \n  { \n    otime   = (int)(floor((float)(itime   - kT + 2 * pT) / dT) + 1); \n    oheight = (int)(floor((float)(iheight - kH + 2 * pH) / dH) + 1); \n    owidth  = (int)(floor((float)(iwidth  - kW + 2 * pW) / dW) + 1); \n  } \n \n  if (pT || pW || pH) \n  { \n     \n \n    if ((otime - 1)*dT >= itime + pT) \n      --otime; \n    if ((oheight - 1)*dH >= iheight + pH) \n      --oheight; \n    if ((owidth  - 1)*dW >= iwidth  + pW) \n      --owidth; \n  } \n \n   \n \n  input = THTensor_(newContiguous)(input); \n \n  if (input->nDimension == 4)  \n \n  { \n     \n \n    THTensor_(resize4d)(output, nslices, otime, oheight, owidth); \n     \n \n    THTensor_(resize4d)(indices, nslices, otime, oheight, owidth); \n \n    input_data = THTensor_(data)(input); \n    output_data = THTensor_(data)(output); \n    indices_data = THTensor_(data)(indices); \n \n    THNN_(VolumetricMaxPooling_updateOutput_frame)( \n      input_data, output_data, \n      indices_data, \n      nslices, \n      itime, iwidth, iheight, \n      otime, owidth, oheight, \n      kT, kW, kH, \n      dT, dW, dH, \n      pT, pW, pH \n    ); \n  } \n  else  \n \n  { \n    long p; \n    long nBatch = input->size[0]; \n \n    long istride = nslices * itime * iwidth * iheight; \n    long ostride = nslices * otime * owidth * oheight; \n \n     \n \n    THTensor_(resize5d)(output, nBatch, nslices, otime, oheight, owidth); \n     \n \n    THTensor_(resize5d)(indices, nBatch, nslices, otime, oheight, owidth); \n \n    input_data = THTensor_(data)(input); \n    output_data = THTensor_(data)(output); \n    indices_data = THTensor_(data)(indices); \n \n#pragma omp parallel for private(p) \n    for (p=0; p < nBatch; p++) \n    { \n      THNN_(VolumetricMaxPooling_updateOutput_frame)( \n        input_data   + p * istride, \n        output_data  + p * ostride, \n        indices_data + p * ostride, \n        nslices, \n        itime, iwidth, iheight, \n        otime, owidth, oheight, \n        kT, kW, kH, \n        dT, dW, dH, \n        pT, pW, pH \n      ); \n    } \n  } \n \n   \n \n  THTensor_(free)(input); \n} ", "pred": " \nvoid THNN_(VolumetricMaxPooling_updateOutput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *output, \n          THTensor *indices, \n          int kT, \n          int kW, \n          int kH, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH, \n          bool ceilMode) \n{ \n  long nslices; \n  long itime; \n  long iheight; \n  long iwidth; \n  long otime; \n  long oheight; \n  long owidth; \n  real *input_data; \n  real *output_data; \n  real *indices_data; \n \n  THArgCheck(input->nDimension == 4 || input->nDimension == 5, 2, \n    \"4D or 5D (batch-mode) tensor expected\" \n  ); \n \n  int dimN = 0; \n  int dimt = 1; \n  int dimh = 2; \n  int dimw = 3; \n \n  if (input->nDimension == 5) \n  { \n    dimN++; \n    dimt++; \n    dimh++; \n    dimw++; \n  } \n \n  THArgCheck(input->size[dimw] >= kW && input->size[dimh] >= kH && input->size[dimt] >= kT, 2, \n    \"input image smaller than kernel size\" \n  ); \n \n  THArgCheck(kT/2 >= pT && kW/2 >= pW && kH/2 >= pH, 2, \n    \"pad should be smaller than half of kernel size\" \n  ); \n \n   \n \n  nslices = input->size[dimN]; \n  itime  = input->size[dimh];                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*13); \n  for(m=0; m<13;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 16; \n  tile_size[1] = 16; \n  tile_size[2] = 4; \n  tile_size[3] = 1024; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<13; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  #pragma omp parallel \n  { \n      LIKWID_MARKER_THREADINIT; \n  #pragma omp barrier \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=floord(Nt-1,2);t1++) { \n    lbp=max(ceild(t1,2),ceild(4*t1-Nt+2,4)); \n    ubp=min(floord(4*Nt+Nz-9,16),floord(8*t1+Nz+2,16)); \n#pragma omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7,t8) \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(max(1,ceild(16*t2-Nz+9,4)),2*t1+1),4*t1-4*t2+2);t3<=min(min(min(floord(4*Nt+Ny-9,4),floord(8*t1+Ny+7,4)),floord(16*t2+Ny+3,4)),floord(16*t1-16*t2+Nz+Ny+5,4));t3++) { \n        for (t4=max(max(max(0,ceild(t1-127,128)),ceild(16*t2-Nz-1011,1024)),ceild(4*t3-Ny-1011,1024));t4<=min(min(min(min(floord(4*Nt+Nx-9,1024),floord(8*t1+Nx+7,1024)),floord(16*t2+Nx+3,1024)),floord(4*t3+Nx-9,1024)),floord(16*t1-16*t2+Nz+Nx+5,1024));t4++) { \n          for (t5=max(max(max(max(max(0,ceild(16*t2-Nz+5,4)),ceild(4*t3-Ny+5,4)),ceild(1024*t4-Nx+5,4)),2*t1),4*t1-4*t2+1);t5<=min(min(min(min(min(floord(16*t1-16*t2+Nz+10,4),Nt-1),2*t1+3),4*t2+2),t3-1),256*t4+254);t5++) { \n            for (t6=max(max(16*t2,4*t5+4),-16*t1+16*t2+8*t5-15);t6<=min(min(16*t2+15,-16*t1+16*t2+8*t5),4*t5+Nz-5);t6++) { \n      ", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*13); \n  for(m=0; m<13;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *) tile_size, sizeof(int) * sizeof(int));                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           "}
{"label": " \nvoid THNN_(VolumetricMaxPooling_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput, \n          THTensor *indices, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH) \n{ \n  int nslices; \n  int itime; \n  int iheight; \n  int iwidth; \n  int otime; \n  int oheight; \n  int owidth; \n  real *gradInput_data; \n  real *gradOutput_data; \n  real *indices_data; \n \n  int dimN = 0; \n  int dimt = 1; \n  int dimh = 2; \n  int dimw = 3; \n \n   \n \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n \n   \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(zero)(gradInput); \n \n  if (input->nDimension == 5) \n  { \n    dimN++; \n    dimt++; \n    dimh++; \n    dimw++; \n  } \n \n   \n \n  nslices = input->size[dimN]; \n  itime = input->size[dimt]; \n  iheight = input->size[dimh]; \n  iwidth = input->size[dimw]; \n  otime = gradOutput->size[dimt]; \n  oheight = gradOutput->size[dimh]; \n  owidth = gradOutput->size[dimw]; \n \n   \n \n  gradInput_data = THTensor_(data)(gradInput); \n  gradOutput_data = THTensor_(data)(gradOutput); \n  indices_data = THTensor_(data)(indices); \n \n   \n \n  if (input->nDimension == 4)  \n \n  { \n    THNN_(VolumetricMaxPooling_updateGradInput_frame)( \n      gradInput_data, gradOutput_data, \n      indices_data, \n      nslices, \n      itime, iwidth, iheight, \n      otime, owidth, oheight, \n      dT, dW, dH, \n      pT, pW, pH \n    ); \n  } \n  else  \n \n  { \n    long p; \n    long nBatch = input->size[0]; \n \n    long istride = nslices * itime * iwidth * iheight; \n    long ostride = nslices * otime * owidth * oheight; \n \n#pragma omp parallel for private(p) \n    for (p = 0; p < nBatch; p++) \n    { \n      THNN_(VolumetricMaxPooling_updateGradInput_frame)( \n        gradInput_data + p * istride, \n        gradOutput_data + p * ostride, \n        indices_data + p * ostride, \n        nslices, \n        itime, iwidth, iheight, \n        otime, owidth, oheight, \n        dT, dW, dH, \n        pT, pW, pH \n      ); \n    } \n  } \n \n   \n \n  THTensor_(free)(gradOutput); \n} ", "pred": " \nvoid THNN_(VolumetricMaxPooling_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput, \n          THTensor *indices, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH) \n{ \n  int nslices; \n  int itime; \n  int iheight; \n  int iwidth; \n  int otime; \n  int oheight; \n  int owidth; \n  real *gradInput_data; \n  real *gradOutput_data; \n  real *indices_data; \n \n  int dimN = 0; \n  int dimt = 1; \n  int dimh = 2; \n  int dimw = 3; \n \n   \n \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n \n   \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(zero)(gradInput); \n \n  if (input->nDimension == 5) \n  { \n    dimN++; \n    dimt++; \n    dimh++; \n    dimw++; \n  } \n \n   \n \n  nslices = input->size[dimN]; \n  itime = input->size[dimt]; \n  iheight = input->size[dimh]; \n  iwidth = input->size[dimw]; \n  otime = gradOutput->size[dimt]; \n  oheight = gradOutput->size[dimh]; \n  owidth = gradOutput->size[dimw]; \n \n   \n \n  gradInput_data = THTensor_(data)(gradInput); \n  gradOutput_data = THTensor_(data)(gradOutput); \n  indices_data = THTensor_(data)(indices); \n \n   \nn                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "}
{"label": " \nMagickExport MagickBooleanType SolarizeImage(Image *image, \n  const double threshold,ExceptionInfo *exception) \n{ \n#define SolarizeImageTag  \"Solarize/Image\" \n \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  if (IsGrayColorspace(image->colorspace)!= MagickFalse) \n    (void) SetImageColorspace(image,sRGBColorspace,exception); \n  if (image->storage_class == PseudoClass) \n    { \n      register ssize_t \n        i; \n \n       \n \n      for (i=0; i < (ssize_t) image->colors; i++) \n      { \n        if ((double) image->colormap[i].red > threshold) \n          image->colormap[i].red=QuantumRange-image->colormap[i].red; \n        if ((double) image->colormap[i].green > threshold) \n          image->colormap[i].green=QuantumRange-image->colormap[i].green; \n        if ((double) image->colormap[i].blue > threshold) \n          image->colormap[i].blue=QuantumRange-image->colormap[i].blue; \n      } \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireAuthenticCacheView(image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,image,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    register ssize_t \n      x; \n \n    register Quantum \n      *restrict q; \n \n    if (status == MagickFalse) \n      continue; \n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception); \n    if (q == (Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      register ssize_t \n        i; \n \n      if (GetPixelReadMask(image,q) == 0) \n        { \n          q+=GetPixelChannels(image); \n          continue; \n        } \n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n      { \n        PixelChannel channel=GetPixelChannelChannel(image,i); \n        PixelTrait traits=GetPixelChannelTraits(image,channel); \n        if ((traits & UpdatePixelTrait) == 0) \n          continue; \n        if ((double) q[i] > threshold) \n          q[i]=QuantumRange-q[i]; \n      } \n      q+=GetPixelChannels(image); \n    } \n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        #pragma omp critical (MagickCore_SolarizeImage) \n        proceed=SetImageProgress(image,SolarizeImageTag,progress++,image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  } \n  image_view=DestroyCacheView(image_view); \n  return(status); \n} ", "pred": " \nMagickExport MagickBooleanType SolarizeImage(Image *image, \n  const double threshold,ExceptionInfo *exception) \n{ \n#define SolarizeImageTag  \"Solarize/Image\" \n \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  if (IsGrayColorspace(image->colorspace)!= MagickFalse) \n    (void) SetImageColorspace(image,sRGBColorspace,exception); \n  if (image->storage_class == PseudoClass) \n    { \n      register ssize_t \n        i; \n \n       \n \n      for (i=0; i < (ssize_t) image->colors; i++) \n      { \n        if ((double) image->colormap[i].red > threshold) \n          image->colormap[i].red=QuantumRange-image->colormap[i].red; \n        if ((double) image->colormap[i].green > threshold) \n          image->colormap[i].green=QuantumRange-image->colormap[i].green; \n        if ((double) image->colormap[i].blue > threshold) \n          image->colormap[i].blue=QuantumRange-image->colormap[i].blue; \n      } \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireAuthenticCacheView(image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,image,exception);\\n    if (image->exception == MagickFalse)  {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_zonesystem_data_t *const d = (const dt_iop_zonesystem_data_t *const)piece->data; \n \n  process_common_setup(self, piece, ivoid, ovoid, roi_in, roi_out); \n \n  const int ch = piece->colors; \n  const int size = d->params.size; \n \n  const float *const in = (const float *const)ivoid; \n  float *const out = (float *const)ovoid; \n \n#pragma omp parallel for SIMD() default(none)    dt_omp_firstprivate(ch, d, in, out, roi_out, size)    schedule(static)    collapse(2) \n  for(size_t k = 0; k < (size_t)ch * roi_out->width * roi_out->height; k += ch) \n  { \n    for(int c = 0; c < 3; c++) \n    { \n       \n \n      const int rz = CLAMPS(in[k] * d->rzscale, 0, size - 2);  \n \n      const float zs = ((rz > 0)? (d->zonemap_offset[rz] / in[k]) : 0) + d->zonemap_scale[rz]; \n \n      const size_t p = (size_t)k + c; \n      out[p] = in[p] * zs; \n    } \n  } \n \n  process_common_cleanup(self, piece, ivoid, ovoid, roi_in, roi_out); \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_zonesystem_data_t *const d = (const dt_iop_zonesystem_data_t *const)piece->data; \n \n  process_common_setup(self, piece, ivoid, ovoid, roi_in, roi_out); \n \n  const int ch = piece->colors; \n  const int size = d->params.size; \n \n  const float *const in = (const float *const)ivoid; \n  float *const out = (float *const)ovoid; \n \n#pragma omp parallel for SIMD() default(none)    dt_omp_firstprivate(ch, d, in, out, roi_out, size)    schedule(static)    collapse(2) \n  for(size_t k = 0; k < (size_t)ch * roi_out->width * roi_out->height; k += ch) \n  { \n    for(int c = 0; c < 3; c++) \n    { \n       \n \n      const int rz = CLAMPS(in[k] * d->rzscale, 0, size - 2);  \n \n      const float zs = ((rz > 0)? (d->zonemap_offset[rz] / in[k]) : 0) + d->zonemap_scale[rz]; \n \n      const size_t p = (size_t)k + c; \n      out[p] = in[p] * zs; \n    } \n  } \n \n  process_common_cleanup(self, piece, ivoid, ovoid, roi_in, roi_out); \n} "}
{"label": " \nstatic void process_common_cleanup(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                   const void *const ivoid, void *const ovoid, \n                                   const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_zonesystem_data_t *d = (dt_iop_zonesystem_data_t *)piece->data; \n  dt_iop_zonesystem_gui_data_t *g = (dt_iop_zonesystem_gui_data_t *)self->gui_data; \n \n  const int width = roi_out->width; \n  const int height = roi_out->height; \n  const int ch = piece->colors; \n  const int size = d->params.size; \n \n  if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, width, height); \n \n   \n \n  if(self->dev->gui_attached && piece->pipe->type == DT_DEV_PIXELPIPE_PREVIEW && g && g->in_preview_buffer \n     && g->out_preview_buffer) \n  { \n    float Lmax[] = { 100.0f }; \n    float Lmin[] = { 0.0f }; \n \n     \n \n    const int radius = 8; \n    const float sigma = 2.5 * (radius * roi_in->scale / piece->iscale); \n \n    dt_gaussian_t *gauss = dt_gaussian_init(width, height, 1, Lmax, Lmin, sigma, DT_IOP_GAUSSIAN_ZERO); \n \n    float *tmp = g_malloc_n((size_t)width * height, sizeof(float)); \n \n    if(gauss && tmp) \n    { \n#pragma omp parallel for default(none)        dt_omp_firstprivate(ch, height, width, ivoid)        shared(tmp)        schedule(static) \n      for(size_t k = 0; k < (size_t)width * height; k++) tmp[k] = ((float *)ivoid)[ch * k]; \n \n      dt_gaussian_blur(gauss, tmp, tmp); \n \n       \n \n      dt_pthread_mutex_lock(&g->lock); \n#pragma omp parallel for default(none)        dt_omp_firstprivate(height, size, width)        shared(tmp, g)        schedule(static) \n      for(size_t k = 0; k < (size_t)width * height; k++) \n      { \n        g->in_preview_buffer[k] = CLAMPS(tmp[k] * (size - 1) / 100.0f, 0, size - 2); \n      } \n      dt_pthread_mutex_unlock(&g->lock); \n \n \n#pragma omp parallel for default(none)        dt_omp_firstprivate(ch, height, ovoid, width)        shared(tmp)        schedule(static) \n      for(size_t k = 0; k < (size_t)width * height; k++) tmp[k] = ((float *)ovoid)[ch * k]; \n \n      dt_gaussian_blur(gauss, tmp, tmp); \n \n \n       \n \n      dt_pthread_mutex_lock(&g->lock); \n#pragma omp parallel for default(none)        dt_omp_firstprivate(height, size, width)        shared(tmp, g)        schedule(static) \n      for(size_t k = 0; k < (size_t)width * height; k++) \n      { \n        g->out_preview_buffer[k] = CLAMPS(tmp[k] * (size - 1) / 100.0f, 0, size - 2); \n      } \n      dt_pthread_mutex_unlock(&g->lock); \n    } \n \n    g_free(tmp); \n    if(gauss) dt_gaussian_free(gauss); \n  } \n} ", "pred": " \nstatic void process_common_cleanup(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                   const void *const ivoid, void *const ovoid, \n                                   const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_zonesystem_data_t *d = (dt_iop_zonesystem_data_t *)piece->data; \n  dt_iop_zonesystem_gui_data_t *g = (dt_iop_zonesystem_gui_data_t *)self->gui_data; \n \n  const int width = roi_out->width; \n  const int height = roi_out->height; \n  const int ch = piece->colors; \n  const int size = d->params.size; \n \n  if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, width, height); \n \n   \n \n  if(self->dev->gui_attached && piece->pipe->type == DT_DEV_PIXELPIPE_PREVIEW && g && g->in_preview_buffer \n     && g->out_preview_buffer) \n  { \n    float Lmax[] = { 100.0f }; \n    float Lmin[] = { 0.0f }; \n \n     \n \n    const int radius = 8; \n    const float sigma = 2.5 * (radius * roi_in->scale / piece->iscale); \n \n    dt_gaussian_t *gauss = dt_gaussian_init(width, height, 1, Lmax, Lmin, sigma, DT_IOP_GAUSSIAN_ZERO); \n \n    float *tmp = g_malloc_n((size_t)width * height, sizeof(float)); \n \n    if(gauss && tmp) \n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \nvoid lbestpso(size_t nDim,  \n \n            fitness_function_ptr fitfunc,  \n \n\t\t\tvoid *ffParams,  \n \n\t\t\tcurrent_result_callback_params_t *callback_params,  \n \n            struct psoParamStruct *psoParams,  \n \n\t\t\tstruct returnData *psoResults  \n){ \n \n\tclock_t time_start = clock(); \n \n\t \n \n\tgsl_rng *rngGen = psoParams->rngGen; \n\t \n\t \n \n\tgsl_multimin_function func2minimz; \n\tfunc2minimz.n = nDim;  \n \n\tfunc2minimz.f = dummyfitfunc; \n \n\tstruct dummyFitFuncParam dffp; \n\tdffp.trufuncPr = fitfunc; \n\tdffp.trufuncParam = ffParams; \n\tfunc2minimz.params = &dffp; \n \n\t \n \n\tgsl_multimin_fminimizer *minimzrState = gsl_multimin_fminimizer_alloc(gsl_multimin_fminimizer_nmsimplex2, nDim); \n\t \n \n\tgsl_vector *locMinStp = gsl_vector_alloc(nDim); \n\tgsl_vector_set_all(locMinStp,psoParams->locMinStpSz); \n\tsize_t lpLocMin; \n \n\tint status; \n\t \n\t \n \n\tsize_t lpParticles, lpPsoIter; \n\t \n \n\tconst size_t popsize = psoParams->popsize; \n\t \n \n\tconst size_t maxSteps = psoParams->maxSteps; \n\t \n \n    struct particleInfo pop[popsize]; \n\t \n \n\tfor (lpParticles = 0; lpParticles < popsize; lpParticles++){ \n\t      initPsoParticles(&pop[lpParticles], nDim, rngGen); \n    }\t \n\t \n \n\tdouble gbestFitVal = GSL_POSINF; \n\tgsl_vector *gbestCoord = gsl_vector_alloc(nDim); \n\tgsl_vector *partSnrCurrCol = gsl_vector_alloc(popsize); \n\tsize_t bestfitParticle; \n\tdouble currBestFitVal; \n\t \n \n\tunsigned char computeOK; \n\tsize_t funcCount; \n\t \n \n\tsize_t lpNbrs;  \n \n\tsize_t nNbrs = 3; \n\tsize_t ringNbrs[nNbrs]; \n\tdouble nbrFitVal;  \n \n\tsize_t lbestPart;  \n \n\tdouble lbestFit;  \n \n\t \n \n\tsize_t lpCoord; \n\tgsl_vector *accVecPbest = gsl_vector_alloc(nDim); \n\tgsl_vector *accVecLbest = gsl_vector_alloc(nDim); \n\tgsl_vector *chi1Vec = gsl_vector_alloc(nDim); \n\tgsl_vector *chi2Vec = gsl_vector_alloc(nDim); \n\t \n\t \n \n\tfor (lpPsoIter = 1; lpPsoIter <= maxSteps; lpPsoIter++){ \n\t\t \n \n \n\t\tif (psoParams->debugDumpFile!= NULL){ \n\t\t\tfprintf(psoParams->debugDumpFile,\"Loop %zu \\n\",lpPsoIter); \n\t\t\tparticleInfoDump(psoParams->debugDumpFile,pop,popsize); \n\t\t}\t\t \n         \n \n  #pragma omp parallel for \n\t\tfor (lpParticles = 0; lpParticles < popsize; lpParticles++){ \n\t\t\t \n \n\t\t\tpop[lpParticles].partSnrCurr = fitfunc(pop[lpParticles].partCoord,ffParams); \n\t\t\t \n \n\t\t\t \n \n\t\t\tgsl_vector_set(partSnrCurrCol,lpParticles,pop[lpParticles].partSnrCurr); \n\t\t\t \n \n\t        computeOK = ((struct fitFuncParams *)ffParams)->fitEvalFlag[parallel_get_thread_num()]; \n\t        funcCount = 0; \n\t        if (computeOK){ \n\t\t\t     \n \n\t            funcCount = 1; \n\t\t\t} \n\t        pop[lpParticles].partFitEvals += funcCount; \n\t\t\t \n \n\t        if (pop[lpParticles].partSnrPbest > pop[lpParticles].partSnrCurr){ \n\t            pop[lpParticles].partSnrPbest = pop[lpParticles].partSnrCurr; \n \n\t             \n \n\t            gsl_vector_memcpy(pop[lpParticles].partPbest,pop[lpParticles].partCoord); \n\t        } \n\t    } \n\t\t \n\t\t \n \n \n\t\t \n \n\t\tbestfitParticle = gsl_vector_min_index(partSnrCurrCol); \n\t    currBestFitVal = pop[bestfitParticle].partSnrCurr;  \n\t    if (gbestFitVal > currBestFitVal){ \n\t\t \n \n\t\t   \tgsl_multimin_fminimizer_set(minimzrState,&func2minimz, \n\t\t\t                            pop[bestfitParticle].partCoord, \n\t\t\t\t\t\t\t\t\t\tlocMinStp); \n\t\t\tfuncCount = 0; \n\t\t\t \n\t\t\tfor (lpLocMin = 0; lpLocMin < psoParams->locMinIter; lpLocMin++){ \n\t\t\t\tstatus = gsl_multimin_fminimizer_iterate(minimzrState); \n\t\t\t\t   \n \n\t\t\t\tif (status) \n\t\t\t\t\tbreak; \n\t\t\t\t  \n \n\t\t\t\tfuncCount += nDim+1; \n\t\t\t\tpop[bestfitParticle].partSnrCurr = gsl_multimin_fminimizer_minimum(minimzrState); \n                gsl_vector_memcpy(pop[bestfitParticle].partCoord, minimzrState->x); \n\t\t\t} \n\t\t\t \n\t        pop[bestfitParticle].partFitEvals += funcCount; \n\t\t\t \n \n\t\t\tpop[bestfitParticle].partSnrPbest = pop[bestfitParticle].partSnrCurr; \n\t\t\tgsl_vector_memcpy(pop[bestfitParticle].partPbest,pop[bestfitParticle].partCoord); \n\t\t\t \n \n\t\t\tgbestFitVal = pop[bestfitParticle].partSnrCurr; \n\t\t\tgsl_vector_memcpy(gbestCoord,pop[bestfitParticle].partCoord); \n\t\t\t \n \n\t\t\tgsl_vector_set(partSnrCurrCol,best", "pred": " \nvoid lbestpso(size_t nDim,  \n \n            fitness_function_ptr fitfunc,  \n \n\t\t\tvoid *ffParams,  \n \n\t\t\tcurrent_result_callback_params_t *callback_params,  \n \n            struct psoParamStruct *psoParams,  \n \n\t\t\tstruct returnData *psoResults  \n){ \n \n\tclock_t time_start = clock(); \n \n\t \n \n\tgsl_rng *rngGen = psoParams->rngGen; \n\t \n\t \n \n\tgsl_multimin_function func2minimz; \n\tfunc2minimz.n = nDim;  \n \n\tfunc2minimz.f = dummyfitfunc; \n \n\tstruct dummyFitFuncParam dffp; \n\tdffp.trufuncPr = fitfunc; \n\tdffp.trufuncParam = ffParams; \n\tfunc2minimz.params = &dffp; \n \n\t \n \n\tgsl_multimin_fminimizer *minimzrState = gsl_multimin_fminimizer_alloc(gsl_multimin_fminimizer_nmsimplex2, nDim); \n\t \n \n\tgsl_vector *locMinStp = gsl_vector_alloc(nDim); \n\tgsl_vector_set_all(locMinStp,psoParams->locMinStpSz); \n\tsize_t lpLocMin; \n \n\tint status; \n\t \n\t \n \n\tsize_t lpParticles, lpPsoIter; \n\t \n \n\tconst size_t popsize = psoParams->popsize; \n\t \n \n\tconst size_t maxSteps = psoParams->maxSteps; \n\t \n \n    struct particleInfo pop[popsize]; \n\t \n \n\tfor (lpParticles = 0; lpParticles < popsize; lpParticles++){ \n\t      initPsoParticles(&pop[lpParticles], nDim, rngGen); \n    }\t \n\t \n \n\tdouble gbestFitVal = GSL_POSINF; \n{\"\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nvoid naive2(int M, int N, float *A, \n            int K, float *B, float *C, float *S) \n{ \n\tint m; \n#pragma omp parallel for \n    for (m = 0; m < M; m++) \n    {\tregister int k,n; register float tmp; \n        for (k = 0; k < K; k++) { \n            tmp = 0; \n            for (n = 0; n < N; n++) \n                tmp += A[m * N + n] * B[n * K + k]; \n            C[m * K + k] = tmp; \n        } \n    } \n} ", "pred": " \nvoid naive2(int M, int N, float *A, \n            int K, float *B, float *C, float *S) \n{ \n\tint m; \n#pragma omp parallel for \n    for (m = 0; m < M; m++) \n    {\tregister int k,n; register float tmp; \n        for (k = 0; k < K; k++) { \n            tmp = 0; \n            for (n = 0; n < N; n++) \n                tmp += A[m * N + n] * B[n * K + k]; \n            C[m * K + k] = tmp; \n        } \n    } \n} "}
{"label": " \nint main( int argc,char *argv[] ) \n{ \n    MPI_Comm   comm[ MAX_THREADS ]; \n    int        my_rank, ii, provided; \n    int        num_threads; \n \n    MPI_Init_thread( &argc, &argv, MPI_THREAD_MULTIPLE, &provided ); \n    if ( provided!= MPI_THREAD_MULTIPLE ) { \n        fprintf( stderr, \"Aborting, MPI_THREAD_MULTIPLE is needed...\\n\" ); \n        fflush( stderr ); \n        MPI_Abort( MPI_COMM_WORLD, 1 ); \n    } \n \n    MPI_Comm_rank( MPI_COMM_WORLD, &my_rank ); \n \n    if ( my_rank == 0 ) { \n        if ( argc!= 2 ) { \n            fprintf( stderr, \"Error: %s num_threads\\n\", argv[0] ); \n            fflush( stderr ); \n            MPI_Abort( MPI_COMM_WORLD, 1 ); \n        } \n        num_threads = atoi( argv[1] ); \n        if ( num_threads < 1 ) { \n            fprintf( stderr, \"Error: Input num_threads=%d < 1 \\n\", \n                             num_threads ); \n            fflush( stderr ); \n            MPI_Abort( MPI_COMM_WORLD, 1 ); \n        } \n        if ( num_threads > MAX_THREADS ) { \n            fprintf( stderr, \"Error: Input num_threads=%d < %d \\n\", \n                             num_threads, MAX_THREADS ); \n            fflush( stderr ); \n            MPI_Abort( MPI_COMM_WORLD, 1 ); \n        } \n        MPI_Bcast( &num_threads, 1, MPI_INT, 0, MPI_COMM_WORLD ); \n    } \n    else \n        MPI_Bcast( &num_threads, 1, MPI_INT, 0, MPI_COMM_WORLD ); \n \n    MPI_Barrier( MPI_COMM_WORLD ); \n \n    for ( ii=0; ii < num_threads; ii++ ) { \n        MPI_Comm_dup( MPI_COMM_WORLD, &comm[ii] ); \n    } \n \n#pragma omp parallel shared( num_threads ) private( ii ) \n    #pragma omp for \n    for ( ii=0; ii < num_threads; ii++ ) { \n        thd_sendrecv( (void *) &comm[ii] ); \n    } \n\t \n    MPI_Finalize(); \n    return 0; \n} ", "pred": " \nint main( int argc,char *argv[] ) \n{ \n    MPI_Comm   comm[ MAX_THREADS ]; \n    int        my_rank, ii, provided; \n    int        num_threads; \n \n    MPI_Init_thread( &argc, &argv, MPI_THREAD_MULTIPLE, &provided ); \n    if ( provided!= MPI_THREAD_MULTIPLE ) { \n        fprintf( stderr, \"Aborting, MPI_THREAD_MULTIPLE is needed...\\n\" ); \n        fflush( stderr ); \n        MPI_Abort( MPI_COMM_WORLD, 1 ); \n    } \n \n    MPI_Comm_rank( MPI_COMM_WORLD, &my_rank ); \n \n    if ( my_rank == 0 ) { \n        if ( argc!= 2 ) { \n            fprintf( stderr, \"Error: %s num_threads\\n\", argv[0] ); \n            fflush( stderr ); \n            MPI_Abort( MPI_COMM_WORLD, 1 ); \n        } \n        num_threads = atoi( argv[1] ); \n        if ( num_threads < 1 ) { \n            fprintf( stderr, \"Error: Input num_threads=%d < 1 \\n\", \n                             num_threads ); \n            fflush( stderr ); \n            MPI_Abort( MPI_COMM_WORLD, 1 ); \n        } \n        if ( num_threads > MAX_THREADS ) { \n            fprintf( stderr, \"Error: Input num_threads=%d < 1 \\n\\\", num_threads );                                                                                                                                                                                                                                                                                                                                                                                                "}
{"label": " \ndouble integrate( double (*fn)(double), double a, double b, int n, int t, int print_times) \n{\t \n\t \n \n\t \n\tdouble tstart = 0;  \n \n\tdouble tend = 0;  \n \n\t \n\tdouble h = 0;  \n \n\tdouble curr_x = 0;  \n \n\tdouble sum = 0;  \n \n\tint i;  \n \n\t \n\t \n \n\ttstart = timer(); \n\t \n\t \n \n\th = (b - a) / (double) n; \n \n \n\t \n \n #pragma omp parallel num_threads(t), default(none), private(i, curr_x), shared(h, a, b, fn, n, sum) if(n>1300) \n\t \n\t \n \n\t \n\t \n \n #pragma omp for reduction(+:sum) schedule(static) \n\tfor (i = 0; i < n; i++) \n\t{ \n\t\tcurr_x = a + i * h; \n\t\t \n \n\t\tsum += h * ( ( (*fn)(curr_x) + (*fn)(curr_x - h) ) / 2); \n\t} \n\t \n\t \n \n\ttend = timer(); \n\t \n\t \n \n\tif (print_times == PRINT_TIMES) \n\t{ \n\t\tprintf(\"%d, %d, %f\\n\", n, t, tend-tstart); \n\t} \n\t \n\t \n \n\treturn sum; \n} ", "pred": " \ndouble integrate( double (*fn)(double), double a, double b, int n, int t, int print_times) \n{\t \n\t \n \n\t \n\tdouble tstart = 0;  \n \n\tdouble tend = 0;  \n \n\t \n\tdouble h = 0;  \n \n\tdouble curr_x = 0;  \n \n\tdouble sum = 0;  \n \n\tint i;  \n \n\t \n\t \n \n\ttstart = timer(); \n\t \n\t \n \n\th = (b - a) / (double) n; \n \n \n\t \n \n #pragma omp parallel num_threads(t), default(none), private(i, curr_x), shared(h, a, b, fn, n, sum) if(n>1300) \n\t \n\t \n \n\t \n\t \n \n #pragma omp for reduction(+:sum) schedule(static) \n\tfor (i = 0; i < n; i++) \n\t{ \n\t\tcurr_x = a + i * h; \n\t\t \n \n\t\tsum += h * ( ( (*fn)(curr_x) + (*fn)(curr_x - h) ) / 2); \n\t} \n\t \n\t \n \n\ttend = timer(); \n\t \n\t \n \n\tif (print_times == PRINT_TIMES) \n\t{ \n\t\tprintf(\"%d, %d, %f\\n\", n, t, tend-tstart); \n\t} \n\t \n\t \n \n\treturn sum; \n} "}
{"label": " \nMagickExport Image *SepiaToneImage(const Image *image,const double threshold, \n  ExceptionInfo *exception) \n{ \n#define SepiaToneImageTag  \"SepiaTone/Image\" \n \n  CacheView \n    *image_view, \n    *sepia_view; \n \n  Image \n    *sepia_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  sepia_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (sepia_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(sepia_image,DirectClass,exception) == MagickFalse) \n    { \n      sepia_image=DestroyImage(sepia_image); \n      return((Image *) NULL); \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  sepia_view=AcquireAuthenticCacheView(sepia_image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,sepia_image,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    register const Quantum \n      *restrict p; \n \n    register ssize_t \n      x; \n \n    register Quantum \n      *restrict q; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    q=GetCacheViewAuthenticPixels(sepia_view,0,y,sepia_image->columns,1, \n      exception); \n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      double \n        intensity, \n        tone; \n \n      intensity=GetPixelIntensity(image,p); \n      tone=intensity > threshold? (double) QuantumRange : intensity+ \n        (double) QuantumRange-threshold; \n      SetPixelRed(sepia_image,ClampToQuantum(tone),q); \n      tone=intensity > (7.0*threshold/6.0)? (double) QuantumRange : \n        intensity+(double) QuantumRange-7.0*threshold/6.0; \n      SetPixelGreen(sepia_image,ClampToQuantum(tone),q); \n      tone=intensity < (threshold/6.0)? 0 : intensity-threshold/6.0; \n      SetPixelBlue(sepia_image,ClampToQuantum(tone),q); \n      tone=threshold/7.0; \n      if ((double) GetPixelGreen(image,q) < tone) \n        SetPixelGreen(sepia_image,ClampToQuantum(tone),q); \n      if ((double) GetPixelBlue(image,q) < tone) \n        SetPixelBlue(sepia_image,ClampToQuantum(tone),q); \n      SetPixelAlpha(sepia_image,GetPixelAlpha(image,p),q); \n      p+=GetPixelChannels(image); \n      q+=GetPixelChannels(sepia_image); \n    } \n    if (SyncCacheViewAuthenticPixels(sepia_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        #pragma omp critical (MagickCore_SepiaToneImage) \n        proceed=SetImageProgress(image,SepiaToneImageTag,progress++, \n          image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  } \n  sepia_view=DestroyCacheView(sepia_view); \n  image_view=DestroyCacheView(image_view); \n  (void) NormalizeImage(sepia_image,exception); \n  (void) ContrastImage(sepia_image,MagickTrue,exception); \n  if (status == MagickFalse) \n    sepia_image=DestroyImage(sepia_image); \n  return(sepia_image); \n} ", "pred": " \nMagickExport Image *SepiaToneImage(const Image *image,const double threshold, \n  ExceptionInfo *exception) \n{ \n#define SepiaToneImageTag  \"SepiaTone/Image\" \n \n  CacheView \n    *image_view, \n    *sepia_view; \n \n  Image \n    *sepia_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  sepia_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (sepia_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(sepia_image,DirectClass,exception) == MagickFalse) \n    { \n      sepia_image=DestroyImage(sepia_image); \n      return((Image *) NULL); \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  sepia_view=AcquireAuthenticCacheView(sepia_image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,sepia_image,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    register const Quantum \n      *restrict p; \n \n    register ssize_t \n      x; \n \n    register Quantum \n      *restrict q; \n \n    if (status == MagickFalse)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nvoid __attribute((noinline)) cholesky_in_place(int N, float (*a)[N]) \n{ \n    float a_jj = 0.0f; \n \n    __assume(N%16==0); \n \n#pragma omp parallel firstprivate(N, a) \n{    \n    for (int j = 0; j < N; j++) \n    { \n \n#pragma omp for  \n        for (int i1 = j + 1; i1 < N; i1++) \n        { \n            int k; \n            float a_ij = a[i1][j]; \n \n#pragma omp simd reduction(-:a_ij) aligned(a:64) suitable(N) \n            for (k = 0; k < j; k++) \n            { \n                a_ij -=  a[i1][k] * a[j][k]; \n            } \n \n            a[i1][j] = a_ij; \n        } \n \n#pragma omp single  \n        { \n            a_jj = a[j][j]; \n        } \n \n        int i2; \n \n#pragma omp simd for private(i2) reduction(-:a_jj) aligned(a:64) suitable(N) \n        for (i2 = 0; i2 < j; i2++) \n        { \n            float tmp = a[j][i2]; \n            a_jj -= tmp * tmp; \n        } \n \n        float local_a_jj = sqrtf(a_jj); \n \n#pragma omp single nowait \n        { \n            a[j][j] = local_a_jj; \n        } \n \n        int i3; \n \n#pragma omp simd for private(i3) aligned(a:64) suitable(N) \n        for (i3 = j + 1; i3 < N; i3++) \n        { \n            a[i3][j] = a[i3][j] / local_a_jj; \n        } \n    } \n} \n} ", "pred": " \nvoid __attribute((noinline)) cholesky_in_place(int N, float (*a)[N]) \n{ \n    float a_jj = 0.0f; \n \n    __assume(N%16==0); \n \n#pragma omp parallel firstprivate(N, a) \n{    \n    for (int j = 0; j < N; j++) \n    { \n \n#pragma omp for  \n        for (int i1 = j + 1; i1 < N; i1++) \n        { \n            int k; \n            float a_ij = a[i1][j]; \n \n#pragma omp simd reduction(-:a_ij) aligned(a:64) suitable(N) \n            for (k = 0; k < j; k++) \n            { \n                a_ij -=  a[i1][k] * a[j][k]; \n            } \n \n            a[i1][j] = a_ij; \n        } \n \n#pragma omp single  \n        { \n            a_jj = a[j][j]; \n        } \n \n        int i2; \n \n#pragma omp simd for private(i2) reduction(-:a_jj) aligned(a:64) suitable(N) \n        for (i2 = 0; i2 < j; i2++) \n        { \n            float tmp = a[j][i2]; \n            a_jj -= tmp * tmp; \n        } \n \n        float local_a_jj = sqrtf(a_jj); \n \n#pragma omp single nowait \n        { \n                                                                                                                                                                           "}
{"label": " \nMagickExport Image *SwirlImage(const Image *image,double degrees, \n  const PixelInterpolateMethod method,ExceptionInfo *exception) \n{ \n#define SwirlImageTag  \"Swirl/Image\" \n \n  CacheView \n    *image_view, \n    *interpolate_view, \n    *swirl_view; \n \n  Image \n    *swirl_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  double \n    radius; \n \n  PointInfo \n    center, \n    scale; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  swirl_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if (swirl_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(swirl_image,DirectClass,exception) == MagickFalse) \n    { \n      swirl_image=DestroyImage(swirl_image); \n      return((Image *) NULL); \n    } \n  if (swirl_image->background_color.alpha!= OpaqueAlpha) \n    swirl_image->alpha_trait=BlendPixelTrait; \n   \n \n  center.x=(double) image->columns/2.0; \n  center.y=(double) image->rows/2.0; \n  radius=MagickMax(center.x,center.y); \n  scale.x=1.0; \n  scale.y=1.0; \n  if (image->columns > image->rows) \n    scale.y=(double) image->columns/(double) image->rows; \n  else \n    if (image->columns < image->rows) \n      scale.x=(double) image->rows/(double) image->columns; \n  degrees=(double) DegreesToRadians(degrees); \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  interpolate_view=AcquireVirtualCacheView(image,exception); \n  swirl_view=AcquireAuthenticCacheView(swirl_image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,swirl_image,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    double \n      distance; \n \n    PointInfo \n      delta; \n \n    register const Quantum \n      *restrict p; \n \n    register ssize_t \n      x; \n \n    register Quantum \n      *restrict q; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    q=QueueCacheViewAuthenticPixels(swirl_view,0,y,swirl_image->columns,1, \n      exception); \n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    delta.y=scale.y*(double) (y-center.y); \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n       \n \n      if (GetPixelReadMask(image,p) == 0) \n        { \n          SetPixelBackgoundColor(swirl_image,q); \n          p+=GetPixelChannels(image); \n          q+=GetPixelChannels(swirl_image); \n          continue; \n        } \n      delta.x=scale.x*(double) (x-center.x); \n      distance=delta.x*delta.x+delta.y*delta.y; \n      if (distance >= (radius*radius)) \n        { \n          register ssize_t \n            i; \n \n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n          { \n            PixelChannel channel=GetPixelChannelChannel(image,i); \n            PixelTrait traits=GetPixelChannelTraits(image,channel); \n            PixelTrait swirl_traits=GetPixelChannelTraits(swirl_image,channel); \n            if ((traits == UndefinedPixelTrait) || \n                (swirl_traits == UndefinedPixelTrait)) \n              continue; \n            SetPixelChannel(swirl_image,channel,p[i],q); \n          } \n        } \n      else \n        { \n          double \n            cosine, \n            factor, \n            sine; \n \n           \n \n          factor=1.0-sqrt((double) distance)/radius; \n          sine=sin((double) (degrees*factor*factor)); \n          cosine=cos((double) (degrees*factor*factor)); \n          status=InterpolatePixelChannels(image,interpolate_view,swirl_image, \n            method,((cosine*delta.x-sine*delta.y)/scale.x+center.x),(double) \n            ((sine*delta.x+cosine*delta.y)/scale.y+center.y),q,exception); \n        } \n      p+=GetPixelChannels(image); \n      q+=GetPixelChannels(swirl_image); \n    } \n    if (SyncCacheViewAuthenticPixels(swirl_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n ", "pred": " \nMagickExport Image *SwirlImage(const Image *image,double degrees, \n  const PixelInterpolateMethod method,ExceptionInfo *exception) \n{ \n#define SwirlImageTag  \"Swirl/Image\" \n \n  CacheView \n    *image_view, \n    *interpolate_view, \n    *swirl_view; \n \n  Image \n    *swirl_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  double \n    radius; \n \n  PointInfo \n    center, \n    scale; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  swirl_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if (swirl_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(swirl_image,DirectClass,exception) == MagickFalse) \n    { \n      swirl_image=DestroyImage(swirl_image); \n      return((Image *) NULL); \n    } \n  if (swirl_image->background_color.alpha!= OpaqueAlpha) \n    swirl_image->alpha_trait=BlendPixelTrait; \n   \n \n  center.x=(double) image->columns/2.0; \n  center.y=(double) image->rows/2.0; \n  radius=MagickMax(center.x,center.y); \n  scale.x=1.0; \n  scale.y=1.0; \n  if (image->columns > image->rows) \n    scale.y=(double) image->columns/(double) image->rows; \n  else \n    if (image->columns < 1.0)   scale.y=(double) image->columns/(double) image->columns/2.0;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "}
{"label": " \nvoid process_sse2(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters) \n  {  \n \n#pragma omp parallel for default(none) schedule(static) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const uint16_t *in = ((uint16_t *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      float *out = ((float *)ovoid) + (size_t)roi_out->width * j; \n \n      int i = 0; \n \n       \n \n      while((!dt_is_aligned(in, 16) ||!dt_is_aligned(out, 16)) && (i < roi_out->width)) \n      { \n        const int id = BL(roi_out, d, j, i); \n        *out = (((float)(*in)) - d->sub[id]) / d->div[id]; \n        i++; \n        in++; \n        out++; \n      } \n \n      const __m128 sub = _mm_set_ps(d->sub[BL(roi_out, d, j, i + 3)], d->sub[BL(roi_out, d, j, i + 2)], \n                                    d->sub[BL(roi_out, d, j, i + 1)], d->sub[BL(roi_out, d, j, i)]); \n \n      const __m128 div = _mm_set_ps(d->div[BL(roi_out, d, j, i + 3)], d->div[BL(roi_out, d, j, i + 2)], \n                                    d->div[BL(roi_out, d, j, i + 1)], d->div[BL(roi_out, d, j, i)]); \n \n       \n \n      for(; i < roi_out->width - (8 - 1); i += 8, in += 8) \n      { \n        const __m128i input = _mm_load_si128((__m128i *)in); \n \n        __m128i ilo = _mm_unpacklo_epi16(input, _mm_set1_epi16(0)); \n        __m128i ihi = _mm_unpackhi_epi16(input, _mm_set1_epi16(0)); \n \n        __m128 flo = _mm_cvtepi32_ps(ilo); \n        __m128 fhi = _mm_cvtepi32_ps(ihi); \n \n        flo = _mm_div_ps(_mm_sub_ps(flo, sub), div); \n        fhi = _mm_div_ps(_mm_sub_ps(fhi, sub), div); \n \n        _mm_stream_ps(out, flo); \n        out += 4; \n        _mm_stream_ps(out, fhi); \n        out += 4; \n      } \n \n       \n \n      for(; i < roi_out->width; i++, in++, out++) \n      { \n        const int id = BL(roi_out, d, j, i); \n        *out = (((float)(*in)) - d->sub[id]) / d->div[id]; \n      } \n    } \n \n    piece->pipe->dsc.filters = dt_rawspeed_crop_dcraw_filters(self->dev->image_storage.buf_dsc.filters, csx, csy); \n    adjust_xtrans_filters(piece->pipe, csx, csy); \n  } \n  else \n  {  \n \n \n    const __m128 sub = _mm_load_ps(d->sub), div = _mm_load_ps(d->div); \n \n#pragma omp parallel for default(none) schedule(static) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)4 * (roi_in->width * (j + csy) + csx); \n      float *out = ((float *)ovoid) + (size_t)4 * roi_out->width * j; \n \n       \n \n      for(int i = 0; i < roi_out->width; i++, in += 4, out += 4) \n      { \n        const __m128 input = _mm_load_ps(in); \n \n        const __m128 scaled = _mm_div_ps(_mm_sub_ps(input, sub), div); \n \n        _mm_stream_ps(out, scaled); \n      } \n    } \n  } \n \n  for(int k = 0; k < 4; k++) piece->pipe->dsc.processed_maximum[k] = 1.0f; \n \n  _mm_sfence(); \n} ", "pred": " \nvoid process_sse2(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters) \n  {  \n \n#pragma omp parallel for default(none) schedule(static) \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const uint16_t *in = ((uint16_t *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      float *out = ((float *)ovoid) + (size_t)roi_out->width * j; \n \n      int i = 0; \n \n       \n \n      while((!dt_is_aligned(in, 16) ||!dt_is_aligned(out, 16)) && (i < roi_out->width)) \n      { \n        const int id = BL(roi_out, d, j, i); \n        *out = (((float)(*in)) - d->sub[id]) / d->div[id]; \n        i++; \n        in++; \n        out++; \n      } \n \n      const __m128 sub = _mm_set_ps(d->sub[BL(roi_out, d, j, i + 3)], d->sub[BL(roi_out, d, j, i + 2)], \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "}
{"label": " \nMagickExport Image *TintImage(const Image *image,const char *blend, \n  const PixelInfo *tint,ExceptionInfo *exception) \n{ \n#define TintImageTag  \"Tint/Image\" \n \n  CacheView \n    *image_view, \n    *tint_view; \n \n  double \n    intensity; \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *tint_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PixelInfo \n    color_vector; \n \n  MagickStatusType \n    flags; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  tint_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if (tint_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(tint_image,DirectClass,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if ((IsGrayColorspace(image->colorspace)!= MagickFalse) && \n      (IsPixelInfoGray(tint) == MagickFalse)) \n    (void) SetImageColorspace(tint_image,sRGBColorspace,exception); \n  if (blend == (const char *) NULL) \n    return(tint_image); \n   \n \n  GetPixelInfo(image,&color_vector); \n  flags=ParseGeometry(blend,&geometry_info); \n  color_vector.red=geometry_info.rho; \n  color_vector.green=geometry_info.rho; \n  color_vector.blue=geometry_info.rho; \n  color_vector.alpha=(MagickRealType) OpaqueAlpha; \n  if ((flags & SigmaValue)!= 0) \n    color_vector.green=geometry_info.sigma; \n  if ((flags & XiValue)!= 0) \n    color_vector.blue=geometry_info.xi; \n  if ((flags & PsiValue)!= 0) \n    color_vector.alpha=geometry_info.psi; \n  if (image->colorspace == CMYKColorspace) \n    { \n      color_vector.black=geometry_info.rho; \n      if ((flags & PsiValue)!= 0) \n        color_vector.black=geometry_info.psi; \n      if ((flags & ChiValue)!= 0) \n        color_vector.alpha=geometry_info.chi; \n    } \n  intensity=(double) GetPixelInfoIntensity(image,tint); \n  color_vector.red=(double) (color_vector.red*tint->red/100.0-intensity); \n  color_vector.green=(double) (color_vector.green*tint->green/100.0-intensity); \n  color_vector.blue=(double) (color_vector.blue*tint->blue/100.0-intensity); \n  color_vector.black=(double) (color_vector.black*tint->black/100.0-intensity); \n  color_vector.alpha=(double) (color_vector.alpha*tint->alpha/100.0-intensity); \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  tint_view=AcquireAuthenticCacheView(tint_image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,tint_image,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    register const Quantum \n      *restrict p; \n \n    register Quantum \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    q=QueueCacheViewAuthenticPixels(tint_view,0,y,tint_image->columns,1, \n      exception); \n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      PixelInfo \n        pixel; \n \n      double \n        weight; \n \n      register ssize_t \n        i; \n \n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n      { \n        PixelChannel channel=GetPixelChannelChannel(image,i); \n        PixelTrait traits=GetPixelChannelTraits(image,channel); \n        PixelTrait tint_traits=GetPixelChannelTraits(tint_image,channel); \n        if ((traits == UndefinedPixelTrait) || \n            (tint_traits == UndefinedPixelTrait)) \n          continue; \n        if (((tint_traits & CopyPixelTrait)!= 0) || \n            (GetPixelReadMask(image,p) == 0)) \n          { \n            SetPixelChannel(tint_image,channel,p[i],q); \n            continue; \n          } \n      } \n      GetPixelInfo(image,&pixel); \n      weight=QuantumScale*GetPixelRed(image,p)-0.5; \n      pixel.red=(double) GetPixelRed(image,p)+color_vector.red*(1.0-(4.0* \n        (weight*weight))); \n      weight=QuantumScale*GetPixelGreen(image,p)-0.5; \n      pixel.green=(double) GetPixelGreen(image,p)+color_vector.green*(1.0-(4.0* \n        (weight*weight))); \n      weight=QuantumScale*GetPixelBlue(image,p)-0.5; \n      pixel.blue=(double) GetPixelBlue(image,p)+color_vector.blue*(1.0-(4.0* \n      ", "pred": " \nMagickExport Image *TintImage(const Image *image,const char *blend, \n  const PixelInfo *tint,ExceptionInfo *exception) \n{ \n#define TintImageTag  \"Tint/Image\" \n \n  CacheView \n    *image_view, \n    *tint_view; \n \n  double \n    intensity; \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *tint_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PixelInfo \n    color_vector; \n \n  MagickStatusType \n    flags; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  tint_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if (tint_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(tint_image,DirectClass,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if ((IsGrayColorspace(image->colorspace)!= MagickFalse) && \n      (IsPixelInfoGray(tint) == MagickFalse)) \n    (void) SetImageColorspace(tint_image,sRGBColorspace,exception); \n  if (blend == (const char *) NULL) \n    return(tint_image); \n   \n \n  GetPixelInfo(image,&color_vector); \n  flags=ParseGeometry(blend,&geometry_info); \n  color_vector.red=geometry_info.rho;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nvoid THNN_(SpatialConvolutionMM_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput, \n          THTensor *weight, \n          THTensor *finput, \n          THTensor *fgradInput, \n          int kW, \n          int kH, \n          int dW, \n          int dH, \n          int padW, \n          int padH) \n{ \n  long nOutputPlane = weight->size[0]; \n \n  THArgCheck( nOutputPlane == gradOutput->size[input->nDimension == 4? 1 : 0], 3, \"Number of output features is not equal to nOutputPlane\" ); \n  THArgCheck(kW > 0 && kH > 0, 9, \"kernel size should be greater than zero\"); \n  THArgCheck(dW > 0 && dH > 0, 11, \"stride should be greater than zero\"); \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(resizeAs)(fgradInput, finput); \n  THTensor_(transpose)(weight, weight, 0, 1); \n \n  if(input->nDimension == 3) \n  { \n    THNN_(SpatialConvolutionMM_updateGradInput_frame)(gradInput, gradOutput, weight, fgradInput, kW, kH, dW, dH, padW, padH); \n  } \n  else \n  { \n    long T = input->size[0]; \n    long t; \n \n#pragma omp parallel for private(t) \n    for(t = 0; t < T; t++) \n    { \n      THTensor *gradInput_t = THTensor_(newSelect)(gradInput, 0, t); \n      THTensor *gradOutput_t = THTensor_(newSelect)(gradOutput, 0, t); \n      THTensor *fgradInput_t = THTensor_(newSelect)(fgradInput, 0, t); \n \n      THNN_(SpatialConvolutionMM_updateGradInput_frame)(gradInput_t, gradOutput_t, weight, fgradInput_t, kW, kH, dW, dH, padW, padH); \n \n      THTensor_(free)(gradInput_t); \n      THTensor_(free)(gradOutput_t); \n      THTensor_(free)(fgradInput_t); \n    } \n  } \n \n  THTensor_(transpose)(weight, weight, 0, 1); \n} ", "pred": " \nvoid THNN_(SpatialConvolutionMM_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput, \n          THTensor *weight, \n          THTensor *finput, \n          THTensor *fgradInput, \n          int kW, \n          int kH, \n          int dW, \n          int dH, \n          int padW, \n          int padH) \n{ \n  long nOutputPlane = weight->size[0]; \n \n  THArgCheck( nOutputPlane == gradOutput->size[input->nDimension == 4? 1 : 0], 3, \"Number of output features is not equal to nOutputPlane\" ); \n  THArgCheck(kW > 0 && kH > 0, 9, \"kernel size should be greater than zero\"); \n  THArgCheck(dW > 0 && dH > 0, 11, \"stride should be greater than zero\"); \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(resizeAs)(fgradInput, finput); \n  THTensor_(transpose)(weight, weight, 0, 1); \n \n  if(input->nDimension == 3) \n  { \n    THNN_(SpatialConvolutionMM_updateGradInput_frame)(gradInput, gradOutput, weight, fgradInput, kW, kH, dW, dH, padW, padH); \n  } \n  else \n  { \n    long T = input->size[0]; \n    long t; \n \n#pragma omp parallel for private(t) \n    for(t = 0; t < T; t++) \n    { \n      THTensor *gradInput_t = THTensor_(newSelect)(gradInput, 0, t); \n      THTensor *gradOutput_t = THTensor_(newSelect)(gradOutput, 0, t);                                                                                                                                                                                       "}
{"label": " \nstatic int \nmom_gauge_spatial( struct site *__restrict A, \n\t\t   const lie_field_def def ) \n{ \n  size_t i ;  \n \n   \n \n  void (*log)( GLU_complex Q[ NCNC ], \n\t       const GLU_complex U[ NCNC ] ) ; \n  log = Hermitian_proj ; \n  switch( def ) { \n  case LOG_DEF :  \n    log = exact_log_slow ;  \n    break ; \n  case LINEAR_DEF : \n    break ; \n  } \n \n#pragma omp parallel for private(i) shared(A) \n  for( i = 0 ; i < LVOLUME ; i++ ) { \n    GLU_complex temp[ NCNC ] ; \n    size_t mu ; \n    for( mu = 0 ; mu < ND ; mu++ ) { \n      log( temp, A[i].O[mu] ) ; \n      equiv( A[i].O[mu], temp ) ; \n    } \n  } \n \n   \n \n  struct fftw_small_stuff FFTW ; \n  small_create_plans_DFT( &FFTW, Latt.dims, ND-1 ) ; \n \n   \n \n   \n   \n \n  size_t t ; \n  for( t = 0 ; t < Latt.dims[ ND - 1 ] ; t++ )  { \n    const size_t slice = LCU *t ; \n    size_t mu, i, j ;  \n     \n \n    for( mu = 0 ; mu < ND ; mu++ ) \n      for( j = 0 ; j < NCNC ; j++ ) { \n\t \n \n        #pragma omp parallel for private(i) \n        for( i = 0 ; i < LCU ; i++ ) { \n\t  FFTW.in[i] = A[ slice + i ].O[mu][j] ;  \n\t} \n\tfftw_execute( FFTW.forward ) ;  \n        #pragma omp parallel for private(i) \n        for( i = 0 ; i < LCU ; i++ ) { \n\t  A[ slice + i ].O[mu][j] = FFTW.out[i] ;  \n\t} \n\t \n \n        #pragma omp parallel for private(i) \n        for( i = 0 ; i < LCU ; i++ ) { \n\t  FFTW.out[i] = A[ slice + i ].O[mu][j] ;  \n\t} \n\tfftw_execute( FFTW.backward ) ;  \n        #pragma omp parallel for private(i) \n        for( i = 0 ; i < LCU ; i++ ) { \n\t  A[ slice + i ].O[mu][j] = FFTW.in[i] ;  \n\t} \n      } \n  } \n \n   \n \n   \n \n  small_clean_up_fftw( FFTW ) ; \n \n  return GLU_SUCCESS ; \n} ", "pred": " \nstatic int \nmom_gauge_spatial( struct site *__restrict A, \n\t\t   const lie_field_def def ) \n{ \n  size_t i ;  \n \n   \n \n  void (*log)( GLU_complex Q[ NCNC ], \n\t       const GLU_complex U[ NCNC ] ) ; \n  log = Hermitian_proj ; \n  switch( def ) { \n  case LOG_DEF :  \n    log = exact_log_slow ;  \n    break ; \n  case LINEAR_DEF : \n    break ; \n  } \n \n#pragma omp parallel for private(i) shared(A) \n  for( i = 0 ; i < LVOLUME ; i++ ) { \n    GLU_complex temp[ NCNC ] ; \n    size_t mu ; \n    for( mu = 0 ; mu < ND ; mu++ ) { \n      log( temp, A[i].O[mu] ) ; \n      equiv( A[i].O[mu], temp ) ; \n    } \n  } \n \n   \n \n  struct fftw_small_stuff FFTW ; \n  small_create_plans_DFT( &FFTW, Latt.dims, ND-1 ) ; \n \n   \n \n   \n   \n \n  size_t t ; \n  for( t = 0 ; t < Latt.dims[ ND - 1 ] ; t++ )  { \n    const size_t slice = LCU *t ; \n    size_t mu, i, j ;  \n     \n \n    for( mu = 0 ; mu < ND ; mu++ ) \n      for( j = 0 ; j < NCNC ; j++ ) { \n\t \n \n        #pragma omp parallel for private(i) \n        for( i = 0 ; i < LCU ; i++ ) { \n\t  FFTW.in[i] = A[ slice + i ].O[mu][j] ;  \n\t} \n\tfftw_execute( FFTW.forward ) ;  \n        #pragma omp parallel for private(i)                                                                                                                                                                                                                                                                                                 "}
{"label": " \nvoid cawfl3(camoperator3d weop, \n\t    cub3d cub, \n\t    cam3d cam, \n\t    tap3d tap, \n\t    slo3d slo, \n\t    bool  inv    \n,  \n\t    sf_fslice data  \n, \n\t    sf_fslice wfld  \n) \n \n \n{ \n    int imz,iw; \n    sf_complex w; \n    int ompith=0; \n     \n#pragma omp parallel for schedule(static)      private(ompith,iw,w,imz)        shared(data,wfld,weop,cub,cam,tap,slo) \n    for (iw=0; iw<cub->aw.n; iw++) { \n\tompith=omp_get_thread_num(); \n \n\tif(inv) {  \n \n\t    w = sf_cmplx(cub->eps*cub->aw.d,+(cub->aw.o+iw*cub->aw.d));  \n \n\t     \n#pragma omp critical \n\t    sf_fslice_get(data,iw,weop->ww[ompith][0][0]); \n\t    taper3d(weop->ww[ompith],tap); \n\t    sf_fslice_put(wfld,iw*cub->amz.n+cub->amz.n-1,weop->ww[ompith][0][0]); \n \n#pragma omp critical \n\t    sf_fslice_get(slo->slice,cub->amz.n-1,slo->so[ompith][0]); \n\t    for (imz=cub->amz.n-1; imz>0; imz--) { \n#pragma omp critical \n\t\tif(cub->verb) sf_warning (\"(ith=%d)... <iw=%3d of %3d> <iz=%3d of %3d>\", \n\t\t\t\t\t  ompith,iw+1,cub->aw.n,imz+1,cub->amz.n); \n \n#pragma omp critical \n\t\tsf_fslice_get(slo->slice,imz-1,slo->ss[ompith][0]); \n\t\tcam3_ssf(w,weop->ww[ompith],cub,cam,tap,slo,imz,ompith); \n\t\tslow3_advance(cub,slo,ompith); \n \n#pragma omp critical \n\t\tsf_fslice_put(wfld,iw*cub->amz.n+imz-1,weop->ww[ompith][0][0]); \n\t    } \n \n\t} else {   \n \n\t    w = sf_cmplx(cub->eps*cub->aw.d,-(cub->aw.o+iw*cub->aw.d));  \n \n \n#pragma omp critical \n\t    sf_fslice_get(data,iw,weop->ww[ompith][0][0]); \n\t    taper3d(weop->ww[ompith],tap); \n\t    sf_fslice_put(wfld,iw*cub->amz.n,weop->ww[ompith][0][0]); \n \n#pragma omp critical \n\t    sf_fslice_get(slo->slice,0,slo->so[ompith][0]); \n\t    for (imz=0; imz<cub->amz.n-1; imz++) {\t \n#pragma omp critical \n\t\tif(cub->verb) sf_warning (\"(ith=%d)... <iw=%3d of %3d> <iz=%3d of %3d>\", \n\t\t\t\t\t  ompith,iw+1,cub->aw.n,imz+1,cub->amz.n); \n     \n#pragma omp critical \n\t\tsf_fslice_get(slo->slice,imz+1,slo->ss[ompith][0]); \n\t\tcam3_ssf(w,weop->ww[ompith],cub,cam,tap,slo,imz,ompith); \n\t\tslow3_advance(cub,slo,ompith); \n \n#pragma omp critical \n\t\tsf_fslice_put(wfld,iw*cub->amz.n+imz+1,weop->ww[ompith][0][0]); \n\t    }  \n \n\t}  \n \n    }  \n \n} ", "pred": " \nvoid cawfl3(camoperator3d weop, \n\t    cub3d cub, \n\t    cam3d cam, \n\t    tap3d tap, \n\t    slo3d slo, \n\t    bool  inv    \n,  \n\t    sf_fslice data  \n, \n\t    sf_fslice wfld  \n) \n \n \n{ \n    int imz,iw; \n    sf_complex w; \n    int ompith=0; \n     \n#pragma omp parallel for schedule(static)      private(ompith,iw,w,imz)        shared(data,wfld,weop,cub,cam,tap,slo) \n    for (iw=0; iw<cub->aw.n; iw++) { \n\tompith=omp_get_thread_num(); \n \n\tif(inv) {  \n \n\t    w = sf_cmplx(cub->eps*cub->aw.d,+(cub->aw.o+iw*cub->aw.d));  \n \n\t     \n#pragma omp critical \n\t    sf_fslice_get(data,iw,weop->ww[ompith][0][0]); \n\t    taper3d(weop->ww[ompith],tap); \n\t    sf_fslice_put(wfld,iw*cub->amz.n+cub->amz.n-1,weop->ww[ompith][0][0]); \n \n#pragma omp critical \n\t    sf_fslice_get(slo->slice,cub->amz.n-1,slo->so[ompith][0]); \n\t    for (imz=cub->amz.n-1; imz>0; imz--) { \n#pragma omp critical \n\t\tif(cub->verb) sf_warning (\"(ith=%d)... <iw=%3d of %3d> <iz=%3d of %3d>\", \n\t\t\t\t\t  ompith,iw+1,cub->aw.n,imz+1,cub->amz.n,cub->amz.n);\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "}
{"label": " \nMagickExport Image *ColorizeImage(const Image *image,const char *blend, \n  const PixelInfo *colorize,ExceptionInfo *exception) \n{ \n#define ColorizeImageTag  \"Colorize/Image\" \n#define Colorize(pixel,blend_percentage,colorize)     (((pixel)*(100.0-(blend_percentage))+(colorize)*(blend_percentage))/100.0) \n \n  CacheView \n    *colorize_view, \n    *image_view; \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *colorize_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickStatusType \n    flags; \n \n  PixelInfo \n    blend_percentage; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  colorize_image=CloneImage(image,image->columns,image->rows,MagickTrue, \n    exception); \n  if (colorize_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(colorize_image,DirectClass,exception) == MagickFalse) \n    { \n      colorize_image=DestroyImage(colorize_image); \n      return((Image *) NULL); \n    } \n  if ((IsGrayColorspace(image->colorspace)!= MagickFalse) || \n      (IsPixelInfoGray(colorize)!= MagickFalse)) \n    (void) SetImageColorspace(colorize_image,sRGBColorspace,exception); \n  if ((colorize_image->alpha_trait == UndefinedPixelTrait) && \n      (colorize->alpha_trait!= UndefinedPixelTrait)) \n    (void) SetImageAlpha(colorize_image,OpaqueAlpha,exception); \n  if (blend == (const char *) NULL) \n    return(colorize_image); \n  GetPixelInfo(image,&blend_percentage); \n  flags=ParseGeometry(blend,&geometry_info); \n  blend_percentage.red=geometry_info.rho; \n  blend_percentage.green=geometry_info.rho; \n  blend_percentage.blue=geometry_info.rho; \n  blend_percentage.black=geometry_info.rho; \n  blend_percentage.alpha=(MagickRealType) TransparentAlpha; \n  if ((flags & SigmaValue)!= 0) \n    blend_percentage.green=geometry_info.sigma; \n  if ((flags & XiValue)!= 0) \n    blend_percentage.blue=geometry_info.xi; \n  if ((flags & PsiValue)!= 0) \n    blend_percentage.alpha=geometry_info.psi; \n  if (blend_percentage.colorspace == CMYKColorspace) \n    { \n      if ((flags & PsiValue)!= 0) \n        blend_percentage.black=geometry_info.psi; \n      if ((flags & ChiValue)!= 0) \n        blend_percentage.alpha=geometry_info.chi; \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  colorize_view=AcquireAuthenticCacheView(colorize_image,exception); \n  #pragma omp parallel for schedule(static,4) shared(progress,status)      magick_threads(image,colorize_image,image->rows,1) \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    MagickBooleanType \n      sync; \n \n    register const Quantum \n      *restrict p; \n \n    register Quantum \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    q=QueueCacheViewAuthenticPixels(colorize_view,0,y,colorize_image->columns,1, \n      exception); \n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      register ssize_t \n        i; \n \n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n      { \n        PixelChannel channel=GetPixelChannelChannel(image,i); \n        PixelTrait traits=GetPixelChannelTraits(image,channel); \n        PixelTrait colorize_traits=GetPixelChannelTraits(colorize_image, \n          channel); \n        if ((traits == UndefinedPixelTrait) || \n            (colorize_traits == UndefinedPixelTrait)) \n          continue; \n        if (((colorize_traits & CopyPixelTrait)!= 0) || \n            (GetPixelReadMask(image,p) == 0)) \n          { \n            SetPixelChannel(colorize_image,channel,p[i],q); \n            continue; \n          } \n        SetPixelChannel(colorize_image,channel,ClampToQuantum(Colorize(p[i], \n          GetPixelInfoChannel(&blend_percentage,channel),GetPixelInfoChannel( \n          colorize,channel))),q); \n      } \n      p+=GetPixelChannels(image); \n      q+=GetPixelChannels(colorize_image); \n    } \n    sync=SyncCacheViewAuthenticPixels(colorize_view,exception); \n    if (sync == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        #pragma omp critical (MagickCore_ColorizeImage) \n        proceed=SetImageProgress(image,ColorizeImageTag,progress++,image->rows); \n  ", "pred": " \nMagickExport Image *ColorizeImage(const Image *image,const char *blend, \n  const PixelInfo *colorize,ExceptionInfo *exception) \n{ \n#define ColorizeImageTag  \"Colorize/Image\" \n#define Colorize(pixel,blend_percentage,colorize)     (((pixel)*(100.0-(blend_percentage))+(colorize)*(blend_percentage))/100.0) \n \n  CacheView \n    *colorize_view, \n    *image_view; \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *colorize_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickStatusType \n    flags; \n \n  PixelInfo \n    blend_percentage; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  colorize_image=CloneImage(image,image->columns,image->rows,MagickTrue, \n    exception); \n  if (colorize_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(colorize_image,DirectClass,exception) == MagickFalse) \n    { \n      colorize_image=DestroyImage(colorize_image); \n      return((Image *) NULL); \n    } \n  if ((IsGrayColorspace(image->colorspace)!= MagickFalse) || \n      (IsPixelInfoGray(colorize)!= MagickFalse)) \n    (void) SetImageColorspace(colorize_image,sRGBColorspace,exception); \n  if ((colorize_image->alpha_trait == UndefinedPixelTrait) && \n      (colorize->alpha_trait == UndefinedPixelTrait)) {  \\n\\n        if (image->signature == MagickSignature)\\n          {\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n            \\n\\n      "}
{"label": " \nint  \ncuts_spatial ( struct site *__restrict A, \n\t       const struct cut_info CUTINFO ) \n{ \n  fprintf( stdout, \"\\n[CUTS] Instantaneous Spatial/Temporal prop calculating... \\n\" ) ;  \n   \n \n  mom_gauge_spatial( A, CUTINFO.definition ) ;  \n \n  if( check_psq( CUTINFO ) == GLU_FAILURE ) { \n    return GLU_FAILURE ; \n  } \n   \n   \n \n  size_t *num_mom = malloc( sizeof( size_t ) ) ;  \n  const struct veclist *list = compute_veclist( num_mom, CUTINFO, \n\t\t\t\t\t\tND-1, GLU_FALSE ) ; \n \n   \n \n  correct_pspace_landau( A, list, num_mom, ND-1 ) ; \n \n   \n \n  char *str = output_str_struct( CUTINFO ) ; \n  FILE *Aps = fopen( str, \"wb\" ) ;  \n \n  write_mom_veclist( Aps, num_mom, list, ND - 1 ) ; \n \n   \n \n   \n \n \n   \n \n  double *g2_spatial = ( double* )malloc( num_mom[0] * sizeof( double ) ) ;  \n  double *g2_temporal = ( double* )malloc( num_mom[0] * sizeof( double ) ) ;  \n \n   \n \n  const double g2_norm = ND > 2? 2.0 / ( ( NCNC - 1 ) * ( ND - 2 ) * LVOLUME ) : 2.0 / ( ( NCNC - 1 ) * LVOLUME ) ;  \n  const double g0_norm = ND > 1? 2.0 / ( ( NCNC - 1 ) * ( ND - 1 ) * LVOLUME ) : 2.0 / ( ( NCNC - 1 ) * LVOLUME ) ;  \n \n   \n \n  const size_t midpoint = ( num_mom[0] - 1 ) >> 1 ; \n \n  size_t i ; \n#pragma omp parallel for private(i)  \n  for( i = 0  ;  i < num_mom[0]  ;  i++  ) { \n    double sum_spatial = 0. ;  \n    double sum_temporal = 0. ; \n    GLU_complex tr ; \n    size_t t, mu, mom, cnj ; \n    for( t = 0 ;  t < Latt.dims[ ND - 1 ]  ;  t++ ) { \n      mom = LCU * t + list[ i ].idx ;   \n      cnj = LCU * t + list[ num_mom[0] - i - 1 ].idx ;   \n       \n \n      for( mu = 0 ; mu < ND - 1 ; mu++ ) {       \n\ttrace_ab( &tr, A[ mom ].O[mu], A[ cnj ].O[mu] ) ; \n\tsum_spatial += (double)creal( tr ) ; \n      } \n      trace_ab( &tr, A[ mom ].O[ ND - 1 ], A[ cnj ].O[ ND - 1 ] ) ; \n      sum_temporal += (double)creal( tr ) ; \n    } \n       \n    if( i!= midpoint ) { \n      sum_spatial *= g2_norm ;  \n      sum_temporal *= g2_norm ;  \n    } else {\t   \n      sum_spatial *= g0_norm ;  \n      sum_temporal *= g0_norm ;  \n    }      \n     \n    g2_spatial[i] = sum_spatial ;  \n    g2_temporal[i] = sum_temporal ;  \n  } \n   \n   \n \n  write_g2g3_to_list( Aps, g2_spatial, g2_temporal, num_mom ) ; \n   \n   \n \n  fprintf( stdout, \"[CUTS] Writing finished...\\n[CUTS] Outputting to %s \\n\", str ) ; \n  \n   \n \n  fclose( Aps ) ; \n  free( (void*)list ) ;  \n  free( num_mom ) ;  \n  free( str ) ; \n  free( g2_spatial ) ; \n  free( g2_temporal ) ; \n \n   \n \n  return GLU_SUCCESS ; \n} ", "pred": " \nint  \ncuts_spatial ( struct site *__restrict A, \n\t       const struct cut_info CUTINFO ) \n{ \n  fprintf( stdout, \"\\n[CUTS] Instantaneous Spatial/Temporal prop calculating... \\n\" ) ;  \n   \n \n  mom_gauge_spatial( A, CUTINFO.definition ) ;  \n \n  if( check_psq( CUTINFO ) == GLU_FAILURE ) { \n    return GLU_FAILURE ; \n  } \n   \n   \n \n  size_t *num_mom = malloc( sizeof( size_t ) ) ;  \n  const struct veclist *list = compute_veclist( num_mom, CUTINFO, \n\t\t\t\t\t\tND-1, GLU_FALSE ) ; \n \n   \n \n  correct_pspace_landau( A, list, num_mom, ND-1 ) ; \n \n   \n \n  char *str = output_str_struct( CUTINFO ) ; \n  FILE *Aps = fopen( str, \"wb\" ) ;  \n \n  write_mom_veclist( Aps, num_mom, list, ND - 1 ) ; \n \n   \n \n   \n \n \n   \n \n  double *g2_spatial = ( double* )malloc( num_mom[0] * sizeof( double ) ) ;  \n  double *g2_temporal = ( double* )malloc( num_mom[0] * sizeof( double ) ) ;  \n \n   \n \n  const double g2_norm = ND > 2? 2.0 / ( ( NCNC - 1 ) * ( ND - 2 ) * LVOLUME ) : 2.0 / ( ( NCNC - 1 ) * LVOLUME ) ;  \n  const double g0_norm = ND > 1? 2.0 / ( ( NCNC - 1 ) * ( ND - 1 ) * LVOLUME ) : 2.0 / ( ( NCNC - 1 ) * LVOLUME ) ;  \n \n   \n \n  const size_t midpoint = ( num_mom[0] - 1 ) >> 1 ; \n \n  size_t i ; \n#pragma omp parallel for private(i)  \n  for( i = 0  ;  i < num_mom[0] * sizeof( size_t ) ) {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n        int i=0; \n \n\t   bomp_bomp_init(4); \n       omp_set_num_threads(4); \n \n        static struct thread_mutex lock = THREAD_MUTEX_INITIALIZER; \n        static spinlock_t lock = 0; \n        static spinlock_t lock = 0; \n        static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; \n \n        uint64_t begin = rdtsc(); \n \n        #pragma omp parallel \n        { \n#pragma omp for private(i) \n\t\t   for(i=0;i<1000000;i++) \n\t\t   { \n                       acquire_spinlock(&lock); \n                       release_spinlock(&lock); \n                       thread_mutex_lock(&lock); \n                       thread_mutex_unlock(&lock); \n\t\t   } \n\t} \n \n        uint64_t end = rdtsc(); \n \n        printf(\"took %lu\\n\", end - begin); \n} ", "pred": " \nint main(int argc, char *argv[]) \n{ \n        int i=0; \n \n\t   bomp_bomp_init(4); \n       omp_set_num_threads(4); \n \n        static struct thread_mutex lock = THREAD_MUTEX_INITIALIZER; \n        static spinlock_t lock = 0; \n        static spinlock_t lock = 0; \n        static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; \n \n        uint64_t begin = rdtsc(); \n \n        #pragma omp parallel \n        { \n#pragma omp for private(i) \n\t\t   for(i=0;i<1000000;i++) \n\t\t   { \n                       acquire_spinlock(&lock); \n                       release_spinlock(&lock); \n                       thread_mutex_lock(&lock); \n                       thread_mutex_unlock(&lock); \n\t\t   } \n\t} \n \n        uint64_t end = rdtsc(); \n \n        printf(\"took %lu\\n\", end - begin); \n} "}
{"label": " \nvoid trans(int M, int N, float *A, \n           int K, float *B, float *C, float *S) \n{ \n\tint k; \n#pragma omp parallel for \n    for (k = 0; k < K; k++) { \n\t    int n,m; \n\t    float tmp; \n\t    int k_x_N = k * N; \n        for (n = 0; n < N; n++) \n            S[k_x_N + n] = B[n * K + k]; \n        for (m = 0; m < M; m++) { \n            tmp = 0; \n            for (int n = 0; n < N; n++) \n                tmp += A[m * N +n] * S[k_x_N + n]; \n            C[m * K + k] = tmp; \n        } \n    } \n \n} ", "pred": " \nvoid trans(int M, int N, float *A, \n           int K, float *B, float *C, float *S) \n{ \n\tint k; \n#pragma omp parallel for \n    for (k = 0; k < K; k++) { \n\t    int n,m; \n\t    float tmp; \n\t    int k_x_N = k * N; \n        for (n = 0; n < N; n++) \n            S[k_x_N + n] = B[n * K + k]; \n        for (m = 0; m < M; m++) { \n            tmp = 0; \n            for (int n = 0; n < N; n++) \n                tmp += A[m * N +n] * S[k_x_N + n]; \n            C[m * K + k] = tmp; \n        } \n    } \n \n} "}
{"label": " \nint main() { \n    double Qx0 = 4.0; \n    double Qy0 = 4.0; \n \n    int Nx = 16; \n    int Ny = 16; \n \n    int Nt = 50000; \n    double dt = 0.0025; \n \n    int NDimx = 2 * Nx + 4; \n    int NDimy = 2 * Ny + 4; \n    double vx[NDimx][NDimy]; \n    double vy[NDimx][NDimy]; \n    int Lx = 2 * Nx; \n    int Ly = 2 * Ny; \n    double DQx = Qx0 / Nx; \n    double DQy = Qy0 / Ny; \n    double DVQ = DQx * DQy / ((2 * M_PI) * (2 * M_PI)); \n    double vvxx[NDimx][NDimy], vvxy[NDimx][NDimy]; \n    double vvyx[NDimx][NDimy], vvyy[NDimx][NDimy]; \n    double vvzx[NDimx][NDimy], vvzy[NDimx][NDimy]; \n \n    printf(\"NCriteria -> %g\\n\",Qx0*Qy0*nu*dt); \n \n    for (int ix = 0; ix <= Lx; ix++) { \n        for (int iy = 0; iy <= Ly; iy++) { \n            double Qx = -Qx0 + ix * DQx; \n            double Qy = -Qy0 + iy * DQy; \n \n            vx[ix][iy] = arc4random_uniform(10) * 1E-3; \n            vy[ix][iy] = arc4random_uniform(10) * 1E-3; \n \n \n            double Q2 = Qx * Qx + Qy * Qy; \n            double Q = sqrt(Q2); \n \n            if (((ix - Nx) * (ix - Nx) + (iy - Ny) * (iy - Ny)) == 0) { \n                continue; \n            } \n            double nx = Qx / Q; \n            double ny = Qy / Q; \n \n            double vn = vx[ix][iy] * nx + vy[ix][iy] * ny; \n \n            vx[ix][iy] -= vn * nx; \n            vy[ix][iy] -= vn * ny; \n        } \n    } \n \n \n    for (int it = 1; it <= Nt; it++) { \n        vx[Nx+1][0] = 1; \n        vy[Nx-1][0] = 1; \n \n        for (int ix = 0; ix <= Lx; ix++) { \n            for (int iy = 0; iy <= Ly; iy++) { \n                vvxx[ix][iy] = 0.0; \n                vvxy[ix][iy] = 0.0; \n                vvyx[ix][iy] = 0.0; \n                vvyy[ix][iy] = 0.0; \n \n                #pragma omp parallel for \n                for (int jx = 0; jx <= Lx; jx++) { \n                    int kx = ix - jx + Nx; \n                    if (kx < 0) continue; \n                    if (kx > Lx) continue; \n                    for (int jy = 0; jy <= Ly; jy++) { \n                        int ky = iy - jy + Ny; \n                        if (ky < 0) continue; \n                        if (ky > Ly) continue; \n \n                        if (((ix - Nx) * (ix - Nx) + (iy - Ny) * (iy - Ny)) == 0) { \n                            continue; \n                        } \n \n                         \n \n                        vvxx[ix][iy] += vx[jx][jy] * vx[kx][ky] * DVQ; \n                        vvxy[ix][iy] += vx[jx][jy] * vy[kx][ky] * DVQ; \n                        vvyx[ix][iy] += vy[jx][jy] * vx[kx][ky] * DVQ; \n                        vvyy[ix][iy] += vy[jx][jy] * vy[kx][ky] * DVQ; \n                    } \n                } \n            } \n        } \n \n \n        for (int ix = 0; ix <= Lx; ix++) { \n            for (int iy = 0; iy <= Ly; iy++) { \n \n                double Qx = -Qx0 + ix * DQx; \n                double Qy = -Qy0 + iy * DQy; \n \n                double Q2 = Qx * Qx + Qy * Qy; \n                if (((ix - Nx) * (ix - Nx) + (iy - Ny) * (iy - Ny)) == 0) { \n                 ", "pred": " \nint main() { \n    double Qx0 = 4.0; \n    double Qy0 = 4.0; \n \n    int Nx = 16; \n    int Ny = 16; \n \n    int Nt = 50000; \n    double dt = 0.0025; \n \n    int NDimx = 2 * Nx + 4; \n    int NDimy = 2 * Ny + 4; \n    double vx[NDimx][NDimy]; \n    double vy[NDimx][NDimy]; \n    int Lx = 2 * Nx; \n    int Ly = 2 * Ny; \n    double DQx = Qx0 / Nx; \n    double DQy = Qy0 / Ny; \n    double DVQ = DQx * DQy / ((2 * M_PI) * (2 * M_PI)); \n    double vvxx[NDimx][NDimy], vvxy[NDimx][NDimy]; \n    double vvyx[NDimx][NDimy], vvyy[NDimx][NDimy]; \n    double vvzx[NDimx][NDimy], vvzy[NDimx][NDimy]; \n \n    printf(\"NCriteria -> %g\\n\",Qx0*Qy0*nu*dt); \n \n    for (int ix = 0; ix <= Lx; ix++) { \n        for (int iy = 0; iy <= Ly; iy++) { \n            double Qx = -Qx0 + ix * DQx; \n            double Qy = -Qy0 + iy * DQy; \n \n            vx[ix][iy] = arc4random_uniform(10) * 1E-3; \n            vy[ix][iy] = arc4random_uniform(10) * 1E-3; \n \n \n            double Q2 = Qx * Qx + Qy * Qy; \n            double Q = sqrt(Qx);\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   "}
{"label": " \nvoid camig3(camoperator3d weop, \n\t    cub3d cub, \n\t    cam3d cam, \n\t    tap3d tap, \n\t    slo3d slo, \n\t    bool  inv    \n,  \n\t    sf_fslice data  \n, \n\t    sf_fslice imag  \n) \n \n \n{ \n    int imz,iw,imy,imx,ihx; \n    sf_complex w; \n    int ompith=0; \n \n    if (!inv) {  \n \n\tLOOP( weop->qq[ihx][imy][imx] = 0.0; ); \n\tfor (imz=0; imz<cub->amz.n; imz++) { \n\t    sf_fslice_put(imag,imz,weop->qq[0][0]); \n\t} \n    } \n     \n#pragma omp parallel for schedule(static)      private(ompith,iw,w,imx,imy,imz,ihx)      shared(data,weop,cub,cam,tap,slo) \n    for (iw=0; iw<cub->aw.n; iw++) { \n\tompith=omp_get_thread_num(); \n \n\tif (inv) {  \n \n\t    w = sf_cmplx(cub->eps*cub->aw.d,+(cub->aw.o+iw*cub->aw.d));  \n \n \n\t    LOOP( weop->ww[ompith][ihx][imy][imx] = sf_cmplx(0,0); );   \n\t     \n\t     \n \n#pragma omp critical \n\t    sf_fslice_get(slo->slice,cub->amz.n-1,slo->so[ompith][0]); \n\t    for (imz=cub->amz.n-1; imz>0; imz--) { \n#pragma omp critical \n\t\tif(cub->verb) sf_warning (\"(ith=%d)... <iw=%3d of %3d> <iz=%3d of %3d>\", \n\t\t\t\t\t  ompith,iw+1,cub->aw.n,imz+1,cub->amz.n); \n \n#pragma omp critical \n\t\t{ \n\t\tsf_fslice_get(imag,imz,weop->qq[0][0]);  \n \n\t\tLOOP( weop->ww[ompith][ihx][imy][imx] += \n\t\t      weop->qq        [ihx][imy][imx]; ); \n\t\tLOOP( weop->ww[ompith][ihx][imy][imx].r +=  \n\t\t      weop->qq        [ihx][imy][imx]; ); \n\t\t} \n#pragma omp critical \n\t\tsf_fslice_get(slo->slice,imz-1,slo->ss[ompith][0]); \n\t\tcam3_ssf(w,weop->ww[ompith],cub,cam,tap,slo,imz,ompith);\t \n\t\tslow3_advance(cub,slo,ompith); \n\t    } \n \n\t     \n \n#pragma omp critical \n\t    { \n\t\tsf_fslice_get(imag,0,weop->qq[0][0]); \n\t\tLOOP( weop->ww[ompith][ihx][imy][imx]  +=  \n\t\t      weop->qq        [ihx][imy][imx]; );\t \n\t\tLOOP( weop->ww[ompith][ihx][imy][imx].r  +=  \n\t\t      weop->qq        [ihx][imy][imx]; ); \n\t\ttaper3d(weop->ww[ompith],tap); \n\t\tsf_fslice_put(data,iw,weop->ww[ompith][0][0]);     \n \n\t    } \n\t     \n\t} else {  \n \n\t    w = sf_cmplx(cub->eps*cub->aw.d,-(cub->aw.o+iw*cub->aw.d));  \n \n \n\t     \n \n#pragma omp critical \n\t    sf_fslice_get(data,iw,weop->ww[ompith][0][0]); \n\t    taper3d(weop->ww[ompith],tap); \n\t     \n#pragma omp critical \n\t    { \n\t\tsf_fslice_get(imag,0,weop->qq[0][0]); \n\t\tLOOP(;      weop->qq        [ihx][imy][imx] +=  \n\t\t     crealf(weop->ww[ompith][ihx][imy][imx] ); ); \n\t\tsf_fslice_put(imag,0,weop->qq[0][0]); \n\t    } \n\t     \n\t     \n \n#pragma omp critical \n\t    sf_fslice_get(slo->slice,0,slo->so[ompith][0]);\t \n\t    for (imz=0; imz<cub->amz.n-1; imz++) { \n#pragma omp critical \n\t\tif(cub->verb) sf_warning (\"(ith=%d)... <iw=%3d of %3d> <iz=%3d of %3d>\", \n\t\t\t\t\t  ompith,iw+1,cub->aw.n,imz+1,cub->amz.n); \n#pragma omp critical \n\t\tsf_fslice_get(slo->slice,imz+1,slo->ss[ompith][0]); \n\t\tcam3_ssf(w,weop->ww[ompith],cub,cam,tap,slo,imz,ompith); \n\t\tslow3_advance(cub,slo,ompith); \n \n#pragma omp critical \n\t\t{ \n\t\t    sf_fslice_get(imag,imz+1,weop->qq[0][0]);  \n \n\t\t    LOOP(;      weop->qq        [ihx][imy][imx] +=  \n\t\t\t crealf(weop->ww[ompith][ihx][imy][imx] ); ); \n\t\t    sf_fslice_put(imag,imz+1,weop->qq[0][0]); \n\t\t} \n \n\t    }  \n \n \n\t}  \n \n    }  \n \n} ", "pred": " \nvoid camig3(camoperator3d weop, \n\t    cub3d cub, \n\t    cam3d cam, \n\t    tap3d tap, \n\t    slo3d slo, \n\t    bool  inv    \n,  \n\t    sf_fslice data  \n, \n\t    sf_fslice imag  \n) \n \n \n{ \n    int imz,iw,imy,imx,ihx; \n    sf_complex w; \n    int ompith=0; \n \n    if (!inv) {  \n \n\tLOOP( weop->qq[ihx][imy][imx] = 0.0; ); \n\tfor (imz=0; imz<cub->amz.n; imz++) { \n\t    sf_fslice_put(imag,imz,weop->qq[0][0]); \n\t} \n    } \n     \n#pragma omp parallel for schedule(static)      private(ompith,iw,w,imx,imy,imz,ihx)      shared(data,weop,cub,cam,tap,slo) \n    for (iw=0; iw<cub->aw.n; iw++) { \n\tompith=omp_get_thread_num(); \n \n\tif (inv) {  \n \n\t    w = sf_cmplx(cub->eps*cub->aw.d,+(cub->aw.o+iw*cub->aw.d));  \n \n \n\t    LOOP( weop->ww[ompith][ihx][imy][imx] = sf_cmplx(0,0); );   \n\t     \n\t     \n \n#pragma omp critical \n\t    sf_fslice_get(slo->slice,cub->amz.n-1,slo->so[ompith][0]); \n\t    for (imz=cub->amz.n-1; imz>0; imz--) { \n#pragma omp critical \n\t\tif(cub->verb) sf_warning (\"(ith=%d)... < 0;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "}
