{"label": " \nvoid sponge3d_apply(float  ***uu, \n\t\t    sponge1d spo, \n\t\t    fdm3d    fdm) \n \n \n{ \n    int iz,ix,iy,ib,ibz,ibx,iby; \n    float w; \n \n    for(ib=0; ib<fdm->nb; ib++) { \n\tw = spo->w[fdm->nb-ib-1]; \n \n\tibz = fdm->nzpad-ib-1; \n\tfor    (iy=0; iy<fdm->nypad; iy++) { \n\t    for(ix=0; ix<fdm->nxpad; ix++) { \n\t\tuu[iy][ix][ib ] *= w;  \n \n\t\tuu[iy][ix][ibz] *= w;  \n \n\t    } \n\t} \n \n\tibx = fdm->nxpad-ib-1; \n\tfor    (iy=0; iy<fdm->nypad; iy++) { \n\t    for(iz=0; iz<fdm->nzpad; iz++) { \n\t\tuu[iy][ib ][iz] *= w;  \n \n\t\tuu[iy][ibx][iz] *= w;  \n \n\t    } \n\t} \n\t \n\tiby = fdm->nypad-ib-1; \n\tfor    (ix=0; ix<fdm->nxpad; ix++) { \n\t    for(iz=0; iz<fdm->nzpad; iz++) { \n\t\tuu[ib ][ix][iz] *= w;  \n \n\t\tuu[iby][ix][iz] *= w;  \n \n\t    } \n\t} \n \n    } \n} ", "pred": " \nvoid sponge3d_apply(float  ***uu, \n\t\t    sponge1d spo, \n\t\t    fdm3d    fdm) \n \n \n{ \n    int iz,ix,iy,ib,ibz,ibx,iby; \n    float w; \n \n    for(ib=0; ib<fdm->nb; ib++) { \n\tw = spo->w[fdm->nb-ib-1]; \n \n\tibz = fdm->nzpad-ib-1; \n\tfor    (iy=0; iy<fdm->nypad; iy++) { \n\t    for(ix=0; ix<fdm->nxpad; ix++) { \n\t\tuu[iy][ix][ib ] *= w;  \n \n\t\tuu[iy][ix][ibz] *= w;  \n \n\t    } \n\t} \n \n\tibx = fdm->nxpad-ib-1; \n\tfor    (iy=0; iy<fdm->nypad; iy++) { \n\t    for(iz=0; iz<fdm->nzpad; iz++) { \n\t\tuu[iy][ib ][iz] *= w;  \n \n\t\tuu[iy][ibx][iz] *= w;  \n \n\t    } \n\t} \n    } \n \n} \n \n \nvoid sponge3d_apply_2(float  ***uu, \n\t\t      sponge1d spo, \n\t\t      fdm3d    fdm) \n \n \n{ \n    int iz,ix,iy,ib,ibz,ibx,iby; \n    float w; \n \n    for(ib=0; ib<fdm->nb; ib"}
{"label": " \nstatic void nlSparseMatrix_mult_rows( \n        NLSparseMatrix* A, \n        const NLdouble* x, \n        NLdouble* y \n) { \n     \n \n     \n    int m = (int)(A->m); \n    int i,ij; \n    NLCoeff* c = NULL; \n    NLRowColumn* Ri = NULL; \n \n     \n    for(i=0; i<m; i++) { \n        Ri = &(A->row[i]);        \n        y[i] = 0; \n        for(ij=0; ij<(int)(Ri->size); ij++) { \n            c = &(Ri->coeff[ij]); \n            y[i] += c->value * x[c->index]; \n        } \n    } \n} ", "pred": " \nstatic void nlSparseMatrix_mult_rows( \n        NLSparseMatrix* A, \n        const NLdouble* x, \n        NLdouble* y \n) { \n     \n \n     \n    int m = (int)(A->m); \n    int i,ij; \n    NLCoeff* c = NULL; \n    NLRowColumn* Ri = NULL; \n \n     \n    for(i=0; i<m; i++) { \n        Ri = &(A->row[i]);        \n        y[i] = 0; \n        for(ij=0; ij<(int)(Ri->size); ij++) { \n            c = &(Ri->coeff[ij]); \n            y[i] += c->value * x[c->index]; \n        } \n    } \n} "}
{"label": "main(int argc, char ** argv) { \n\t \n \n\tlong lower, upper; \n\tsscanf(argv[1], \"%ld\", &lower); \n\tsscanf(argv[2], \"%ld\", &upper); \n \n\tint i;  \n\tlong result = 0.0; \n\t \n\t \n \n\tif(lower == 1) { \n\t\tresult = 1.0; \n\t\tlower = 2; \n\t} \n\t \n \n\t \n \n\tfor (i = lower; i <= upper; i++) { \n\t\tresult = result + getTotient(i); \n\t} \n\t \n\t \n \n\tprintf(\"Sum of Totients between [%ld..%ld] is %ld \\n\", lower, upper, result); \n\t \n\t \n \n\treturn 0; \n} \n ", "pred": "main(int argc, char ** argv) { \n\t \n \n\tlong lower, upper; \n\tsscanf(argv[1], \"%ld\", &lower); \n\tsscanf(argv[2], \"%ld\", &upper); \n \n\tint i;  \n\tlong result = 0.0; \n\t \n\t \n \n\tif(lower == 1) { \n\t\tresult = 1.0; \n\t\tlower = 2; \n\t} \n\t \n \n\t \n \n\tfor (i = lower; i <= upper; i++) { \n\t\tresult = result + getTotient(i); \n\t} \n\t \n\t \n \n\tprintf(\"Sum of Totients between [%ld..%ld] is %ld \\n\", lower, upper, result); \n\t \n\t \n \n\treturn 0; \n} \n "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_grain_data_t *data = (dt_iop_grain_data_t *)piece->data; \n \n  unsigned int hash = _hash_string(piece->pipe->image.filename) % (int)fmax(roi_out->width * 0.3, 1.0); \n \n  const int ch = piece->colors; \n   \n \n  const double strength = (data->strength / 100.0); \n  const double octaves = 3; \n   \n \n  const double wd = fminf(piece->buf_in.width, piece->buf_in.height); \n  const double zoom = (1.0 + 8 * data->scale / 100) / 800.0; \n  const int filter = fabsf(roi_out->scale - 1.0f) > 0.01; \n   \n \n   \n \n  const double filtermul = piece->iscale / (roi_out->scale * wd); \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    float *in = ((float *)ivoid) + (size_t)roi_out->width * j * ch; \n    float *out = ((float *)ovoid) + (size_t)roi_out->width * j * ch; \n    for(int i = 0; i < roi_out->width; i++) \n    { \n       \n \n       \n \n      double wx = (roi_out->x + i) / roi_out->scale; \n      double wy = (roi_out->y + j) / roi_out->scale; \n       \n \n       \n \n      double x = wx / wd; \n      double y = wy / wd; \n       \n \n      double noise = 0.0; \n      if(filter) \n      { \n         \n \n        const float fib1 = 34.0, fib2 = 21.0; \n        for(int l = 0; l < fib2; l++) \n        { \n          float px = l / fib2, py = l * (fib1 / fib2); \n          py -= (int)py; \n          float dx = px * filtermul, dy = py * filtermul; \n          noise += (1.0 / fib2) * _simplex_2d_noise(x + dx + hash, y + dy, octaves, 1.0, zoom); \n        } \n      } \n      else \n      { \n        noise = _simplex_2d_noise(x + hash, y, octaves, 1.0, zoom); \n      } \n \n      out[0] = in[0] + dt_lut_lookup_2d_1c(data->grain_lut, (noise * strength) * GRAIN_LIGHTNESS_STRENGTH_SCALE, in[0] / 100.0f); \n      out[1] = in[1]; \n      out[2] = in[2]; \n      out[3] = in[3]; \n \n      out += ch; \n      in += ch; \n    } \n  } \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_grain_data_t *data = (dt_iop_grain_data_t *)piece->data; \n \n  unsigned int hash = _hash_string(piece->pipe->image.filename) % (int)fmax(roi_out->width * 0.3, 1.0); \n \n  const int ch = piece->colors; \n   \n \n  const double strength = (data->strength / 100.0); \n  const double octaves = 3; \n   \n \n  const double wd = fminf(piece->buf_in.width, piece->buf_in.height); \n  const double zoom = (1.0 + 8 * data->scale / 100) / 800.0; \n  const int filter = fabsf(roi_out->scale - 1.0f) > 0.01; \n   \n \n   \n \n  const double filtermul = piece->iscale / (roi_out->width * roi_out->height); \n  const double filteradd = filtermul * (1.0 - powf(filter, 2.0)); \n  const double filtermul2 = filtermul * (1.0 - powf(filter, 2.0)); \n  const double filteradd2 = filtermul2 * (1.0 - powf(filter, 2.0)); \n  const double filtermul3 = filtermul * (1.0 - powf(filter, 3.0)); \n  const double filteradd3 = filtermul3 * (1.0 - powf(filter, 3.0)); \n  const double filtermul4 = filtermul * (1.0 - powf(filter, 4.0)); \n  const double filteradd4 = filtermul4 * (1.0 - powf(filter, 4.0)); \n  const double filtermul5 = filtermul * (1.0 - powf(filter, 5.0)); \n  const double filteradd5 = filtermul5 * (1.0 - powf(filter, 5.0)); \n  const double filtermul6 = filtermul * (1.0 - powf(filter, 6.0)); \n  const double filteradd6 = filtermul6 * (1.0 - powf(filter, 6.0)); \n  const double filtermul7 = filtermul * (1.0 - powf(filter, 7.0)); \n  const double filteradd7 = filtermul7 * (1.0 - powf(filter, 7.0)); \n  const double filtermul8 = filtermul * (1.0 - powf(filter, 8.0)); \n  const double filteradd8 = filtermul8 * (1.0 - powf(filter, 8.0)); \n  const double filtermul9 = filtermul * (1.0 - powf(filter, 9.0)); \n  const double filteradd9 = filtermul9 * (1.0 - powf(filter, 9.0)); \n  const double filtermul10 = filtermul * (1.0 - powf(filter, 10.0)); \n  const double filteradd10 = filtermul10 * (1.0 - powf(filter, 10.0)); \n  const double filtermul11 = filtermul * (1.0 - powf(filter, 11.0)); \n  const double filteradd11 = filtermul11 * (1.0 - powf(filter, 11.0)); \n  const double filtermul12 = filtermul * (1.0 - powf(filter, 12.0)); \n  const double filteradd12 = filtermul12 * (1.0 - powf(filter, 12.0)); \n  const double filtermul13 = filtermul * (1.0 - powf(filter, 13.0)); \n  const double filteradd13 = filtermul13 * (1.0 - powf(filter, 13.0)); \n  const double filtermul14 = filtermul *"}
{"label": " \nstatic MagickBooleanType XShearImage(Image *image,const double degrees, \n  const size_t width,const size_t height,const ssize_t x_offset, \n  const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define XShearImageTag  \"XShear/Image\" \n \n  typedef enum \n  { \n    LEFT, \n    RIGHT \n  } ShearDirection; \n \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PixelInfo \n    background; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickCoreSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  status=MagickTrue; \n  background=image->background_color; \n  progress=0; \n  image_view=AcquireAuthenticCacheView(image,exception); \n  for (y=0; y < (ssize_t) height; y++) \n  { \n    PixelInfo \n      pixel, \n      source, \n      destination; \n \n    double \n      area, \n      displacement; \n \n    register Quantum \n      *magick_restrict p, \n      *magick_restrict q; \n \n    register ssize_t \n      i; \n \n    ShearDirection \n      direction; \n \n    ssize_t \n      step; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewAuthenticPixels(image_view,0,y_offset+y,image->columns,1, \n      exception); \n    if (p == (Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    p+=x_offset*GetPixelChannels(image); \n    displacement=degrees*(double) (y-height/2.0); \n    if (displacement == 0.0) \n      continue; \n    if (displacement > 0.0) \n      direction=RIGHT; \n    else \n      { \n        displacement*=(-1.0); \n        direction=LEFT; \n      } \n    step=(ssize_t) floor((double) displacement); \n    area=(double) (displacement-step); \n    step++; \n    pixel=background; \n    GetPixelInfo(image,&source); \n    GetPixelInfo(image,&destination); \n    switch (direction) \n    { \n      case LEFT: \n      { \n         \n \n        if (step > x_offset) \n          break; \n        q=p-step*GetPixelChannels(image); \n        for (i=0; i < (ssize_t) width; i++) \n        { \n          if ((x_offset+i) < step) \n            { \n              p+=GetPixelChannels(image); \n              GetPixelInfoPixel(image,p,&pixel); \n              q+=GetPixelChannels(image); \n              continue; \n            } \n          GetPixelInfoPixel(image,p,&source); \n          CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n            &source,(double) GetPixelAlpha(image,p),area,&destination); \n          SetPixelViaPixelInfo(image,&destination,q); \n          GetPixelInfoPixel(image,p,&pixel); \n          p+=GetPixelChannels(image); \n          q+=GetPixelChannels(image); \n        } \n        CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n          &background,(double) background.alpha,area,&destination); \n        SetPixelViaPixelInfo(image,&destination,q); \n        q+=GetPixelChannels(image); \n        for (i=0; i < (step-1); i++) \n        { \n          SetPixelViaPixelInfo(image,&background,q); \n          q+=GetPixelChannels(image); \n        } \n        break; \n      } \n      case RIGHT: \n      { \n         \n \n        p+=width*GetPixelChannels(image); \n        q=p+step*GetPixelChannels(image); \n        for (i=0; i < (ssize_t) width; i++) \n        { \n          p-=GetPixelChannels(image); \n          q-=GetPixelChannels(image); \n          if ((size_t) (x_offset+width+step-i) > image->columns) \n            continue; \n          GetPixelInfoPixel(image,p,&source); \n          CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n            &source,(double) GetPixelAlpha(image,p),area,&destination); \n          SetPixelViaPixelInfo(image,&destination,q); \n          GetPixelInfoPixel(image,p,&pixel); \n        } \n        CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n          &background,(double) background.alpha,area,&destination); \n        q-=GetPixelChannels(image); \n        SetPixelViaPixelInfo(image,&destination,q); \n        for (i=0; i < (step-1); i++) \n        { \n          q-=GetPixelChannels(image); \n          SetPixelViaPixelInfo(image,&background,q); \n        } \n        break; \n      } \n    } \n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        proceed=SetImageProgress(image,XShearImageTag,progress++,height); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  } \n  image_view=DestroyCacheView(image_view); \n  return(status); \n} ", "pred": " \nstatic MagickBooleanType XShearImage(Image *image,const double degrees, \n  const size_t width,const size_t height,const ssize_t x_offset, \n  const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define XShearImageTag  \"XShear/Image\" \n \n  typedef enum \n  { \n    LEFT, \n    RIGHT \n  } ShearDirection; \n \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PixelInfo \n    background; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickCoreSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  status=MagickTrue; \n  background=image->background_color; \n  progress=0; \n  image_view=AcquireAuthenticCacheView(image,exception); \n  for (y=0; y < (ssize_t) height; y++) \n  { \n    PixelInfo \n      pixel; \n \n    const int\n      id = GetOpenMPThreadId(); \n \n    const Quantum\n      *magick_restrict p; \n \n    ssize_t\n      x; \n \n    size_t\n      columns; \n \n    ssize_t\n      i; \n \n    if (status == MagickFalse)\n      continue; \n \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n \n    if (p == (const Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n \n    columns=GetCacheViewExtent(image_view); \n \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      if (GetPixelReadMask(image,p) == 0) \n        { \n          p+=GetPixelChannels(image); \n          continue; \n        } \n \n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n      { \n        PixelChannel channel = GetPixelChannelChannel(image,i); \n \n        if (channel == background) \n          continue; \n \n        if (channel == (PixelChannel) NULL) \n          continue; \n \n        if (channel == (PixelChannel) NULL) \n          continue; \n \n        if (channel == YELLOW) \n          { \n            if (GetPixelLuma(image,p) < (Quantum) (QuantumRange/2.0)) \n              { \n                p+=GetPixelChannels(image); \n                continue; \n              } \n \n            if (GetPixelLuma(image,p) > (Quantum) (QuantumRange/2.0)) \n              { \n                p+=GetPixelChannels(image); \n                continue; \n              } \n \n            if (GetPixelIntensity(image,p) < (Quantum) (QuantumRange/2.0)) \n              { \n                p+=GetPixelChannels(image); \n                continue; \n              } \n \n            if (GetPixelIntensity(image,p) > (Quantum) (QuantumRange/2.0)) \n              { \n                p+=GetPixelChannels(image); \n                continue; \n              } \n \n            if (GetPixelRed(image,p) < (Quantum) (QuantumRange/2.0)) \n              { \n                p+=GetPixelChannels(image); \n                continue; \n              } \n \n            if (GetPixelRed(image,p) > (Quantum) (QuantumRange/2.0)) \n              { \n                p+=GetPixelChannels(image); \n                continue; \n              } \n \n            if (GetPixelGreen(image,p) < (Quantum) (QuantumRange/2.0)) \n              { \n                p+=GetPixelChannels(image); \n                continue; \n              } \n \n            if (GetPixelGreen(image,p) > (Quantum) (QuantumRange/2.0)) \n              { \n                p+=GetPixelChannels(image); \n                continue; \n              } \n \n            if (GetPixelBlue(image,p) < (Quantum) (QuantumRange/2.0)) \n              { \n                p+=GetPixelChannels(image); \n                continue; \n              } \n \n            if (GetPixelBlue(image,p) > (Quantum) (QuantumRange/2.0)) \n              { \n                p+=GetPixelChannels(image); \n                continue; \n              } \n \n            if (GetPixelBlack(image,p) < (Quantum) (QuantumRange/2.0)) \n              { \n                p+=GetPixelChannels(image); \n                continue; \n              } \n \n            if (GetPixelBlack(image,p) > (Quantum) (Quantum"}
{"label": " \ndouble processMyersGPU(char *refFile, char *qryFile, uint32_t numBuffers, uint32_t numThreads, uint32_t maxMbPerBuffer, uint32_t numTasks) \n{ \n\tvoid \t \t**buffer; \n\ttest_t\t\ttestData[numThreads];  \n \n\tuint32_t \taverageQuerySize, averageCandidatesPerQuery; \n \n\tuint32_t \terror, idBuffer, iteration, threadID, idTask; \n\tdouble\t\tts, ts1; \n \n\tfor(threadID = 0; threadID < numThreads; ++threadID) \n\t\tloadTestData(qryFile, &testData[threadID], &averageQuerySize, &averageCandidatesPerQuery); \n \n\tbpm_gpu_init_(&buffer, numBuffers, maxMbPerBuffer, refFile, PROFILE_REFERENCE_FILE, 0, averageQuerySize, \n\t\t\t\t        averageCandidatesPerQuery, ARCH_SUPPORTED); \n \n\tts = sampleTime(); \n \n\t\tfor(idTask = 0; idTask < numTasks; ++idTask){ \n      idBuffer = idTask % numBuffers; \n \n       \n \n      printf(\"Host thread %d \\t sent job %d \\t to buffer %d \\t in device %d \\n\", omp_get_thread_num(), idTask, idBuffer, bpm_gpu_buffer_get_id_device_(buffer[idBuffer])); \n \n       \n \n      putIntoBuffer(buffer[idBuffer], &testData[idBuffer]); \n \n      bpm_gpu_send_buffer_(buffer[idBuffer], testData[idBuffer].totalQueriesEntries, testData[idBuffer].numQueries, testData[idBuffer].numCandidates); \n      bpm_gpu_receive_buffer_(buffer[idBuffer]); \n \n       \n \n      getFromBuffer(buffer[idBuffer], &testData[idBuffer]); \n\t\t} \n \n\tts1 = sampleTime(); \n\tbpm_gpu_destroy_(&buffer); \n \n\t \n \n\terror = saveResults(qryFile, &testData[0], numBuffers); \n\tif(error!= 0){fprintf(stderr, \"Error %d, saving results \\n\", error); exit(EXIT_FAILURE);} \n \n\tfreeTestData(&testData[0], numThreads); \n\treturn(ts1-ts); \n} ", "pred": " \ndouble processMyersGPU(char *refFile, char *qryFile, uint32_t numBuffers, uint32_t numThreads, uint32_t maxMbPerBuffer, uint32_t numTasks) \n{ \n\tvoid \t \t**buffer; \n\ttest_t\t\ttestData[numThreads];  \n \n\tuint32_t \taverageQuerySize, averageCandidatesPerQuery; \n \n\tuint32_t \terror, idBuffer, iteration, threadID, idTask; \n\tdouble\t\tts, ts1; \n \n\tfor(threadID = 0; threadID < numThreads; ++threadID) \n\t\tloadTestData(qryFile, &testData[threadID], &averageQuerySize, &averageCandidatesPerQuery); \n \n\tbpm_gpu_init_(&buffer, numBuffers, maxMbPerBuffer, refFile, PROFILE_REFERENCE_FILE, 0, averageQuerySize, \n\t\t\t\t        averageCandidatesPerQuery, ARCH_SUPPORTED); \n \n\tts = sampleTime(); \n \n\t\tfor(idTask = 0; idTask < numTasks; ++idTask){ \n      idBuffer = idTask % numBuffers; \n \n       \n \n      printf(\"Host thread %d \\t sent job %d \\t to buffer %d \\t to thread %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d \\t to host %d"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 32; \n  tile_size[3] = 64; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,12);t1++) { \n    lbp=max(ceild(t1,2),ceild(24*t1-Nt+3,24)); \n    ubp=min(floord(Nt+Nz-4,24),floord(12*t1+Nz+9,24)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(3*t1-7,8)),ceild(24*t2-Nz-28,32));t3<=min(min(min(floord(Nt+Ny-4,32),floord(12*t1+Ny+21,32)),floord(24*t2+Ny+20,32)),floord(24*t1-24*t2+Nz+Ny+19,32));t3++) { \n        for (t4=max(max(max(0,ceild(3*t1-15,16)),ceild(24*t2-Nz-60,64)),ceild(32*t3-Ny-60,64));t4<=min(min(min(min(floord(Nt+Nx-4,64),floord(12*t1+Nx+21,64)),floord(24*t2+Nx+20,64)),floord(32*t3+Nx+28,64)),floord(24*t1-24*t2+Nz+Nx+19,64));t4++) { \n          for (t5=max(max(max(max(max(0,12*t1),24*t1-24*t2+1),24*t2-Nz+2),32*t3-Ny+2),64*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,12*t1+23),24*t2+22),32*t3+30),64*t4+62),24*t1-24*t2+Nz+21);t5++) { \n            for (t6=max(max(24*t2,t5+1),-24*t1+24*t2+2*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(32*t3,t5+1);t7<=min(32*t3+31,t5+Ny-2);t7++) { \n                lbv=max(64*t4,t5+1); \n                ubv=min(64*t4+63,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = (((((((coef[0][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (coef[1][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)])) + (coef[2][ (-t5+t6)][ (-t5", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    coef[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      coef[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_v[i] = (double **) malloc(sizeof(double"}
{"label": " \nvoid \nfoo (void) \n{ \n  for (int i = 0; i < 10000; i++) \n    for (int j = 0; j < 128; j++) \n      a[i][j] += 3; \n} ", "pred": " \nvoid \nfoo (void) \n{ \n  for (int i = 0; i < 10000; i++) \n    for (int j = 0; j < 128; j++) \n      a[i][j] += 3; \n} "}
{"label": " \nstatic MagickBooleanType RadonTransform(const Image *image, \n  const double threshold,size_t *projection,ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  MatrixInfo \n    *destination_matrixs, \n    *source_matrixs; \n \n  MagickBooleanType \n    status; \n \n  size_t \n    count, \n    width; \n \n  ssize_t \n    j, \n    y; \n \n  unsigned char \n    c; \n \n  unsigned short \n    bits[256]; \n \n  for (width=1; width < ((image->columns+7)/8); width<<=1) ; \n  source_matrixs=AcquireMatrixInfo(width,image->rows,sizeof(unsigned short), \n    exception); \n  destination_matrixs=AcquireMatrixInfo(width,image->rows, \n    sizeof(unsigned short),exception); \n  if ((source_matrixs == (MatrixInfo *) NULL) || \n      (destination_matrixs == (MatrixInfo *) NULL)) \n    { \n      if (destination_matrixs!= (MatrixInfo *) NULL) \n        destination_matrixs=DestroyMatrixInfo(destination_matrixs); \n      if (source_matrixs!= (MatrixInfo *) NULL) \n        source_matrixs=DestroyMatrixInfo(source_matrixs); \n      return(MagickFalse); \n    } \n  if (NullMatrix(source_matrixs) == MagickFalse) \n    { \n      destination_matrixs=DestroyMatrixInfo(destination_matrixs); \n      source_matrixs=DestroyMatrixInfo(source_matrixs); \n      return(MagickFalse); \n    } \n  for (j=0; j < 256; j++) \n  { \n    c=(unsigned char) j; \n    for (count=0; c!= 0; c>>=1) \n      count+=c & 0x01; \n    bits[j]=(unsigned short) count; \n  } \n  status=MagickTrue; \n  image_view=AcquireVirtualCacheView(image,exception); \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    register const Quantum \n      *magick_restrict p; \n \n    register ssize_t \n      i, \n      x; \n \n    size_t \n      bit, \n      byte; \n \n    unsigned short \n      value; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    if (p == (const Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    bit=0; \n    byte=0; \n    i=(ssize_t) (image->columns+7)/8; \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      byte<<=1; \n      if (((MagickRealType) GetPixelRed(image,p) < threshold) || \n          ((MagickRealType) GetPixelGreen(image,p) < threshold) || \n          ((MagickRealType) GetPixelBlue(image,p) < threshold)) \n        byte|=0x01; \n      bit++; \n      if (bit == 8) \n        { \n          value=bits[byte]; \n          (void) SetMatrixElement(source_matrixs,--i,y,&value); \n          bit=0; \n          byte=0; \n        } \n      p+=GetPixelChannels(image); \n    } \n    if (bit!= 0) \n      { \n        byte<<=(8-bit); \n        value=bits[byte]; \n        (void) SetMatrixElement(source_matrixs,--i,y,&value); \n      } \n  } \n  RadonProjection(image,source_matrixs,destination_matrixs,-1,projection); \n  (void) NullMatrix(source_matrixs); \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    register const Quantum \n      *magick_restrict p; \n \n    register ssize_t \n      i, \n      x; \n \n    size_t \n      bit, \n      byte; \n \n    unsigned short \n     value; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    if (p == (const Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    bit=0; \n    byte=0; \n    i=0; \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      byte<<=1; \n      if (((MagickRealType) GetPixelRed(image,p) < threshold) || \n          ((MagickRealType) GetPixelGreen(image,p) < threshold) || \n          ((MagickRealType) GetPixelBlue(image,p) < threshold)) \n        byte|=0x01; \n      bit++; \n      if (bit == 8) \n        { \n          value=bits[byte]; \n          (void) SetMatrixElement(source_matrixs,i++,y,&value); \n          bit=0; \n          byte=0; \n        } \n      p+=GetPixelChannels(image); \n    } \n    if (bit!= 0) \n      { \n        byte<<=(8-bit); \n        value=bits[byte]; \n        (void) SetMatrixElement(source_matrixs,i++,y,&value); \n      } \n  } \n  RadonProjection(image,source_matrixs,destination_matrixs,1,projection); \n  image_view=DestroyCacheView(image_view); \n  destination_matrixs=DestroyMatrixInfo(destination_matrixs); \n  source_matrixs=DestroyMatrixInfo(source_matrixs); \n  return(MagickTrue); \n} ", "pred": " \nstatic MagickBooleanType RadonTransform(const Image *image, \n  const double threshold,size_t *projection,ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  MatrixInfo \n    *destination_matrixs, \n    *source_matrixs; \n \n  MagickBooleanType \n    status; \n \n  size_t \n    count, \n    width; \n \n  ssize_t \n    j, \n    y; \n \n  unsigned char \n    c; \n \n  unsigned short \n    bits[256]; \n \n  for (width=1; width < ((image->columns+7)/8); width<<=1) ; \n  source_matrixs=AcquireMatrixInfo(width,image->rows,sizeof(unsigned short), \n    exception); \n  destination_matrixs=AcquireMatrixInfo(width,image->rows, \n    sizeof(unsigned short),exception); \n  if ((source_matrixs == (MatrixInfo *) NULL) || \n      (destination_matrixs == (MatrixInfo *) NULL)) \n    { \n      if (destination_matrixs!= (MatrixInfo *) NULL) \n        destination_matrixs=DestroyMatrixInfo(destination_matrixs); \n      if (source_matrixs!= (MatrixInfo *) NULL) \n        source_matrixs=DestroyMatrixInfo(source_matrixs); \n      return(MagickFalse); \n    } \n \n  /*\n    Allocate destination matrix.\n  */\n  destination_matrixs->rows=image->rows; \n  destination_matrixs->columns=image->columns; \n  destination_matrixs->depth=image->depth; \n  destination_matrixs->xsize=image->xsize; \n  destination_matrixs->ysize=image->ysize; \n  destination_matrixs->storage_class=image->storage_class; \n  destination_matrixs->colors=image->colors; \n  destination_matrixs->exception=exception; \n \n  /*\n    Allocate source matrix.\n  */\n  source_matrixs->rows=image->rows; \n  source_matrixs->columns=image->columns; \n  source_matrixs->depth=image->depth; \n  source_matrixs->xsize=image->xsize; \n  source_matrixs->ysize=image->ysize; \n  source_matrixs->storage_class=image->storage_class; \n  source_matrixs->colors=image->colors; \n  source_matrixs->exception=exception; \n \n  /*\n    Initialize source and destination matrices.\n  */\n  for (j=0; j < (ssize_t) image->colors; j++)\n  {\n    bits[j]=0;\n    for (c=0; c < (unsigned char) image->depth; c++)\n      bits[j]|=(1 << (7-c));\n  }\n \n  /*\n    Compute the source and destination pixel offsets.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    count=0;\n    for (j=0; j < (ssize_t) image->colors; j++)\n    {\n      c=GetPixelRed(image,source_matrixs,j);\n      c=GetPixelGreen(image,source_matrixs,j);\n      c=GetPixelBlue(image,source_matrixs,j);\n      c=GetPixelIndex(image,source_matrixs,j);\n      bits[c]=1;\n      count++;\n    }\n    for (j=0; j < (ssize_t) image->colors; j++)\n    {\n      c=GetPixelRed(image,destination_matrixs,j);\n      c=GetPixelGreen(image,destination_matrixs,j);\n      c=GetPixelBlue(image,destination_matrixs,j);\n      c=GetPixelIndex(image,destination_matrixs,j);\n      bits[c]=1;\n      count++;\n    }\n    if (count == 0)\n      continue;\n    for (j=0; j < (ssize_t) image->colors; j++)\n    {\n      c=GetPixelRed(image,destination_matrixs,j);\n      c=GetPixelGreen(image,destination_matrixs,j);\n      c=GetPixelBlue(image,destination_matrixs,j);\n      c=GetPixelIndex(image,destination_matrixs,j);\n      bits[c]|=0x80;\n    }\n    for (j=0; j < (ssize_t) image->colors; j++)\n    {\n      c=GetPixelRed(image,destination_matrixs,j);\n      c=GetPixelGreen(image,destination_matrixs,j);\n      c=GetPixelBlue(image,destination_matrixs,j);\n      c=GetPixelIndex(image,destination_matrixs,j);\n      bits[c]&=0x7f;\n    }\n    for (j=0; j < (ssize_t) image->colors; j++)\n    {\n      c=GetPixelRed(image,destination_matrixs,j);\n      c=GetPixelGreen(image,destination_matrixs,j);\n      c=GetPixelBlue(image,destination_matrixs,j);\n      c=GetPixelIndex(image,destination_matrixs,j);\n      bits[c]&=0x80;\n    }\n    for (j=0; j < (ssize_t) image->colors; j++)\n    {\n      c=GetPixelRed(image,destination_matrixs,j);\n      c=GetPixelGreen(image,destination_matrixs,j);\n      c=GetPixelBlue(image,destination_matrixs,j);\n      c=GetPixelIndex(image,destination_matrixs,j);\n      bits[c]&=0x7f;\n    }\n    for (j=0; j < (ssize_t) image->colors; j++)\n    {\n      c=GetPixelRed(image,destination_matrixs,j);\n      c=GetPixelGreen(image,destination_matrixs,j);\n      c=GetPixelBlue(image,destination_matrixs,j);\n      c=GetPixelIndex(image,destination_matrixs,j);\n      bits[c]&=0x80;\n    }\n    for (j=0; j < (ssize_t) image->colors; j++)\n    {\n      c=GetPixelRed(image,destination_matrixs,j);\n      c=GetPixelGreen(image,destination_matrixs,j);\n      c=GetPixelBlue(image,destination_matrixs,j);\n   "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 16; \n  tile_size[1] = 16; \n  tile_size[2] = 16; \n  tile_size[3] = 32; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0765; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,8);t1++) { \n    lbp=max(ceild(t1,2),ceild(16*t1-Nt+3,16)); \n    ubp=min(floord(Nt+Nz-4,16),floord(8*t1+Nz+5,16)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-1,2)),ceild(16*t2-Nz-12,16));t3<=min(min(min(floord(Nt+Ny-4,16),floord(8*t1+Ny+13,16)),floord(16*t2+Ny+12,16)),floord(16*t1-16*t2+Nz+Ny+11,16));t3++) { \n        for (t4=max(max(max(0,ceild(t1-3,4)),ceild(16*t2-Nz-28,32)),ceild(16*t3-Ny-28,32));t4<=min(min(min(min(floord(Nt+Nx-4,32),floord(8*t1+Nx+13,32)),floord(16*t2+Nx+12,32)),floord(16*t3+Nx+12,32)),floord(16*t1-16*t2+Nz+Nx+11,32));t4++) { \n          for (t5=max(max(max(max(max(0,8*t1),16*t1-16*t2+1),16*t2-Nz+2),16*t3-Ny+2),32*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,8*t1+15),16*t2+14),16*t3+14),32*t4+30),16*t1-16*t2+Nz+13);t5++) { \n            for (t6=max(max(16*t2,t5+1),-16*t1+16*t2+2*t5-15);t6<=min(min(16*t2+15,-16*t1+16*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(16*t3,t5+1);t7<=min(16*t3+15,t5+Ny-2);t7++) { \n                lbv=max(32*t4,t5+1); \n                ubv=min(32*t4+31,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = ((alpha * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (beta * (((((A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)] + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) - 1][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8) - 1]) + A[ t5 % 2][ (-t5+t6) + 1][ (-t5+t7)][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) + 1][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8) + 1])));; \n                } \n              } \n            } \n          } \n        } \n      } \n    } \n  } \n} \n \n \n      gettimeofday(&end, 0); \n      ts_return = timeval_subtract(&result, &end, &start); \n      tdiff = (double) (result.tv_sec + result.tv_usec * 1.0e-6); \n      min_tdiff", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n  for(t=0; t<Nt; t++){ \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i"}
{"label": " \nvoid sponge2d_apply(float**   uu, \n\t\t    sponge   spo, \n\t\t    fdm2d    fdm) \n \n \n{ \n    int iz,ix,ib,ibz,ibx; \n    float w; \n \n    for(ib=0; ib<fdm->nb; ib++) { \n\tw = spo->w[fdm->nb-ib-1]; \n \n\tibz = fdm->nzpad-ib-1; \n\tfor(ix=0; ix<fdm->nxpad; ix++) { \n \n \n\t    uu[ix][ib ] *= w;  \n \n\t    uu[ix][ibz] *= w;  \n \n  \n \n\t} \n \n\tibx = fdm->nxpad-ib-1; \n\tfor(iz=0; iz<fdm->nzpad; iz++) { \n\t    uu[ib ][iz] *= w;  \n \n\t    uu[ibx][iz] *= w;  \n \n\t} \n \n    } \n} ", "pred": " \nvoid sponge2d_apply(float**   uu, \n\t\t    sponge   spo, \n\t\t    fdm2d    fdm) \n \n \n{ \n    int iz,ix,ib,ibz,ibx; \n    float w; \n \n    for(ib=0; ib<fdm->nb; ib++) { \n\tw = spo->w[fdm->nb-ib-1]; \n \n\tibz = fdm->nzpad-ib-1; \n\tfor(ix=0; ix<fdm->nxpad; ix++) { \n \n \n\t    uu[ix][ib ] *= w;  \n \n\t    uu[ix][ibz] *= w;  \n \n  \n \n\t} \n \n\tibx = fdm->nxpad-ib-1; \n\tfor(iz=0; iz<fdm->nzpad; iz++) { \n\t    uu[ib ][iz] *= w;  \n \n\t    uu[ibx][iz] *= w;  \n \n\t} \n \n    } \n} "}
{"label": " \nint main(int argc, char* argv[]) \n{ \n    bool verb; \n    int it, nt, ih, nh, is, ns, nsg, nrg, left, right, ic, aper, shift, c, cc, hh; \n    int ir, nr, jump, sleft, sright, tap; \n    float datum, length, t0, dt, h0, dh, s0, ds, sg0, dsg, rg0, drg, dist, tau, delta; \n    float r, dr, s, h, coef; \n    float ***tr_in, ***tr_out, **stable, **rtable; \n    sf_file in, out, sgreen, rgreen, interm; \n \n    sf_init (argc,argv); \n    in = sf_input(\"in\"); \n    out = sf_output(\"out\"); \n     \n    if (!sf_getbool(\"verb\",&verb)) verb=false; \n     \n \n \n    if (!sf_getfloat(\"datum\",&datum)) sf_error(\"Need datum=\"); \n     \n \n \n    if (!sf_getint(\"aperture\",&aper)) aper=50; \n     \n \n \n    if (!sf_getint(\"taper\",&tap)) tap=10; \n     \n \n \n    if (!sf_getfloat(\"length\",&length)) length=0.025; \n     \n \n \n     \n \n    if (!sf_histint(in,\"n1\",&nt)) sf_error(\"No nt=\"); \n    if (!sf_histint(in,\"n2\",&nh)) sf_error(\"No nh=\"); \n    if (!sf_histint(in,\"n3\",&ns)) sf_error(\"No ns=\"); \n \n    if (!sf_histfloat(in,\"o1\",&t0)) sf_error(\"No t0=\"); \n    if (!sf_histfloat(in,\"d1\",&dt)) sf_error(\"No dt=\"); \n \n    if (!sf_histfloat(in,\"o2\",&h0)) sf_error(\"No h0=\"); \n    if (!sf_histfloat(in,\"d2\",&dh)) sf_error(\"No dh=\"); \n \n    if (!sf_histfloat(in,\"o3\",&s0)) sf_error(\"No s0=\"); \n    if (!sf_histfloat(in,\"d3\",&ds)) sf_error(\"No ds=\"); \n \n    tr_in = sf_floatalloc3(nt,nh,ns); \n    sf_floatread(tr_in[0][0],nt*nh*ns,in); \n \n     \n \n    tr_out = sf_floatalloc3(nt,nh,ns); \n \n     \n \n    sgreen = sf_input(\"sgreen\"); \n \n    if (!sf_histint(sgreen,\"n1\",&nsg)) sf_error(\"No nsg=\"); \n    if (!sf_histfloat(sgreen,\"o1\",&sg0)) sf_error(\"No sg0=\"); \n    if (!sf_histfloat(sgreen,\"d1\",&dsg)) sf_error(\"No dsg=\"); \n \n    stable = sf_floatalloc2(nsg,nsg); \n    sf_floatread(stable[0],nsg*nsg,sgreen); \n    sf_fileclose(sgreen); \n \n     \n \n    rgreen = sf_input(\"rgreen\"); \n \n    if (!sf_histint(rgreen,\"n1\",&nrg)) sf_error(\"No nrg=\"); \n    if (!sf_histfloat(rgreen,\"o1\",&rg0)) sf_error(\"No rg0=\"); \n    if (!sf_histfloat(rgreen,\"d1\",&drg)) sf_error(\"No drg=\"); \n \n    rtable = sf_floatalloc2(nrg,nrg); \n    sf_floatread(rtable[0],nrg*nrg,rgreen); \n    sf_fileclose(rgreen); \n \n     \n \n    if (NULL!= sf_getstring(\"interm\")) { \n\tinterm = sf_output(\"interm\"); \n    } else { \n\tinterm = NULL; \n    } \n \n     \n \n    filt_init(dt,length); \n \n     \n \n    for (is=0; is < ns; is++) { \n\tif (verb) sf_warning(\"Processing common-shot gather %d of %d.\",is+1,ns); \n \n\tfor (ih=0; ih < nh; ih++) { \n \n\t    c = (s0+is*ds+h0+ih*dh-rg0)/drg+0.5; \n\t    if (c < 0 || c > nrg-1) sf_error(\"Receiver table too small.\"); \n \n\t     \n \n\t    left  = (ih-aper < 0)?    0:    ih-aper; \n\t    right = (ih+aper > nh-1)? nh-1: ih+aper; \n\t     \n\t    for (ic=left; ic <= right; ic++) { \n\t\t \n\t\tcc = (s0+is*ds+h0+ic*dh-rg0)/drg+0.5; \n\t\tif (cc < 0 || cc > nrg-1) sf_error(\"Receiver table too small.\"); \n \n\t\t \n \n\t\tcoef = 1.; \n\t\tcoef *= (ic-left  >= tap)? 1.: (ic-left)/tap; \n\t\tcoef *= (right-ic >= tap)? 1.: (right-ic)/tap; \n \n\t\t \n \n\t\ttau = rtable[cc][c]; \n \n\t\t \n \n\t\tdist = datum*datum+(ic-ih)*dh*(ic-ih)*dh; \n \n\t\t \n \n\t\tfilt_set(tau); \n \n\t\tshift = 0; \n\t\tdelta = 0.; \n\t\tfor (it=0; it < nt; it++) { \n\t\t    if (((float)it)*dt < tau)  \n\t\t\tcontinue; \n\t\t    else if (shift == 0) \n\t\t\tdelta = (((float)it*dt)-tau)/dt; \n \n\t\t    tr_out[is][ih][it] += coef/SF_PI \n\t\t\t*dh*datum*tau/dist \n\t\t\t*pick(delta,tr_in[is][ic],shift); \n\t\t    shift++; \n\t\t} \n\t    } \n \n\t} \n    } \n \n    if (NULL!= interm) sf_floatwrite(tr_out[0][0],nt*nh*ns,interm); \n \n     \n \n    for (is=0; is < ns; is++) { \n\tfor (ih=0; ih < nh; ih++) { \n\t    for (it=0; it < nt; it++) { \n\t\ttr_in[is][ih][it] = 0.; \n\t    } \n\t} \n    } \n \n     \n \n    s = fabsf((ns-1)*ds); \n    h = fabsf((nh-1)*dh); \n \n    if (fabsf(ds) >= fabsf(dh)) { \n\tdr = fabsf(dh); \n\tjump = 1; \n    } else { \n\tdr = fabsf(ds); \n\tjump = dh/ds+0.5; \n    } \n     \n    nr = (s+h)/dr+1.5; \n \n     \n \n    for (ir=0; ir < nr; ir++) { \n\tif (verb) sf_warning(\"Processing common-receiver gather %d of %d.\",ir+1,nr); \n \n\tr = ir*dr+((ds<=0.)?-1.:0.)*s+((dh<=0.)?-1.:0.)*h; \n\t \n\t \n \n\tsleft  = (ir*dr+((ds<=0.)?-1.:0.)*s+((ds<=0.)?0.:-1.)*h)/ds+0.5; \n\tsright = (ir*dr+((ds<=0.)?-1.:0.)*s+((ds<=0.)?-1.:0.)*h)/ds+0.5; \n \n\tif (sleft < 0) sleft = 0; \n\tif (sright > ns-1) sright = ns-1; \n\t \n\t \n \n\tleft = (r-s", "pred": " \nint main(int argc, char* argv[]) \n{ \n    bool verb; \n    int it, nt, ih, nh, is, ns, nsg, nrg, left, right, ic, aper, shift, c, cc, hh; \n    int ir, nr, jump, sleft, sright, tap; \n    float datum, length, t0, dt, h0, dh, s0, ds, sg0, dsg, rg0, drg, dist, tau, delta; \n    float r, dr, s, h, coef; \n    float ***tr_in, ***tr_out, **stable, **rtable; \n    sf_file in, out, sgreen, rgreen, interm; \n \n    sf_init (argc,argv); \n    in = sf_input(\"in\"); \n    out = sf_output(\"out\"); \n     \n    if (!sf_getbool(\"verb\",&verb)) verb=false; \n     \n \n \n    if (!sf_getfloat(\"datum\",&datum)) sf_error(\"Need datum=\"); \n     \n \n \n    if (!sf_getint(\"aperture\",&aper)) aper=50; \n    if (!sf_getint(\"jump\",&jump)) jump=1; \n    if (!sf_getint(\"sleft\",&sleft)) sleft=0; \n    if (!sf_getint(\"sright\",&sright)) sright=0; \n    if (!sf_getint(\"left\",&left)) left=0; \n    if (!sf_getint(\"right\",&right)) right=0; \n    if (!sf_getint(\"ic\",&ic)) ic=0; \n    if (!sf_getint(\"is\",&is)) is=0; \n    if (!sf_getint(\"ns\",&ns)) ns=0; \n    if (!sf_getint(\"nsg\",&nsg)) nsg=0; \n    if (!sf_getint(\"nrg\",&nrg)) nrg=0; \n    if (!sf_getint(\"left\",&left)) left=0; \n    if (!sf_getint(\"right\",&right)) right=0; \n    if (!sf_getint(\"ic\",&ic)) ic=0; \n    if (!sf_getint(\"is\",&is)) is=0; \n    if (!sf_getint(\"ns\",&ns)) ns=0; \n    if (!sf_getint(\"nsg\",&nsg)) nsg=0; \n    if (!sf_getint(\"nrg\",&nrg)) nrg=0; \n    if (!sf_getint(\"left\",&left)) left=0; \n    if (!sf_getint(\"right\",&right)) right=0; \n    if (!sf_getint(\"ic\",&ic)) ic=0; \n    if (!sf_getint(\"is\",&is)) is=0; \n    if (!sf_getint(\"ns\",&ns)) ns=0; \n    if (!sf_getint(\"nsg\",&nsg)) nsg=0; \n    if (!sf_getint(\"nrg\",&nrg)) nrg=0; \n    if (!sf_getint(\"left\",&left)) left=0; \n    if (!sf_getint(\"right\",&right)) right=0; \n    if (!sf_getint(\"ic\",&ic)) ic=0; \n    if (!sf_getint(\"is\",&is)) is=0; \n    if (!sf_getint(\"ns\",&ns)) ns=0; \n    if (!sf_getint(\"nsg\",&nsg)) nsg=0; \n    if (!sf_getint(\"nrg\",&nrg)) nrg=0; \n    if (!sf_getint(\"left\",&left)) left=0; \n    if (!sf_getint(\"right\",&right)) right=0; \n    if (!sf_getint(\"ic\",&ic)) ic=0; \n    if (!sf_getint(\"is\",&is)) is=0; \n    if (!sf_getint(\"ns\",&ns)) ns=0; \n    if (!sf_getint(\"nsg\",&nsg)) nsg=0; \n    if (!sf_getint(\"nrg\",&nrg)) nrg=0; \n    if (!sf_getint(\"left\",&left)) left=0; \n    if (!sf_getint(\"right\",&right)) right=0; \n    if (!sf_getint(\"ic\",&ic)) ic=0; \n    if (!sf_getint(\"is\",&is)) is=0; \n    if (!sf_getint(\"ns\",&ns)) ns=0; \n    if (!sf_getint(\"nsg\",&nsg)) nsg=0; \n    if (!sf_getint(\"nrg\",&nrg)) nrg=0; \n    if (!sf_getint(\"left\",&left)) left=0; \n    if (!sf_getint(\"right\",&right)) right=0; \n    if (!sf_getint(\"ic\",&ic)) ic=0; \n    if (!sf_getint(\"is\",&is)) is=0; \n    if (!sf_getint(\"ns\",&ns)) ns=0; \n    if (!sf_getint(\"nsg\",&nsg)) nsg=0; \n    if (!sf_getint(\"nrg\",&nrg)) nrg=0; \n    if (!sf_getint(\"left\",&left)) left=0; \n    if (!sf_getint(\"right\",&right)) right=0; \n    if (!sf_getint(\"ic\",&ic)) ic=0; \n    if (!sf_getint(\"is\",&is)) is=0; \n    if (!sf_getint(\"ns\",&ns)) ns=0; \n    if (!sf_getint(\"nsg\",&nsg)) nsg=0; \n    if (!sf_getint(\"nrg\",&nrg)) nrg=0; \n    if (!sf_getint(\"left\",&left)) left=0; \n    if (!sf_getint(\"right\",&right)) right=0; \n    if (!sf_getint(\"ic\",&ic)) ic=0; \n    if (!sf_getint(\"is\",&is)) is=0; \n    if (!sf_getint(\"ns\",&ns)) ns=0; \n    if (!sf_getint(\"nsg\",&nsg)) nsg=0; \n    if (!sf_getint(\"nrg\",&nrg)) nrg=0; \n    if (!sf_getint(\"left\",&left)) left=0; \n    if (!sf_getint(\"right\",&right)) right=0; \n    if (!sf_getint(\"ic\",&ic)) ic=0; \n    if (!sf_getint(\"is\",&is)) is=0; \n    if (!sf_getint(\"ns\",&ns)) ns=0; \n    if (!sf_getint(\"nsg\",&nsg)) nsg=0; \n    if (!sf_getint(\"nrg\",&nrg)) nrg=0; \n    if (!sf_getint(\"left\",&left)) left=0; \n    if (!sf_getint(\"right\",&right)) right=0; \n    if (!sf_getint(\"ic\",&ic)) ic=0; \n    if (!sf_getint(\"is\",&is)) is=0; \n    if (!sf_getint(\"ns\",&ns)) ns=0; \n    if (!sf_getint(\"nsg\",&nsg)) nsg=0; \n    if (!sf_getint(\"nrg\",&nrg)) nrg=0; \n    if (!sf_getint(\"left\",&left)) left=0; \n    if (!sf_getint(\"right\",&right)) right=0; \n    if (!sf_getint(\"ic\",&ic)) ic=0; \n    if (!sf_getint(\"is\",&is)) is=0; \n    if (!sf_getint(\"ns\",&ns)) ns=0; \n    if (!sf_getint(\"nsg\",&nsg)) nsg=0; \n    if (!sf_getint(\"nrg\",&nrg)) nrg=0; \n    if (!sf_getint(\"left\",&left)) left=0; \n"}
{"label": " \nvoid get_pearson_similarity(float* rating_m, float* rating_n, double* average_matrix, k_similarity_struct * k_similarity_matrix, int start_index_m, int start_index_n, int flag){ \n        \n \n\tprintf(\" in pearson_similarity start_index_m=%d, start_index_n=%d\\n\", start_index_m, start_index_n); \n\t \n\tint nPadded = ( USER_COUNT%8 == 0? USER_COUNT : USER_COUNT + (8-USER_COUNT%8) ); \n  \n\tdouble similarity; \n\t \n        int i,j,m,n,s,k; \n \n\tint ua,ub,uc; \n  \n\tfloat sum_numerator=0; \n\tfloat sum_denominator_square_m=0; \n\tfloat sum_denominator_square_n=0; \n\tfloat sum_denominator=0; \n \n \n\tdouble* sum_numerator_matrix =(double*) _mm_malloc(sizeof(double)*USER_COUNT,64); \n\tdouble* sum_denominator_matrix_m =(double*) _mm_malloc(sizeof(double)*USER_COUNT,64); \n\tdouble* sum_denominator_matrix_n =(double*) _mm_malloc(sizeof(double)*USER_COUNT,64); \n \n\tmemset(sum_numerator_matrix,0,sizeof(double)*USER_COUNT);\t \n\tmemset(sum_denominator_matrix_m,0,sizeof(double)*USER_COUNT);\t \n\tmemset(sum_denominator_matrix_n,0,sizeof(double)*USER_COUNT);\t \n \n \n\t \n \n \n \n\t \n\tint numthreads;\t \n        int item_index; \n \n\tint block_m,block_n; \n\t \n\tint end_m=(ITEM_COUNT<(start_index_m+ITEM_BLOCK)? ITEM_COUNT:(start_index_m+ITEM_BLOCK)); \n\tint end_n=(ITEM_COUNT<(start_index_n+ITEM_BLOCK)? ITEM_COUNT:(start_index_n+ITEM_BLOCK)); \n \n\tprintf(\"the number of threads is %d\\n\", omp_get_num_threads()); \n\t \n\tprintf(\" end_m = %d, end_n = %d\\n\",end_m,end_n); \n \n \n\tdouble a = microtime(); \n \n \n\t \n         \n \n\t \n \n\t \n \n\tunsigned int mn;   \n     \n \n        for (mn = 0; mn < (end_m-start_index_m)*(end_n-start_index_n); mn++)  \n     \n \n        {       \n \n \n       \n \n         \n \n\t\t \n\t\t\tm = start_index_m + mn / ( end_n - start_index_n ); \n\t\t\tn = start_index_n + mn % ( end_n - start_index_n );  \n \n \n\t\t\tblock_m = m - start_index_m; \n\t\t\tblock_n = n - start_index_n;\t \n \n \n \n \n \n\t\t\tsum_numerator=0; \n\t\t\tsum_denominator_square_m=0; \n\t\t\tsum_denominator_square_n=0; \n\t\t\tsum_denominator=0; \n\t\t\t \n\t\t\t \n \n \n\t \n \n \n \n \n \n\t\t\t \n \n \n \n \n \n                        for (i=0;i < USER_COUNT; i++) \n                        {   \n\t\t\t       \t \n \n                               \tsum_numerator += (rating_m[block_m*USER_COUNT+i])*(rating_n[block_n*USER_COUNT+i]); \n                                \n \n\t\t\t\t \n                                 \n \n       \t                        sum_denominator_square_m += powf((rating_m[block_m*USER_COUNT+i]),2.0); \n       \t \n \n             \t                sum_denominator_square_n += powf((rating_n[block_n*USER_COUNT+i]),2.0); \n           \n \n\t \n \n\t \n \n \n \n                        } \n \n \n \n \n \n\t \n                         \n \n                        sum_denominator = sqrt (sum_denominator_square_m*sum_denominator_square_n); \n                        if(sum_denominator!=0) \n\t\t\t\tsimilarity = sum_numerator/sum_denominator; \n\t\t\telse \n\t\t\t\tsimilarity = 0; \n \n \n \n \n \n                \n \n        } \n \n\tdouble b = microtime(); \n\tdouble duration = b-a; \n \n\tprintf(\" time consumed: %fs\\n\", duration); \nexit(0); \n} ", "pred": " \nvoid get_pearson_similarity(float* rating_m, float* rating_n, double* average_matrix, k_similarity_struct * k_similarity_matrix, int start_index_m, int start_index_n, int flag){ \n        \n \n\tprintf(\" in pearson_similarity start_index_m=%d, start_index_n=%d\\n\", start_index_m, start_index_n); \n\t \n\tint nPadded = ( USER_COUNT%8 == 0? USER_COUNT : USER_COUNT + (8-USER_COUNT%8) ); \n  \n\tdouble similarity; \n\t \n        int i,j,m,n,s,k; \n \n\tint ua,ub,uc; \n  \n\tfloat sum_numerator=0; \n\tfloat sum_denominator_square_m=0; \n\tfloat sum_denominator_square_n=0; \n\tfloat sum_denominator=0; \n \n \n\tdouble* sum_numerator_matrix =(double*) _mm_malloc(sizeof(double)*USER_COUNT,64); \n\tdouble* sum_denominator_matrix_m =(double*) _mm_malloc(sizeof(double)*USER_COUNT,64); \n\tdouble* sum_denominator_matrix_n =(double*) _mm_malloc(sizeof(double)*USER_COUNT,64); \n \n\tfor(i=0;i<USER_COUNT;i++){ \n\t\tsum_numerator_matrix[i]=0; \n\t\tsum_denominator_matrix_m[i]=0; \n\t\tsum_denominator_matrix_n[i]=0; \n\t} \n \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"}
{"label": " \nMagickExport Image *IntegralRotateImage(const Image *image,size_t rotations, \n  ExceptionInfo *exception) \n{ \n#define RotateImageTag  \"Rotate/Image\" \n \n  CacheView \n    *image_view, \n    *rotate_view; \n \n  Image \n    *rotate_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  RectangleInfo \n    page; \n \n   \n \n  assert(image!= (Image *) NULL); \n  page=image->page; \n  rotations%=4; \n  if (rotations == 0) \n    return(CloneImage(image,0,0,MagickTrue,exception)); \n  if ((rotations == 1) || (rotations == 3)) \n    rotate_image=CloneImage(image,image->rows,image->columns,MagickTrue, \n      exception); \n  else \n    rotate_image=CloneImage(image,image->columns,image->rows,MagickTrue, \n      exception); \n  if (rotate_image == (Image *) NULL) \n    return((Image *) NULL); \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  rotate_view=AcquireAuthenticCacheView(rotate_image,exception); \n  switch (rotations) \n  { \n    case 1: \n    { \n      size_t \n        tile_height, \n        tile_width; \n \n      ssize_t \n        tile_y; \n \n       \n \n      GetPixelCacheTileSize(image,&tile_width,&tile_height); \n      tile_width=image->columns; \n      for (tile_y=0; tile_y < (ssize_t) image->rows; tile_y+=(ssize_t) tile_height) \n      { \n        register ssize_t \n          tile_x; \n \n        if (status == MagickFalse) \n          continue; \n        tile_x=0; \n        for ( ; tile_x < (ssize_t) image->columns; tile_x+=(ssize_t) tile_width) \n        { \n          MagickBooleanType \n            sync; \n \n          register const Quantum \n            *magick_restrict p; \n \n          register Quantum \n            *magick_restrict q; \n \n          register ssize_t \n            y; \n \n          size_t \n            height, \n            width; \n \n          width=tile_width; \n          if ((tile_x+(ssize_t) tile_width) > (ssize_t) image->columns) \n            width=(size_t) (tile_width-(tile_x+tile_width-image->columns)); \n          height=tile_height; \n          if ((tile_y+(ssize_t) tile_height) > (ssize_t) image->rows) \n            height=(size_t) (tile_height-(tile_y+tile_height-image->rows)); \n          p=GetCacheViewVirtualPixels(image_view,tile_x,tile_y,width,height, \n            exception); \n          if (p == (const Quantum *) NULL) \n            { \n              status=MagickFalse; \n              break; \n            } \n          for (y=0; y < (ssize_t) width; y++) \n          { \n            register const Quantum \n              *magick_restrict tile_pixels; \n \n            register ssize_t \n              x; \n \n            if (status == MagickFalse) \n              continue; \n            q=QueueCacheViewAuthenticPixels(rotate_view,(ssize_t) \n              (rotate_image->columns-(tile_y+height)),y+tile_x,height,1, \n              exception); \n            if (q == (Quantum *) NULL) \n              { \n                status=MagickFalse; \n                continue; \n              } \n            tile_pixels=p+((height-1)*width+y)*GetPixelChannels(image); \n            for (x=0; x < (ssize_t) height; x++) \n            { \n              register ssize_t \n                i; \n \n              if (GetPixelWriteMask(image,tile_pixels) == 0) \n                { \n                  tile_pixels-=width*GetPixelChannels(image); \n                  q+=GetPixelChannels(rotate_image); \n                  continue; \n                } \n              for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n              { \n                PixelChannel channel=GetPixelChannelChannel(image,i); \n                PixelTrait traits=GetPixelChannelTraits(image,channel); \n                PixelTrait rotate_traits=GetPixelChannelTraits(rotate_image, \n                  channel); \n                if ((traits == UndefinedPixelTrait) || \n                    (rotate_traits == UndefinedPixelTrait)) \n                  continue; \n                SetPixelChannel(rotate_image,channel,tile_pixels[i],q); \n              } \n              tile_pixels-=width*GetPixelChannels(image); \n              q+=GetPixelChannels(rotate_image); \n            } \n            sync=SyncCacheViewAuthenticPixels(rotate_view,exception); \n            if (sync == MagickFalse) \n      ", "pred": " \nMagickExport Image *IntegralRotateImage(const Image *image,size_t rotations, \n  ExceptionInfo *exception) \n{ \n#define RotateImageTag  \"Rotate/Image\" \n \n  CacheView \n    *image_view, \n    *rotate_view; \n \n  Image \n    *rotate_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  RectangleInfo \n    page; \n \n   \n \n  assert(image!= (Image *) NULL); \n  page=image->page; \n  rotations%=4; \n  if (rotations == 0) \n    return(CloneImage(image,0,0,MagickTrue,exception)); \n  if ((rotations == 1) || (rotations == 3)) \n    rotate_image=CloneImage(image,image->rows,image->columns,MagickTrue, \n      exception); \n  else \n    rotate_image=CloneImage(image,image->columns,image->rows,MagickTrue, \n      exception); \n  if (rotate_image == (Image *) NULL) \n    return((Image *) NULL); \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  rotate_view=AcquireAuthenticCacheView(rotate_image,exception); \n  for ( ; rotations > 0; rotations-=4) \n  { \n    /*\n      Rotate image.\n    */ \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void) TransformImageColorspace(rotate_image,GRAYColorspace,exception); \n    (void)"}
{"label": " \nvoid BLI_covariance_m_vn_ex( \n        const int n, const float *cos_vn, const int nbr_cos_vn, const float *center, const bool use_sample_correction, \n        float *r_covmat) \n{ \n\tint i, j, k; \n \n\t \n \n\tconst float covfac = 1.0f / (float)(use_sample_correction? nbr_cos_vn - 1 : nbr_cos_vn); \n \n\tmemset(r_covmat, 0, sizeof(*r_covmat) * (size_t)(n * n)); \n \n\tfor (i = 0; i < n; i++) { \n\t\tfor (j = i; j < n; j++) { \n\t\t\tr_covmat[i * n + j] = 0.0f; \n\t\t\tif (center) { \n\t\t\t\tfor (k = 0; k < nbr_cos_vn; k++) { \n\t\t\t\t\tr_covmat[i * n + j] += (cos_vn[k * n + i] - center[i]) * (cos_vn[k * n + j] - center[j]); \n\t\t\t\t} \n\t\t\t} \n\t\t\telse { \n\t\t\t\tfor (k = 0; k < nbr_cos_vn; k++) { \n\t\t\t\t\tr_covmat[i * n + j] += cos_vn[k * n + i] * cos_vn[k * n + j]; \n\t\t\t\t} \n\t\t\t} \n\t\t\tr_covmat[i * n + j] *= covfac; \n\t\t} \n\t} \n\t \n \n\tfor (i = 1; i < n; i++) { \n\t\tfor (j = 0; j < i; j++) { \n\t\t\tr_covmat[i * n + j] = r_covmat[j * n + i]; \n\t\t} \n\t} \n} ", "pred": " \nvoid BLI_covariance_m_vn_ex( \n        const int n, const float *cos_vn, const int nbr_cos_vn, const float *center, const bool use_sample_correction, \n        float *r_covmat) \n{ \n\tint i, j, k; \n \n\t \n \n\tconst float covfac = 1.0f / (float)(use_sample_correction? nbr_cos_vn - 1 : nbr_cos_vn); \n \n\tmemset(r_covmat, 0, sizeof(*r_covmat) * (size_t)(n * n)); \n \n\tfor (i = 0; i < n; i++) { \n\t\tfor (j = i; j < n; j++) { \n\t\t\tr_covmat[i * n + j] = 0.0f; \n\t\t\tif (center) { \n\t\t\t\tfor (k = 0; k < nbr_cos_vn; k++) { \n\t\t\t\t\tr_covmat[i * n + j] += (cos_vn[k * n + i] - center[i]) * (cos_vn[k * n + j] - center[j]); \n\t\t\t\t} \n\t\t\t} \n\t\t\telse { \n\t\t\t\tfor (k = 0; k < nbr_cos_vn; k++) { \n\t\t\t\t\tr_covmat[i * n + j] += (cos_vn[k * n + i] - 1.0f) * (cos_vn[k * n + j] - 1.0f); \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t} \n \n\tfor (i = 0; i < n; i++) { \n\t\tfor (j = i; j < n; j++) { \n\t\t\tr_covmat[i * n + j] *= covfac; \n\t\t} \n\t} \n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"label": " \nvoid InterfaceAssembly(Simulation *simu,  LinearSolver *solver,schnaps_real theta, schnaps_real dt) \n{ \n \n  int fsize =  simu->wsize / simu->macromesh.nbelems; \n \n  for(int ifa = 0; ifa < simu->macromesh.nbfaces; ifa++){ \n    int ieL = simu->macromesh.face2elem[4 * ifa + 0]; \n    int locfaL = simu->macromesh.face2elem[4 * ifa + 1]; \n    int ieR = simu->macromesh.face2elem[4 * ifa + 2]; \n    field *fL = simu->fd + ieL; \n    field *fR = NULL; \n    int offsetR = -1; \n     \n \n    int offsetL = fsize * ieL; \n    if (ieR >= 0) { \n      fR = simu->fd + ieR; \n      offsetR = fsize * ieR; \n    } \n \n   \n    const unsigned int m = fL->model.m; \n \n \n     \n \n    for(int ipgfL = 0; ipgfL < NPGF(fL->deg, fL->raf, locfaL); ipgfL++) { \n \n      schnaps_real xpgref[3], xpgref_in[3], wpg; \n     \n       \n \n       \n \n      int ipgL = ref_pg_face(fL->deg, fL->raf, locfaL, ipgfL, xpgref, &wpg, xpgref_in); \n     \n       \n \n      schnaps_real vnds[3], xpg[3]; \n      { \n\tschnaps_real dtau[3][3], codtau[3][3]; \n\tschnaps_ref2phy(fL->physnode, \n\t\txpgref, \n\t\tNULL, locfaL,  \n \n\t\txpg, dtau, \n\t\tcodtau, NULL, vnds);  \n \n      } \n     \n      if (fR!= NULL) {   \n \n\tschnaps_real xrefL[3]; \n\t{ \n\t  schnaps_real xpg_in[3]; \n\t  schnaps_ref2phy(fL->physnode, \n\t\t  xpgref_in, \n\t\t  NULL, -1,  \n \n\t\t  xpg_in, NULL, \n\t\t  NULL, NULL, NULL);  \n \n\t  PeriodicCorrection(xpg_in,fL->period); \n\t  schnaps_phy2ref(fR->physnode, xpg_in, xrefL); \n\t \n\t} \n       \n\tint ipgR = ref_ipg(fR->deg,fR->raf, xrefL); \n \n \n\tschnaps_real flux[m]; \n\tschnaps_real wL[m]; \n\tschnaps_real wR[m]; \n \n\tfor (int iv1 = 0; iv1 < m; iv1++){ \n \n\t\t\t     \n \n\t  for(int iv = 0; iv < m; iv++) { \n\t    wL[iv] = (iv == iv1); \n\t    wR[iv] = 0; \n\t  } \n\t  int imem1 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgL, iv1) + offsetL; \n \n\t   \n \n \n\t  fL->model.NumFlux(wL, wR, vnds, flux); \n \n\t   \n \n \n\t  for(int iv2 = 0; iv2 < m; iv2++) { \n\t    int imem2 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgL, iv2) + offsetL;\t\t   \n\t    schnaps_real val = theta * dt * flux[iv2] * wpg;\t\t       \n\t    AddLinearSolver(solver, imem2, imem1, val); \n\t\t       \n\t    imem2 = fR->varindex(fR->deg, fR->raf, fR->model.m, ipgR, iv2) + offsetR; \n\t    val = theta * dt * flux[iv2] * wpg;\t\t       \n\t    AddLinearSolver(solver, imem2, imem1, -val); \n\t  } \n\t\t   \n\t  for(int iv = 0; iv < m; iv++) { \n\t    wL[iv] = 0; \n\t    wR[iv] = (iv == iv1); \n\t  } \n\t  imem1 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgR, iv1) + offsetR; \n \n \n\t  fL->model.NumFlux(wL, wR, vnds, flux); \n \n\t  for(int iv2 = 0; iv2 < m; iv2++) { \n\t    int imem2 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgL, iv2) + offsetL; \n\t    schnaps_real val = theta * dt * flux[iv2] * wpg; \n\t    AddLinearSolver(solver, imem2, imem1, val); \n\t\t     \n\t    imem2 = fR->varindex(fR->deg, fR->raf, fR->model.m, ipgR, iv2) + offsetR;\t\t     \n\t    val = theta *dt * flux[iv2] * wpg;\t\t     \n\t    AddLinearSolver(solver, imem2, imem1, -val); \n\t  } \n\t} \n \n      } else {  \n \n \n\t \n \n\tschnaps_real flux0[m], wL[m]; \n\tfor(int iv = 0; iv < m; iv++) { \n\t  wL[iv] = 0; \n\t} \n\tfL->model.BoundaryFlux(xpg, fL->tnow, wL, vnds, flux0); \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n       \n\tfor(int iv1 = 0; iv1 < m; iv1++) { \n\t  int imem1 = fL->varindex(fL->deg, fL->raf,fL->model.m, ipgL, iv1) + offsetL; \n \n\t  for(int iv = 0; iv < m; iv++) { \n\t    wL[iv] = (iv == iv1); \n\t  } \n \n\t  schnaps_real flux[m]; \n\t  fL->model.BoundaryFlux(xpg, fL->tnow, wL, vnds, flux); \n \n\t  for(int iv2 = 0; iv2 < m; iv2++) { \n\t     \n \n\t    int imem2 = fL->varindex(fL->deg, fL->raf,fL->model.m, ipgL, iv2) + offsetL; \n\t    schnaps_real val = theta *dt * (flux[iv2]-flux0[iv2]) * wpg;\t\t     \n\t    AddLinearSolver(solver, imem2, imem1, val); \n\t  } \n\t}  \n \n \n      }  \n \n \n   \n    }  \n \n \n  }  \n \n \n} ", "pred": " \nvoid InterfaceAssembly(Simulation *simu,  LinearSolver *solver,schnaps_real theta, schnaps_real dt) \n{ \n \n  int fsize =  simu->wsize / simu->macromesh.nbelems; \n \n  for(int ifa = 0; ifa < simu->macromesh.nbfaces; ifa++){ \n    int ieL = simu->macromesh.face2elem[4 * ifa + 0]; \n    int locfaL = simu->macromesh.face2elem[4 * ifa + 1]; \n    int ieR = simu->macromesh.face2elem[4 * ifa + 2]; \n    field *fL = simu->fd + ieL; \n    field *fR = NULL; \n    int offsetR = -1; \n     \n \n    int offsetL = fsize * ieL; \n    if (ieR >= 0) { \n      fR = simu->fd + ieR; \n      offsetR = fsize * ieR; \n    } \n \n   \n    const unsigned int m = fL->model.m; \n \n \n     \n \n    for(int i = 0; i < fL->model.n; i++){ \n      int ie = fL->model.elem[i]; \n      field *f = fL->model.field[i]; \n      int offset = fL->model.offset[i]; \n      int n = fL->model.n[i]; \n      int *ieL = simu->macromesh.elem2face[4 * ie + 0]; \n      int *ieR = simu->macromesh.elem2face[4 * ie + 1]; \n      int *ieL2 = simu->macromesh.elem2face[4 * ie + 2]; \n      int *ieR2 = simu->macromesh.elem2face[4 * ie + 3]; \n      int *ieL3 = simu->macromesh.elem2face[4 * ie + 4]; \n      int *ieR3 = simu->macromesh.elem2face[4 * ie + 5]; \n      int *ieL4 = simu->macromesh.elem2face[4 * ie + 6]; \n      int *ieR4 = simu->macromesh.elem2face[4 * ie + 7]; \n      int *ieL5 = simu->macromesh.elem2face[4 * ie + 8]; \n      int *ieR5 = simu->macromesh.elem2face[4 * ie + 9]; \n      int *ieL6 = simu->macromesh.elem2face[4 * ie + 10]; \n      int *ieR6 = simu->macromesh.elem2face[4 * ie + 11]; \n      int *ieL7 = simu->macromesh.elem2face[4 * ie + 12]; \n      int *ieR7 = simu->macromesh.elem2face[4 * ie + 13]; \n      int *ieL8 = simu->macromesh.elem2face[4 * ie + 14]; \n      int *ieR8 = simu->macromesh.elem2face[4 * ie + 15]; \n      int *ieL9 = simu->macromesh.elem2face[4 * ie + 16]; \n      int *ieR9 = simu->macromesh.elem2face[4 * ie + 17]; \n      int *ieL10 = simu->macromesh.elem2face[4 * ie + 18]; \n      int *ieR10 = simu->macromesh.elem2face[4 * ie + 19]; \n      int *ieL11 = simu->macromesh.elem2face[4 * ie + 20]; \n      int *ieR11 = simu->macromesh.elem2face[4 * ie + 21]; \n      int *ieL12 = simu->macromesh.elem2face[4 * ie + 22]; \n      int *ieR12 = simu->macromesh.elem2face[4 * ie + 23]; \n      int *ieL13 = simu->macromesh.elem2face[4 * ie + 24]; \n      int *ieR13 = simu->macromesh.elem2face[4 * ie + 25]; \n      int *ieL14 = simu->macromesh.elem2face[4 * ie + 26]; \n      int *ieR14 = simu->macromesh.elem2face[4 * ie + 27]; \n      int *ieL15 = simu->macromesh.elem2face[4 * ie + 28]; \n      int *ieR15 = simu->macromesh.elem2face[4 * ie + 29]; \n      int *ieL16 = simu->macromesh.elem2face[4 * ie + 30]; \n      int *ieR16 = simu->macromesh.elem2face[4 * ie + 31]; \n      int *ieL17 = simu->macromesh.elem2face[4 * ie + 32]; \n      int *ieR17 = simu->macromesh.elem2face[4 * ie + 33]; \n      int *ieL18 = simu->macromesh.elem2face[4 * ie + 34]; \n      int *ieR18 = simu->macromesh.elem2face[4 * ie + 35]; \n      int *ieL19 = simu->macromesh.elem2face[4 * ie + 36]; \n      int *ieR19 = simu->macromesh.elem2face[4 * ie + 37]; \n      int *ieL20 = simu->macromesh.elem2face[4 * ie + 38]; \n      int *ieR20 = simu->macromesh.elem2face[4 * ie + 39]; \n      int *ieL21 = simu->macromesh.elem2face[4 * ie + 40]; \n      int *ieR21 = simu->macromesh.elem2face[4 * ie + 41]; \n      int *ieL22 = simu->macromesh.elem2face[4 * ie + 42]; \n      int *ieR22 = simu->macromesh.elem2face[4 * ie + 43]; \n      int *ieL23 = simu->macromesh.elem2face[4 * ie + 44]; \n      int *ieR23 = simu->macromesh.elem2face[4 * ie + 45]; \n      int *ieL24 = simu->macromesh.elem2face[4 * ie + 46]; \n      int *ieR24 = simu->macromesh.elem2face[4 * ie + 47]; \n      int *ieL25 = simu->macromesh.elem2face[4 * ie + 48]; \n      int *ieR25 = simu->macromesh.elem2face[4 * ie + 49]; \n      int *ieL26 = simu->macromesh.elem2face[4 * ie + 50]; \n      int *ieR26 = simu->macromesh.elem2face[4 * ie + 51]; \n      int *ieL27 = simu->macromesh.elem2face[4 * ie + 52]; \n    "}
{"label": " \nvoid \n_lw6ker_map_state_spread_gradient (lw6sys_context_t * sys_context, \n\t\t\t\t   _lw6ker_map_state_t * map_state, const lw6map_rules_t * rules, int32_t nb_spreads, u_int32_t team_mask) \n{ \n  int i; \n  int teams_concerned[LW6MAP_MAX_NB_TEAMS]; \n  int n = 0; \n \n  _lw6ker_map_state_apply_cursors (sys_context, map_state, rules, team_mask); \n   \n \n  for (i = 0; i < map_state->max_nb_teams; ++i) \n    { \n      if (map_state->teams[i].active) \n\t{ \n\t  if (lw6ker_team_mask_is_concerned (sys_context, i, team_mask)) \n\t    { \n\t      teams_concerned[n] = i; \n\t      n++; \n\t    } \n\t} \n    } \n   \n \n \n  for (i = 0; i < n; ++i) \n    { \n       \n \n      int j; \n \n      for (j = 0; j < nb_spreads; ++j) \n\t{ \n\t  _lw6ker_spread_update_gradient (sys_context, &(map_state->teams[teams_concerned[i]]), map_state->shape.d == 1, rules->spread_mode); \n\t} \n    } \n} ", "pred": " \nvoid \n_lw6ker_map_state_spread_gradient (lw6sys_context_t * sys_context, \n\t\t\t\t   _lw6ker_map_state_t * map_state, const lw6map_rules_t * rules, int32_t nb_spreads, u_int32_t team_mask) \n{ \n  int i; \n  int teams_concerned[LW6MAP_MAX_NB_TEAMS]; \n  int n = 0; \n \n  _lw6ker_map_state_apply_cursors (sys_context, map_state, rules, team_mask); \n   \n \n  for (i = 0; i < map_state->max_nb_teams; ++i) \n    { \n      if (map_state->teams[i].active) \n\t{ \n\t  if (lw6ker_team_mask_is_concerned (sys_context, i, team_mask)) \n\t    { \n\t      teams_concerned[n] = i; \n\t      n++; \n\t    } \n\t} \n    } \n   \n \n \n  for (i = 0; i < n; ++i) \n    { \n      int j; \n      int team_id = teams_concerned[i]; \n      lw6map_state_t *state = &map_state->teams[team_id]; \n      lw6map_state_t *state_next = &map_state->teams[teams_concerned[i+1]]; \n      lw6map_state_t *"}
{"label": " \nvoid InterfaceCoupling(Simulation *simu,  LinearSolver *solver, int itest) \n{ \n \n  int fsize =  simu->wsize / simu->macromesh.nbelems; \n \n  for(int ifa = 0; ifa < simu->macromesh.nbfaces; ifa++){ \n    int ieL = simu->macromesh.face2elem[4 * ifa + 0]; \n    int locfaL = simu->macromesh.face2elem[4 * ifa + 1]; \n    int ieR = simu->macromesh.face2elem[4 * ifa + 2]; \n    field *fL = simu->fd + ieL; \n    field *fR = NULL; \n    int offsetR = -1; \n     \n \n    int offsetL = fsize * ieL; \n    if (ieR >= 0) { \n      fR = simu->fd + ieR; \n      offsetR = fsize * ieR; \n    } \n \n   \n    const unsigned int m = fL->model.m; \n \n \n     \n \n    for(int ipgfL = 0; ipgfL < NPGF(fL->deg, fL->raf, locfaL); ipgfL++) { \n \n      schnaps_real xpgref[3], xpgref_in[3], wpg; \n     \n       \n \n       \n \n      int ipgL = ref_pg_face(fL->deg, fL->raf, locfaL, ipgfL, xpgref, &wpg, xpgref_in); \n     \n       \n \n      schnaps_real vnds[3], xpg[3]; \n      { \n\tschnaps_real dtau[3][3], codtau[3][3]; \n\tschnaps_ref2phy(fL->physnode, \n\t\txpgref, \n\t\tNULL, locfaL,  \n \n\t\txpg, dtau, \n\t\tcodtau, NULL, vnds);  \n \n      } \n     \n      if (fR!= NULL) {   \n \n\tschnaps_real xrefL[3]; \n\t{ \n\t  schnaps_real xpg_in[3]; \n\t  schnaps_ref2phy(fL->physnode, \n\t\t  xpgref_in, \n\t\t  NULL, -1,  \n \n\t\t  xpg_in, NULL, \n\t\t  NULL, NULL, NULL);  \n \n\t  PeriodicCorrection(xpg_in,fL->period); \n\t  schnaps_phy2ref(fR->physnode, xpg_in, xrefL); \n\t \n\t} \n       \n\tint ipgR = ref_ipg(fR->deg,fR->raf, xrefL); \n \n \n \n\tfor (int iv1 = 0; iv1 < m; iv1++){ \n \n\t\t\t     \n\t  int imem1 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgL, iv1) + offsetL; \n \n\t  for(int iv2 = 0; iv2 < m; iv2++) { \n\t    int imem2 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgL, iv2) + offsetL;\t\t   \n\t    IsNonZero(solver, imem2, imem1); \n\t\t       \n\t    imem2 = fR->varindex(fR->deg, fR->raf, fR->model.m, ipgR, iv2) + offsetR; \n\t    IsNonZero(solver, imem2, imem1); \n\t  } \n\t\t   \n\t  imem1 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgR, iv1) + offsetR; \n \n \n\t  for(int iv2 = 0; iv2 < m; iv2++) { \n\t    int imem2 = fL->varindex(fL->deg, fL->raf, fL->model.m, ipgL, iv2) + offsetL; \n\t    IsNonZero(solver, imem2, imem1); \n\t\t     \n\t    imem2 = fR->varindex(fR->deg, fR->raf, fR->model.m, ipgR, iv2) + offsetR;\t\t     \n\t    IsNonZero(solver, imem2, imem1); \n\t  } \n\t} \n \n      } else {  \n \n \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n       \n\tfor(int iv1 = 0; iv1 < m; iv1++) { \n\t  int imem1 = fL->varindex(fL->deg, fL->raf,fL->model.m, ipgL, iv1) + offsetL; \n \n\t  for(int iv2 = 0; iv2 < m; iv2++) { \n\t    int imem2 = fL->varindex(fL->deg, fL->raf,fL->model.m, ipgL, iv2) + offsetL; \n\t    IsNonZero(solver, imem2, imem1); \n\t  } \n\t}  \n \n \n      }  \n \n \n   \n    }  \n \n \n  }  \n \n \n} ", "pred": " \nvoid InterfaceCoupling(Simulation *simu,  LinearSolver *solver, int itest) \n{ \n \n  int fsize =  simu->wsize / simu->macromesh.nbelems; \n \n  for(int ifa = 0; ifa < simu->macromesh.nbfaces; ifa++){ \n    int ieL = simu->macromesh.face2elem[4 * ifa + 0]; \n    int locfaL = simu->macromesh.face2elem[4 * ifa + 1]; \n    int ieR = simu->macromesh.face2elem[4 * ifa + 2]; \n    field *fL = simu->fd + ieL; \n    field *fR = NULL; \n    int offsetR = -1; \n     \n \n    int offsetL = fsize * ieL; \n    if (ieR >= 0) { \n      fR = simu->fd + ieR; \n      offsetR = fsize * ieR; \n    } \n \n   \n    const unsigned int m = fL->model.m; \n \n \n     \n \n    for(int ipgfL = 0; ipgfL < fL->model.nbe; ipgfL++){ \n      int ifaL = fL->model.be[ipgfL]; \n      int ieL = simu->macromesh.face2elem[4 * ifaL + 0]; \n      int locfaL = simu->macromesh.face2elem[4 * ifaL + 1]; \n      int ieR = simu->macromesh.face2elem[4 * ifaL + 2]; \n      field *fL = simu->fd + ieL; \n      field *fR = NULL; \n      int offsetR = -1; \n       \n      int offsetL = fsize * ieL; \n      if (ieR >= 0) { \n        fR = simu->fd + ieR; \n        offsetR = fsize * ieR; \n      } \n \n      for(int ifaR = 0; ifaR < simu->macromesh.nbfaces; ifaR++){ \n        int ieL = simu->macromesh.face2elem[4 * ifaR + 0]; \n        int locfaL = simu->macromesh.face2elem[4 * ifaR + 1]; \n        int ieR = simu->macromesh.face2elem[4 * ifaR + 2]; \n        field *fL = simu->fd + ieL; \n        field *fR = NULL; \n        int offsetR = -1; \n         \n        int offsetL = fsize * ieL; \n        if (ieR >= 0) { \n          fR = simu->fd + ieR; \n          offsetR = fsize * ieR; \n        } \n \n        for(int ifaL = 0; ifaL < simu->macromesh.nbfaces; ifaL++){ \n          int ifaR = fL->model.be[ifaL]; \n          int ieL = simu->macromesh.face2elem[4 * ifaL + 0]; \n          int locfaL = simu->macromesh.face2elem[4 * ifaL + 1]; \n          int ieR = simu->macromesh.face2elem[4 * ifaL + 2]; \n          field *fL = simu->fd + ieL; \n          field *fR = NULL; \n          int offsetR = -1; \n           \n          int offsetL = fsize * ieL; \n          if (ieR >= 0) { \n            fR = simu->fd + ieR; \n            offsetR = fsize * ieR; \n          } \n \n          for(int ifaR = 0; ifaR < simu->macromesh.nbfaces; ifaR++){ \n            int ifaL = fL->model.be[ifaR]; \n            int ieL = simu->macromesh.face2elem[4 * ifaL + 0]; \n            int locfaL = simu->macromesh.face2elem[4 * ifaL + 1]; \n            int ieR = simu->macromesh.face2elem[4 * ifaL + 2]; \n            field *fL = simu->fd + ieL; \n            field *fR = NULL; \n            int offsetR = -1;"}
{"label": " \ndouble processSmithWatermanCPU(char *refFile, char *qryFile, uint32_t numThreads, uint32_t numBuffers) \n{ \n\ttest_t\t\ttestData; \n\tdouble\t\tts, ts1; \n\tuint32_t \t**matrix; \n\tchar \t \t*query = NULL, *candidate = NULL, *reference = NULL; \n\tuint32_t \tsizeRef, error, tID; \n\tuint32_t \taverageQuerySize, averageCandidatesPerQuery; \n \n\tloadTestData(qryFile, &testData, &averageQuerySize, &averageCandidatesPerQuery); \n\tloadReference(refFile, &reference, &sizeRef);\t \n \n\tmatrix = (uint32_t **) malloc(numThreads * sizeof(uint32_t *)); \n\tfor(tID = 0; tID < numThreads; tID++){ \n\t\tmatrix[tID] = (uint32_t *) malloc((averageQuerySize * 2) * (averageQuerySize * 4) * sizeof(uint32_t)); \n\t\tif (matrix[tID] == NULL) {fprintf(stderr, \"Error allocating SW matrix \\n\"); exit(EXIT_FAILURE);} \n\t} \n \n\tts = sampleTime(); \n \n\t{ \n\t\tuint32_t threadID = omp_get_thread_num(); \n\t\tuint32_t idQuery, idCandidate, sizeQuery, sizeCandidate, positionCandidate; \n\t\tchar \t *query = NULL, *candidate = NULL; \n \n\t\tfor (idCandidate = 0; idCandidate < testData.numCandidates; idCandidate++){ \n \n\t\t\tidQuery \t\t\t= testData.candidates[idCandidate].query; \n\t\t\tquery\t\t\t\t= testData.raw_queries + testData.pos_raw_queries[idQuery]; \n\t\t\tcandidate\t\t\t= reference + testData.candidates[idCandidate].position; \n\t\t\tsizeQuery \t\t\t= testData.qinfo[idQuery].size; \n\t\t\tsizeCandidate \t\t= testData.candidates[idCandidate].size; \n\t\t\tpositionCandidate \t= testData.candidates[idCandidate].position; \n \n\t\t\tcomputeSW(query, candidate, idCandidate, sizeQuery, sizeCandidate, sizeRef, positionCandidate, matrix[threadID], testData.results); \n\t\t} \n\t} \n \n\tts1 = sampleTime(); \n \n\terror = saveResults(qryFile, &testData, numBuffers); \n\tif(error!= 0) {fprintf(stderr, \"Error %d, saving results \\n\", error); exit(EXIT_FAILURE);} \n \n\tfreeTestData(&testData, numBuffers); \n\treturn(ts1-ts); \n} ", "pred": " \ndouble processSmithWatermanCPU(char *refFile, char *qryFile, uint32_t numThreads, uint32_t numBuffers) \n{ \n\ttest_t\t\ttestData; \n\tdouble\t\tts, ts1; \n\tuint32_t \t**matrix; \n\tchar \t \t*query = NULL, *candidate = NULL, *reference = NULL; \n\tuint32_t \tsizeRef, error, tID; \n\tuint32_t \taverageQuerySize, averageCandidatesPerQuery; \n \n\tloadTestData(qryFile, &testData, &averageQuerySize, &averageCandidatesPerQuery); \n\tloadReference(refFile, &reference, &sizeRef);\t \n \n\tmatrix = (uint32_t **) malloc(numThreads * sizeof(uint32_t *)); \n\tfor(tID = 0; tID < numThreads; tID++){ \n\t\tmatrix[tID] = (uint32_t *) malloc((averageQuerySize * 2) * (averageQuerySize * 4) * sizeof(uint32_t)); \n\t\tif (matrix[tID] == NULL) {fprintf(stderr, \"Error allocating SW matrix \\n\"); exit(EXIT_FAILURE);} \n\t} \n \n\tts = sampleTime(); \n \n\t{ \n\t\tuint32_t threadID = 0; \n\t\tfor(tID = 0; tID < numThreads; tID++){ \n\t\t\tquery = (char *) malloc(sizeRef * sizeof(char)); \n\t\t\tcandidate = (char *) malloc(sizeRef * sizeof(char)); \n\t\t\treference = (char *) malloc(sizeRef * sizeof(char)); \n\t\t\tfor(threadID = 0; threadID < numThreads; threadID++){ \n\t\t\t\tmatrix[threadID][threadID] = threadID; \n\t\t\t\tmatrix[threadID][threadID] = threadID; \n\t\t\t} \n\t\t} \n \n\t\tfor(tID = 0; tID < numThreads; tID++){ \n\t\t\tquery = (char *) malloc(sizeRef * sizeof(char)); \n\t\t\tcandidate = (char *) malloc(sizeRef * sizeof(char)); \n\t\t\treference = (char *) malloc(sizeRef * sizeof(char)); \n\t\t\tfor(threadID = 0; threadID < numThreads; threadID++){ \n\t\t\t\tmatrix[threadID][threadID] = threadID; \n\t\t\t\tmatrix[threadID][threadID] = threadID; \n\t\t\t} \n\t\t} \n \n\t\tfor(tID = 0; tID < numThreads; tID++){ \n\t\t\tquery = (char *) malloc(sizeRef * sizeof(char)); \n\t\t\tcandidate = (char *) malloc(sizeRef * sizeof(char)); \n\t\t\t"}
{"label": " \nstatic MagickBooleanType YShearImage(Image *image,const double degrees, \n  const size_t width,const size_t height,const ssize_t x_offset, \n  const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define YShearImageTag  \"YShear/Image\" \n \n  typedef enum \n  { \n    UP, \n    DOWN \n  } ShearDirection; \n \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PixelInfo \n    background; \n \n  ssize_t \n    x; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickCoreSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  status=MagickTrue; \n  progress=0; \n  background=image->background_color; \n  image_view=AcquireAuthenticCacheView(image,exception); \n  for (x=0; x < (ssize_t) width; x++) \n  { \n    ssize_t \n      step; \n \n    double \n      area, \n      displacement; \n \n    PixelInfo \n      pixel, \n      source, \n      destination; \n \n    register Quantum \n      *magick_restrict p, \n      *magick_restrict q; \n \n    register ssize_t \n      i; \n \n    ShearDirection \n      direction; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewAuthenticPixels(image_view,x_offset+x,0,1,image->rows, \n      exception); \n    if (p == (Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    p+=y_offset*GetPixelChannels(image); \n    displacement=degrees*(double) (x-width/2.0); \n    if (displacement == 0.0) \n      continue; \n    if (displacement > 0.0) \n      direction=DOWN; \n    else \n      { \n        displacement*=(-1.0); \n        direction=UP; \n      } \n    step=(ssize_t) floor((double) displacement); \n    area=(double) (displacement-step); \n    step++; \n    pixel=background; \n    GetPixelInfo(image,&source); \n    GetPixelInfo(image,&destination); \n    switch (direction) \n    { \n      case UP: \n      { \n         \n \n        if (step > y_offset) \n          break; \n        q=p-step*GetPixelChannels(image); \n        for (i=0; i < (ssize_t) height; i++) \n        { \n          if ((y_offset+i) < step) \n            { \n              p+=GetPixelChannels(image); \n              GetPixelInfoPixel(image,p,&pixel); \n              q+=GetPixelChannels(image); \n              continue; \n            } \n          GetPixelInfoPixel(image,p,&source); \n          CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n            &source,(double) GetPixelAlpha(image,p),area, \n            &destination); \n          SetPixelViaPixelInfo(image,&destination,q); \n          GetPixelInfoPixel(image,p,&pixel); \n          p+=GetPixelChannels(image); \n          q+=GetPixelChannels(image); \n        } \n        CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n          &background,(double) background.alpha,area,&destination); \n        SetPixelViaPixelInfo(image,&destination,q); \n        q+=GetPixelChannels(image); \n        for (i=0; i < (step-1); i++) \n        { \n          SetPixelViaPixelInfo(image,&background,q); \n          q+=GetPixelChannels(image); \n        } \n        break; \n      } \n      case DOWN: \n      { \n         \n \n        p+=height*GetPixelChannels(image); \n        q=p+step*GetPixelChannels(image); \n        for (i=0; i < (ssize_t) height; i++) \n        { \n          p-=GetPixelChannels(image); \n          q-=GetPixelChannels(image); \n          if ((size_t) (y_offset+height+step-i) > image->rows) \n            continue; \n          GetPixelInfoPixel(image,p,&source); \n          CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n            &source,(double) GetPixelAlpha(image,p),area, \n            &destination); \n          SetPixelViaPixelInfo(image,&destination,q); \n          GetPixelInfoPixel(image,p,&pixel); \n        } \n        CompositePixelInfoAreaBlend(&pixel,(double) pixel.alpha, \n          &background,(double) background.alpha,area,&destination); \n        q-=GetPixelChannels(image); \n        SetPixelViaPixelInfo(image,&destination,q); \n        for (i=0; i < (step-1); i++) \n        { \n          q-=GetPixelChannels(image); \n          SetPixelViaPixelInfo(image,&background,q); \n        } \n        break; \n      } \n    } \n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        proceed=SetImageProgress(image,YShearImageTag,progress++,image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  } \n  image_view=DestroyCacheView(image_view); \n  return(status); \n} ", "pred": " \nstatic MagickBooleanType YShearImage(Image *image,const double degrees, \n  const size_t width,const size_t height,const ssize_t x_offset, \n  const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define YShearImageTag  \"YShear/Image\" \n \n  typedef enum \n  { \n    UP, \n    DOWN \n  } ShearDirection; \n \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PixelInfo \n    background; \n \n  ssize_t \n    x; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickCoreSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  status=MagickTrue; \n  progress=0; \n  background=image->background_color; \n  image_view=AcquireAuthenticCacheView(image,exception); \n  for (x=0; x < (ssize_t) width; x++) \n  { \n    ssize_t \n      y; \n \n    PixelInfo \n      pixel; \n \n    double\n      angle; \n \n    if (status == MagickFalse)\n      continue; \n \n    angle=DegreesToRadians(degrees); \n    if (angle > 360.0)\n      angle-=360.0; \n \n    y=0; \n    if (y_offset!= 0) \n      { \n        y=y_offset+(ssize_t) (image->rows-1-y_offset); \n        if (y < 0)\n          y=0; \n        if (y >= (ssize_t) image->rows)\n          y=image->rows-1; \n      } \n \n    if (x_offset!= 0) \n      { \n        x=x_offset+(ssize_t) (image->columns-1-x_offset); \n        if (x < 0)\n          x=0; \n        if (x >= (ssize_t) image->columns)\n          x=image->columns-1; \n      } \n \n    if (y < (ssize_t) image->rows)\n      { \n        if (image->matte!= MagickFalse)\n          { \n            if (image->colorspace == CMYKColorspace)\n              { \n                pixel.red=ScaleCharToQuantum((unsigned char)\n                  QuantumRange*GetPixelRed(image,p)); \n                pixel.green=ScaleCharToQuantum((unsigned char)\n                  QuantumRange*GetPixelGreen(image,p)); \n                pixel.blue=ScaleCharToQuantum((unsigned char)\n                  QuantumRange*GetPixelBlue(image,p)); \n                pixel.black=ScaleCharToQuantum((unsigned char)\n                  QuantumRange*GetPixelBlack(image,p)); \n              }\n            else\n              { \n                pixel.red=ScaleQuantumToShort(GetPixelRed(image,p)); \n                pixel.green=ScaleQuantumToShort(GetPixelGreen(image,p)); \n                pixel.blue=ScaleQuantumToShort(GetPixelBlue(image,p)); \n                pixel.black=ScaleQuantumToShort(GetPixelBlack(image,p)); \n              } \n            (void) WriteBlob(image,sizeof(pixel),&pixel); \n          } \n        else\n          { \n            if (image->colorspace == CMYKColorspace)\n              { \n                pixel.red=ScaleCharToQuantum((unsigned char)\n                  QuantumRange*GetPixelRed(image,p)); \n                pixel.green=ScaleCharToQuantum((unsigned char)\n                  QuantumRange*GetPixelGreen(image,p)); \n                pixel.blue=ScaleCharToQuantum((unsigned char)\n                  QuantumRange*GetPixelBlue(image,p)); \n                pixel.black=ScaleCharToQuantum((unsigned char)\n                  QuantumRange*GetPixelBlack(image,p)); \n              }\n            else\n              { \n                pixel.red=ScaleQuantumToShort(GetPixelRed(image,p)); \n                pixel.green=ScaleQuantumToShort(GetPixelGreen(image,p)); \n                pixel.blue=ScaleQuantumToShort(GetPixelBlue(image,p)); \n                pixel.black=ScaleQuantumToShort(GetPixelBlack(image,p)); \n              } \n            (void) WriteBlob(image,sizeof(pixel),&pixel); \n          } \n      } \n \n    if (image->matte!= MagickFalse)\n      { \n        if (image->colorspace == CMYKColorspace)\n          { \n            if (image->alpha_trait!= UndefinedPixelTrait)\n              { \n                if (image->alpha_trait == BlendPixelTrait)\n                  { \n                    p=GetAuthenticPixelQueue(image); \n                    if (p == (PixelPacket *) NULL)\n                      break; \n                    for (x=0; x < (ssize_t) image->columns; x++)\n                    { \n          "}
{"label": " \nstatic MagickBooleanType CompositeOverImage(Image *image, \n  const Image *composite_image,const MagickBooleanType clip_to_self, \n  const ssize_t x_offset,const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define CompositeImageTag  \"Composite/Image\" \n \n  CacheView \n    *composite_view, \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n   \n \n  status=MagickTrue; \n  progress=0; \n  composite_view=AcquireVirtualCacheView(composite_image,exception); \n  image_view=AcquireAuthenticCacheView(image,exception); \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    const Quantum \n      *pixels; \n \n    register const Quantum \n      *restrict p; \n \n    register Quantum \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    size_t \n      channels; \n \n    if (status == MagickFalse) \n      continue; \n    if (clip_to_self!= MagickFalse) \n      { \n        if (y < y_offset) \n          continue; \n        if ((y-y_offset) >= (ssize_t) composite_image->rows) \n          continue; \n      } \n     \n \n    pixels=(Quantum *) NULL; \n    p=(Quantum *) NULL; \n    if ((y >= y_offset) && ((y-y_offset) < (ssize_t) composite_image->rows)) \n      { \n        p=GetCacheViewVirtualPixels(composite_view,0,y-y_offset, \n          composite_image->columns,1,exception); \n        if (p == (const Quantum *) NULL) \n          { \n            status=MagickFalse; \n            continue; \n          } \n        pixels=p; \n        if (x_offset < 0) \n          p-=x_offset*GetPixelChannels(composite_image); \n      } \n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception); \n    if (q == (Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      MagickRealType \n        alpha, \n        Da, \n        Dc, \n        gamma, \n        Sa, \n        Sc; \n \n      register ssize_t \n        i; \n \n      if (clip_to_self!= MagickFalse) \n        { \n          if (x < x_offset) \n            { \n              q+=GetPixelChannels(image); \n              continue; \n            } \n          if ((x-x_offset) >= (ssize_t) composite_image->columns) \n            break; \n        } \n      if ((pixels == (Quantum *) NULL) || (x < x_offset) || \n          ((x-x_offset) >= (ssize_t) composite_image->columns)) \n        { \n          Quantum \n            source[MaxPixelChannels]; \n \n           \n \n          if (GetPixelMask(image,q)!= 0) \n            { \n              q+=GetPixelChannels(image); \n              continue; \n            } \n          (void) GetOneVirtualPixel(composite_image,x-x_offset,y-y_offset, \n            source,exception); \n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n          { \n            PixelChannel \n              channel; \n \n            PixelTrait \n              composite_traits, \n              traits; \n \n            channel=GetPixelChannelChannel(image,i); \n            traits=GetPixelChannelTraits(image,channel); \n            composite_traits=GetPixelChannelTraits(composite_image,channel); \n            if ((traits == UndefinedPixelTrait) || \n                (composite_traits == UndefinedPixelTrait)) \n              continue; \n            q[i]=source[channel]; \n          } \n          q+=GetPixelChannels(image); \n          continue; \n        } \n       \n \n      if (GetPixelMask(composite_image,p)!= 0) \n        { \n          p+=GetPixelChannels(composite_image); \n          channels=GetPixelChannels(composite_image); \n          if (p >= (pixels+channels*composite_image->columns)) \n            p=pixels; \n          q+=GetPixelChannels(image); \n          continue; \n        } \n      Sa=QuantumScale*GetPixelAlpha(composite_image,p); \n      Da=QuantumScale*GetPixelAlpha(image,q); \n      alpha=Sa*(-Da)+Sa+Da; \n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n      { \n        PixelChannel \n          channel; \n \n        PixelTrait \n          composite_traits, \n          traits; \n \n        channel=GetPixelChannelChannel(image,i); \n        traits=GetPixelChannelTraits(image,channel); \n        composite_traits=GetPixelChannelTraits(composite_image,channel); \n        if ((traits == UndefinedPixelTrait) || \n            (composite_traits == UndefinedPixelTrait)) \n          continue; \n        if ((traits & CopyPixelTrait)!= 0) \n          { \n            if (channel!=", "pred": " \nstatic MagickBooleanType CompositeOverImage(Image *image, \n  const Image *composite_image,const MagickBooleanType clip_to_self, \n  const ssize_t x_offset,const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define CompositeImageTag  \"Composite/Image\" \n \n  CacheView \n    *composite_view, \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n   \n \n  status=MagickTrue; \n  progress=0; \n  composite_view=AcquireVirtualCacheView(composite_image,exception); \n  image_view=AcquireAuthenticCacheView(image,exception); \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    const Quantum \n      *pixels; \n \n    register const Quantum \n      *restrict p; \n \n    register Quantum \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    size_t \n      channels; \n \n    if (status == MagickFalse)\n      continue; \n \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n \n    if (p == (const Quantum *) NULL)\n      { \n        status=MagickFalse; \n        continue; \n      }\n \n    q=GetCacheViewAuthenticPixels(composite_view,0,y,composite_image->columns,1,\n      exception); \n \n    if (q == (Quantum *) NULL)\n      { \n        status=MagickFalse; \n        continue; \n      }\n \n    for (x=0; x < (ssize_t) composite_image->columns; x++) \n    { \n      register ssize_t \n        i; \n \n      for (i=0; i < (ssize_t) GetPixelChannels(composite_image); i++) \n      { \n        PixelChannel channel = GetPixelChannelChannel(composite_image,i); \n \n        if (channel == AlphaPixelChannel)\n          continue; \n \n        if (channel == IndexPixelChannel)\n          { \n            PixelTrait traits = GetPixelChannelTraits(composite_image,i); \n            if ((traits & UpdatePixelTrait) == 0)\n              continue; \n \n            q[i]=CompositePixelTrait(p[i],q[i],clip_to_self,x_offset,y_offset); \n            continue; \n          } \n \n        if (channel == IndexAlphaPixelChannel)\n          { \n            PixelTrait traits = GetPixelChannelTraits(composite_image,i); \n            if ((traits & UpdatePixelTrait) == 0)\n              continue; \n \n            q[i]=CompositePixelTrait(p[i],q[i],clip_to_self,x_offset,y_offset); \n            continue; \n          } \n \n        if (channel == PixelAlphaChannel)\n          { \n            PixelTrait traits = GetPixelChannelTraits(composite_image,i); \n            if ((traits & UpdatePixelTrait) == 0)\n              continue; \n \n            q[i]=CompositePixelTrait(p[i],q[i],clip_to_self,x_offset,y_offset); \n            continue; \n          } \n \n        if (channel == PixelTrait)\n          { \n            PixelTrait traits = GetPixelChannelTraits(composite_image,i); \n            if ((traits & UpdatePixelTrait) == 0)\n              continue; \n \n            q[i]=CompositePixelTrait(p[i],q[i],clip_to_self,x_offset,y_offset); \n            continue; \n          } \n \n        if (channel == PixelTrait | AlphaPixelTrait)\n          { \n            PixelTrait traits = GetPixelChannelTraits(composite_image,i); \n            if ((traits & UpdatePixelTrait) == 0)\n              continue; \n \n            q[i]=CompositePixelTrait(p[i],q[i],clip_to_self,x_offset,y_offset); \n            continue; \n          } \n \n        if (channel == PixelTrait | IndexPixelTrait)\n          { \n            PixelTrait traits = GetPixelChannelTraits(composite_image,i); \n            if ((traits & UpdatePixelTrait) == 0)\n              continue; \n \n            q[i]=CompositePixelTrait(p[i],q[i],clip_to_self,x_offset,y_offset); \n            continue; \n          } \n \n        if (channel == PixelTrait | IndexAlphaPixelTrait)\n          { \n            PixelTrait traits = GetPixelChannelTraits(composite_image,i); \n            if ((traits & UpdatePixelTrait) == 0)\n              continue; \n \n            q[i]=CompositePixelTrait(p[i],q[i],clip_to_self,x_offset,y_offset); \n            continue; \n          } \n \n        if (channel == PixelTrait | PixelAlphaChannel)\n          { \n            PixelTrait traits = GetPixelChannelTraits(composite_image,i); \n            if ((traits & UpdatePixelTrait) == 0)\n              continue; \n \n            q[i]=CompositePixelTrait(p[i],q[i],clip_to_self,x_offset,y_offset); \n            continue; \n          } \n \n        if (channel == PixelTrait | PixelTrait)\n          { \n            PixelTrait traits = GetPixelChannelTraits(composite_image,i); \n            if ((traits & UpdatePixelTrait) == 0)\n              continue; \n \n            q[i]=CompositePixelTrait("}
{"label": " \nstatic void _combine_masks_exclusion(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                     const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      const float pos = both_positive(dest[index], mask); \n      const float neg = (1.0f - pos); \n      const float b1 = dest[index]; \n      dest[index] = pos * MAX((1.0f - b1) * mask, b1 * (1.0f - mask)) + neg * MAX(b1, mask); \n    } \n  } \n  else \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      const float pos = both_positive(dest[index], mask); \n      const float neg = (1.0f - pos); \n      const float b1 = dest[index]; \n      dest[index] = pos * MAX((1.0f - b1) * mask, b1 * (1.0f - mask)) + neg * MAX(b1, mask); \n    } \n  } \n} ", "pred": " \nstatic void _combine_masks_exclusion(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                     const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      const float pos = both_positive(dest[index], mask); \n      const float neg = (1.0f - pos); \n      const float b1 = dest[index]; \n      dest[index] = pos * MAX((1.0f - b1) * mask, b1 * (1.0f - mask)) + neg * MAX(b1, mask); \n    } \n  } \n  else \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      const float pos = both_positive(dest[index], mask); \n      const float neg = (1.0f - pos); \n      const float b1 = dest[index]; \n      dest[index] = pos * MAX((1.0f - b1) * mask, b1 * (1.0f - mask)) + neg * MAX(b1, mask); \n    } \n  } \n  \n"}
{"label": " \nvoid mul_add_mul(spinor * const R,spinor * const S,spinor * const U,const _Complex double c1,const _Complex double c2, const int N) \n{ \n\tspinorfield_linalg_wrr(R, S, U); \n  { \n \n  spinor *r, *s, *u; \n   \n  for (int ix = 0; ix < N; ++ix) \n  { \n    r=(spinor *) R + ix; \n    s=(spinor *) S + ix; \n    u=(spinor *) U + ix; \n     \n    r->s0.c0 = c1 * s->s0.c0 + c2 * u->s0.c0; \n    r->s0.c1 = c1 * s->s0.c1 + c2 * u->s0.c1; \n    r->s0.c2 = c1 * s->s0.c2 + c2 * u->s0.c2; \n \n    r->s1.c0 = c1 * s->s1.c0 + c2 * u->s1.c0; \n    r->s1.c1 = c1 * s->s1.c1 + c2 * u->s1.c1; \n    r->s1.c2 = c1 * s->s1.c2 + c2 * u->s1.c2; \n     \n    r->s2.c0 = c1 * s->s2.c0 + c2 * u->s2.c0; \n    r->s2.c1 = c1 * s->s2.c1 + c2 * u->s2.c1; \n    r->s2.c2 = c1 * s->s2.c2 + c2 * u->s2.c2; \n     \n    r->s3.c0 = c1 * s->s3.c0 + c2 * u->s3.c0; \n    r->s3.c1 = c1 * s->s3.c1 + c2 * u->s3.c1; \n    r->s3.c2 = c1 * s->s3.c2 + c2 * u->s3.c2; \n  } \n  }  \n \n} ", "pred": " \nvoid mul_add_mul(spinor * const R,spinor * const S,spinor * const U,const _Complex double c1,const _Complex double c2, const int N) \n{ \n\tspinorfield_linalg_wrr(R, S, U); \n  { \n \n  spinor *r, *s, *u; \n   \n  for (int ix = 0; ix < N; ++ix) \n  { \n    r=(spinor *) R + ix; \n    s=(spinor *) S + ix; \n    u=(spinor *) U + ix; \n     \n    r->s0.c0 = c1 * s->s0.c0 + c2 * u->s0.c0; \n    r->s0.c1 = c1 * s->s0.c1 + c2 * u->s0.c1; \n    r->s0.c2 = c1 * s->s0.c2 + c2 * u->s0.c2; \n \n    r->s1.c0 = c1 * s->s1.c0 + c2 * u->s1.c0; \n    r->s1.c1 = c1 * s->s1.c1 + c2 * u->s1.c1; \n    r->s1.c2 = c1 * s->s1.c2 + c2 * u->s1.c2; \n \n    r->s2.c0 = c1 * s->s2.c0 + c2 * u->s2.c0; \n    r->s2.c1 = c1 * s->s2.c1 + c2 * u->s2.c1; \n    r->s2.c2 = c1 * s->s2.c2 + c2 * u->s2.c2; \n \n    r->s3.c0 = c1 * s->s3.c0 + c2 * u->s3.c0; \n    r->s3.c1 = c1 * s->s3.c1 + c2 * u->s3.c1; \n    r->s3.c2 = c1 * s->s3.c2 + c2 * u->s3.c2; \n \n    r->s4.c0 = c1 * s->s4"}
{"label": " \nstatic void _combine_masks_union(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                 const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      dest[index] = MAX(dest[index], mask); \n    } \n  } \n  else \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      dest[index] = MAX(dest[index], mask); \n    } \n  } \n} ", "pred": " \nstatic void _combine_masks_union(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                 const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      dest[index] = MAX(dest[index], mask); \n    } \n  } \n  else \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      dest[index] = MAX(dest[index], mask); \n    } \n  } \n} "}
{"label": " \nMagickExport MagickBooleanType CompositeImage(Image *image, \n  const Image *composite,const CompositeOperator compose, \n  const MagickBooleanType clip_to_self,const ssize_t x_offset, \n  const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define CompositeImageTag  \"Composite/Image\" \n \n  CacheView \n    *composite_view, \n    *image_view; \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *composite_image, \n    *destination_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickRealType \n    amount, \n    destination_dissolve, \n    midpoint, \n    percent_luma, \n    percent_chroma, \n    source_dissolve, \n    threshold; \n \n  MagickStatusType \n    flags; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(composite!= (Image *) NULL); \n  assert(composite->signature == MagickSignature); \n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse) \n    return(MagickFalse); \n  composite_image=CloneImage(composite,0,0,MagickTrue,exception); \n  if (composite_image == (const Image *) NULL) \n    return(MagickFalse); \n  if (IsGrayColorspace(image->colorspace)!= MagickFalse) \n    (void) SetImageColorspace(image,RGBColorspace,exception); \n  (void) SetImageColorspace(composite_image,image->colorspace,exception); \n  if ((compose == OverCompositeOp) || (compose == SrcOverCompositeOp)) \n    { \n      status=CompositeOverImage(image,composite_image,clip_to_self,x_offset, \n        y_offset,exception); \n      composite_image=DestroyImage(composite_image); \n      return(status); \n    } \n  destination_image=(Image *) NULL; \n  amount=0.5; \n  destination_dissolve=1.0; \n  percent_luma=100.0; \n  percent_chroma=100.0; \n  source_dissolve=1.0; \n  threshold=0.05f; \n  switch (compose) \n  { \n    case CopyCompositeOp: \n    { \n      if ((x_offset < 0) || (y_offset < 0)) \n        break; \n      if ((x_offset+(ssize_t) composite_image->columns) >= (ssize_t) image->columns) \n        break; \n      if ((y_offset+(ssize_t) composite_image->rows) >= (ssize_t) image->rows) \n        break; \n      status=MagickTrue; \n      composite_view=AcquireVirtualCacheView(composite_image,exception); \n      image_view=AcquireAuthenticCacheView(image,exception); \n      for (y=0; y < (ssize_t) composite_image->rows; y++) \n      { \n        MagickBooleanType \n          sync; \n \n        register const Quantum \n          *p; \n \n        register Quantum \n          *q; \n \n        register ssize_t \n          x; \n \n        if (status == MagickFalse) \n          continue; \n        p=GetCacheViewVirtualPixels(composite_view,0,y,composite_image->columns, \n          1,exception); \n        q=GetCacheViewAuthenticPixels(image_view,x_offset,y+y_offset, \n          composite_image->columns,1,exception); \n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL)) \n          { \n            status=MagickFalse; \n            continue; \n          } \n        for (x=0; x < (ssize_t) composite_image->columns; x++) \n        { \n          register ssize_t \n            i; \n \n          if (GetPixelMask(composite_image,p)!= 0) \n            { \n              p+=GetPixelChannels(composite_image); \n              q+=GetPixelChannels(image); \n              continue; \n            } \n          for (i=0; i < (ssize_t) GetPixelChannels(composite_image); i++) \n          { \n            PixelChannel \n              channel; \n \n            PixelTrait \n              composite_traits, \n              traits; \n \n            channel=GetPixelChannelChannel(composite_image,i); \n            composite_traits=GetPixelChannelTraits(composite_image,channel); \n            traits=GetPixelChannelTraits(image,channel); \n            if ((traits == UndefinedPixelTrait) || \n                (composite_traits == UndefinedPixelTrait)) \n              continue; \n            SetPixelChannel(image,channel,p[i],q); \n          } \n          p+=GetPixelChannels(composite_image); \n          q+=GetPixelChannels(image); \n        } \n        sync=SyncCacheViewAuthenticPixels(image_view,exception); \n        if (sync == MagickFalse) \n          status=MagickFalse; \n        if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n          { \n            MagickBooleanType \n              proceed; \n \n            proceed=SetImageProgress(image,CompositeImageTag, \n              (MagickOffsetType) y,image->rows); \n            if (proceed == MagickFalse) \n              status=MagickFalse; \n          } \n      } \n      composite_view=DestroyCacheView(composite_view); \n      image_view=DestroyCacheView(image_view); \n      composite_image=DestroyImage(composite_image); \n      return(status); \n    } \n    case CopyAlphaCompositeOp: \n    case ChangeMaskCompositeOp: \n    case IntensityCompositeOp: \n    { \n       \n \n      if (image->alpha_trait!= BlendPixelTrait) \n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception); \n", "pred": " \nMagickExport MagickBooleanType CompositeImage(Image *image, \n  const Image *composite,const CompositeOperator compose, \n  const MagickBooleanType clip_to_self,const ssize_t x_offset, \n  const ssize_t y_offset,ExceptionInfo *exception) \n{ \n#define CompositeImageTag  \"Composite/Image\" \n \n  CacheView \n    *composite_view, \n    *image_view; \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *composite_image, \n    *destination_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickRealType \n    amount, \n    destination_dissolve, \n    midpoint, \n    percent_luma, \n    percent_chroma, \n    source_dissolve, \n    threshold; \n \n  MagickStatusType \n    flags; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n \n  if (clip_to_self!= MagickFalse)\n    {\n      if (CompositeImageClipToSelf(image,composite,compose,x_offset,y_offset,\n          &image->exception) == MagickFalse)\n        return(MagickFalse);\n    }\n \n  /*\n    Composite image.\n  */\n  composite_image=CloneImage(composite,0,0,MagickTrue,exception); \n  if (composite_image == (Image *) NULL)\n    return(MagickFalse);\n \n  destination_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (destination_image == (Image *) NULL)\n    {\n      destination_image=DestroyImage(composite_image);\n      return(MagickFalse);\n    }\n \n  /*\n    Determine the geometry of the composite image.\n  */\n  flags=ParseGeometry(composite_image->filename,&geometry_info);\n  if ((flags & SigmaValue) == 0)\n    {\n      geometry_info.rho=1.0;\n      geometry_info.sigma=1.0;\n    }\n \n  /*\n    Compute the amount of chroma.\n  */\n  destination_dissolve=MagickMax(MagickMax(geometry_info.rho,\n                                             geometry_info.sigma),\n                                  MagickEpsilon);\n \n  /*\n    Compute the amount of luma.\n  */\n  midpoint=MagickMax(MagickMax(geometry_info.rho,\n                                 geometry_info.sigma),\n                       MagickEpsilon);\n \n  /*\n    Compute the percent of luma.\n  */\n  percent_luma=MagickMax(MagickMax(geometry_info.rho,\n                                    geometry_info.sigma),\n                           MagickEpsilon);\n \n  /*\n    Compute the percent of chroma.\n  */\n  percent_chroma=MagickMax(MagickMax(geometry_info.rho,\n                                      geometry_info.sigma),\n                             MagickEpsilon);\n \n  /*\n    Compute the amount of source.\n  */\n  source_dissolve=MagickMax(MagickMax(geometry_info.rho,\n                                       geometry_info.sigma),\n                              MagickEpsilon);\n \n  /*\n    Compute the amount of threshold.\n  */\n  threshold=MagickMax(MagickMax(geometry_info.rho,\n                                 geometry_info.sigma),\n                        MagickEpsilon);\n \n  /*\n    Compute the amount of source.\n  */\n  source_dissolve=MagickMax(MagickMax(geometry_info.rho,\n                                       geometry_info.sigma),\n                              MagickEpsilon);\n \n  /*\n    Compute the amount of destination.\n  */\n  destination_dissolve=MagickMax(MagickMax(geometry_info.rho,\n                                            geometry_info.sigma),\n                                   MagickEpsilon);\n \n  /*\n    Compute the amount of midpoint.\n  */\n  midpoint=MagickMax(MagickMax(geometry_info.rho,\n                                geometry_info.sigma),\n                       MagickEpsilon);\n \n  /*\n    Compute the amount of percent_luma.\n  */\n  percent_luma=MagickMax(MagickMax(geometry_info.rho,\n                                    geometry_info.sigma),\n                           MagickEpsilon);\n \n  /*\n    Compute the amount of percent_chroma.\n  */\n  percent_chroma=MagickMax(MagickMax(geometry_info.rho,\n                                      geometry_info.sigma),\n                             MagickEpsilon);\n \n  /*\n    Compute the amount of percent_source.\n  */\n  percent_source=MagickMax(MagickMax(geometry_info.rho,\n                                      geometry_info.sigma),\n                             MagickEpsilon);\n \n  /*\n    Compute the amount of percent_threshold.\n  */\n  percent_threshold=MagickMax(MagickMax(geometry_info.rho,\n                                         geometry_info.sigma),\n                                MagickEpsilon);\n"}
{"label": " \nint main (int argc, char* argv[])  \n{ \n     \n \n    char* corUnit; \n    char* unit; \n    int  zoSize, dataSize, tNumRed, velSize; \n    float *zo, *zoSq, *semb, *velModel, *data; \n    int *count; \n    int is, ir, ip, it, forDataInd, vxInd; \n    float shotPos, curOffset, halfOffset, fabsOffset, offsetSq, curPos, l0, forA; \n    float t0, vel, a, t, forLim, limitLeft, limitRight, bef, aft, sample, curSemb; \n    float sampleSq, sqSample; \n    int vtInd, vInd, tInd, dataInd, indZO, vwhalf, ts, totalCount, ind, ic, iw, offset; \n     \n \n \n \n    sf_init (argc,argv); \n \n \n \n    dataFile = sf_input (\"in\"); \n     \n \n    outFile  = sf_output(\"out\"); \n     \n \n \n    if ( NULL!= sf_getstring(\"aux\") ) { \n\t \n  \n\tauxFile  = sf_output (\"aux\"); \n    } else { \n\tsf_error (\"Need output: partial zero-offset sections\"); \n    } \n \n    if ( NULL!= sf_getstring (\"vel\") ) { \n\t \n  \n\tvelFile  = sf_input (\"vel\"); \n    } else { sf_error (\"Need input: velocity model\"); } \n \n     \n \n \n    if (!sf_histint   (dataFile, \"n1\", &tNum_)   ) sf_error (\"Need n1= in input\"); \n    if (!sf_histfloat (dataFile, \"d1\", &tStep_)  ) sf_error (\"Need d1= in input\"); \n    if (!sf_histfloat (dataFile, \"o1\", &tStart_) ) sf_error (\"Need o1= in input\"); \n \n    if (!sf_histint   (dataFile, \"n2\", &recNum_)   ) sf_error (\"Need n2= in input\"); \n    if (!sf_histfloat (dataFile, \"d2\", &recStep_)  ) sf_error (\"Need d2= in input\"); \n    if (!sf_histfloat (dataFile, \"o2\", &recStart_) ) sf_error (\"Need o2= in input\"); \n     \n    if (!sf_histint   (dataFile, \"n3\", &shotNum_)   ) sf_error (\"Need n3= in input\"); \n    if (!sf_histfloat (dataFile, \"d3\", &shotStep_)  ) sf_error (\"Need d3= in input\"); \n    if (!sf_histfloat (dataFile, \"o3\", &shotStart_) ) sf_error (\"Need o3= in input\"); \n \n     \n \n \n    if (!sf_histint   (velFile, \"n1\", &vtNum_)   ) sf_error (\"Need n1= in input\"); \n    if (!sf_histfloat (velFile, \"d1\", &vtStep_)  ) sf_error (\"Need d1= in input\"); \n    if (!sf_histfloat (velFile, \"o1\", &vtStart_) ) sf_error (\"Need o1= in input\"); \n \n    if (!sf_histint   (velFile, \"n2\", &vxNum_)   ) sf_error (\"Need n2= in input\"); \n    if (!sf_histfloat (velFile, \"d2\", &vxStep_)  ) sf_error (\"Need d2= in input\"); \n    if (!sf_histfloat (velFile, \"o2\", &vxStart_) ) sf_error (\"Need o2= in input\"); \n \n \n \n \n \n \n \n \n\t \n     \n \n     \n \n \n \n \n \n     \n \n    corUnit = (char*) \"m\"; unit = sf_histstring (dataFile, \"unit2\"); if (!unit) sf_error (\"unit2 in data file is not defined\"); \n    if ( strcmp (corUnit, unit) ) { recStep_ *= 1000; recStart_ *= 1000; } \n     \n \n    corUnit = (char*) \"m\"; unit = sf_histstring (dataFile, \"unit3\"); if (!unit) sf_error (\"unit3 in data file is not defined\"); \n    if ( strcmp (corUnit, unit) ) { shotStep_ *= 1000; shotStart_ *= 1000; } \n \n     \n \n     \n \n \n \n \n    if (!sf_getfloat (\"po\",    &pStart_) ) pStart_ = shotStart_; \n     \n \n    if (!sf_getint (\"pn\", &pNum_) ) pNum_ = recNum_; \n     \n \n    if (!pNum_) {sf_warning (\"vn value is changed to 1\"); pNum_ = recNum_;} \n    if (!sf_getfloat (\"pd\",    &pStep_) ) pStep_ = recStep_; \n     \n \n    if (!pStep_) {sf_warning (\"pd value is changed to 50\"); pStep_ = recStep_;} \n \n    if (!sf_getint (\"wh\",   &wh_) )   wh_ = 11; \n     \n \n    if (!wh_) {sf_warning (\"vertical window size is changed to 1\"); wh_ = 1;} \n \n    sf_putint    (outFile, \"n1\", tNum_); \n    sf_putint    (outFile, \"n2\", pNum_); \n    sf_putint    (outFile, \"n3\", 1); \n    sf_putfloat  (outFile, \"d1\", tStep_);  \n    sf_putfloat  (outFile, \"d2\", pStep_); \n    sf_putint    (outFile, \"d3\", 10); \n    sf_putfloat  (outFile, \"o1\", tStart_);  \n    sf_putfloat  (outFile, \"o2\", pStart_); \n    sf_putfloat  (outFile, \"o3\", 0); \n    sf_putstring (outFile, \"label1\", \"time\"); \n    sf_putstring (outFile, \"label2\", \"inline\");  \n    sf_putstring (outFile, \"unit2\",  \"m\");  \n \n    sf_putint    (auxFile, \"n1\", tNum_); \n    sf_putint    (auxFile, \"n2\", pNum_); \n    sf_putint    (auxFile, \"n3\", 1); \n    sf_putfloat  (auxFile, \"d1\", tStep_);  \n    sf_putfloat  (auxFile, \"d2\", pStep_); \n    sf_putint    (auxFile, \"d3\", 10); \n    sf_putfloat  (auxFile, \"o1\", tStart_);  \n    sf_putfloat  (auxFile, \"o2\", pStart_); \n    sf_putfloat  (auxFile, \"o3\", 0); \n    sf_putstring (auxFile, \"label1\", \"time\"); \n    sf_putstring (auxFile, \"label2\", \"inline\"); \n    sf_putstring (auxFile, \"unit2\",  \"m\");  \n \n    zoSize = pNum_ * tNum_; \n    dataSize = shotNum_ * recNum_ * tNum_; \n    tNumRed = tNum_ - 2; \n    velSize = vtNum_ * vxNum_;\t \n \n    zo    = sf_floatalloc (zoSize); \n    zoSq  = sf_floatalloc (zoSize); \n    semb  = sf_floatalloc (zoSize); \n    count = sf_intalloc (zoSize); \n \n    velModel = sf_floatalloc (velSize); \n    sf_floatread (velModel, velSize, velFile);", "pred": " \nint main (int argc, char* argv[])  \n{ \n     \n \n    char* corUnit; \n    char* unit; \n    int  zoSize, dataSize, tNumRed, velSize; \n    float *zo, *zoSq, *semb, *velModel, *data; \n    int *count; \n    int is, ir, ip, it, forDataInd, vxInd; \n    float shotPos, curOffset, halfOffset, fabsOffset, offsetSq, curPos, l0, forA; \n    float t0, vel, a, t, forLim, limitLeft, limitRight, bef, aft, sample, curSemb; \n    float sampleSq, sqSample; \n    int vtInd, vInd, tInd, dataInd, indZO, vwhalf, ts, totalCount, ind, ic, iw, offset; \n     \n \n \n \n    sf_init (argc,argv); \n \n \n \n    dataFile = sf_input (\"in\"); \n     \n \n    outFile  = sf_output(\"out\"); \n     \n \n \n    if ( NULL!= sf_getstring(\"aux\") ) { \n        auxFile = sf_output(\"aux\"); \n    } else { \n        auxFile = NULL; \n    } \n \n \n \n    if ( NULL!= sf_getstring(\"corUnit\") ) { \n        corUnit = sf_output(\"corUnit\"); \n    } else { \n        corUnit = NULL; \n    } \n \n \n \n    if ( NULL!= sf_getstring(\"unit\") ) { \n        unit = sf_output(\"unit\"); \n    } else { \n        unit = NULL; \n    } \n \n \n \n    if ( NULL!= sf_getstring(\"zoSize\") ) { \n        zoSize = sf_input (\"zoSize\"); \n    } else { \n        zoSize = 0; \n    } \n \n \n    if ( NULL!= sf_getstring(\"dataSize\") ) { \n        dataSize = sf_input (\"dataSize\"); \n    } else { \n        dataSize = 0; \n    } \n \n \n    if ( NULL!= sf_getstring(\"tNumRed\") ) { \n        tNumRed = sf_input (\"tNumRed\"); \n    } else { \n        tNumRed = 0; \n    } \n \n \n    if ( NULL!= sf_getstring(\"velSize\") ) { \n        velSize = sf_input (\"velSize\"); \n    } else { \n        velSize = 0; \n    } \n \n \n    if ( NULL!= sf_getstring(\"velModel\") ) { \n        velModel = sf_output(\"velModel\"); \n    } else { \n        velModel = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"data\") ) { \n        data = sf_input(\"data\"); \n    } else { \n        data = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"count\") ) { \n        count = sf_input(\"count\"); \n    } else { \n        count = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"is\") ) { \n        is = sf_input(\"is\"); \n    } else { \n        is = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"ir\") ) { \n        ir = sf_input(\"ir\"); \n    } else { \n        ir = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"ip\") ) { \n        ip = sf_input(\"ip\"); \n    } else { \n        ip = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"it\") ) { \n        it = sf_input(\"it\"); \n    } else { \n        it = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"forDataInd\") ) { \n        forDataInd = sf_input(\"forDataInd\"); \n    } else { \n        forDataInd = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"vxInd\") ) { \n        vxInd = sf_input(\"vxInd\"); \n    } else { \n        vxInd = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"forLim\") ) { \n        forLim = sf_input(\"forLim\"); \n    } else { \n        forLim = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"limitLeft\") ) { \n        limitLeft = sf_input(\"limitLeft\"); \n    } else { \n        limitLeft = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"limitRight\") ) { \n        limitRight = sf_input(\"limitRight\"); \n    } else { \n        limitRight = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"bef\") ) { \n        bef = sf_input(\"bef\"); \n    } else { \n        bef = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"aft\") ) { \n        aft = sf_input(\"aft\"); \n    } else { \n        aft = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"sample\") ) { \n        sample = sf_input(\"sample\"); \n    } else { \n        sample = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"curSemb\") ) { \n        curSemb = sf_input(\"curSemb\"); \n    } else { \n        curSemb = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"t0\") ) { \n        t0 = sf_input(\"t0\"); \n    } else { \n        t0 = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"vel\") ) { \n        vel = sf_input(\"vel\"); \n    } else { \n        vel = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"dataInd\") ) { \n        dataInd = sf_input(\"dataInd\"); \n    } else { \n        dataInd = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"indZO\") ) { \n        indZO = sf_input(\"indZO\"); \n    } else { \n        indZO = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"vzInd\") ) { \n        vzInd = sf_input(\"vzInd\"); \n    } else { \n        vzInd = NULL; \n    } \n \n \n    if ( NULL!= sf_getstring(\"tInd\") ) { \n    "}
{"label": " \nvoid findLinkFlows(double dt) \n{ \n    int i; \n \n     \n \n \n{ \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n        if ( isTrueConduit(i) &&!Link[i].bypassed ) \n            dwflow_findConduitFlow(i, Steps, Omega, dt); \n    } \n} \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n\t    if ( isTrueConduit(i) ) updateNodeFlows(i); \n    } \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n        if (!isTrueConduit(i) ) \n        {\t \n            if (!Link[i].bypassed ) findNonConduitFlow(i, dt); \n            updateNodeFlows(i); \n        } \n    } \n} ", "pred": " \nvoid findLinkFlows(double dt) \n{ \n    int i; \n \n     \n \n \n{ \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n        if ( isTrueConduit(i) &&!Link[i].bypassed ) \n            dwflow_findConduitFlow(i, Steps, Omega, dt); \n    } \n} \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n\t    if ( isTrueConduit(i) ) updateNodeFlows(i); \n    } \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n        if (!isTrueConduit(i) ) \n        {\t \n            if (!Link[i].bypassed ) findNonConduitFlow(i, dt); \n            updateNodeFlows(i); \n        } \n    } \n \n}"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 32; \n  tile_size[3] = 64; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=Nt-1;t1++) { \n    lbp=ceild(t1+1,2); \n    ubp=min(floord(4*Nt+Nz-9,8),floord(4*t1+Nz-2,8)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(ceild(t1-6,8),ceild(8*t2-Nz-19,32));t3<=min(floord(4*Nt+Ny-9,32),floord(4*t1+Ny-1,32));t3++) { \n        for (t4=max(max(ceild(t1-14,16),ceild(8*t2-Nz-51,64)),ceild(32*t3-Ny-51,64));t4<=min(min(floord(4*Nt+Nx-9,64),floord(4*t1+Nx-1,64)),floord(32*t3+Nx+19,64));t4++) { \n          for (t5=max(max(max(max(0,ceild(8*t2-Nz+5,4)),ceild(32*t3-Ny+5,4)),ceild(64*t4-Nx+5,4)),t1);t5<=min(min(min(Nt-1,t1+1),8*t3+6),16*t4+14);t5++) { \n            for (t6=max(max(8*t2,4*t5+4),-8*t1+8*t2+8*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(32*t3,4*t5+4);t7<=min(32*t3+31,4*t5+Ny-5);t7++) { \n                lbv=max(64*t4,4*t5+4); \n                ubv=min(64*t4+63,4*t5+Nx-5); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((2.0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) - A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (roc2[ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] * (((((coef0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (coef1 * (((((A[ t5 % 2][ (-4*t5+t6) - 1][ (-4*t5+t7)][ (-4*t5+t8)] + A[ t5 % 2][ (-4*t5+t6) + 1][ (-4*t5+t7)][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) - 1][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) + 1][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0; j<Ny; j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n  for(t=0; t<Nt; t++){ \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      }"}
{"label": " \nint findNodeDepths(double dt) \n{ \n    int i; \n    int converged;       \n \n    double yOld;         \n \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++ ) link_setOutfallDepth(i); \n \n     \n \n     \n \n    converged = TRUE; \n \n{ \n \n    for ( i = 0; i < Nobjects[NODE]; i++ ) \n    { \n        if ( Node[i].type == OUTFALL ) continue; \n        yOld = Node[i].newDepth; \n        setNodeDepth(i, dt); \n        Xnode[i].converged = TRUE; \n        if ( fabs(yOld - Node[i].newDepth) > HeadTol ) \n        { \n            converged = FALSE; \n            Xnode[i].converged = FALSE; \n        } \n    } \n}                                                                               \n \n    return converged; \n} ", "pred": " \nint findNodeDepths(double dt) \n{ \n    int i; \n    int converged;       \n \n    double yOld;         \n \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++ ) link_setOutfallDepth(i); \n \n     \n \n     \n \n    converged = TRUE; \n \n{ \n \n    for ( i = 0; i < Nobjects[NODE]; i++ ) \n    { \n        if ( Node[i].type == OUTFALL ) continue; \n        yOld = Node[i].newDepth; \n        setNodeDepth(i, dt); \n        Xnode[i].converged = TRUE; \n        if ( fabs(yOld - Node[i].newDepth) > HeadTol ) \n        { \n            converged = FALSE; \n            Xnode[i].converged = FALSE; \n        } \n    } \n \n} \n \nreturn( converged ); \n} \n \nint findNodeDepths(double dt) \n{ \n    int i; \n    int converged;       \n \n    double yOld;         \n \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i"}
{"label": " \nint wrtieee(float *array, unsigned int n, int header, struct seq_file *out) { \n \n\tunsigned int i, j, l, nbuf, loop; \n\tunsigned char buff[BSIZ]; \n \n\tnbuf = 0; \n\tif (header) { \n\t\tif (n >= 4294967295U / 4) \t \n \n\t\t\tfatal_error(\"wrtieee: grid too large for 4-byte header\",\"\"); \n\t\tl = n * 4; \n \n\t\tbuff[nbuf  ] = (l >> 24) & 255; \n\t\tbuff[nbuf+1] = (l >> 16) & 255; \n\t\tbuff[nbuf+2] = (l >>  8) & 255; \n\t\tbuff[nbuf+3] = l         & 255; \n\t\tnbuf += 4; \n\t} \n\ti = 0; \n\twhile (i < n) { \n\t\tloop = (BSIZ - nbuf)/4; \n\t\tloop  = (n-i) > loop? loop : (n-i); \n\t\tfor (j = 0 ; j < loop; j++) { \n\t\t    flt2ieee(array[i+j], buff + nbuf + j*4); \n\t\t} \n\t\ti += loop; \n\t\tnbuf += 4*loop; \n \n\t\tif (nbuf >= BSIZ) {\t\t \n \n\t\t    if (ieee_little_endian) swap_buffer(buff, BSIZ); \n\t\t    fwrite_file(buff, 1, BSIZ, out); \n\t\t    nbuf = 0; \n\t\t} \n\t} \n\tif (header) { \n\t\tl = n * 4; \n\t\tbuff[nbuf  ] = (l >> 24) & 255; \n\t\tbuff[nbuf+1] = (l >> 16) & 255; \n\t\tbuff[nbuf+2] = (l >>  8) & 255; \n\t\tbuff[nbuf+3] = l         & 255; \n\t\tnbuf += 4; \n\t} \n\tif (nbuf) { \n\t    if (ieee_little_endian) swap_buffer(buff, nbuf); \n\t    fwrite_file(buff, 1, nbuf, out); \n\t} \n\treturn 0; \n} ", "pred": " \nint wrtieee(float *array, unsigned int n, int header, struct seq_file *out) { \n \n\tunsigned int i, j, l, nbuf, loop; \n\tunsigned char buff[BSIZ]; \n \n\tnbuf = 0; \n\tif (header) { \n\t\tif (n >= 4294967295U / 4) \t \n \n\t\t\tfatal_error(\"wrtieee: grid too large for 4-byte header\",\"\"); \n\t\tl = n * 4; \n \n\t\tbuff[nbuf  ] = (l >> 24) & 255; \n\t\tbuff[nbuf+1] = (l >> 16) & 255; \n\t\tbuff[nbuf+2] = (l >>  8) & 255; \n\t\tbuff[nbuf+3] = l         & 255; \n\t\tnbuf += 4; \n\t} \n\ti = 0; \n\twhile (i < n) { \n\t\tloop = (BSIZ - nbuf)/4; \n\t\tloop  = (n-i) > loop? loop : (n-i); \n\t\tfor (j = 0 ; j < loop; j++) { \n\t\t    flt2ieee(array[i+j], buff + nbuf + j*4); \n\t\t} \n\t\ti += loop; \n\t\tnbuf += 4*loop; \n\t} \n\treturn 0; \n} \n \n\n/*\n * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle,"}
{"label": " \nstatic void _combine_masks_difference(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                      const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      dest[index] *= (1.0f - mask * both_positive(dest[index],mask)); \n    } \n  } \n  else \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      dest[index] *= (1.0f - mask * both_positive(dest[index],mask)); \n    } \n  } \n} ", "pred": " \nstatic void _combine_masks_difference(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                      const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      dest[index] *= (1.0f - mask * both_positive(dest[index],mask)); \n    } \n  } \n  else \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      dest[index] *= (1.0f - mask * both_positive(dest[index],mask)); \n    } \n  } \n} "}
{"label": " \nstatic void _combine_masks_intersect(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                     const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      dest[index] = MIN(MAX(dest[index], 0.0f), MAX(mask, 0.0f)); \n    } \n  } \n  else \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      dest[index] = MIN(MAX(dest[index], 0.0f), MAX(mask, 0.0f)); \n    } \n  } \n} ", "pred": " \nstatic void _combine_masks_intersect(float *const restrict dest, float *const restrict newmask, const size_t npixels, \n                                     const float opacity, const int inverted) \n{ \n  if(inverted) \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * (1.0f - newmask[index]); \n      dest[index] = MIN(MAX(dest[index], 0.0f), MAX(mask, 0.0f)); \n    } \n  } \n  else \n  { \n    for(int index = 0; index < npixels; index++) \n    { \n      const float mask = opacity * newmask[index]; \n      dest[index] = MIN(MAX(dest[index], 0.0f), MAX(mask, 0.0f)); \n    } \n  } \n} "}
{"label": " \nint <ompts:testcode:functionname>omp_atomic</ompts:testcode:functionname> (FILE * logFile) \n{ \n    <ompts:orphan:vars> \n\tint sum; \n        int diff; \n        double dsum = 0; \n        double dt = 0.5;\t \n \n        double ddiff; \n        int product; \n        int x; \n        int *logics; \n        int bit_and = 1; \n        int bit_or = 0; \n        int exclusiv_bit_or = 0; \n    </ompts:orphan:vars> \n \n#define DOUBLE_DIGITS 20\t \n \n#define MAX_FACTOR 10 \n#define KNOWN_PRODUCT 3628800\t \n \n    int j; \n    int known_sum; \n    int known_diff; \n    int known_product; \n    int result = 0; \n    int logic_and = 1; \n    int logic_or = 0; \n    double dknown_sum; \n    double rounding_error = 1.E-9; \n    double dpt, div; \n    int logicsArray[LOOPCOUNT]; \n    logics = logicsArray; \n     \n    sum = 0; \n    diff = 0; \n    product = 1; \n \n    { \n\t<ompts:orphan> \n\t    int i; \n\t    for (i = 1; i <= LOOPCOUNT; i++) \n\t    { \n\t\t<ompts:check>#pragma omp atomic</ompts:check> \n\t\tsum += i; \n\t    } \n\t</ompts:orphan> \n    } \n    known_sum = (LOOPCOUNT * (LOOPCOUNT + 1)) / 2; \n    if (known_sum!= sum) \n    { \n        fprintf (logFile,  \n                 \"Error in sum with integers: Result was %d instead of %d.\\n\",  \n                 sum, known_sum); \n        result++; \n    } \n     \n    { \n        <ompts:orphan>    \n            int i; \n            for (i = 0; i < LOOPCOUNT; i++) \n            { \n                 <ompts:check>#pragma omp atomic</ompts:check> \n                 diff -= i; \n            } \n        </ompts:orphan> \n    } \n    known_diff = ((LOOPCOUNT - 1) * LOOPCOUNT) / 2 * -1; \n    if (diff!= known_diff) \n    { \n        fprintf (logFile, \n              \"Error in difference with integers: Result was %d instead of 0.\\n\", \n               diff); \n        result++; \n    } \n \n     \n \n    dsum = 0; \n    dpt = 1; \n \n    for (j = 0; j < DOUBLE_DIGITS; ++j) \n      { \n        dpt *= dt; \n      } \n    dknown_sum = (1 - dpt) / (1 -dt); \n    { \n        <ompts:orphan> \n            int i; \n            for (i = 0; i < DOUBLE_DIGITS; ++i) \n            { \n                <ompts:check>#pragma omp atomic</ompts:check> \n                dsum += pow (dt, i); \n            } \n        </ompts:orphan> \n    } \n \n    if (dsum!= dknown_sum && (fabs (dsum - dknown_sum) > rounding_error)) \n    { \n        fprintf (logFile, \n                 \"Error in sum with doubles: Result was %f instead of: %f (Difference: %E)\\n\", \n                 dsum, dknown_sum, dsum - dknown_sum); \n        result++; \n    } \n \n    dpt = 1; \n \n    for (j = 0; j < DOUBLE_DIGITS; ++j) \n    { \n        dpt *= dt; \n    } \n    ddiff = (1 - dpt) / (1 - dt); \n   { \n         <ompts:orphan> \n            int i; \n            for (i = 0; i < DOUBLE_DIGITS; ++i) \n            { \n                <ompts:check>#pragma omp atomic</ompts:check> \n                ddiff -= pow (dt, i); \n            } \n         </ompts:orphan> \n    }  \n    if (fabs (ddiff) > rounding_error) \n    { \n        fprintf (logFile, \n                 \"Error in difference with doubles: Result was %E instead of 0.0\\n\", \n                 ddiff); \n        result++; \n    } \n \n    { \n         <ompts:orphan> \n            int i; \n            for (i = 1; i <= MAX_FACTOR; i++) \n            { \n                <ompts:check>#pragma omp atomic</ompts:check> \n                product *= i; \n            } \n         </ompts:orphan> \n    } \n     \n    known_product = KNOWN_PRODUCT; \n    if (known_product!= product) \n    { \n        fprintf (logFile, \n                 \"Error in product with integers: Result was %d instead of %d\\n\", \n                 product, known_product); \n        result++; \n    } \n \n    product = KNOWN_PRODUCT; \n    { \n        <ompts:orphan> \n           int i; \n            for (i = 1; i <= MAX_FACTOR; ++i) \n            { \n                <ompts:check>#pragma omp atomic</ompts:check> \n                product /= i; \n    ", "pred": " \nint <ompts:testcode:functionname>omp_atomic</ompts:testcode:functionname> (FILE * logFile) \n{ \n    <ompts:orphan:vars> \n\tint sum; \n        int diff; \n        double dsum = 0; \n        double dt = 0.5;\t \n \n        double ddiff; \n        int product; \n        int x; \n        int *logics; \n        int bit_and = 1; \n        int bit_or = 0; \n        int exclusiv_bit_or = 0; \n    </ompts:orphan:vars> \n \n#define DOUBLE_DIGITS 20\t \n \n#define MAX_FACTOR 10 \n#define KNOWN_PRODUCT 3628800\t \n \n    int j; \n    int known_sum; \n    int known_diff; \n    int known_product; \n    int result = 0; \n    int logic_and = 1; \n    int logic_or = 0; \n    int logic_xor = 0; \n    int logic_not = 0; \n    int logic_and_not = 0; \n    int logic_or_not = 0; \n    int logic_xor_not = 0; \n    int logic_and_and = 0; \n    int logic_or_or = 0; \n    int logic_xor_xor = 0; \n    int logic_and_xor = 0; \n    int logic_or_xor = 0; \n    int logic_and_and = 0; \n    int logic_or_and = 0; \n    int logic_xor_and = 0; \n    int logic_and_or = 0; \n    int logic_or_or = 0; \n    int logic_xor_or = 0; \n    int logic_and_xor = 0; \n    int logic_or_xor = 0; \n    int logic_xor_and = 0; \n    int logic_and_and = 0; \n    int logic_or_and = 0; \n    int logic_xor_and = 0; \n    int logic_and_or = 0; \n    int logic_or_or = 0; \n    int logic_xor_or = 0; \n    int logic_and_xor = 0; \n    int logic_or_xor = 0; \n    int logic_xor_and = 0; \n    int logic_and_and = 0; \n    int logic_or_and = 0; \n    int logic_xor_and = 0; \n    int logic_and_or = 0; \n    int logic_or_or = 0; \n    int logic_xor_or = 0; \n    int logic_and_xor = 0; \n    int logic_or_xor = 0; \n    int logic_xor_and = 0; \n    int logic_and_and = 0; \n    int logic_or_and = 0; \n    int logic_xor_and = 0; \n    int logic_and_or = 0; \n    int logic_or_or = 0; \n    int logic_xor_or = 0; \n    int logic_and_xor = 0; \n    int logic_or_xor = 0; \n    int logic_xor_and = 0; \n    int logic_and_and = 0; \n    int logic_or_and = 0; \n    int logic_xor_and = 0; \n    int logic_and_or = 0; \n    int logic_or_or = 0; \n    int logic_xor_or = 0; \n    int logic_and_xor = 0; \n    int logic_or_xor = 0; \n    int logic_xor_and = 0; \n    int logic_and_and = 0; \n    int logic_or_and = 0; \n    int logic_xor_and = 0; \n    int logic_and_or = 0; \n    int logic_or_or = 0; \n    int logic_xor_or = 0; \n    int logic_and_xor = 0; \n    int logic_or_xor = 0; \n    int logic_xor_and = 0; \n    int logic_and_and = 0; \n    int logic_or_and = 0; \n    int logic_xor_and = 0; \n    int logic_and_or = 0; \n    int logic_or_or = 0; \n    int logic_xor_or = 0; \n    int logic_and_xor = 0; \n    int logic_or_xor = 0; \n    int logic_xor_and = 0; \n    int logic_and_and = 0; \n    int logic_or_and = 0; \n    int logic_xor_and = 0; \n    int logic_and_or = 0; \n    int logic_or_or = 0; \n    int logic_xor_or = 0; \n    int logic_and_xor = 0; \n    int logic_or_xor = 0; \n    int logic_xor_and = 0; \n    int logic_and_and = 0; \n    int logic_or_and = 0; \n    int logic_xor_and = 0; \n    int logic_and_or = 0; \n    int logic_or_or = 0; \n    int logic_xor_or = 0; \n    int logic_and_xor = 0; \n    int logic_or_xor = 0; \n    int logic_xor_and = 0; \n    int logic_and_and = 0; \n    int logic_or_and = 0; \n    int logic_xor_and = 0; \n    int logic_and_or = 0; \n    int logic_or_or = 0; \n    int logic_xor_or = 0; \n    int logic_and_xor = 0; \n    int logic_or_xor = 0; \n    int logic_xor_and = 0; \n    int logic_and_and = 0; \n    int logic_or_and = 0; \n    int logic_xor_and = 0; \n    int logic_and_or = 0; \n    int logic_or_or = 0; \n    int logic_xor_or = 0; \n    int logic_and_xor = 0; \n    int logic_or_xor = 0; \n    int logic_xor_and = 0; \n    int logic_and_and = 0; \n    int logic_or_and = 0; \n    int logic_xor_and = 0; \n    int logic_and_or = 0; \n    int logic_or_or = 0; \n    int logic_xor_or = 0; \n    int logic_and_xor = 0; \n    int logic_or_xor = 0; \n    int logic_xor_and = 0; \n    int logic_and_and = 0; \n    int logic_or_and = 0; \n    int logic_xor_and = 0; \n    int logic_and_or = 0; \n    int logic_or_or = 0; \n    int logic_xor_or = 0; \n    int logic_and_xor = 0; \n    int logic_or_xor = 0; \n    int logic_xor_and = 0; \n    int logic_and_and = 0; \n    int logic_or_and = 0; \n    int logic_xor_and = 0; \n    int logic_and_or = 0; \n    int logic_or_or = 0; \n    int logic_xor_or = 0; \n    int logic_and_xor = 0; \n    int logic_or_xor"}
{"label": " \nint \nread_triplet_and_proj( int *__restrict *__restrict triplet,  \n\t\t       double *__restrict *__restrict proj,  \n\t\t       const int *__restrict *__restrict momentum,  \n\t\t       const size_t nnmax,  \n\t\t       const size_t count, \n\t\t       const size_t nmom ) \n{ \n  size_t mu, i, flag = 0 ; \n \n   \n \n  char *str = malloc( (1+strlen(HAVE_PREFIX))*sizeof(char)), tmp[64] ; \n  sprintf( str, \"%s\", HAVE_PREFIX ) ; \n  sprintf( tmp, \"/Local/Moments/TRIPNP.PROJ%d.\", \n\t   #ifndef PROJ_GRACEY \n\t   -1  \n\t   #else \n\t   PROJ_GRACEY  \n\t   #endif  \n\t   ) ; \n  append_char( &str, tmp ) ; \n   \n  for( mu = 0 ; mu < ND-1 ; mu++ ) { \n    sprintf( tmp, \"%zux\", Latt.dims[mu] ) ; \n    append_char( &str, tmp ) ; \n  } \n  sprintf( tmp, \"%zu_%zu.config\", Latt.dims[mu], nnmax ) ; \n  append_char( &str, tmp ) ; \n \n  FILE *config = fopen( str, \"rb\" ) ; \n   \n \n  if( config == NULL ) { \n    flag = 1 ; \n  } else { \n    fclose( config ) ;  \n  } \n \n   \n \n  if( flag == 1 ) { \n    init_delta( ) ; \n     \n \n    FILE *config2 = fopen( str, \"wb\" ) ; \n \n    fprintf( stdout, \"[CUTS] Storing Triplet and Proj list @@@...\\n%s\\n\", \n\t     str ) ; \n \n     \n \n    int **triple = ( int **)malloc( count * sizeof( int* ) ) ; \n    for( i = 0 ; i < count ; i++ ) { \n      triple[i] = (int*)malloc( 3 *  sizeof (int ) ) ; \n    } \n    fprintf( stdout, \"[CUTS] Precomputing triplet \\n\" ) ; \n     \n \n    get_triplet( triple, momentum, nnmax, nmom ) ; \n     \n \n    for( i = 0 ; i < count ; i++ ) { \n      fwrite( triple[i], sizeof(int), 3, config2 ) ; \n    } \n    fprintf( stdout, \"[CUTS] Computing projector... \\n\" ) ; \n     \n \n    compute_projector( triple, proj, momentum, count ) ; \n     \n \n    for( i = 0 ; i < count ; i++ ) { \n      fwrite( proj[i], sizeof( double ), ND * ND * ND, config2 ) ; \n    } \n     \n \n    fclose( config2 ) ; \n    free_delta( ) ; \n     \n \n    for( i = 0 ; i < count ; i++ ) { \n      free( triple[i] ) ; \n    } \n    free( triple ) ;  \n  } \n \n   \n \n  config = fopen( str, \"rb\" ) ; \n  for( i = 0 ; i < count ; i++ ) { \n    if( fread( triplet[i], sizeof( int ), 3, config )!= 3 ) {  \n      return GLU_FAILURE ;  \n    } \n  } \n   \n \n  for( i = 0 ; i < count ; i++ ) { \n    if( fread( proj[i], sizeof( double ), ND * ND * ND, config ) \n\t!= ND * ND * ND ) { \n      return GLU_FAILURE ;  \n    } \n  } \n   \n \n  fclose( config ) ; \n  free( str ) ; \n   \n \n  init_delta( ) ; \n   \n \n  if( get_triplet( triplet, momentum, nnmax, nmom ) == GLU_FAILURE ) { \n    free_delta( ) ; \n    return GLU_FAILURE ; \n  } \n   \n \n  compute_projector( triplet, proj, momentum, count ) ; \n   \n \n  free_delta( ) ; \n  return GLU_SUCCESS ; \n} ", "pred": " \nint \nread_triplet_and_proj( int *__restrict *__restrict triplet,  \n\t\t       double *__restrict *__restrict proj,  \n\t\t       const int *__restrict *__restrict momentum,  \n\t\t       const size_t nnmax,  \n\t\t       const size_t count, \n\t\t       const size_t nmom ) \n{ \n  size_t mu, i, flag = 0 ; \n \n   \n \n  char *str = malloc( (1+strlen(HAVE_PREFIX))*sizeof(char)), tmp[64] ; \n  sprintf( str, \"%s\", HAVE_PREFIX ) ; \n  sprintf( tmp, \"/Local/Moments/TRIPNP.PROJ%d.\", \n\t   #ifndef PROJ_GRACEY \n\t   -1  \n\t   #else \n\t   PROJ_GRACEY  \n\t   #endif  \n\t   ) ; \n  append_char( &str, tmp ) ; \n   \n  for( mu = 0 ; mu < ND-1 ; mu++ ) { \n    sprintf( tmp, \"%zux\", Latt.dims[mu] ) ; \n    append_char( &str, tmp ) ; \n  } \n  sprintf( tmp, \"%zu\", Latt.dims[ND-1] ) ; \n  append_char( &str, tmp ) ; \n   \n  for( i = 0 ; i < count ; i++ ) { \n    sprintf( tmp, \"%zu\", momentum[i] ) ; \n    append_char( &str, tmp ) ; \n  } \n  sprintf( tmp, \"%zu\", nnmax ) ; \n  append_char( &str, tmp ) ; \n   \n  for( i = 0 ; i < nmom ; i++ ) { \n    sprintf( tmp, \"%zu\", momentum[i] ) ; \n    append_char( &str, tmp ) ; \n  } \n  sprintf( tmp, \"%zu\", count ) ; \n  append_char( &str, tmp ) ; \n   \n  for( i = 0 ; i < count ; i++ ) { \n    sprintf( tmp, \"%zu\", momentum[i] ) ; \n    append_char( &str, tmp ) ; \n  } \n  sprintf( tmp, \"%zu\", nnmax ) ; \n  append_char( &str, tmp ) ; \n   \n  for( i = 0 ; i < count ; i++ ) { \n    sprintf( tmp, \"%zu\", momentum[i] ) ; \n    append_char( &str, tmp ) ; \n  } \n  sprintf( tmp, \"%zu\", count ) ; \n  append_char( &str, tmp ) ; \n   \n  for( i = 0 ; i < count ; i++ ) { \n    sprintf( tmp, \"%zu\", momentum[i] ) ; \n    append_char( &str, tmp ) ; \n  } \n  sprintf( tmp, \"%zu\", nnmax ) ; \n  append_char( &str, tmp ) ; \n   \n  for( i = 0 ; i < count ; i++ ) { \n    sprintf( tmp, \"%zu\", momentum[i] ) ; \n    append_char( &str, tmp ) ; \n  } \n  sprintf( tmp, \"%zu\", count ) ; \n  append_char( &str, tmp ) ; \n   \n  for( i = 0 ; i < count ; i++ ) { \n    sprintf( tmp, \"%zu\", momentum[i] ) ; \n    append_char( &str, tmp ) ; \n  } \n  sprintf( tmp, \"%zu\", nnmax ) ; \n  append_char( &str, tmp ) ; \n   \n  for( i = 0 ; i < count ; i++ ) { \n    sprintf( tmp, \"%zu\", momentum[i] ) ; \n    append_char( &str, tmp ) ; \n  } \n  sprintf( tmp, \"%zu\", count ) ; \n  append_char( &str, tmp ) ; \n   \n  for( i = 0 ; i < count ; i++ ) { \n    sprintf( tmp, \"%zu\", momentum[i] ) ; \n    append_char( &str, tmp ) ; \n  } \n  sprintf( tmp, \"%zu\", nnmax ) ; \n  append_char( &str, tmp ) ; \n   \n  for( i = 0 ; i < count ; i++ ) { \n    sprintf( tmp, \"%zu\", momentum[i] ) ; \n    append_char( &str, tmp ) ; \n  } \n  sprintf( tmp, \"%zu\", count ) ; \n  append_char( &str, tmp ) ; \n   \n"}
{"label": " \nvoid multiply_matrices(struct mat c, struct mat a, struct mat b) \n{ \n  #ifdef NO_OPENMP \n  long int num_cores = get_num_cpus(); \n  int use_single_core = 1; \n  size_t rows; \n  unsigned int i; \n  pthread_t* threads; \n  struct mult_mat_struct* args; \n  if(num_cores > 1) \n    { \n      if((size_t)num_cores > c.n) \n\t{ \n\t   \n \n\t  num_cores = c.n; \n\t} \n      threads = (pthread_t*)malloc(sizeof(pthread_t) * num_cores); \n      args = (struct mult_mat_struct*)malloc(sizeof(struct mult_mat_struct) * num_cores); \n       \n \n      if(threads!= NULL && args!= NULL) \n\t{ \n\t  use_single_core = 0; \n\t  for(i = 0; i < num_cores; ++i) \n\t    { \n\t      rows = c.n / num_cores; \n\t      args[i].a = a; \n\t      args[i].b = b; \n\t      args[i].c = c; \n\t      args[i].first_row = i * rows; \n\t      args[i].last_row = args[i].first_row + rows; \n\t      if(i == (num_cores - 1)) \n\t\t{ \n\t\t   \n \n\t\t  args[i].last_row = c.n; \n\t\t} \n\t      if(pthread_create(&threads[i], NULL, multiply_matrices_part, &args[i])!= 0) \n\t\t{ \n\t\t  use_single_core = 1; \n\t\t  break; \n\t\t} \n\t    } \n\t   \n \n\t  for(i = 0; i < num_cores; ++i) \n\t    { \n\t      if(pthread_join(threads[i], NULL)!= 0) \n\t\t{ \n\t\t   \n \n\t\t  use_single_core = 1; \n\t\t} \n\t    } \n\t} \n    } \n   \n \n  if(use_single_core == 1) \n    { \n      struct mult_mat_struct s; \n      s.a = a; \n      s.b = b; \n      s.c = c; \n      s.first_row = 0; \n      s.last_row = c.n; \n      multiply_matrices_part(&s); \n    } \n  #else \n  size_t x, y, i, index; \n   \n \n  if(a.n!= c.n || b.n!= c.n) \n    return; \n  for(y = 0; y < c.n; ++y) \n    { \n      for(x = 0; x < c.n; ++x) \n        { \n           \n \n          index = y * c.n + x; \n          c.data[index] = 0; \n          for(i = 0; i < c.n; ++i) \n            { \n              c.data[index] += a.data[y * c.n + i] * b.data[i * c.n + x]; \n\t    } \n        } \n    } \n  #endif \n} ", "pred": " \nvoid multiply_matrices(struct mat c, struct mat a, struct mat b) \n{ \n  #ifdef NO_OPENMP \n  long int num_cores = get_num_cpus(); \n  int use_single_core = 1; \n  size_t rows; \n  unsigned int i; \n  pthread_t* threads; \n  struct mult_mat_struct* args; \n  if(num_cores > 1) \n    { \n      if((size_t)num_cores > c.n) \n\t{ \n\t   \n \n\t  num_cores = c.n; \n\t} \n      threads = (pthread_t*)malloc(sizeof(pthread_t) * num_cores); \n      args = (struct mult_mat_struct*)malloc(sizeof(struct mult_mat_struct) * num_cores); \n       \n \n      if(threads!= NULL && args!= NULL) \n\t{ \n\t  use_single_core = 0; \n\t  for(i = 0; i < num_cores; ++i) \n\t    { \n\t      rows = c.n / num_cores; \n\t      args[i].a = a; \n\t      args[i].b = b; \n\t      args[i].c = c; \n\t      args[i].rows = rows; \n\t      args[i].n = rows; \n\t      args[i].m = rows; \n\t      args[i].k = rows; \n\t      args[i].l = rows; \n\t      args[i].i = i; \n\t      args[i].j = i; \n\t      args[i].p = NULL; \n\t      args[i].q = NULL; \n\t      args[i].r = NULL; \n\t      args[i].s = NULL; \n\t      args[i].t = NULL; \n\t      args[i].u = NULL; \n\t      args[i].v = NULL; \n\t      args[i].w = NULL; \n\t      args[i].x = NULL; \n\t      args[i].y = NULL; \n\t      args[i].z = NULL; \n\t      args[i].w_size = 0; \n\t      args[i].x_size = 0; \n\t      args[i].y_size = 0; \n\t      args[i].z_size = 0; \n\t      args[i].w_stride = 0; \n\t      args[i].x_stride = 0; \n\t      args[i].y_stride = 0; \n\t      args[i].z_stride = 0; \n\t      args[i].w_block = 0; \n\t      args[i].x_block = 0; \n\t      args[i].y_block = 0; \n\t      args[i].z_block = 0; \n\t      args[i].w_block_size = 0; \n\t      args[i].x_block_size = 0; \n\t      args[i].y_block_size = 0; \n\t      args[i].z_block_size = 0; \n\t      args[i].w_block_stride = 0; \n\t      args[i].x_block_stride = 0; \n\t      args[i].y_block_stride = 0; \n\t      args[i].z_block_stride = 0; \n\t      args[i].w_block_size_stride = 0; \n"}
{"label": " \nvoid THNN_(SpatialSubSampling_updateOutput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *output, \n    THTensor *weight, \n    THTensor *bias, \n    int kW, int kH, \n    int dW, int dH) \n{ \n  THArgCheck(!bias || THTensor_(isContiguous)(bias), 5, \"bias must be contiguous\"); \n \n  real *weight_data = THTensor_(data)(weight); \n  real *bias_data = THTensor_(data)(bias); \n  real *output_data; \n  real *input_data; \n \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n \n  long inputWidth; \n  long inputHeight; \n  long outputWidth; \n  long outputHeight; \n \n  int nInputPlane = THTensor_(size)(weight,0); \n \n  long k; \n \n  THNN_(SpatialSubSampling_shapeCheck)(input, NULL, weight, kW, kH); \n \n  if (input->nDimension == 4) { \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  inputWidth = input->size[dimw]; \n  inputHeight = input->size[dimh]; \n  outputWidth = (inputWidth - kW) / dW + 1; \n  outputHeight = (inputHeight - kH) / dH + 1; \n \n  if (input->nDimension == 3) \n    THTensor_(resize3d)(output, nInputPlane, outputHeight, outputWidth); \n  else \n    THTensor_(resize4d)(output, input->size[0], nInputPlane, outputHeight, outputWidth); \n \n  input = THTensor_(newContiguous)(input); \n  input_data = THTensor_(data)(input); \n  output_data = THTensor_(data)(output); \n \n  for(k = 0; k < nInputPlane; k++) \n  { \n    long p; \n    for(p = 0; p < nbatch; p++) \n    { \n      long xx, yy; \n       \n \n      real *ptr_output = output_data + p*nInputPlane*outputWidth*outputHeight + k*outputWidth*outputHeight; \n       \n \n      real the_weight = weight_data[k]; \n       \n \n      real z = bias_data[k]; \n      long i; \n      for(i = 0; i < outputWidth*outputHeight; i++) \n        ptr_output[i] = z; \n \n      for(yy = 0; yy < outputHeight; yy++) \n      { \n        for(xx = 0; xx < outputWidth; xx++) \n        { \n           \n \n          real *ptr_input = input_data + p*nInputPlane*inputWidth*inputHeight + k*inputWidth*inputHeight + yy*dH*inputWidth+xx*dW; \n          real sum = 0; \n          long kx, ky; \n \n          for(ky = 0; ky < kH; ky++) \n          { \n            for(kx = 0; kx < kW; kx++) \n              sum += ptr_input[kx]; \n            ptr_input += inputWidth;  \n \n          } \n           \n \n          *ptr_output++ += the_weight*sum; \n        } \n      } \n    } \n  } \n  THTensor_(free)(input); \n} ", "pred": " \nvoid THNN_(SpatialSubSampling_updateOutput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *output, \n    THTensor *weight, \n    THTensor *bias, \n    int kW, int kH, \n    int dW, int dH) \n{ \n  THArgCheck(!bias || THTensor_(isContiguous)(bias), 5, \"bias must be contiguous\"); \n \n  real *weight_data = THTensor_(data)(weight); \n  real *bias_data = THTensor_(data)(bias); \n  real *output_data; \n  real *input_data; \n \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n \n  long inputWidth; \n  long inputHeight; \n  long outputWidth; \n  long outputHeight; \n \n  int nInputPlane = THTensor_(size)(weight,0); \n \n  long k; \n \n  THNN_(SpatialSubSampling_shapeCheck)(input, NULL, weight, kW, kH); \n \n  if (input->nDimension == 4) { \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (output->nDimension == 4) { \n    nbatch = output->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 3) { \n    nInputPlane = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (output->nDimension == 3) { \n    nInputPlane = output->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 2) { \n    nInputPlane = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (output->nDimension == 2) { \n    nInputPlane = output->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 1) { \n    nInputPlane = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (output->nDimension == 1) { \n    nInputPlane = output->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 3) { \n    nInputPlane = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (output->nDimension == 3) { \n    nInputPlane = output->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 2) { \n    nInputPlane = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (output->nDimension == 2) { \n    nInputPlane = output->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 1) { \n    nInputPlane = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (output->nDimension == 1) { \n    nInputPlane = output->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 3) { \n    nInputPlane = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (output->nDimension == 3) { \n    nInputPlane = output->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 2) { \n    nInputPlane = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (output->nDimension =="}
{"label": " \nstatic void csr_ax(int startAdr,int stopAdr,int PthIdx,CsrArg *arg) { \n  pCsr    A; \n  double *x,*y,dd; \n  int     i,j,ic; \n \n  A = arg->A; \n  x = arg->x; \n  y = arg->y; \n \n   \n \n  for (i=startAdr-1; i<stopAdr; i++) { \n    y[i] = 0.0; \n    for (j=A->row[i]; j<A->row[i+1]; j++) { \n      dd    = A->val[j] * x[A->col[j]]; \n      y[i] += dd; \n    } \n  } \n \n  if ( A->typ & CS_SYM ) { \n     \n \n    for (i=startAdr-1; i<stopAdr; i++) { \n      for (j=A->row[i]+1; j<A->row[i+1]; j++) { \n        ic = A->col[j]; \n\tdd     = A->val[j] * x[i]; \n        y[ic] += dd; \n      } \n    } \n  } \n} ", "pred": " \nstatic void csr_ax(int startAdr,int stopAdr,int PthIdx,CsrArg *arg) { \n  pCsr    A; \n  double *x,*y,dd; \n  int     i,j,ic; \n \n  A = arg->A; \n  x = arg->x; \n  y = arg->y; \n \n   \n \n  for (i=startAdr-1; i<stopAdr; i++) { \n    y[i] = 0.0; \n    for (j=A->row[i]; j<A->row[i+1]; j++) { \n      dd    = A->val[j] * x[A->col[j]]; \n      y[i] += dd; \n    } \n  } \n \n  if ( A->typ & CS_SYM ) { \n     \n \n    for (i=startAdr-1; i<stopAdr; i++) { \n      for (j=A->row[i]+1; j<A->row[i+1]; j++) { \n        ic = A->col[j]; \n\tdd     = A->val[j] * x[ic]; \n\ty[i] += dd; \n      } \n    } \n  } \n \n  for (i=startAdr-"}
{"label": "static int dt_brush_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                 dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  if(!module) return 0; \n  double start = dt_get_wtime(); \n  double start2; \n \n  const int px = roi->x; \n  const int py = roi->y; \n  const int width = roi->width; \n  const int height = roi->height; \n  const float scale = roi->scale; \n \n   \n \n  float *points = NULL, *border = NULL, *payload = NULL; \n \n  int points_count, border_count, payload_count; \n \n  if(!_brush_get_points_border(module->dev, form, module->iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, piece->pipe,&points, &points_count, \n                               &border, &border_count, &payload, &payload_count, 0)) \n  { \n    dt_free_align(points); \n    dt_free_align(border); \n    dt_free_align(payload); \n    return 0; \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] brush points took %0.04f sec\\n\", form->name, dt_get_wtime() - start); \n  start = start2 = dt_get_wtime(); \n \n   \n \n  dt_iop_image_fill(buffer, 0.0f, width, height, 1); \n \n  const guint nb_corner = g_list_length(form->points); \n \n   \n \n  for(int i = nb_corner * 3; i < border_count; i++) \n  { \n    const float xx = border[2 * i]; \n    const float yy = border[2 * i + 1]; \n    border[2 * i] = xx * scale - px; \n    border[2 * i + 1] = yy * scale - py; \n  } \n \n  for(int i = nb_corner * 3; i < points_count; i++) \n  { \n    const float xx = points[2 * i]; \n    const float yy = points[2 * i + 1]; \n    points[2 * i] = xx * scale - px; \n    points[2 * i + 1] = yy * scale - py; \n  } \n \n   \n \n  float xmin = 0.0f, xmax = 0.0f, ymin = 0.0f, ymax = 0.0f; \n  xmin = ymin = FLT_MAX; \n  xmax = ymax = FLT_MIN; \n \n  for(int i = nb_corner * 3; i < border_count; i++) \n  { \n     \n \n    const float xx = border[i * 2]; \n    const float yy = border[i * 2 + 1]; \n    xmin = fminf(xx, xmin); \n    xmax = fmaxf(xx, xmax); \n    ymin = fminf(yy, ymin); \n    ymax = fmaxf(yy, ymax); \n  } \n  for(int i = nb_corner * 3; i < points_count; i++) \n  { \n     \n \n    const float xx = points[i * 2]; \n    const float yy = points[i * 2 + 1]; \n    xmin = fminf(xx, xmin); \n    xmax = fmaxf(xx, xmax); \n    ymin = fminf(yy, ymin); \n    ymax = fmaxf(yy, ymax); \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] brush_fill min max took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n \n \n \n   \n \n  if(xmax < 0 || ymax < 0 || xmin >= width || ymin >= height) \n  { \n    dt_free_align(points); \n    dt_free_align(border); \n    dt_free_align(payload); \n    return 1; \n  } \n \n   \n \n  for(int i = nb_corner * 3; i < border_count; i++) \n  { \n    const int p0[] = { points[i * 2], points[i * 2 + 1] }; \n    const int p1[] = { border[i * 2], border[i * 2 + 1] }; \n \n    if(MAX(p0[0], p1[0]) < 0 || MIN(p0[0], p1[0]) >= width || MAX(p0[1], p1[1]) < 0 \n       || MIN(p0[1], p1[1]) >= height) \n      continue; \n \n    _brush_falloff_roi(buffer, p0, p1, width, height, payload[i * 2], payload[i * 2 + 1]); \n  } \n \n  dt_free_align(points); \n  dt_free_align(border); \n  dt_free_align(payload); \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] brush fill buffer took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start); \n \n  return 1; \n} \n ", "pred": "static int dt_brush_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                 dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  if(!module) return 0; \n  double start = dt_get_wtime(); \n  double start2; \n \n  const int px = roi->x; \n  const int py = roi->y; \n  const int width = roi->width; \n  const int height = roi->height; \n  const float scale = roi->scale; \n \n   \n \n  float *points = NULL, *border = NULL, *payload = NULL; \n \n  int points_count, border_count, payload_count; \n \n  if(!_brush_get_points_border(module->dev, form, module->iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, piece->pipe,&points, &points_count, \n                               &border, &border_count, &payload, &payload_count)) \n  { \n    dt_control_log(_(\"Unable to get points for brush.\")); \n    return 0; \n  } \n \n  if(points_count < 1) \n  { \n    dt_control_log(_(\"No points found for brush.\")); \n    return 0; \n  } \n \n  if(border_count < 1) \n  { \n    dt_control_log(_(\"No border found for brush.\")); \n    return 0; \n  } \n \n  if(payload_count < 1) \n  { \n    dt_control_log(_(\"No payload found for brush.\")); \n    return 0; \n  } \n \n  if(points_count > 1) \n  { \n    dt_control_log(_(\"Multiple points found for brush.\")); \n    return 0; \n  } \n \n  if(border_count > 1) \n  { \n    dt_control_log(_(\"Multiple border found for brush.\")); \n    return 0; \n  } \n \n  if(payload_count > 1) \n  { \n    dt_control_log(_(\"Multiple payload found for brush.\")); \n    return 0; \n  } \n \n  if(points_count == 1) \n  { \n    dt_control_log(_(\"Single point found for brush.\")); \n    return 0; \n  } \n \n  if(border_count == 1) \n  { \n    dt_control_log(_(\"Single border found for brush.\")); \n    return 0; \n  } \n \n  if(payload_count == 1) \n  { \n    dt_control_log(_(\"Single payload found for brush.\")); \n    return 0; \n  } \n \n  if(points_count == 1) \n  { \n    dt_control_log(_(\"Single point found for brush.\")); \n    return 0; \n  } \n \n  if(border_count == 1) \n  { \n    dt_control_log(_(\"Single border found for brush.\")); \n    return 0; \n  } \n \n  if(payload_count == 1) \n  { \n    dt_control_log(_(\"Single payload found for brush.\")); \n    return 0; \n  } \n \n  if(points_count == 1) \n  { \n    dt_control_log(_(\"Single point found for brush.\")); \n    return 0; \n  } \n \n  if(border_count == 1) \n  { \n    dt_control_log(_(\"Single border found for brush.\")); \n    return 0; \n  } \n \n  if(payload_count == 1) \n  { \n    dt_control_log(_(\"Single payload found for brush.\")); \n    return 0; \n  } \n \n  if(points_count == 1) \n  { \n    dt_control_log(_(\"Single point found for brush.\")); \n    return 0; \n  } \n \n  if(border_count == 1) \n  { \n    dt_control_log(_(\"Single border found for brush.\")); \n    return 0; \n  } \n \n  if(payload_count == 1) \n  { \n    dt_control_log(_(\"Single payload found for brush.\")); \n    return 0; \n  } \n \n  if(points_count == 1) \n  { \n    dt_control_log(_(\"Single point found for brush.\")); \n    return 0; \n  } \n \n  if(border_count == 1) \n  { \n    dt_control_log(_(\"Single border found for brush.\")); \n    return 0; \n  } \n \n  if(payload_count == 1) \n  { \n    dt_control_log(_(\"Single payload found for brush.\")); \n    return 0; \n  } \n \n  if(points_count == 1) \n  { \n    dt_control_log(_(\"Single point found for brush.\")); \n    return 0; \n  } \n \n  if(border_count == 1) \n  { \n    dt_control_log(_(\"Single border found for brush.\")); \n    return 0; \n  } \n \n  if(payload_count == 1) \n  { \n    dt_control_log(_(\"Single payload found for brush.\")); \n    return 0; \n  } \n \n  if(points_count == 1) \n  { \n    dt_control_log(_(\"Single point found for brush.\")); \n    return 0; \n  } \n \n  if(border_count == 1) \n  { \n    dt_control_log(_(\"Single border found for brush.\")); \n    return 0; \n  } \n \n  if(payload_count == 1) \n  { \n    dt_control_log(_(\"Single payload found for brush.\")); \n    return 0; \n  } \n \n  if(points_count == 1) \n  { \n    dt_control_log(_(\"Single point found for brush.\")); \n    return 0; \n  } \n \n"}
{"label": " \nvoid mexFunction(int nlhs, mxArray *plhs[], \n                 int nrhs, const mxArray *prhs[]) \n{ \n   \n  \n  int a,b,c,k,M,N, m,n,i,kstart,j,insert,kend; \n  int size1,size2; \n  double *ps,*pM, *pk, *po,*po2; \n  int mRows,nCols; \n  mxArray *infOut[1]; \n  double inf; \n   \n \n \n   \n     \n  if (nrhs!= 2) { \n    mexErrMsgTxt(\"Two input arguments required.\"); \n  }  \n  if (nlhs > 2) { \n    mexErrMsgTxt(\"Too many output arguments.\"); \n  } \n \n   \n \n  if (!(mxIsDouble(prhs[0]))) { \n    mexErrMsgTxt(\"Input array must be of type double.\"); \n  } \n     \n   \n \n  M = mxGetM(prhs[0]); \n  N = mxGetN(prhs[0]); \n   \n   \n \n  pM  = (double *)mxGetPr(prhs[0]); \n  pk  = (double *)mxGetPr(prhs[1]); \n \n  k=(int) pk[0]; \n  plhs[0]=mxCreateDoubleMatrix(k,N,mxREAL); \n  plhs[1]=mxCreateDoubleMatrix(k,N,mxREAL); \n  po=mxGetPr(plhs[0]); \n  po2=mxGetPr(plhs[1]); \n   \n  mexCallMATLAB(1,infOut,0,NULL,\"inf\"); \n  ps=mxGetPr(infOut[0]);  \n  inf=ps[0]; \n \n  { \n  for(n=0;n<N;n++){ \n    kstart=n*k; \n    kend=kstart+k; \n    for(j=kstart;j<kend;j++) po[j]=inf; \n   for(m=0;m<M;m++){ \n    i=n*M+m; \n     if(pM[i]<po[kend-1]) { \n        \n \n       for(j=kstart;j<kend && po[j]<pM[i];j++); \n       insert=j; \n        \n \n       for(j=kend-1;j>insert;j--){po[j]=po[j-1];po2[j]=po2[j-1];} \n        \n \n       if(insert<kend) {po[insert]=pM[i];po2[insert]=m+1;} \n       } \n    }\t \n   } \n  } \n} ", "pred": " \nvoid mexFunction(int nlhs, mxArray *plhs[], \n                 int nrhs, const mxArray *prhs[]) \n{ \n   \n  \n  int a,b,c,k,M,N, m,n,i,kstart,j,insert,kend; \n  int size1,size2; \n  double *ps,*pM, *pk, *po,*po2; \n  int mRows,nCols; \n  mxArray *infOut[1]; \n  double inf; \n   \n \n \n   \n     \n  if (nrhs!= 2) { \n    mexErrMsgTxt(\"Two input arguments required.\"); \n  }  \n  if (nlhs > 2) { \n    mexErrMsgTxt(\"Too many output arguments.\"); \n  } \n \n   \n \n  if (!(mxIsDouble(prhs[0]))) { \n    mexErrMsgTxt(\"Input array must be of type double.\"); \n  } \n     \n   \n \n  M = mxGetM(prhs[0]); \n  N = mxGetN(prhs[0]); \n   \n   \n \n  pM  = (double *)mxGetPr(prhs[0]); \n  pk  = (double *)mxGetPr(prhs[1]); \n  po  = (double *)mxGetPr(prhs[2]); \n  po2 = (double *)mxGetPr(prhs[3]); \n   \n   \n   \n  if (mxIsComplex(prhs[0])) { \n     \n                                                                                                                                                                                                                                                                                                                                                    "}
{"label": " \nvoid \nfoo (unsigned long long int a, unsigned long long int b, unsigned long long int c) \n{ \n  unsigned long long int i; \n  for (i = a; i < b; i += c) \n    { \n      j++; \n      bar (&j); \n    } \n} ", "pred": " \nvoid \nfoo (unsigned long long int a, unsigned long long int b, unsigned long long int c) \n{ \n  unsigned long long int i; \n  for (i = a; i < b; i += c) \n    { \n      j++; \n      bar (&j); \n    } \n} "}
{"label": " \nvoid sgemm_host_omp(float *a, float *b, float *c, int n, int m, int q) \n{ \n    { \n        int k = 0; \n        for (int i = 0; i < n; i++) \n            for (int j = 0; j < q; j++) \n                c[k++] = 0.0; \n \n        for (int i = 0; i < n; i++) { \n            for (int k = 0; k < m; k++) { \n                for (int j = 0; j < q; j++) \n                    c[i * q + j] += a[i * m + k] * b[k * q + j]; \n    \t\t} \n\t    } \n\t} \n} ", "pred": " \nvoid sgemm_host_omp(float *a, float *b, float *c, int n, int m, int q) \n{ \n    { \n        int k = 0; \n        for (int i = 0; i < n; i++) \n            for (int j = 0; j < q; j++) \n                c[k++] = 0.0; \n \n        for (int i = 0; i < n; i++) { \n            for (int k = 0; k < m; k++) { \n                for (int j = 0; j < q; j++) \n                    c[i * q + j] += a[i * m + k] * b[k * q + j]; \n    \t\t} \n\t    } \n\t} \n} "}
{"label": " \nint grow(float *p, float *q, int c, int n) \n{ \n    const int s = (n + 2) * c; \n    const int a = (c - 1); \n \n    float *P; \n    float *Q; \n \n    int N = 0; \n    int i; \n    int j; \n    int d; \n \n    memcpy(q, p, (size_t) (n + 2) * (n + 2) * c * sizeof (float)); \n \n    for     (i = 1; i <= n; i++) \n        for (j = 1; j <= n; j++) \n        { \n            P = p + ((n + 2) * i + j) * c; \n            Q = q + ((n + 2) * i + j) * c; \n \n            if (Q[a] == 0) \n            { \n                d = 0; \n \n                if ((Q - s - c)[a]) { accumulate(P, Q - s - c, a); d++; } \n                if ((Q - s    )[a]) { accumulate(P, Q - s   , a); d++; } \n                if ((Q - s + c)[a]) { accumulate(P, Q - s + c, a); d++; } \n \n                if ((Q     - c)[a]) { accumulate(P, Q     - c, a); d++; } \n                if ((Q     + c)[a]) { accumulate(P, Q     + c, a); d++; } \n \n                if ((Q + s - c)[a]) { accumulate(P, Q + s - c, a); d++; } \n                if ((Q + s    )[a]) { accumulate(P, Q + s   , a); d++; } \n                if ((Q + s + c)[a]) { accumulate(P, Q + s + c, a); d++; } \n \n                if (d) \n                { \n                    divide(P, (float) d, a); \n                    N++; \n                } \n            } \n        } \n    return N; \n} ", "pred": " \nint grow(float *p, float *q, int c, int n) \n{ \n    const int s = (n + 2) * c; \n    const int a = (c - 1); \n \n    float *P; \n    float *Q; \n \n    int N = 0; \n    int i; \n    int j; \n    int d; \n \n    memcpy(q, p, (size_t) (n + 2) * (n + 2) * c * sizeof (float)); \n \n    for     (i = 1; i <= n; i++) \n        for (j = 1; j <= n; j++) \n        { \n            P = p + ((n + 2) * i + j) * c; \n            Q = q + ((n + 2) * i + j) * c; \n \n            if (Q[a] == 0) \n            { \n                d = 0; \n \n                for (int k = 0; k < c; k++) \n                { \n                    if (P[k]!= 0) \n                    { \n                        d = 1; \n                        break; \n                    } \n                } \n \n                if (d == 0) \n                { \n                    N++; \n                    P[a] = 1; \n                    Q[a] = 1; \n                } \n            } \n        } \n \n    return N; \n} \n \n \nint main() \n{ \n    float *p = (float *) malloc(sizeof(float) * (2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *"}
{"label": " \nstatic void \ncompute_projector( int *__restrict *__restrict triplet,  \n\t\t   double *__restrict *__restrict proj,  \n\t\t   const int *__restrict *__restrict momentum,  \n\t\t   const size_t count ) \n{ \n   \n \n  size_t i ; \n  for( i = 0 ; i < count ; i++ ) { \n    double mom[ 3 ][ ND ] ; \n    size_t mu ; \n \n    for( mu = 0 ; mu < ND ; mu ++ ) { \n      #ifdef PSQ_MOM \n       \n \n      mom[ 0 ][ mu ] = momentum[ triplet[ i ][ 0 ] ][ mu ] * Latt.twiddles[ mu ] ; \n      mom[ 1 ][ mu ] = momentum[ triplet[ i ][ 1 ] ][ mu ] * Latt.twiddles[ mu ] ; \n      mom[ 2 ][ mu ] = momentum[ triplet[ i ][ 2 ] ][ mu ] * Latt.twiddles[ mu ] ; \n      #else \n       \n \n      mom[ 0 ][ mu ] = 2.0 * sin( momentum[ triplet[ i ][ 0 ] ][ mu ] * Latt.twiddles[ mu ] ) ; \n      mom[ 1 ][ mu ] = 2.0 * sin( momentum[ triplet[ i ][ 1 ] ][ mu ] * Latt.twiddles[ mu ] ) ; \n      mom[ 2 ][ mu ] = 2.0 * sin( momentum[ triplet[ i ][ 2 ] ][ mu ] * Latt.twiddles[ mu ] ) ; \n      #endif \n    } \n \n    size_t nu, rho ; \n    for( mu = 0 ; mu < ND ; mu ++ ) { \n      for( nu = 0 ; nu < ND ; nu ++ ) { \n\tfor( rho = 0 ; rho < ND ; rho ++ ) { \n\t  const size_t z = rho + ND * ( nu + ND * mu ) ;  \n\t   \n \n          #ifdef PROJ_GRACEY \n\t  proj[i][z] = get_proj_gracey( mom[ 0 ], \t\t\t\t\tmom[ 1 ],\t \t\t\t\t\tmu, nu, rho ) ; \n          #else \n\t  proj[i][z] = get_proj( mom[ 0 ], \t\t\t\t mom[ 1 ], \t\t\t\t mom[ 2 ], \t\t\t\t mu, nu, rho ) ; \n          #endif \n\t} } } \n  } \n  return ; \n} ", "pred": " \nstatic void \ncompute_projector( int *__restrict *__restrict triplet,  \n\t\t   double *__restrict *__restrict proj,  \n\t\t   const int *__restrict *__restrict momentum,  \n\t\t   const size_t count ) \n{ \n   \n \n  size_t i ; \n  for( i = 0 ; i < count ; i++ ) { \n    double mom[ 3 ][ ND ] ; \n    size_t mu ; \n \n    for( mu = 0 ; mu < ND ; mu ++ ) { \n      #ifdef PSQ_MOM \n       \n \n      mom[ 0 ][ mu ] = momentum[ triplet[ i ][ 0 ] ][ mu ] * Latt.twiddles[ mu ] ; \n      mom[ 1 ][ mu ] = momentum[ triplet[ i ][ 1 ] ][ mu ] * Latt.twiddles[ mu ] ; \n      mom[ 2 ][ mu ] = momentum[ triplet[ i ][ 2 ] ][ mu ] * Latt.twiddles[ mu ] ; \n      #else \n       \n \n      mom[ 0 ][ mu ] = 2.0 * sin( momentum[ triplet[ i ][ 0 ] ][ mu ] ) ; \n      mom[ 1 ][ mu ] = 2.0 * sin( momentum[ triplet[ i ][ 1 ] ][ mu ] ) ; \n      mom[ 2 ][ mu ] = 2.0 * sin( momentum[ triplet[ i ][ 2 ] ][ mu ] ) ; \n      #endif \n \n    } \n \n    for( mu = 0 ; mu < ND ; mu ++ ) { \n      #ifdef PSQ_MOM \n       \n \n      proj[ i ][ mu ] = mom[ 0 ][ mu ] * Latt.twiddles[ mu ] ; \n      #else \n       \n \n      proj[ i ][ mu ] = mom[ 0 ][ mu ] ; \n      #endif \n    } \n  } \n \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"label": " \nint main(int argc, char** argv) { \n    int i, j, k; \n    int ni = NI; \n    int nj = NJ; \n    int nk = NK; \n    int nl = NL; \n     \n     \n \n    init_array(); \n     \n     \n    for (i = 0; i < ni; i++) \n        for (j = 0; j < nj; j++) { \n            C[i][j] = 0; \n            for (k = 0; k < nk; ++k) \n                C[i][j] += A[i][k] * B[k][j]; \n        } \n    for (i = 0; i < ni; i++) \n        for (j = 0; j < nl; j++) { \n            E[i][j] = 0; \n            for (k = 0; k < nj; ++k) \n                E[i][j] += C[i][k] * D[k][j]; \n        } \n     \n    double total = 0; \n    for(int y=0; y<ni; ++y){ \n        for(int x=0; x<ni; ++x) { \n            total+= E[y][x]; \n        } \n    } \n    printf(\"Total: %f\\n\",total); \n    return 0; \n} ", "pred": " \nint main(int argc, char** argv) { \n    int i, j, k; \n    int ni = NI; \n    int nj = NJ; \n    int nk = NK; \n    int nl = NL; \n     \n     \n \n    init_array(); \n     \n     \n    for (i = 0; i < ni; i++) \n        for (j = 0; j < nj; j++) { \n            C[i][j] = 0; \n            for (k = 0; k < nk; ++k) \n                C[i][j] += A[i][k] * B[k][j]; \n        } \n    for (i = 0; i < ni; i++) \n        for (j = 0; j < nl; j++) { \n            E[i][j] = 0; \n            for (k = 0; k < nj; ++k) \n                E[i][j] += A[i][k] * B[k][j]; \n        } \n    for (i = 0; i < ni; i++) \n        for (j = 0; j < ni; j++) { \n            F[i][j] = 0; \n            for (k = 0; k < nj; ++k) \n                F[i][j] += A[i][k] * B["}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 16; \n  tile_size[3] = 2048; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0765; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,12);t1++) { \n    lbp=max(ceild(t1,2),ceild(24*t1-Nt+3,24)); \n    ubp=min(floord(Nt+Nz-4,24),floord(12*t1+Nz+9,24)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(3*t1-3,4)),ceild(24*t2-Nz-12,16));t3<=min(min(min(floord(Nt+Ny-4,16),floord(12*t1+Ny+21,16)),floord(24*t2+Ny+20,16)),floord(24*t1-24*t2+Nz+Ny+19,16));t3++) { \n        for (t4=max(max(max(0,ceild(3*t1-511,512)),ceild(24*t2-Nz-2044,2048)),ceild(16*t3-Ny-2044,2048));t4<=min(min(min(min(floord(Nt+Nx-4,2048),floord(12*t1+Nx+21,2048)),floord(24*t2+Nx+20,2048)),floord(16*t3+Nx+12,2048)),floord(24*t1-24*t2+Nz+Nx+19,2048));t4++) { \n          for (t5=max(max(max(max(max(0,12*t1),24*t1-24*t2+1),24*t2-Nz+2),16*t3-Ny+2),2048*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,12*t1+23),24*t2+22),16*t3+14),2048*t4+2046),24*t1-24*t2+Nz+21);t5++) { \n            for (t6=max(max(24*t2,t5+1),-24*t1+24*t2+2*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(16*t3,t5+1);t7<=min(16*t3+15,t5+Ny-2);t7++) { \n                lbv=max(2048*t4,t5+1); \n                ubv=min(2048*t4+2047,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = ((alpha * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (beta * (((((A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)] + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) - 1][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8) - 1]) + A[ t5 % 2][ (-t5+t6) + 1][ (-t5+t7)][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) + 1][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8) + 1])));; \n                } \n              } \n            } \n          } \n        } \n      } \n    } \n  } \n} \n \n \n      gettimeofday(&end, 0); \n      ts_return = timeval_subtract(&result, &end, &start); \n      tdiff = (double) (result.tv_sec + result.tv_usec * 1.0e-6); \n  ", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n  for(t=0; t<Nt; t++){ \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i"}
{"label": " \nstatic  \nvoid kernel_deriche(int w, int h, DATA_TYPE alpha, \n       DATA_TYPE POLYBENCH_2D(imgIn, W, H, w, h), \n       DATA_TYPE POLYBENCH_2D(imgOut, W, H, w, h), \n       DATA_TYPE POLYBENCH_2D(y1, W, H, w, h), \n       DATA_TYPE POLYBENCH_2D(y2, W, H, w, h)) { \n    int i,j; \n    DATA_TYPE xm1, tm1, ym1, ym2; \n    DATA_TYPE xp1, xp2; \n    DATA_TYPE tp1, tp2; \n    DATA_TYPE yp1, yp2; \n    \n    DATA_TYPE k; \n    DATA_TYPE a1, a2, a3, a4, a5, a6, a7, a8; \n    DATA_TYPE b1, b2, c1, c2; \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nk = (SCALAR_VAL(1.0)-EXP_FUN(-alpha))*(SCALAR_VAL(1.0)-EXP_FUN(-alpha))/(SCALAR_VAL(1.0)+SCALAR_VAL(2.0)*alpha*EXP_FUN(-alpha)-EXP_FUN(SCALAR_VAL(2.0)*alpha)); a1 = a5 = k; a2 = a6 = k*EXP_FUN(-alpha)*(alpha-SCALAR_VAL(1.0)); a3 = a7 = k*EXP_FUN(-alpha)*(alpha+SCALAR_VAL(1.0)); a4 = a8 = -k*EXP_FUN(SCALAR_VAL(-2.0)*alpha); b1 = POW_FUN(SCALAR_VAL(2.0),-alpha); b2 = -EXP_FUN(SCALAR_VAL(-2.0)*alpha);; \nc1 = c2 = 1;; \nif (_PB_H >= 1) { \n  for (t2=0;t2<=_PB_W-1;t2++) { \n    ym1 = SCALAR_VAL(0.0);; \n    ym2 = SCALAR_VAL(0.0);; \n    xm1 = SCALAR_VAL(0.0);; \n    for (t4=0;t4<=_PB_H-1;t4++) { \n      y1[t2][t4] = a1*imgIn[t2][t4] + a2*xm1 + b1*ym1 + b2*ym2; xm1 = imgIn[t2][t4]; ym2 = ym1; ym1 = y1[t2][t4];; \n    } \n  } \n} \nif (_PB_H <= 0) { \n  for (t2=0;t2<=_PB_W-1;t2++) { \n    ym1 = SCALAR_VAL(0.0);; \n    ym2 = SCALAR_VAL(0.0);; \n    xm1 = SCALAR_VAL(0.0);; \n  } \n} \nif (_PB_H >= 1) { \n  for (t2=0;t2<=_PB_W-1;t2++) { \n    yp1 = SCALAR_VAL(0.0);; \n    yp2 = SCALAR_VAL(0.0);; \n    xp1 = SCALAR_VAL(0.0);; \n    xp2 = SCALAR_VAL(0.0);; \n    for (t4=-_PB_H+1;t4<=0;t4++) { \n      y2[t2][-t4] = a3*xp1 + a4*xp2 + b1*yp1 + b2*yp2; xp2 = xp1; xp1 = imgIn[t2][-t4]; yp2 = yp1; yp1 = y2[t2][-t4];; \n    } \n  } \n} \nif (_PB_H <= 0) { \n  for (t2=0;t2<=_PB_W-1;t2++) { \n    yp1 = SCALAR_VAL(0.0);; \n    yp2 = SCALAR_VAL(0.0);; \n    xp1 = SCALAR_VAL(0.0);; \n    xp2 = SCALAR_VAL(0.0);; \n  } \n} \nif (_PB_H >= 1) { \n  lbp=0; \n  ubp=_PB_W-1; \n  for (t2=lbp;t2<=ubp;t2++) { \n    for (t4=0;t4<=_PB_H-1;t4++) { \n      imgOut[t2][t4] = c1 * (y1[t2][t4] + y2[t2][t4]);; \n    } \n  } \n} \nif (_PB_W >= 1) { \n  for (t2=0;t2<=_PB_H-1;t2++) { \n    tm1 = SCALAR_VAL(0.0);; \n    ym1 = SCALAR_VAL(0.0);; \n    ym2 = SCALAR_VAL(0.0);; \n    for (t4=0;t4<=_PB_W-1;t4++) { \n      y1[t4][t2] = a5*imgOut[t4][t2] + a6*tm1 + b1*ym1 + b2*ym2; tm1 = imgOut[t4][t2]; ym2 = ym1; ym1 = y1 [t4][t2];; \n    } \n  } \n} \nif (_PB_W <= 0) { \n  for (t2=0;t2<=_PB_H-1;t2++) { \n    tm1 = SCALAR_VAL(0.0);; \n    ym1 = SCALAR_VAL(0.0);; \n    ym2 = SCALAR_VAL(0.0);; \n  } \n} \nif (_PB_W >= 1) { \n  for (t2=0;t2<=_PB_H-1;t2++) { \n    tp1 = SCALAR_VAL(0.0);; \n    tp2 = SCALAR_VAL(0.0);; \n    yp1 = SCALAR_VAL(0.0);; \n    yp2 = SCALAR_VAL(0.0);; \n    for (t4=-_PB_W+1;t4<=0;t4++) { \n      y2[-t4][t2] = a7*tp1 + a8*tp2 + b1*yp1 + b2*yp2; tp2 = tp1; tp1 = imgOut[-t4][t2]; yp2 = yp1; yp1 = y2[-t4][t2];; \n    } \n  } \n} \nif (_PB_W <= 0) { \n  for (t2=0;t2<=_PB_H-1;t2++) { \n    tp1 = SCALAR_VAL(0.0);; \n    tp2 = SCALAR_VAL(0.0);; \n    yp1 = SCALAR_VAL(0.0);; \n    yp2 = SCALAR_VAL(0.0);; \n  } \n} \nif (_PB_H >= 1) { \n  lbp=0; \n  ubp=_PB_W-1; \n  for (t2=lbp;t2<=ubp;t2++) { \n    for (t4=0;t4<=_PB_H-1;t4++) { \n      imgOut[t2][t4] = c2*(y1[t2][t4] + y2[t2][t4]);; \n    } \n  } \n} \n \n \n} ", "pred": " \nstatic  \nvoid kernel_deriche(int w, int h, DATA_TYPE alpha, \n       DATA_TYPE POLYBENCH_2D(imgIn, W, H, w, h), \n       DATA_TYPE POLYBENCH_2D(imgOut, W, H, w, h), \n       DATA_TYPE POLYBENCH_2D(y1, W, H, w, h), \n       DATA_TYPE POLYBENCH_2D(y2, W, H, w, h)) { \n    int i,j; \n    DATA_TYPE xm1, tm1, ym1, ym2; \n    DATA_TYPE xp1, xp2; \n    DATA_TYPE tp1, tp2; \n    DATA_TYPE yp1, yp2; \n    \n    DATA_TYPE k; \n    DATA_TYPE a1, a2, a3, a4, a5, a6, a7, a8; \n    DATA_TYPE b1, b2, c1, c2; \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5; \n int lb, ub, p, q; \n DATA_TYPE *x1, *x2, *y1, *y2; \n DATA_TYPE *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8; \n DATA_TYPE *b1, *b2, *c1, *c2; \n DATA_TYPE *y1p, *y2p, *ypp; \n DATA_TYPE *yp, *ypp1, *ypp2; \n DATA_TYPE *tp1p, *tp2p, *tp1, *tp2; \n DATA_TYPE *ypp1, *ypp2; \n \n DATA_TYPE *imgInp, *imgOutp; \n DATA_TYPE *y1p1, *y2p1, *ypp1; \n DATA_TYPE *y1p2, *y2p2, *ypp2; \n DATA_TYPE *ypp1p, *ypp2p; \n \n DATA_TYPE *x1p1, *x1p2, *x2p1, *x2p2; \n DATA_TYPE *x1p3, *x1p4, *x1p5, *x1p6, *x1p7; \n DATA_TYPE *x2p1, *x2p2, *x2p3, *x2p4, *x2p5, *x2p6, *x2p7; \n DATA_TYPE *x2p3p, *x2p4p, *x2p5p, *x2p6p, *x2p7p; \n \n DATA_TYPE *y1p1, *y1p2, *y2p1, *y2p2; \n DATA_TYPE *y1p3, *y1p4, *y1p5, *y1p6, *y1p7; \n DATA_TYPE *y2p1, *y2p2, *y2p3, *y2p4, *y2p5, *y2p6, *y2p7; \n \n DATA_TYPE *a1p1, *a1p2, *a2p1, *a2p2; \n DATA_TYPE *a3p1, *a3p2, *a4p1, *a4p2; \n DATA_TYPE *a5p1, *a5p2, *a6p1, *a6p2; \n DATA_TYPE *a7p1, *a7p2, *a8p1, *a8p2; \n \n DATA_TYPE *b1p1, *b1p2, *b2p1, *b2p2; \n DATA_TYPE *b3p1, *b3p2, *b4p1, *b4p2; \n DATA_TYPE *b5p1, *b5p2, *b6p1, *b6p2; \n DATA_TYPE *b7p1, *b7p2, *b8p1, *b8p2; \n \n DATA_TYPE *c1p1, *c1p2, *c2p1, *c2p2; \n DATA_TYPE *c3p1, *c3p2, *c4p1, *c4p2; \n DATA_TYPE *c5p1, *c5p2, *c6p1, *c6p2; \n DATA_TYPE *c7p1, *c7p2, *c8p1, *c8p2; \n \n DATA_TYPE *yp1, *yp2; \n DATA_TYPE *xp1, *xp2; \n \n DATA_TYPE *y1p, *y2p, *ypp, *yp; \n DATA_TYPE *x1p, *x2p, *xp, *ypp1, *ypp2; \n DATA_TYPE *x1, *x2, *xp1, *xp2; \n \n DATA_TYPE *a1p, *a2p, *a3p, *a4p, *a5p, *a6p, *a7p, *a8p; \n DATA_TYPE *b1p, *b2p, *b3p, *b4p, *b5p, *b6p, *b7p, *b8p; \n DATA_TYPE *c1p, *c2p, *c3p, *c4p, *c5p, *c6p, *c7p, *c8p; \n DATA_TYPE *d1p, *d2p, *d3p, *d4p, *d5p, *d6p, *d7p, *d8p; \n \n DATA_TYPE *y1p1, *y1p2, *y2p1, *y2p2; \n DATA_TYPE *y1p3, *y1p4, *y1p5, *y1p6, *y1p7; \n DATA_TYPE *y2p1, *y2p2, *y2p3, *y2p4, *y2p5, *y2p6, *y2p7; \n DATA_TYPE *y2p3p, *y2p4p, *y2p5p, *y2p6p, *y2p7p; \n \n DATA_TYPE *a1p1, *a1p2, *a2p1, *a2p2; \n DATA_TYPE *a3p1, *a3p2, *a4p1, *a4p2; \n DATA_TYPE *a5p1, *a5p2, *a6p1, *a6p2; \n DATA_TYPE *a7p1, *a7p2, *a8p1, *a8p2; \n \n DATA_TYPE *b1p1, *b1p2, *b2p1, *b2p2; \n DATA_TYPE *b3p1, *b3p2, *b4p1, *b4p2; \n DATA_TYPE *b5p1, *b5p2, *b6p1, *b6p2; \n DATA_TYPE *b7p1, *b7p2, *b8p1, *b8p2; \n \n DATA_TYPE *c1p1, *c1p2, *c2p1, *c2p2; \n DATA_TYPE *c3p1, *c3p2, *c4p1, *c4p2; \n DATA_TYPE *c5p1, *c5p2, *c6p1, *c6p2; \n DATA_TYPE *c7p1, *c7p2, *c8p1, *c8p2; \n \n DATA_TYPE *d1p1, *d1p2, *d2p1, *d2p2; \n DATA_TYPE *d3p1, *d3p2, *d4p1, *d4p2; \n DATA_TYPE *d5p1, *d5p2, *d6p1, *d6p2; \n DATA_TYPE *d7p1, *d7p2, *d8p1, *d8p2; \n"}
{"label": " \nint main(int argc, char* argv[]) \n{ \n    bool verb,fsrf,snap,expl,dabc,sout,uses; \n    int  jsnap,ntsnap,jdata; \n    char *atype; \n    int ompnth=1; \n \n     \n \n    sf_file Fwav=NULL;  \n \n    sf_file Fsou=NULL;  \n \n    sf_file Frec=NULL;  \n \n    sf_file Fvel=NULL;  \n \n    sf_file Fang=NULL;  \n \n    sf_file Fdat=NULL;  \n \n    sf_file Fwfl=NULL;  \n \n \n     \n \n    sf_axis at,az,ax,ay; \n    sf_axis as,ar; \n \n    int     nt,nz,nx,ny,ns,nr,nb; \n    int     it,iz,ix,iy; \n    float   dt,dz,dx,dy,dt2; \n \n     \n \n    fdm3d    fdm=NULL; \n    abcone3d abc=NULL; \n    sponge   spo=NULL; \n \n     \n \n    float  *ww=NULL;            \n \n    pt3d   *ss=NULL;            \n \n    pt3d   *rr=NULL;            \n \n    float  *dd=NULL;            \n \n \n    float ***tt=NULL; \n    float ***vp=NULL;            \n \n \n    float ***vpn=NULL; \n    float ***vpz=NULL; \n    float ***vpx=NULL; \n    float ***vsz=NULL; \n \n    float ***tht=NULL,***sit=NULL,***cot=NULL; \n    float ***phi=NULL,***sip=NULL,***cop=NULL; \n    float st,ct,sp,cp; \n \n    float ***pm=NULL,***po=NULL,***pp=NULL,***pa=NULL,***pt=NULL;  \n \n    float ***qm=NULL,***qo=NULL,***qp=NULL,***qa=NULL,***qt=NULL;  \n \n    float ***sf=NULL;  \n \n \n     \n \n    lint3d cs,cr; \n \n     \n \n    float cox,cax,cbx,c1x,c2x; \n    float coy,cay,cby,c1y,c2y; \n    float coz,caz,cbz,c1z,c2z; \n \n     \n \n    sf_axis   acz=NULL,acx=NULL,acy=NULL; \n    int       nqz,nqx,nqy; \n    float     oqz,oqx,oqy; \n    float     dqz,dqx,dqy; \n    float     ***pc=NULL; \n \n    float H1p,H2p,H1q,H2q; \n \n     \n \n     \n \n    sf_init(argc,argv); \n \n     \n \n    if (NULL == (atype = sf_getstring(\"atype\"))) atype = \"i\"; \n    switch(atype[0]) { \n\tcase 't': \n\t    sf_warning(\"TTI model\"); \n\t    break; \n \n\tcase 'v': \n\t    sf_warning(\"VTI model\"); \n\t    break; \n \n\tcase 'i': \n\tdefault: \n\t    sf_warning(\"ISO model\"); \n\t    break; \n    } \n \n     \n \n     \n \n    ompnth=omp_init(); \n     \n \n \n     \n \n    if(! sf_getbool(\"verb\",&verb)) verb=false;  \n \n    if(! sf_getbool(\"snap\",&snap)) snap=false;  \n \n    if(! sf_getbool(\"free\",&fsrf)) fsrf=false;  \n \n    if(! sf_getbool(\"expl\",&expl)) expl=false;  \n \n    if(! sf_getbool(\"dabc\",&dabc)) dabc=false;  \n \n    if(! sf_getbool(\"sout\",&sout)) sout=false;  \n \n    if(! sf_getbool(\"uses\",&uses)) uses=false;  \n \n     \n \n \n     \n \n     \n \n    Fwav = sf_input (\"in\" );  \n \n    Fvel = sf_input (\"vel\");  \n \n    Fsou = sf_input (\"sou\");  \n \n    Frec = sf_input (\"rec\");  \n \n    Fang = sf_input (\"ang\");  \n \n    Fwfl = sf_output(\"wfl\");  \n \n    Fdat = sf_output(\"out\");  \n \n \n     \n \n     \n \n    at = sf_iaxa(Fwav,2); sf_setlabel(at,\"t\"); if(verb) sf_raxa(at);  \n \n    ax = sf_iaxa(Fvel,2); sf_setlabel(ax,\"x\"); if(verb) sf_raxa(ax);  \n \n    ay = sf_iaxa(Fvel,3); sf_setlabel(ay,\"y\"); if(verb) sf_raxa(ay);  \n \n    az = sf_iaxa(Fvel,1); sf_setlabel(az,\"z\"); if(verb) sf_raxa(az);  \n \n \n    as = sf_iaxa(Fsou,2); sf_setlabel(as,\"s\"); if(verb) sf_raxa(as);  \n \n    ar = sf_iaxa(Frec,2); sf_setlabel(ar,\"r\"); if(verb) sf_raxa(ar);  \n \n \n    nt = sf_n(at); dt = sf_d(at); \n    nz = sf_n(az); dz = sf_d(az); \n    nx = sf_n(ax); dx = sf_d(ax); \n    ny = sf_n(ay); dy = sf_d(ay); \n \n    ns = sf_n(as); \n    nr = sf_n(ar); \n     \n \n \n     \n \n     \n \n    if(! sf_getint(\"jdata\",&jdata)) jdata=1; \n    if(snap) {   \n \n\tif(! sf_getint(\"jsnap\",&jsnap)) jsnap=nt;         \n    } \n     \n \n \n     \n \n     \n \n    sf_oaxa(Fdat,ar,1); \n \n    sf_setn(at,nt/jdata); \n    sf_setd(at,dt*jdata); \n    sf_oaxa(Fdat,at,2); \n \n     \n \n    if(snap) { \n\tif(!sf_getint  (\"nqz\",&nqz)) nqz=sf_n(az); \n\tif(!sf_getint  (\"nqx\",&nqx)) nqx=sf_n(ax); \n\tif(!sf_getint  (\"nqy\",&nqy)) nqy=sf_n(ay); \n \n\tif(!sf_getfloat(\"oqz\",&oqz)) oqz=sf_o(az); \n\tif(!sf_getfloat(\"oqx\",&oqx)) oqx=sf_o(ax); \n\tif(!sf_getfloat(\"oqy\",&oqy)) oqy=sf_o(ay); \n \n\tdqz=sf_d(az); \n\tdqx=sf_d(ax); \n\tdqy=sf_d(ay); \n \n\tacz = sf", "pred": " \nint main(int argc, char* argv[]) \n{ \n    bool verb,fsrf,snap,expl,dabc,sout,uses; \n    int  jsnap,ntsnap,jdata; \n    char *atype; \n    int ompnth=1; \n \n     \n \n    sf_file Fwav=NULL;  \n \n    sf_file Fsou=NULL;  \n \n    sf_file Frec=NULL;  \n \n    sf_file Fvel=NULL;  \n \n    sf_file Fang=NULL;  \n \n    sf_file Fdat=NULL;  \n \n    sf_file Fwfl=NULL;  \n \n \n     \n \n    sf_axis at,az,ax,ay; \n    sf_axis as,ar; \n \n    int     nt,nz,nx,ny,ns,nr,nb; \n    int     it,iz,ix,iy; \n    float   dt,dz,dx,dy,dt2; \n \n     \n \n    fdm3d    fdm=NULL; \n    abcone3d abcone=NULL; \n    abcone3d abcone2=NULL; \n    abcone3d abcone3=NULL; \n    abcone3d abcone4=NULL; \n    abcone3d abcone5=NULL; \n    abcone3d abcone6=NULL; \n    abcone3d abcone7=NULL; \n    abcone3d abcone8=NULL; \n    abcone3d abcone9=NULL; \n    abcone3d abcone10=NULL; \n    abcone3d abcone11=NULL; \n    abcone3d abcone12=NULL; \n    abcone3d abcone13=NULL; \n    abcone3d abcone14=NULL; \n    abcone3d abcone15=NULL; \n    abcone3d abcone16=NULL; \n    abcone3d abcone17=NULL; \n    abcone3d abcone18=NULL; \n    abcone3d abcone19=NULL; \n    abcone3d abcone20=NULL; \n    abcone3d abcone21=NULL; \n    abcone3d abcone22=NULL; \n    abcone3d abcone23=NULL; \n    abcone3d abcone24=NULL; \n    abcone3d abcone25=NULL; \n    abcone3d abcone26=NULL; \n    abcone3d abcone27=NULL; \n    abcone3d abcone28=NULL; \n    abcone3d abcone29=NULL; \n    abcone3d abcone30=NULL; \n    abcone3d abcone31=NULL; \n    abcone3d abcone32=NULL; \n    abcone3d abcone33=NULL; \n    abcone3d abcone34=NULL; \n    abcone3d abcone35=NULL; \n    abcone3d abcone36=NULL; \n    abcone3d abcone37=NULL; \n    abcone3d abcone38=NULL; \n    abcone3d abcone39=NULL; \n    abcone3d abcone40=NULL; \n    abcone3d abcone41=NULL; \n    abcone3d abcone42=NULL; \n    abcone3d abcone43=NULL; \n    abcone3d abcone44=NULL; \n    abcone3d abcone45=NULL; \n    abcone3d abcone46=NULL; \n    abcone3d abcone47=NULL; \n    abcone3d abcone48=NULL; \n    abcone3d abcone49=NULL; \n    abcone3d abcone50=NULL; \n    abcone3d abcone51=NULL; \n    abcone3d abcone52=NULL; \n    abcone3d abcone53=NULL; \n    abcone3d abcone54=NULL; \n    abcone3d abcone55=NULL; \n    abcone3d abcone56=NULL; \n    abcone3d abcone57=NULL; \n    abcone3d abcone58=NULL; \n    abcone3d abcone59=NULL; \n    abcone3d abcone60=NULL; \n    abcone3d abcone61=NULL; \n    abcone3d abcone62=NULL; \n    abcone3d abcone63=NULL; \n    abcone3d abcone64=NULL; \n    abcone3d abcone65=NULL; \n    abcone3d abcone66=NULL; \n    abcone3d abcone67=NULL; \n    abcone3d abcone68=NULL; \n    abcone3d abcone69=NULL; \n    abcone3d abcone70=NULL; \n    abcone3d abcone71=NULL; \n    abcone3d abcone72=NULL; \n    abcone3d abcone73=NULL; \n    abcone3d abcone74=NULL; \n    abcone3d abcone75=NULL; \n    abcone3d abcone76=NULL; \n    abcone3d abcone77=NULL; \n    abcone3d abcone78=NULL; \n    abcone3d abcone79=NULL; \n    abcone3d abcone80=NULL; \n    abcone3d abcone81=NULL; \n    abcone3d abcone82=NULL; \n    abcone3d abcone83=NULL; \n    abcone3d abcone84=NULL; \n    abcone3d abcone85=NULL; \n    abcone3d abcone86=NULL; \n    abcone3d abcone87=NULL; \n    abcone3d abcone88=NULL; \n    abcone3d abcone89=NULL; \n    abcone3d abcone90=NULL; \n    abcone3d abcone91=NULL; \n    abcone3d abcone92=NULL; \n    abcone3d abcone93=NULL; \n    abcone3d abcone94=NULL; \n    abcone3d abcone95=NULL; \n    abcone3d abcone96=NULL; \n    abcone3d abcone97=NULL; \n    abcone3d abcone98=NULL; \n    abcone3d abcone99=NULL; \n    abcone3d abcone100=NULL; \n    abcone3d abcone101=NULL; \n    abcone3d abcone102=NULL; \n    abcone3d abcone103=NULL; \n    abcone3d abcone104=NULL; \n    abcone3d abcone105=NULL; \n    abcone3d abcone106=NULL; \n    abcone3d abcone107=NULL; \n    abcone3d abcone108=NULL; \n    abcone3d abcone109=NULL; \n    abcone3d abcone110="}
{"label": " \nvoid THNN_(SpatialConvolutionLocal_updateGradInput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *gradOutput, \n    THTensor *gradInput, \n    THTensor *weight, \n    THTensor *finput, \n    THTensor *fgradInput, \n    int kW, int kH, \n    int dW, int dH, \n    int padW, int padH, \n    long inputWidth, long inputHeight, \n    long outputWidth, long outputHeight) \n{ \n  int freeWeight = THNN_(view_weight_local)(&weight); \n \n  THNN_(SpatialConvolutionLocal_shapeCheck) \n    (input, gradOutput, weight, NULL, kH, kW, dH, dW, padH, padW, \n     inputHeight, inputWidth, outputHeight, outputWidth); \n \n  input = THTensor_(newContiguous)(input); \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n  long nInputPlane = THTensor_(size)(weight,2)/(kW*kH); \n  long nOutputPlane = THTensor_(size)(weight,1); \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(resizeAs)(fgradInput, finput); \n  THTensor_(transpose)(weight, weight, 1, 2); \n \n  if(input->nDimension == 3) \n  { \n    THNN_(SpatialConvolutionLocal_updateGradInput_frame) \n      (gradInput, gradOutput, weight, \n       fgradInput, kW, kH, dW, dH, padW, padH, \n       nInputPlane, inputWidth, inputHeight, \n       nOutputPlane, outputWidth, outputHeight); \n  } \n  else \n  { \n    long T = input->size[0]; \n    long t; \n \n    for(t = 0; t < T; t++) \n    { \n      THTensor *gradInput_t = THTensor_(newSelect)(gradInput, 0, t); \n      THTensor *gradOutput_t = THTensor_(newSelect)(gradOutput, 0, t); \n      THTensor *fgradInput_t = THTensor_(newSelect)(fgradInput, 0, t); \n \n      THNN_(SpatialConvolutionLocal_updateGradInput_frame) \n\t(gradInput_t, gradOutput_t, weight, fgradInput_t, \n\t kW, kH, dW, dH, padW, padH, \n\t nInputPlane, inputWidth, inputHeight, \n\t nOutputPlane, outputWidth, outputHeight); \n \n      THTensor_(free)(gradInput_t); \n      THTensor_(free)(gradOutput_t); \n      THTensor_(free)(fgradInput_t); \n    } \n  } \n \n  THTensor_(transpose)(weight, weight, 1, 2); \n \n  THTensor_(free)(input); \n  THTensor_(free)(gradOutput); \n  if (freeWeight) \n    THTensor_(free)(weight); \n \n} ", "pred": " \nvoid THNN_(SpatialConvolutionLocal_updateGradInput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *gradOutput, \n    THTensor *gradInput, \n    THTensor *weight, \n    THTensor *finput, \n    THTensor *fgradInput, \n    int kW, int kH, \n    int dW, int dH, \n    int padW, int padH, \n    long inputWidth, long inputHeight, \n    long outputWidth, long outputHeight) \n{ \n  int freeWeight = THNN_(view_weight_local)(&weight); \n \n  THNN_(SpatialConvolutionLocal_shapeCheck) \n    (input, gradOutput, weight, NULL, kH, kW, dH, dW, padH, padW, \n     inputHeight, inputWidth, outputHeight, outputWidth); \n \n  input = THTensor_(newContiguous)(input); \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n  long nInputPlane = THTensor_(size)(weight,2)/(kW*kH); \n  long nOutputPlane = THTensor_(size)(weight,2)/(kH*kW); \n \n  long nInputPlane2 = nInputPlane*nInputPlane; \n  long nOutputPlane2 = nOutputPlane*nOutputPlane; \n \n  long nInputPlane3 = nInputPlane2*nInputPlane; \n  long nOutputPlane3 = nOutputPlane2*nOutputPlane; \n \n  long nInputPlane4 = nInputPlane3*nInputPlane; \n  long nOutputPlane4 = nOutputPlane3*nOutputPlane; \n \n  long nInputPlane5 = nInputPlane4*nInputPlane; \n  long nOutputPlane5 = nOutputPlane4*nOutputPlane; \n \n  long nInputPlane6 = nInputPlane5*nInputPlane; \n  long nOutputPlane6 = nOutputPlane5*nOutputPlane; \n \n  long nInputPlane7 = nInputPlane6*nInputPlane; \n  long nOutputPlane7 = nOutputPlane6*nOutputPlane; \n \n  long nInputPlane8 = nInputPlane7*nInputPlane; \n  long nOutputPlane8 = nOutputPlane7*nOutputPlane; \n \n  long nInputPlane9 = nInputPlane8*nInputPlane; \n  long nOutputPlane9 = nOutputPlane8*nOutputPlane; \n \n  long nInputPlane10 = nInputPlane9*nInputPlane; \n  long nOutputPlane10 = nOutputPlane9*nOutputPlane; \n \n  long nInputPlane11 = nInputPlane10*nInputPlane; \n  long nOutputPlane11 = nOutputPlane10*nOutputPlane; \n \n  long nInputPlane12 = nInputPlane11*nInputPlane; \n  long nOutputPlane12 = nOutputPlane11*nOutputPlane; \n \n  long nInputPlane13 = nInputPlane12*nInputPlane; \n  long nOutputPlane13 = nOutputPlane12*nOutputPlane; \n \n  long nInputPlane14 = nInputPlane13*nInputPlane; \n  long nOutputPlane14 = nOutputPlane13*nOutputPlane; \n \n  long nInputPlane15 = nInputPlane14*nInputPlane; \n  long nOutputPlane15 = nOutputPlane14*nOutputPlane; \n \n  long nInputPlane16 = nInputPlane"}
{"label": " \nvoid x_solve() \n{ \n  int i, j, k, m, n, isize; \n \n   \n \n   \n \n \n  if (timeron) timer_start(t_xsolve); \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n  isize = grid_points[0]-1; \n \n   \n \n   \n \n   \n \n  for (k = 1; k <= grid_points[2]-2; k++) { \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      for (i = 0; i <= isize; i++) { \n        tmp1 = rho_i[k][j][i]; \n        tmp2 = tmp1 * tmp1; \n        tmp3 = tmp1 * tmp2; \n         \n \n         \n \n         \n \n        fjac[i][0][0] = 0.0; \n        fjac[i][1][0] = 1.0; \n        fjac[i][2][0] = 0.0; \n        fjac[i][3][0] = 0.0; \n        fjac[i][4][0] = 0.0; \n \n        fjac[i][0][1] = -(u[k][j][i][1] * tmp2 * u[k][j][i][1]) \n          + c2 * qs[k][j][i]; \n        fjac[i][1][1] = ( 2.0 - c2 ) * ( u[k][j][i][1] / u[k][j][i][0] ); \n        fjac[i][2][1] = - c2 * ( u[k][j][i][2] * tmp1 ); \n        fjac[i][3][1] = - c2 * ( u[k][j][i][3] * tmp1 ); \n        fjac[i][4][1] = c2; \n \n        fjac[i][0][2] = - ( u[k][j][i][1]*u[k][j][i][2] ) * tmp2; \n        fjac[i][1][2] = u[k][j][i][2] * tmp1; \n        fjac[i][2][2] = u[k][j][i][1] * tmp1; \n        fjac[i][3][2] = 0.0; \n        fjac[i][4][2] = 0.0; \n \n        fjac[i][0][3] = - ( u[k][j][i][1]*u[k][j][i][3] ) * tmp2; \n        fjac[i][1][3] = u[k][j][i][3] * tmp1; \n        fjac[i][2][3] = 0.0; \n        fjac[i][3][3] = u[k][j][i][1] * tmp1; \n        fjac[i][4][3] = 0.0; \n \n        fjac[i][0][4] = ( c2 * 2.0 * square[k][j][i] - c1 * u[k][j][i][4] ) \n          * ( u[k][j][i][1] * tmp2 ); \n        fjac[i][1][4] = c1 *  u[k][j][i][4] * tmp1  \n          - c2 * ( u[k][j][i][1]*u[k][j][i][1] * tmp2 + qs[k][j][i] ); \n        fjac[i][2][4] = - c2 * ( u[k][j][i][2]*u[k][j][i][1] ) * tmp2; \n        fjac[i][3][4] = - c2 * ( u[k][j][i][3]*u[k][j][i][1] ) * tmp2; \n        fjac[i][4][4] = c1 * ( u[k][j][i][1] * tmp1 ); \n \n        njac[i][0][0] = 0.0; \n        njac[i][1][0] = 0.0; \n        njac[i][2][0] = 0.0; \n        njac[i][3][0] = 0.0; \n        njac[i][4][0] = 0.0; \n \n        njac[i][0][1] = - con43 * c3c4 * tmp2 * u[k][j][i][1]; \n        njac[i][1][1] =   con43 * c3c4 * tmp1; \n        njac[i][2][1] =   0.0; \n        njac[i][3][1] =   0.0; \n        njac[i][4][1] =   0.0; \n \n        njac[i][0][2] = - c3c4 * tmp2 * u[k][j][i][2]; \n        njac[i][1][2] =   0.0; \n        njac[i][2][2] =   c3c4 * tmp1; \n        njac[i][3][2] =   0.0; \n        njac[i][4][2] =   0.0; \n \n        njac[i][0][3] = - c3c4 * tmp2 * u[k][j][i][3]; \n        njac[i][1][3] =   0.0; \n        njac[i][2][3] =   0.0; \n        njac[i][3][3] =   c3c4 * tmp1; \n        njac[i][4][3] =   0.0; \n \n        njac[i][0][4] = - ( con43 * c3c4 \n            - c1345 ) * tmp3 * (u[k][j][i][1]*u[k][j][i][1]) \n          - ( c3c4 - c1345 ) * tmp3 * (u[k][j][i][2]*u[k][j][i][2]) \n          - ( c3c4 - c1345 ) * tmp3 * (u[k][j][i][3]*u[k][j][i][3]) \n          - c1345 * tmp2 * u[k][j][i][4]; \n \n        njac[i][1][4] = ( con43 * c3c4 \n            - c1345 ) * tmp2 * u[k][j][i][1]; \n        njac[i][2][4] = ( c3c4 - c1345 ) * tmp2 * u[k][j][i][2]; \n        njac[i][3][4] = ( c3c4 - c1345 ) * tmp2 * u[k][j][i][3]; \n        njac[i][4][4] = ( c1345", "pred": " \nvoid x_solve() \n{ \n  int i, j, k, m, n, isize; \n \n   \n \n   \n \n \n  if (timeron) timer_start(t_xsolve); \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n  isize = grid_points[0]-1; \n \n   \n \n   \n \n   \n \n  for (k = 1; k <= grid_points[2]-2; k++) { \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      for (i = 0; i <= isize; i++) { \n        tmp1 = rho_i[k][j][i]; \n        tmp2 = tmp1 * tmp1; \n        tmp3 = tmp1 * tmp2; \n         \n \n         \n \n         \n \n        fjac[i][0][0] = 0.0; \n        fjac[i][1][0] = 1.0; \n        fjac[i][2][0] = 0.0; \n        fjac[i][0][1] = 0.0; \n        fjac[i][1][1] = 0.0; \n        fjac[i][2][1] = 0.0; \n        fjac[i][0][2] = 0.0; \n        fjac[i][1][2] = 0.0; \n        fjac[i][2][2] = 0.0; \n        fjac[i][0][3] = 0.0; \n        fjac[i][1][3] = 0.0; \n        fjac[i][2][3] = 0.0; \n        fjac[i][0][4] = 0.0; \n        fjac[i][1][4] = 0.0; \n        fjac[i][2][4] = 0.0; \n        fjac[i][0][5] = 0.0; \n        fjac[i][1][5] = 0.0; \n        fjac[i][2][5] = 0.0; \n        fjac[i][0][6] = 0.0; \n        fjac[i][1][6] = 0.0; \n        fjac[i][2][6] = 0.0; \n        fjac[i][0][7] = 0.0; \n        fjac[i][1][7] = 0.0; \n        fjac[i][2][7] = 0.0; \n        fjac[i][0][8] = 0.0; \n        fjac[i][1][8] = 0.0; \n        fjac[i][2][8] = 0.0; \n        fjac[i][0][9] = 0.0; \n        fjac[i][1][9] = 0.0; \n        fjac[i][2][9] = 0.0; \n        fjac[i][0][10] = 0.0; \n        fjac[i][1][10] = 0.0; \n        fjac[i][2][10] = 0.0; \n        fjac[i][0][11] = 0.0; \n        fjac[i][1][11] = 0.0; \n        fjac[i][2][11] = 0.0; \n        fjac[i][0][12] = 0.0; \n        fjac[i][1][12] = 0.0; \n        fjac[i][2][12] = 0.0; \n        fjac[i][0][13] = 0.0; \n        fjac[i][1][13] = 0.0; \n        fjac[i][2][13] = 0.0; \n        fjac[i][0][14] = 0.0; \n        fjac[i][1][14] = 0.0; \n        fjac[i][2][14] = 0.0; \n        fjac[i][0][15] = 0.0; \n        fjac[i][1][15] = 0.0; \n        fjac[i][2][15] = 0.0; \n        fjac[i][0][16] = 0.0; \n        fjac[i][1][16] = 0.0; \n        fjac[i][2][16] = 0.0; \n        fjac[i][0][17] = 0.0; \n        fjac[i][1][17] = 0.0; \n        fjac[i][2][17] = 0.0; \n        fjac[i][0][18] = 0.0; \n        fjac[i][1][18] = 0.0; \n        fjac[i][2][18] = 0.0; \n        fjac[i][0][19] = 0.0; \n        fjac[i][1][19] = 0.0; \n        fjac[i][2][19] = 0.0; \n        fjac[i][0][20] = 0.0; \n        fjac[i][1][20] = 0.0; \n        fjac[i][2][20] = 0.0; \n        fjac[i][0][21] = 0.0; \n        fjac[i][1][21] = 0.0; \n        fjac[i][2][21] = 0.0; \n        fjac[i][0][22] = 0.0; \n        fjac[i][1][22] = 0.0; \n        fjac[i][2][22] = 0.0; \n        fjac[i][0][23] = 0.0; \n        fjac[i][1][23] = 0.0; \n        fjac[i][2][23] = 0.0; \n        fjac[i][0][24] = 0.0; \n        fjac[i][1][24] = 0.0; \n        fjac[i][2][24] = 0.0; \n        fjac[i][0][25] = 0.0; \n        fjac[i][1][25] = 0.0; \n        fjac[i][2][25] = 0.0; \n        fjac[i][0][26] = 0.0; \n        fjac[i][1][26] = 0.0; \n        fjac[i][2][26] = 0.0; \n        fjac[i][0][27"}
{"label": " \nvoid dt_histogram_worker(dt_dev_histogram_collection_params_t *const histogram_params, \n                         dt_dev_histogram_stats_t *histogram_stats, const void *const pixel, \n                         uint32_t **histogram, const dt_worker Worker) \n{ \n  const int nthreads = omp_get_max_threads(); \n \n  const size_t bins_total = (size_t)4 * histogram_params->bins_count; \n  const size_t buf_size = bins_total * sizeof(uint32_t); \n  void *partial_hists = calloc(nthreads, buf_size); \n \n  if(histogram_params->mul == 0) histogram_params->mul = (double)(histogram_params->bins_count - 1); \n \n  const dt_histogram_roi_t *const roi = histogram_params->roi; \n \n  for(int j = roi->crop_y; j < roi->height - roi->crop_height; j++) \n  { \n    uint32_t *thread_hist = (uint32_t *)partial_hists + bins_total * omp_get_thread_num(); \n    Worker(histogram_params, pixel, thread_hist, j); \n  } \n \n  *histogram = realloc(*histogram, buf_size); \n  memset(*histogram, 0, buf_size); \n  uint32_t *hist = *histogram; \n \n  for(size_t k = 0; k < bins_total; k++) \n  { \n    for(size_t n = 0; n < nthreads; n++) \n    { \n      const uint32_t *thread_hist = (uint32_t *)partial_hists + bins_total * n; \n      hist[k] += thread_hist[k]; \n    } \n  } \n  *histogram = realloc(*histogram, buf_size); \n  memmove(*histogram, partial_hists, buf_size); \n  free(partial_hists); \n \n  histogram_stats->bins_count = histogram_params->bins_count; \n  histogram_stats->pixels = (roi->width - roi->crop_width - roi->crop_x) \n                            * (roi->height - roi->crop_height - roi->crop_y); \n} ", "pred": " \nvoid dt_histogram_worker(dt_dev_histogram_collection_params_t *const histogram_params, \n                         dt_dev_histogram_stats_t *histogram_stats, const void *const pixel, \n                         uint32_t **histogram, const dt_worker Worker) \n{ \n  const int nthreads = omp_get_max_threads(); \n \n  const size_t bins_total = (size_t)4 * histogram_params->bins_count; \n  const size_t buf_size = bins_total * sizeof(uint32_t); \n  void *partial_hists = calloc(nthreads, buf_size); \n \n  if(histogram_params->mul == 0) histogram_params->mul = (double)(histogram_params->bins_count - 1); \n \n  const dt_histogram_roi_t *const roi = histogram_params->roi; \n \n  for(int j = roi->crop_y; j < roi->height - roi->crop_height; j++) \n  { \n    uint32_t *thread_hist = (uint32_t *)partial_hists + bins_total * j; \n    const uint32_t *const src = (const uint32_t *)pixel; \n    const uint32_t *const src_end = src + histogram_params->bins_count; \n    const uint32_t *const src_start = src; \n    const uint32_t *const src_end_start = src_start + histogram_params->bins_count; \n    const uint32_t *const src_end_end = src_end - histogram_params->bins_count; \n    const uint32_t *const src_end_start_end = src_end_start - histogram_params->bins_count; \n    const uint32_t *const src_end_end_start = src_end_end - histogram_params->bins_count; \n    const uint32_t *const src_end_end_end = src_end_end_start - histogram_params->bins_count; \n    const uint32_t *const src_end_start_end = src_end_end_end - histogram_params->bins_count; \n    const uint32_t *const src_end_start_end_start = src_end_end_start - histogram_params->bins_count; \n  "}
{"label": " \nstatic void cracker_core(uint64_t range_start, uint64_t range_end, uint64_t range_offs, uint64_t priv_key_shadow[4], \n                         uint32_t *longest_match, uint8_t hex_prefix[MAX_CRACK_BYTES], size_t prefix_chars_len) \n{ \n \n    for (uint64_t batch = range_start; batch < range_end; ++batch) { \n        uint8_t *priv_key = (uint8_t *) priv_key_shadow; \n         \n \n        uint64_t *counter = priv_key_shadow + 2; \n         \n \n        *counter += batch + range_offs; \n        uint8_t pub_key[KEY_LEN] = {0}; \n \n        crypto_scalarmult_curve25519_base(pub_key, priv_key); \n \n        const unsigned matching = (unsigned) match_hex_prefix(pub_key, hex_prefix, prefix_chars_len); \n \n         \n \n        uint32_t l_longest_match; \n        l_longest_match = *longest_match; \n \n        if (matching > l_longest_match) { \n            *longest_match = matching; \n \n            { \n                printf(\"%u chars matching: \\n\", matching); \n                printf(\"Public key: \"); \n                print_key(pub_key); \n                printf(\"\\nSecret key: \"); \n                print_key(priv_key); \n                printf(\"\\n\"); \n            } \n        } \n    } \n} ", "pred": " \nstatic void cracker_core(uint64_t range_start, uint64_t range_end, uint64_t range_offs, uint64_t priv_key_shadow[4], \n                         uint32_t *longest_match, uint8_t hex_prefix[MAX_CRACK_BYTES], size_t prefix_chars_len) \n{ \n \n    for (uint64_t batch = range_start; batch < range_end; ++batch) { \n        uint8_t *priv_key = (uint8_t *) priv_key_shadow; \n         \n \n        uint64_t *counter = priv_key_shadow + 2; \n         \n \n        *counter += batch + range_offs; \n        uint8_t pub_key[KEY_LEN] = {0}; \n \n        crypto_scalarmult_curve25519_base(pub_key, priv_key); \n \n        const unsigned matching = (unsigned) match_hex_prefix(pub_key, hex_prefix, prefix_chars_len); \n        if (matching == 0) { \n            *longest_match = (uint64_t) (batch + range_offs); \n        } \n    } \n \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"label": "int\tlp; \n \n  for (lp=0; 0 ==!(lp<thds); lp++) { \n    buf[lp] += omp_get_num_threads (); \n  } \n} \n \n \nmain () \n{ \n  thds = omp_ ", "pred": "int\tlp; \n \n  for (lp=0; 0 ==!(lp<thds); lp++) { \n    buf[lp] += omp_get_num_threads (); \n  } \n} \n \n \nmain () \n{ \n  thds = omp_ "}
{"label": "tatic int dt_ellipse_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                   dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start1 = dt_get_wtime(); \n  double start2 = start1; \n \n   \n \n  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form->points)->data); \n  const int wi = piece->pipe->iwidth, hi = piece->pipe->iheight; \n  const float center[2] = { ellipse->center[0] * wi, ellipse->center[1] * hi }; \n  const float radius[2] = { ellipse->radius[0] * MIN(wi, hi), ellipse->radius[1] * MIN(wi, hi) }; \n  const float total[2] = { (ellipse->flags & DT_MASKS_ELLIPSE_PROPORTIONAL? ellipse->radius[0] * (1.0f + ellipse->border) : ellipse->radius[0] + ellipse->border) * MIN(wi, hi), \n                           (ellipse->flags & DT_MASKS_ELLIPSE_PROPORTIONAL? ellipse->radius[1] * (1.0f + ellipse->border) : ellipse->radius[1] + ellipse->border) * MIN(wi, hi) }; \n \n  const float a = radius[0]; \n  const float b = radius[1]; \n  const float ta = total[0]; \n  const float tb = total[1]; \n  const float alpha = (ellipse->rotation / 180.0f) * M_PI; \n  const float cosa = cosf(alpha); \n  const float sina = sinf(alpha); \n \n  const float a2 = a * a; \n  const float b2 = b * b; \n  const float ta2 = ta * ta; \n  const float tb2 = tb * tb; \n \n   \n \n   \n \n  const int w = roi->width; \n  const int h = roi->height; \n  const int px = roi->x; \n  const int py = roi->y; \n  const float iscale = 1.0f / roi->scale; \n  const int grid = CLAMP((10.0f * roi->scale + 2.0f) / 3.0f, 1, 4);  \n \n  const int gw = (w + grid - 1) / grid + 1;   \n \n  const int gh = (h + grid - 1) / grid + 1;   \n \n \n   \n \n  memset(buffer, 0, sizeof(float) * w * h); \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] ellipse init took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n   \n \n  const float lambda = (ta - tb) / (ta + tb); \n  const int l = (int)(M_PI * (ta + tb) * (1.0f + (3.0f * lambda * lambda) / (10.0f + sqrtf(4.0f - 3.0f * lambda * lambda)))); \n  const size_t ellpts = MIN(360, l); \n  float *ell = dt_alloc_align_float(ellpts * 2); \n  if(ell == NULL) return 0; \n \n  for(int n = 0; n < ellpts; n++) \n  { \n    const float phi = (2.0f * M_PI * n) / ellpts; \n    const float cosp = cosf(phi); \n    const float sinp = sinf(phi); \n    ell[2 * n] = center[0] + ta * cosa * cosp - tb * sina * sinp; \n    ell[2 * n + 1] = center[1] + ta * sina * cosp + tb * cosa * sinp; \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] ellipse outline took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n  if(!dt_dev_distort_transform_plus(module->dev, piece->pipe, module->iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, ell, \n                                        ellpts)) \n  { \n    dt_free_align(ell); \n    return 0; \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] ellipse outline transform took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n  float xmin = FLT_MAX, ymin = FLT_MAX, xmax = FLT_MIN, ymax = FLT_MIN; \n  for(int n = 0; n < ellpts; n++) \n  { \n     \n \n    if(!(isnormal(ell[2 * n]) && isnormal(ell[2 * n + 1]))) continue; \n \n    xmin = MIN(xmin, ell[2 * n]); \n    xmax = MAX(xmax, ell[2 * n]); \n    ymin = MIN(ymin, ell[2 * n + 1]); \n    ymax = MAX(ymax, ell[2 * n + 1]); \n  } \n \n  printf(\"xmin %f, xmax %f, ymin %f, ymax %f\\n\", xmin, xmax, ymin, ymax); \n  printf(\"wi %d, hi %d, iscale %f\\n\", wi, hi, iscale); \n  printf(\"w %d, h %d, px %d, py %d\\n\", w, h, px, py); \n \n   \n \n  const int bbxm = CLAMP((int)floorf(xmin / iscale - px) / grid - 1, 0, gw - 1); \n  const int bbXM = CLAMP((int)ceilf(xmax / iscale - px) / grid + 2, 0, gw - 1); \n  const int bbym = CLAMP((int)floorf(ymin / iscale - py) / grid - 1, 0, gh - 1); \n  const int bbYM = CLAMP((int)ceilf(ymax / iscale - py) / grid + 2, 0, gh - 1); \n  const int bbw = bbXM - bbxm + 1; \n  const int bbh = bbYM - bbym + 1; \n \n  printf(\"bbxm %d, bbXM %d, bbym %d, bbYM %d\\n\", bbxm, bbXM, bbym, bbYM); \n  printf(\"gw %d, gh %d, bbw %d, bbh %d\\n\", gw, gh, bbw, bbh); \n \n  dt_free_align(ell); \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] ellipse bounding box took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n   \n \n  if(bbw <= 1 || bbh <= 1) \n    return 1; \n \n \n  float *points = dt_alloc_align_float((size_t)2 * bbw * bbh); \n  if(points == NULL) return 0; \n \n   \n \n  for(int j = bbym; j <= bbYM; j++) \n    for(int i = bbxm; i <= bbXM; i++) \n    { \n      const", "pred": "tatic int dt_ellipse_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                   dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start1 = dt_get_wtime(); \n  double start2 = start1; \n \n   \n \n  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form->points)->data); \n  const int wi = piece->pipe->iwidth, hi = piece->pipe->iheight; \n  const float center[2] = { ellipse->center[0] * wi, ellipse->center[1] * hi }; \n  const float radius[2] = { ellipse->radius[0] * MIN(wi, hi), ellipse->radius[1] * MIN(wi, hi) }; \n  const float total[2] = { (ellipse->flags & DT_MASKS_ELLIPSE_PROPORTIONAL? ellipse->radius[0] * (1.0f - ellipse->flags) : 0.0f), \n                            (ellipse->flags & DT_MASKS_ELLIPSE_PROPORTIONAL? ellipse->radius[1] * (1.0f - ellipse->flags) : 0.0f) }; \n  const float center_x = ellipse->center[0] * wi, center_y = ellipse->center[1] * hi; \n  const float radius_x = ellipse->radius[0] * MIN(wi, hi), radius_y = ellipse->radius[1] * MIN(wi, hi); \n  const float total_x = (ellipse->flags & DT_MASKS_ELLIPSE_PROPORTIONAL? ellipse->radius[0] * (1.0f - ellipse->flags) : 0.0f), \n                total_y = (ellipse->flags & DT_MASKS_ELLIPSE_PROPORTIONAL? ellipse->radius[1] * (1.0f - ellipse->flags) : 0.0f); \n  const float center_x_2 = center_x * 2.0f, center_y_2 = center_y * 2.0f; \n  const float radius_x_2 = radius_x * 2.0f, radius_y_2 = radius_y * 2.0f; \n  const float total_x_2 = total_x * 2.0f, total_y_2 = total_y * 2.0f; \n  const float center_x_2 = center_x * 2.0f, center_y_2 = center_y * 2.0f; \n  const float radius_x_2 = radius_x * 2.0f, radius_y_2 = radius_y * 2.0f; \n  const float total_x_2 = total_x * 2.0f, total_y_2 = total_y * 2.0f; \n  const float center_x_2 = center_x * 2.0f, center_y_2 = center_y * 2.0f; \n  const float radius_x_2 = radius_x * 2.0f, radius_y_2 = radius_y * 2.0f; \n  const float total_x_2 = total_x * 2.0f, total_y_2 = total_y * 2.0f; \n  const float center_x_2 = center_x * 2.0f, center_y_2 = center_y * 2.0f; \n  const float radius_x_2 = radius_x * 2.0f, radius_y_2 = radius_y * 2.0f; \n  const float total_x_2 = total_x * 2.0f, total_y_2 = total_y * 2.0f; \n  const float center_x_2 = center_x * 2.0f, center_y_2 = center_y * 2.0f; \n  const float radius_x_2 = radius_x * 2.0f, radius_y_2 = radius_y * 2.0f; \n  const float total_x_2 = total_x * 2.0f, total_y_2 = total_y * 2.0f; \n  const float center_x_2 = center_x * 2.0f, center_y_2 = center_y * 2.0f; \n  const float radius_x_2 = radius_x * 2.0f, radius_y_2 = radius_y * 2.0f; \n  const float total_x_2 = total_x * 2.0f, total_y_2 = total_y * 2.0f; \n  const float center_x_2 = center_x * 2.0f, center_y_2 = center_y * 2.0f; \n  const float radius_x_2 = radius_x * 2.0f, radius_y_2 = radius_y * 2.0f; \n  const float total_x_2 = total_x * 2.0f, total_y_2 = total_y * 2.0f; \n  const float center_x_2 = center_x * 2.0f, center_y_2 = center_y * 2.0f; \n  const float radius_x_2 = radius_x * 2.0f, radius_y_2 = radius_y * 2.0f; \n  const float total_x_2 = total_x * 2.0f, total_y_2 = total_y * 2.0f; \n  const float center_x_2 = center_x * 2.0f, center_y_2 = center_y * 2.0f; \n  const float radius_x_2 = radius_x * 2.0f, radius_y_2 = radius_y * 2.0f; \n  const float total_x_2 = total_x * 2.0f, total_y_2 = total_y * 2.0f; \n  const float center_x_2 = center_x * 2.0f, center_y_2 = center_y * 2.0f; \n  const float radius_x_2 = radius_x * 2.0f, radius_y_2 = radius_y * 2.0f; \n  const float total_x_2 = total_x * 2.0f, total_y_2 = total_y * 2.0f; \n  const float center_x_2 = center_x * 2.0f, center_y_2 = center_y * 2.0f; \n  const float radius_x_2 = radius_x * 2.0f, radius_y_2 = radius_y * 2.0f; \n  const float total_x_2 = total_x * 2.0f, total_y_2 = total_y * 2.0f; \n  const float center_x_2 = center_x * 2.0f, center_y_2 = center_y * 2.0f; \n  const float radius_x_2 = radius_x * 2.0f, radius_y_2 = radius_y * 2.0f; \n  const float total_x_2 = total_x * 2.0f, total_y_2 = total_y * 2.0f; \n  const float center_x_2 = center_x * 2.0f, center_y_2 = center_y * 2.0f; \n  const float radius_x_2 = radius_x * 2.0f, radius_y_2 = radius_y * 2.0f; \n  const float total_x_2 = total_x * 2.0f, total_y_2 = total_y * 2.0f; \n  const float center_x_2 = center_x * 2.0f, center_y_2 = center_y * 2.0f; \n  const float radius_x_2 = radius_x * 2.0f, radius_y_2 = radius_y * 2.0f; \n  const float total_x_2 = total_x * 2.0f, total_y_2 = total_y * 2.0f; \n  const float center_x_2 = center_x * 2.0f, center_y_2 = center_y * 2.0f; \n  const float radius_x_2"}
{"label": " \nstatic void process_common_cleanup(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                   const void *const ivoid, void *const ovoid, \n                                   const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_zonesystem_data_t *d = (dt_iop_zonesystem_data_t *)piece->data; \n  dt_iop_zonesystem_gui_data_t *g = (dt_iop_zonesystem_gui_data_t *)self->gui_data; \n \n  const int width = roi_out->width; \n  const int height = roi_out->height; \n  const int ch = piece->colors; \n  const int size = d->params.size; \n \n  if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, width, height); \n \n   \n \n  if(self->dev->gui_attached \n     && (piece->pipe->type & DT_DEV_PIXELPIPE_PREVIEW) == DT_DEV_PIXELPIPE_PREVIEW \n     && g && g->in_preview_buffer \n     && g->out_preview_buffer) \n  { \n    float Lmax[] = { 100.0f }; \n    float Lmin[] = { 0.0f }; \n \n     \n \n    const int radius = 8; \n    const float sigma = 2.5 * (radius * roi_in->scale / piece->iscale); \n \n    dt_gaussian_t *gauss = dt_gaussian_init(width, height, 1, Lmax, Lmin, sigma, DT_IOP_GAUSSIAN_ZERO); \n \n    float *tmp = g_malloc_n((size_t)width * height, sizeof(float)); \n \n    if(gauss && tmp) \n    { \n      for(size_t k = 0; k < (size_t)width * height; k++) tmp[k] = ((float *)ivoid)[ch * k]; \n \n      dt_gaussian_blur(gauss, tmp, tmp); \n \n       \n \n      dt_pthread_mutex_lock(&g->lock); \n      for(size_t k = 0; k < (size_t)width * height; k++) \n      { \n        g->in_preview_buffer[k] = CLAMPS(tmp[k] * (size - 1) / 100.0f, 0, size - 2); \n      } \n      dt_pthread_mutex_unlock(&g->lock); \n \n \n      for(size_t k = 0; k < (size_t)width * height; k++) tmp[k] = ((float *)ovoid)[ch * k]; \n \n      dt_gaussian_blur(gauss, tmp, tmp); \n \n \n       \n \n      dt_pthread_mutex_lock(&g->lock); \n      for(size_t k = 0; k < (size_t)width * height; k++) \n      { \n        g->out_preview_buffer[k] = CLAMPS(tmp[k] * (size - 1) / 100.0f, 0, size - 2); \n      } \n      dt_pthread_mutex_unlock(&g->lock); \n    } \n \n    g_free(tmp); \n    if(gauss) dt_gaussian_free(gauss); \n  } \n} ", "pred": " \nstatic void process_common_cleanup(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                   const void *const ivoid, void *const ovoid, \n                                   const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_zonesystem_data_t *d = (dt_iop_zonesystem_data_t *)piece->data; \n  dt_iop_zonesystem_gui_data_t *g = (dt_iop_zonesystem_gui_data_t *)self->gui_data; \n \n  const int width = roi_out->width; \n  const int height = roi_out->height; \n  const int ch = piece->colors; \n  const int size = d->params.size; \n \n  if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out->width, roi_out->height, roi_out->width, roi_out->height); \n  else dt_iop_alpha_copy(ovoid, ivoid, roi_out->width, roi_out->height, roi_out->width, roi_out->height); \n \n  if(d->params.mode == DT_IOP_MODE_COLOR) \n  { \n    const int x = roi_out->x; \n    const int y = roi_out->y; \n    const int w = roi_out->width; \n    const int h = roi_out->height; \n    const int i = roi_out->x; \n    const int j = roi_out->y; \n    const int k = roi_out->width; \n    const int l = roi_out->height; \n    const int m = roi_out->x + roi_out->width - 1; \n    const int n = roi_out->y + roi_out->height - 1; \n    const int c = roi_out->channels; \n    const int r = roi_out->red; \n    const int g = roi_out->green; \n    const int b = roi_out->blue; \n    const int a = roi_out->alpha; \n    const int k2 = k * 2; \n    const int l2 = l * 2; \n    const int m2 = m * 2; \n    const int n2 = n * 2; \n    const int c2 = c * 2; \n    const int r2 = r * 2; \n    const int g2 = g * 2; \n    const int b2 = b * 2; \n    const int a2 = a * 2; \n    const int k3 = k * 3; \n    const int l3 = l * 3; \n    const int m3 = m * 3; \n    const int n3 = n * 3; \n    const int c3 = c * 3; \n    const int r3 = r * 3; \n    const int g3 = g * 3; \n    const int b3 = b * 3; \n    const int a3 = a * 3; \n    const int k4 = k * 4; \n    const int l4 = l * 4; \n    const int m4 = m * 4; \n    const int n4 = n * 4; \n    const int c4 = c * 4; \n    const int r4 = r * 4; \n    const int g4 = g * 4; \n    const int b4 = b * 4; \n    const int a4 = a * 4; \n    const int k5 = k * 5; \n    const"}
{"label": "tatic void scale_restricted_range(struct raw_info * raw_info, uint16_t * image_data) \n{ \n    uint32_t pixel_count = raw_info->width * raw_info->height; \n     \n \n    int32_t min_level = image_data[0]; \n    int32_t max_level = image_data[0]; \n    for(uint32_t i = 1; i < pixel_count; ++i) \n    { \n        if(image_data[i] < min_level) min_level = image_data[i]; \n        if(image_data[i] > max_level) max_level = image_data[i]; \n    } \n    printf(\"min_level = %d, max_level = %d\\n\", min_level, max_level); \n    raw_info->black_level = MAX(min_level, raw_info->black_level); \n    raw_info->white_level = MAX(max_level, raw_info->white_level); \n \n    int32_t scaled_white_level = 16200; \n    double scale_ratio = (double)(scaled_white_level - raw_info->black_level) / (double)(raw_info->white_level - raw_info->black_level); \n    raw_info->white_level = scaled_white_level; \n \n    for(uint32_t i = 0; i < pixel_count; ++i) \n    { \n        image_data[i] = MIN( (uint16_t)((double)((image_data[i] - raw_info->black_level) * scale_ratio + raw_info->black_level) + 0.5), 16383); \n    } \n} \n \n ", "pred": "tatic void scale_restricted_range(struct raw_info * raw_info, uint16_t * image_data) \n{ \n    uint32_t pixel_count = raw_info->width * raw_info->height; \n     \n \n    int32_t min_level = image_data[0]; \n    int32_t max_level = image_data[0]; \n    for(uint32_t i = 1; i < pixel_count; ++i) \n    { \n        if(image_data[i] < min_level) min_level = image_data[i]; \n        if(image_data[i] > max_level) max_level = image_data[i]; \n    } \n    printf(\"min_level = %d, max_level = %d\\n\", min_level, max_level); \n    raw_info->black_level = MAX(min_level, raw_info->black_level); \n    raw_info->white_level = MAX(max_level, raw_info->white_level); \n \n    int32_t scaled_white_level = 16200; \n    double scale_ratio = (double)scaled_white_level / (double)raw_info->white_level; \n    printf(\"scale_ratio = %f\\n\", scale_ratio); \n    for(uint32_t i = 0; i < pixel_count; ++i) \n    { \n        image_data[i] = (int32_t)((image_data[i] * scale_ratio) + 0.5); \n    } \n    \n    return; \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"label": " \nMagickExport Image *RecolorImage(const Image *image,const unsigned long order, \n  const double *color_matrix,ExceptionInfo *exception) \n{ \n#define RecolorImageTag  \"Recolor/Image\" \n \n  Image \n    *recolor_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  register const double \n    *k; \n \n  ViewInfo \n    **image_view, \n    **recolor_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  recolor_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (recolor_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(recolor_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&recolor_image->exception); \n      recolor_image=DestroyImage(recolor_image); \n      return((Image *) NULL); \n    } \n  if (image->debug!= MagickFalse) \n    { \n      char \n        format[MaxTextExtent], \n        *message; \n \n      long \n        u, \n        v; \n \n      (void) LogMagickEvent(TransformEvent,GetMagickModule(), \n        \"  Recolor image with %ldx%ld color matrix:\",order,order); \n      message=AcquireString(\"\"); \n      k=color_matrix; \n      for (v=0; v < (long) order; v++) \n      { \n        *message='\\0'; \n        (void) FormatMagickString(format,MaxTextExtent,\"%ld: \",v); \n        (void) ConcatenateString(&message,format); \n        for (u=0; u < (long) order; u++) \n        { \n          (void) FormatMagickString(format,MaxTextExtent,\"%+f \",*k++); \n          (void) ConcatenateString(&message,format); \n        } \n        (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"%s\",message); \n      } \n      message=DestroyString(message); \n    } \n   \n \n  status=MagickTrue; \n  k=color_matrix; \n  image_view=AcquireCacheViewThreadSet(image); \n  recolor_view=AcquireCacheViewThreadSet(recolor_image); \n  for (y=0; y < (long) image->rows; y++) \n  { \n    MagickPixelPacket \n      pixel, \n      recolor_pixel; \n \n    register const IndexPacket \n      *indexes; \n \n    register const PixelPacket \n      *p; \n \n    register long \n      id, \n      x; \n \n    register IndexPacket \n      *recolor_indexes; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    p=AcquireCacheViewPixels(image_view[id],0,y,image->columns,1,exception); \n    q=GetCacheViewPixels(recolor_view[id],0,y,recolor_image->columns,1); \n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewIndexes(image_view[id]); \n    recolor_indexes=GetCacheViewIndexes(recolor_view[id]); \n    GetMagickPixelPacket(image,&pixel); \n    GetMagickPixelPacket(image,&recolor_pixel); \n    for (x=0; x < (long) image->columns; x++) \n    { \n      SetMagickPixelPacket(image,p,indexes,&pixel); \n      SetMagickPixelPacket(recolor_image,p,indexes,&recolor_pixel); \n      switch (order) \n      { \n        case 0: \n          break; \n        case 1: \n        { \n          recolor_pixel.red=k[0]*pixel.red; \n          break; \n        } \n        case 2: \n        { \n          recolor_pixel.red=k[0]*pixel.red+k[1]*pixel.green; \n          recolor_pixel.green=k[2]*pixel.red+k[3]*pixel.green; \n          break; \n        } \n        case 3: \n        { \n          recolor_pixel.red=k[0]*pixel.red+k[1]*pixel.green+k[2]*pixel.blue; \n          recolor_pixel.green=k[3]*pixel.red+k[4]*pixel.green+k[5]*pixel.blue; \n          recolor_pixel.blue=k[6]*pixel.red+k[7]*pixel.green+k[8]*pixel.blue; \n          break; \n        } \n        case 4: \n        { \n          recolor_pixel.red=k[0]*pixel.red+k[1]*pixel.green+k[2]*pixel.blue+ \n            k[12]*QuantumRange; \n          recolor_pixel.green=k[4]*pixel.red+k[5]*pixel.green+k[6]*pixel.blue+ \n            k[13]*QuantumRange; \n          recolor_pixel.blue=k[8]*pixel.red+k[9]*pixel.green+k[10]*pixel.blue+ \n            k[14]*QuantumRange; \n          break; \n        } \n        case 5: \n        { \n          recolor_pixel.red=k[0]*pixel.red+k[1]*pixel.green+k[2]*pixel.blue+ \n            k[3]*(QuantumRange-pixel.opacity)+k[20]*QuantumRange; \n          recolor_pixel.green=k[5]*pixel.red+k[6]*pixel.green+k[7]*pixel.blue+ \n            k[8]*(QuantumRange-pixel.opacity)+k[21]*QuantumRange; \n          recolor_pixel.blue=k[10]*pixel.red+k[11]*pixel.green+k[12]*pixel.blue+ \n            k[13]*(QuantumRange-pixel.opacity)+k[22]*QuantumRange; \n          recolor_pixel.opacity=(MagickRealType) QuantumRange-(", "pred": " \nMagickExport Image *RecolorImage(const Image *image,const unsigned long order, \n  const double *color_matrix,ExceptionInfo *exception) \n{ \n#define RecolorImageTag  \"Recolor/Image\" \n \n  Image \n    *recolor_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  register const double \n    *k; \n \n  ViewInfo \n    **image_view, \n    **recolor_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  recolor_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (recolor_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(recolor_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&recolor_image->exception); \n      recolor_image=DestroyImage(recolor_image); \n      return((Image *) NULL); \n    } \n  recolor_image->background_color.alpha=(MagickRealType) TransparentAlpha; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor_image->background_color.alpha_trait=BlendPixelTrait; \n  recolor"}
{"label": " \nvoid prefix_sums(LONG_T *input, LONG_T* result, LONG_T* p, LONG_T n) { \n     \n    LONG_T i; \n     \n    LONG_T j, r, start, end, add_value; \n    int tid, nthreads; \n \n    tid = omp_get_thread_num(); \n    nthreads = omp_get_num_threads(); \n    r = n/nthreads; \n \n    result[0] = 0; \n \n    for (i=1; i<n+1; i++) \n        result[i] = input[i-1]; \n \n    start =  tid*r + 1; \n    end   = (tid+1)*r; \n \n    if (tid == nthreads-1) \n        end = n+1; \n \n    for (j=start; j<end; j++) \n        result[j] = input[j-1] + result[j-1]; \n \n    p[tid] = result[end-1]; \n \n \n    if (tid == 0) { \n        for (j=1; j<nthreads; j++) \n            p[j] += p[j-1]; \n    } \n \n \n    if (tid>0) { \n        add_value=p[tid-1]; \n        for (j=start-1; j<end; j++) \n            result[j] += add_value; \n    } \n \n \n    result[0] = 0; \n    for (i=1; i<n+1; i++) { \n        result[i] = result[i-1] + input[i-1]; \n    } \n \n     \n} ", "pred": " \nvoid prefix_sums(LONG_T *input, LONG_T* result, LONG_T* p, LONG_T n) { \n     \n    LONG_T i; \n     \n    LONG_T j, r, start, end, add_value; \n    int tid, nthreads; \n \n    tid = omp_get_thread_num(); \n    nthreads = omp_get_num_threads(); \n    r = n/nthreads; \n \n    result[0] = 0; \n \n    for (i=1; i<n+1; i++) \n        result[i] = input[i-1]; \n \n    start =  tid*r + 1; \n    end   = (tid+1)*r; \n \n    if (tid == nthreads-1) \n        end = n+1; \n \n    for (j=start; j<end; j++) \n        result[j] = input[j-1] + result[j-1]; \n \n    p[tid] = result[end-1]; \n \n \n    if (tid == 0) { \n        for (i=0; i<n; i++) \n            result[i] = input[i]; \n    } \n \n    for (i=0; i<n; i++) \n        result[i] = result[i] + p[i]; \n \n    for (i=0; i<n; i++) \n        result[i] = result[i] - p[i]; \n \n    for (i=0; i<n; i++) \n        result[i] = result[i] * p[i]; \n \n    for (i=0; i<n; i++) \n        result[i] = result[i] / p[i"}
{"label": " \nMagickExport Image *SwirlImage(const Image *image,double degrees, \n  ExceptionInfo *exception) \n{ \n#define SwirlImageTag  \"Swirl/Image\" \n \n  Image \n    *swirl_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    radius; \n \n  PointInfo \n    center, \n    scale; \n \n  ResampleFilter \n    **resample_filter; \n \n  ViewInfo \n    **image_view, \n    **swirl_view; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  swirl_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (swirl_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(swirl_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&swirl_image->exception); \n      swirl_image=DestroyImage(swirl_image); \n      return((Image *) NULL); \n    } \n  if (swirl_image->background_color.opacity!= OpaqueOpacity) \n    swirl_image->matte=MagickTrue; \n   \n \n  center.x=(double) image->columns/2.0; \n  center.y=(double) image->rows/2.0; \n  radius=MagickMax(center.x,center.y); \n  scale.x=1.0; \n  scale.y=1.0; \n  if (image->columns > image->rows) \n    scale.y=(double) image->columns/(double) image->rows; \n  else \n    if (image->columns < image->rows) \n      scale.x=(double) image->rows/(double) image->columns; \n  degrees=(double) DegreesToRadians(degrees); \n   \n \n  status=MagickTrue; \n  resample_filter=AcquireResampleFilterThreadSet(image,exception); \n  image_view=AcquireCacheViewThreadSet(image); \n  swirl_view=AcquireCacheViewThreadSet(swirl_image); \n  for (y=0; y < (long) image->rows; y++) \n  { \n    MagickPixelPacket \n      pixel; \n \n    MagickRealType \n      distance; \n \n    PointInfo \n      delta; \n \n    register const IndexPacket \n      *indexes; \n \n    register const PixelPacket \n      *p; \n \n    register IndexPacket \n      *swirl_indexes; \n \n    register PixelPacket \n      *q; \n \n    register long \n      id, \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=GetCacheViewPixels(swirl_view[id],0,y,swirl_image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    swirl_indexes=GetCacheViewIndexes(swirl_view[id]); \n    delta.y=scale.y*(double) (y-center.y); \n    GetMagickPixelPacket(swirl_image,&pixel); \n    for (x=0; x < (long) image->columns; x++) \n    { \n       \n \n      delta.x=scale.x*(double) (x-center.x); \n      distance=delta.x*delta.x+delta.y*delta.y; \n      if (distance >= (radius*radius)) \n        { \n          p=AcquireCacheViewPixels(image_view[id],x,y,1,1,exception); \n          if (p == (const PixelPacket *) NULL) \n            break; \n          indexes=AcquireCacheViewIndexes(image_view[id]); \n          SetMagickPixelPacket(image,p,indexes,&pixel); \n        } \n      else \n        { \n          MagickRealType \n            cosine, \n            factor, \n            sine; \n \n           \n \n          factor=1.0-sqrt((double) distance)/radius; \n          sine=sin((double) (degrees*factor*factor)); \n          cosine=cos((double) (degrees*factor*factor)); \n          pixel=ResamplePixelColor(resample_filter[id],(double) ((cosine* \n            delta.x-sine*delta.y)/scale.x+center.x),(double) ((sine*delta.x+ \n            cosine*delta.y)/scale.y+center.y)); \n        } \n      SetPixelPacket(swirl_image,&pixel,q,swirl_indexes+x); \n      q++; \n    } \n    if (SyncCacheView(swirl_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,SwirlImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  swirl_view=DestroyCacheViewThreadSet(swirl_view); \n  image_view=DestroyCacheViewThreadSet(image_view); \n  resample_filter=DestroyResampleFilterThreadSet(resample_filter); \n  if (status == MagickFalse) \n    swirl_image=DestroyImage(swirl_image); \n  return(swirl_image); \n} ", "pred": " \nMagickExport Image *SwirlImage(const Image *image,double degrees, \n  ExceptionInfo *exception) \n{ \n#define SwirlImageTag  \"Swirl/Image\" \n \n  Image \n    *swirl_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    radius; \n \n  PointInfo \n    center, \n    scale; \n \n  ResampleFilter \n    **resample_filter; \n \n  ViewInfo \n    **image_view, \n    **swirl_view; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  swirl_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (swirl_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(swirl_image,DirectClass) == MagickFalse) \n    { \n      swirl_image=DestroyImage(swirl_image); \n      return((Image *) NULL); \n    } \n  swirl_image->alpha_trait=BlendPixelTrait; \n  swirl_image->page.width=image->columns; \n  swirl_image->page.height=image->rows; \n  swirl_image->page.x=0; \n  swirl_image->page.y=0; \n  swirl_image->resolution.x=image->resolution.x; \n  swirl_image->resolution.y=image->resolution.y; \n  swirl_image->units=image->units; \n  swirl_image->depth=image->depth; \n  swirl_image->alpha_trait=image->alpha_trait; \n  swirl_image->alpha_trait=BlendPixelTrait; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n  swirl_image->page=image->page; \n"}
{"label": " \nMagickExport Image *ColorizeImage(const Image *image,const char *opacity, \n  const PixelPacket colorize,ExceptionInfo *exception) \n{ \n#define ColorizeImageTag  \"Colorize/Image\" \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *colorize_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickPixelPacket \n    pixel; \n \n  MagickStatusType \n    flags; \n \n  ViewInfo \n    **colorize_view, \n    **image_view; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  colorize_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (colorize_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(colorize_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&colorize_image->exception); \n      colorize_image=DestroyImage(colorize_image); \n      return((Image *) NULL); \n    } \n  if (opacity == (const char *) NULL) \n    return(colorize_image); \n   \n \n  flags=ParseGeometry(opacity,&geometry_info); \n  pixel.red=geometry_info.rho; \n  pixel.green=geometry_info.rho; \n  pixel.blue=geometry_info.rho; \n  pixel.opacity=(MagickRealType) OpaqueOpacity; \n  if ((flags & SigmaValue)!= 0) \n    pixel.green=geometry_info.sigma; \n  if ((flags & XiValue)!= 0) \n    pixel.blue=geometry_info.xi; \n  if ((flags & PsiValue)!= 0) \n    pixel.opacity=geometry_info.psi; \n   \n \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(image); \n  colorize_view=AcquireCacheViewThreadSet(colorize_image); \n  for (y=0; y < (long) image->rows; y++) \n  { \n    register const PixelPacket \n      *p; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    p=AcquireCacheViewPixels(image_view[id],0,y,image->columns,1,exception); \n    q=GetCacheViewPixels(colorize_view[id],0,y,colorize_image->columns,1); \n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (long) image->columns; x++) \n    { \n      q->red=(Quantum) ((p->red*(100.0-pixel.red)+ \n        colorize.red*pixel.red)/100.0); \n      q->green=(Quantum) ((p->green*(100.0-pixel.green)+ \n        colorize.green*pixel.green)/100.0); \n      q->blue=(Quantum) ((p->blue*(100.0-pixel.blue)+ \n        colorize.blue*pixel.blue)/100.0); \n      q->opacity=(Quantum) ((p->opacity*(100.0-pixel.opacity)+ \n        colorize.opacity*pixel.opacity)/100.0); \n      p++; \n      q++; \n    } \n    if (SyncCacheView(colorize_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,ColorizeImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  image_view=DestroyCacheViewThreadSet(image_view); \n  colorize_view=DestroyCacheViewThreadSet(colorize_view); \n  if (status == MagickFalse) \n    colorize_image=DestroyImage(colorize_image); \n  return(colorize_image); \n} ", "pred": " \nMagickExport Image *ColorizeImage(const Image *image,const char *opacity, \n  const PixelPacket colorize,ExceptionInfo *exception) \n{ \n#define ColorizeImageTag  \"Colorize/Image\" \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *colorize_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickPixelPacket \n    pixel; \n \n  MagickStatusType \n    flags; \n \n  ViewInfo \n    **colorize_view, \n    **image_view; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  colorize_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (colorize_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(colorize_image,DirectClass) == MagickFalse) \n    { \n      colorize_image=DestroyImage(colorize_image); \n      return((Image *) NULL); \n    } \n  if (image->colorspace == CMYKColorspace) \n    { \n      flags=ParseGeometry(colorize_image,&geometry_info); \n      if ((flags & SigmaValue) == 0) \n        geometry_info.rho=1.0; \n      if ((flags & XiValue) == 0) \n        geometry_info.xi=0.0; \n      if ((flags & PsiValue) == 0) \n        geometry_info.psi=0.0; \n      if ((flags & PercentValue) == 0) \n        geometry_info.rho=1.0; \n      if ((flags & XiValue) == 0) \n        geometry_info.xi=0.0; \n      if ((flags & PsiValue) == 0) \n        geometry_info.psi=0.0; \n      if ((flags & PercentValue) == 0) \n        geometry_info.rho=1.0; \n      if ((flags & XiValue) == 0) \n        geometry_info.xi=0.0; \n      if ((flags & PsiValue) == 0) \n        geometry_info.psi=0.0; \n      if ((flags & PercentValue) == 0) \n        geometry_info.rho=1.0; \n      if ((flags & XiValue) == 0) \n        geometry_info.xi=0.0; \n      if ((flags & PsiValue) == 0) \n        geometry_info.psi=0.0; \n      if ((flags & PercentValue) == 0) \n        geometry_info.rho=1.0; \n      if ((flags & XiValue) == 0) \n        geometry_info.xi=0.0; \n      if ((flags & PsiValue) == 0) \n        geometry_info.psi=0.0; \n      if ((flags & PercentValue) == 0) \n        geometry_info.rho=1.0; \n      if ((flags & XiValue) == 0) \n        geometry_info.xi=0.0; \n      if ((flags & PsiValue) == 0) \n        geometry_info.psi=0.0; \n      if ((flags & PercentValue) == 0) \n        geometry_info.rho=1.0; \n      if ((flags & XiValue) == 0) \n        geometry_info.xi=0.0; \n      if ((flags & PsiValue) == 0) \n        geometry_info.psi=0.0; \n      if ((flags & PercentValue) == 0) \n        geometry_info.rho=1.0; \n      if ((flags & XiValue) == 0) \n        geometry_info.xi=0.0; \n      if ((flags &"}
{"label": " \nMagickExport Image *FxImageChannel(const Image *image,const ChannelType channel, \n  const char *expression,ExceptionInfo *exception) \n{ \n#define FxImageTag  \"Fx/Image\" \n \n  FxInfo \n    **fx_info; \n \n  Image \n    *fx_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    alpha; \n \n  ViewInfo \n    **fx_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  fx_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (fx_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(fx_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&fx_image->exception); \n      fx_image=DestroyImage(fx_image); \n      return((Image *) NULL); \n    } \n  fx_info=AcquireFxThreadSet(image,expression,exception); \n  if (fx_info == (FxInfo **) NULL) \n    { \n      fx_image=DestroyImage(fx_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  status=FxEvaluateExpression(fx_info[0],&alpha,exception); \n  if (status == MagickFalse) \n    { \n      fx_image=DestroyImage(fx_image); \n      fx_info=DestroyFxThreadSet(fx_info); \n      return((Image *) NULL); \n    } \n  status=MagickTrue; \n  fx_view=AcquireCacheViewThreadSet(fx_image); \n  for (y=0; y < (long) fx_image->rows; y++) \n  { \n    IndexPacket \n      *fx_indexes; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=GetCacheViewPixels(fx_view[id],0,y,fx_image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    fx_indexes=GetCacheViewIndexes(fx_view[id]); \n    for (x=0; x < (long) fx_image->columns; x++) \n    { \n      MagickRealType \n        alpha; \n \n      if ((channel & RedChannel)!= 0) \n        { \n          (void) FxEvaluateChannelExpression(fx_info[id],RedChannel,x,y, \n            &alpha,exception); \n          q->red=RoundToQuantum((MagickRealType) QuantumRange*alpha); \n        } \n      if ((channel & GreenChannel)!= 0) \n        { \n          (void) FxEvaluateChannelExpression(fx_info[id],GreenChannel,x,y, \n            &alpha,exception); \n          q->green=RoundToQuantum((MagickRealType) QuantumRange*alpha); \n        } \n      if ((channel & BlueChannel)!= 0) \n        { \n          (void) FxEvaluateChannelExpression(fx_info[id],BlueChannel,x,y, \n            &alpha,exception); \n          q->blue=RoundToQuantum((MagickRealType) QuantumRange*alpha); \n        } \n      if ((channel & OpacityChannel)!= 0) \n        { \n          (void) FxEvaluateChannelExpression(fx_info[id],OpacityChannel,x,y, \n            &alpha,exception); \n          if (image->matte == MagickFalse) \n            q->opacity=RoundToQuantum((MagickRealType) QuantumRange*alpha); \n          else \n            q->opacity=RoundToQuantum((MagickRealType) (QuantumRange- \n              QuantumRange*alpha)); \n        } \n      if (((channel & IndexChannel)!= 0) && \n          (fx_image->colorspace == CMYKColorspace)) \n        { \n          (void) FxEvaluateChannelExpression(fx_info[id],IndexChannel,x,y, \n            &alpha,exception); \n          fx_indexes[x]=(IndexPacket) RoundToQuantum((MagickRealType) \n            QuantumRange*alpha); \n        } \n      q++; \n    } \n    if (SyncCacheView(fx_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,FxImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  fx_image->matte=fx_info[0]->matte; \n  fx_view=DestroyCacheViewThreadSet(fx_view); \n  fx_info=DestroyFxThreadSet(fx_info); \n  if (status == MagickFalse) \n    fx_image=DestroyImage(fx_image); \n  return(fx_image); \n} ", "pred": " \nMagickExport Image *FxImageChannel(const Image *image,const ChannelType channel, \n  const char *expression,ExceptionInfo *exception) \n{ \n#define FxImageTag  \"Fx/Image\" \n \n  FxInfo \n    **fx_info; \n \n  Image \n    *fx_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    alpha; \n \n  ViewInfo \n    **fx_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  fx_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (fx_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(fx_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&fx_image->exception); \n      fx_image=DestroyImage(fx_image); \n      return((Image *) NULL); \n    } \n  fx_info=FxGetImageCache(fx_image,exception); \n  if (fx_info == (FxInfo **) NULL) \n    { \n      fx_image=DestroyImage(fx_image); \n      return((Image *) NULL); \n    } \n  fx_view=FxGetView(fx_image,channel,exception); \n  if (fx_view == (ViewInfo **) NULL) \n    { \n      fx_image=DestroyImage(fx_image); \n      return((Image *) NULL); \n    } \n  if (fx_info[channel] == (FxInfo *) NULL) \n    { \n      fx_info[channel]=(FxInfo *) AcquireMagickMemory(sizeof(**fx_info)); \n      if (fx_info[channel] == (FxInfo *) NULL) \n        { \n          fx_image=DestroyImage(fx_image); \n          return((Image *) NULL); \n        } \n      fx_info[channel]->view=fx_view[channel]; \n      fx_info[channel]->image=fx_image; \n      fx_info[channel]->exception=exception; \n      fx_info[channel]->signature=MagickCoreSignature; \n      fx_info[channel]->number_channels=1; \n      fx_info[channel]->channels=AcquireQuantumMemory(1,sizeof(FxChannel)); \n      fx_info[channel]->channels[0].channel=channel; \n      fx_info[channel]->channels[0].view=fx_view[channel]; \n      fx_info[channel]->channels[0].image=fx_image; \n      fx_info[channel]->channels[0].exception=exception; \n      fx_info[channel]->channels[0].signature=MagickCoreSignature; \n      fx_info[channel]->channels[0].number_channels=1; \n      fx_info[channel]->channels[0].channels=AcquireQuantumMemory(1,sizeof(FxChannel)); \n      fx_info[channel]->channels[0].channels[0].channel=channel; \n      fx_info[channel]->channels[0].channels[0].view=fx_view[channel]; \n      fx_info[channel]->channels[0].channels[0].image=fx_image; \n      fx_info[channel]->channels[0].channels[0].exception=exception; \n      fx_info[channel]->channels[0].channels[0].signature=MagickCoreSignature; \n      fx_info[channel]->channels[0].channels[0].number_channels=1; \n      fx_info[channel]->channels[0].channels[0].channels=AcquireQuantumMemory(1,sizeof(FxChannel)); \n      fx_info[channel]->channels[0].channels[0].channels[0].channel=channel; \n      fx_info[channel]->channels[0].channels[0].channels[0].view=fx_view[channel]; \n      fx_info[channel]->channels[0].channels[0].channels[0].image=fx_image; \n      fx_info[channel]->channels[0].channels[0].channels[0].exception=exception; \n      fx_info[channel]->channels[0].channels[0].channels[0].signature=MagickCoreSignature; \n      fx_info[channel]->channels[0].channels[0].channels[0].number_channels=1; \n      fx_info[channel]->channels[0].channels[0].channels[0].channels=AcquireQuantumMemory(1,sizeof(FxChannel)); \n      fx_info[channel]->channels[0].channels[0].channels[0].channels[0].channel=channel; \n      fx_info[channel]->channels[0].channels[0].channels[0].channels[0].view=fx_view[channel]; \n      fx_info[channel]->channels[0].channels[0].channels[0].channels[0].image=fx_image; \n      fx_info[channel]->channels[0].channels[0].channels[0].channels[0].exception=exception; \n      fx_info[channel]->channels[0].channels[0].channels[0].channels[0].signature=MagickCoreSignature; \n      fx_info[channel]->channels[0].channels[0].channels[0].channels[0].number_channels=1; \n      fx_info[channel]->channels[0].channels[0].channels[0].channels[0].channels=AcquireQuantumMemory(1,sizeof(FxChannel)); \n      fx_info[channel]->channels[0].channels[0].channels[0].channels[0].channels[0].channel=channel; \n      fx_info[channel]->channels[0].channels[0].channels[0].channels[0].channels[0].view=fx_view[channel]; \n      fx_info[channel]->channels[0].channels[0].channels[0].channels[0].channels[0]."}
{"label": "tatic void make_14bit(uint16_t * raw_image_buff, size_t raw_image_size, struct raw_info * raw_info) \n{ \n    uint32_t pixel_count = raw_image_size / 2; \n    int bits_shift = 14 - raw_info->bits_per_pixel; \n    raw_info->black_level <<= bits_shift; \n    raw_info->white_level <<= bits_shift; \n    raw_info->bits_per_pixel = 14; \n    raw_info->frame_size = raw_info->width * raw_info->height * 14 / 8; \n \n    for(uint32_t i = 0; i < pixel_count; ++i) \n    { \n        raw_image_buff[i] <<= bits_shift; \n    } \n} \n \n ", "pred": "tatic void make_14bit(uint16_t * raw_image_buff, size_t raw_image_size, struct raw_info * raw_info) \n{ \n    uint32_t pixel_count = raw_image_size / 2; \n    int bits_shift = 14 - raw_info->bits_per_pixel; \n    raw_info->black_level <<= bits_shift; \n    raw_info->white_level <<= bits_shift; \n    raw_info->bits_per_pixel = 14; \n    raw_info->frame_size = raw_info->width * raw_info->height * 14 / 8; \n \n    for(uint32_t i = 0; i < pixel_count; ++i) \n    { \n        raw_image_buff[i] <<= bits_shift; \n    } \n} \n \n "}
{"label": " \nMagickExport Image *SketchImage(const Image *image,const double radius, \n  const double sigma,const double angle,ExceptionInfo *exception) \n{ \n  Image \n    *blend_image, \n    *blur_image, \n    *dodge_image, \n    *random_image, \n    *sketch_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  ViewInfo \n    **random_view; \n \n   \n \n  random_image=CloneImage(image,image->columns << 1,image->rows << 1, \n    MagickTrue,exception); \n  if (random_image == (Image *) NULL) \n    return((Image *) NULL); \n  status=MagickTrue; \n  random_view=AcquireCacheViewThreadSet(random_image); \n  for (y=0; y < (long) random_image->rows; y++) \n  { \n    MagickPixelPacket \n      pixel; \n \n    register IndexPacket \n      *indexes; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=SetCacheViewPixels(random_view[id],0,y,random_image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewIndexes(random_view[id]); \n    GetMagickPixelPacket(random_image,&pixel); \n    for (x=0; x < (long) random_image->columns; x++) \n    { \n      pixel.red=(MagickRealType) (QuantumRange*GetPseudoRandomValue()); \n      pixel.green=pixel.red; \n      pixel.blue=pixel.red; \n      if (image->colorspace == CMYKColorspace) \n        pixel.index=pixel.red; \n      SetPixelPacket(random_image,&pixel,q,indexes+x); \n      q++; \n    } \n    if (SyncCacheView(random_view[id]) == MagickFalse) \n      status=MagickFalse; \n  } \n  random_view=DestroyCacheViewThreadSet(random_view); \n  if (status == MagickFalse) \n    { \n      random_image=DestroyImage(random_image); \n      return(random_image); \n    } \n  blur_image=MotionBlurImage(random_image,radius,sigma,angle,exception); \n  random_image=DestroyImage(random_image); \n  if (blur_image == (Image *) NULL) \n    return((Image *) NULL); \n  dodge_image=EdgeImage(blur_image,radius,exception); \n  blur_image=DestroyImage(blur_image); \n  if (dodge_image == (Image *) NULL) \n    return((Image *) NULL); \n  (void) NormalizeImage(dodge_image); \n  (void) NegateImage(dodge_image,MagickFalse); \n  (void) TransformImage(&dodge_image,(char *) NULL,\"50%\"); \n  sketch_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (sketch_image == (Image *) NULL) \n    { \n      dodge_image=DestroyImage(dodge_image); \n      return((Image *) NULL); \n    } \n  (void) CompositeImage(sketch_image,ColorDodgeCompositeOp,dodge_image,0,0); \n  dodge_image=DestroyImage(dodge_image); \n  blend_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (blend_image == (Image *) NULL) \n    { \n      sketch_image=DestroyImage(sketch_image); \n      return((Image *) NULL); \n    } \n  blend_image->geometry=AcquireString(\"20x80\"); \n  (void) CompositeImage(sketch_image,BlendCompositeOp,blend_image,0,0); \n  blend_image=DestroyImage(blend_image); \n  return(sketch_image); \n} ", "pred": " \nMagickExport Image *SketchImage(const Image *image,const double radius, \n  const double sigma,const double angle,ExceptionInfo *exception) \n{ \n  Image \n    *blend_image, \n    *blur_image, \n    *dodge_image, \n    *random_image, \n    *sketch_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  ViewInfo \n    **random_view; \n \n   \n \n  random_image=CloneImage(image,image->columns << 1,image->rows << 1, \n    MagickTrue,exception); \n  if (random_image == (Image *) NULL) \n    return((Image *) NULL); \n  status=MagickTrue; \n  random_view=AcquireCacheViewThreadSet(random_image); \n  for (y=0; y < (long) random_image->rows; y++) \n  { \n    MagickPixelPacket \n      pixel; \n \n    register IndexPacket \n      *indexes; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse)\n      continue; \n \n    q=GetCacheViewAuthenticPixels(random_view,0,y,random_image->columns,1,\n      exception); \n \n    if (q == (PixelPacket *) NULL)\n      { \n        status=MagickFalse; \n        continue; \n      } \n \n    indexes=GetCacheViewAuthenticIndexQueue(random_view); \n \n    for (id=0; id < (ssize_t) random_image->columns; id++) \n    { \n      x=0; \n \n      for (id=0; id < (ssize_t) random_image->rows; id++) \n      { \n        if (GetPixelReadMask(random_image,q) == 0)\n          { \n            pixel=q[id]; \n \n            if (x < (ssize_t) radius)\n              { \n                if (x == 0)\n                  { \n                    SetPixelRed(blend_image,pixel); \n                    SetPixelGreen(blend_image,pixel); \n                    SetPixelBlue(blend_image,pixel); \n                    SetPixelAlpha(blend_image,pixel); \n                  }\n \n                SetPixelRed(blur_image,pixel); \n                SetPixelGreen(blur_image,pixel); \n                SetPixelBlue(blur_image,pixel); \n                SetPixelAlpha(blur_image,pixel); \n \n                SetPixelRed(dodge_image,pixel); \n                SetPixelGreen(dodge_image,pixel); \n                SetPixelBlue(dodge_image,pixel); \n                SetPixelAlpha(dodge_image,pixel); \n \n                SetPixelRed(random_image,pixel); \n                SetPixelGreen(random_image,pixel); \n                SetPixelBlue(random_image,pixel); \n                SetPixelAlpha(random_image,pixel); \n \n                SetPixelRed"}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_colormapping_data_t *data = (dt_iop_colormapping_data_t *)piece->data; \n  dt_iop_colormapping_gui_data_t *g = (dt_iop_colormapping_gui_data_t *)self->gui_data; \n  float *in = (float *)ivoid; \n  float *out = (float *)ovoid; \n \n  const int width = roi_in->width; \n  const int height = roi_in->height; \n  const int ch = piece->colors; \n \n  const float scale = piece->iscale / roi_in->scale; \n  const float sigma_s = 50.0f / scale; \n  const float sigma_r = 8.0f;  \n \n \n   \n \n  if(self->dev->gui_attached && g && piece->pipe->type == DT_DEV_PIXELPIPE_PREVIEW && (data->flag & ACQUIRE)) \n  { \n    dt_pthread_mutex_lock(&g->lock); \n    if(g->buffer) free(g->buffer); \n \n    g->buffer = malloc((size_t)width * height * ch * sizeof(float)); \n    g->width = width; \n    g->height = height; \n    g->ch = ch; \n \n    if(g->buffer) memcpy(g->buffer, in, (size_t)width * height * ch * sizeof(float)); \n \n    dt_pthread_mutex_unlock(&g->lock); \n  } \n \n   \n \n  if(data->flag & HAS_TARGET && data->flag & HAS_SOURCE) \n  { \n     \n \n \n    float dominance = data->dominance / 100.0f; \n    float equalization = data->equalization / 100.0f; \n \n     \n \n    int *const mapio = malloc(data->n * sizeof(int)); \n \n    get_cluster_mapping(data->n, data->target_mean, data->target_weight, data->source_mean, \n                        data->source_weight, dominance, mapio); \n \n    float(*const var_ratio)[2] = malloc(2 * data->n * sizeof(float)); \n \n    for(int i = 0; i < data->n; i++) \n    { \n      var_ratio[i][0] \n          = (data->target_var[i][0] > 0.0f)? data->source_var[mapio[i]][0] / data->target_var[i][0] : 0.0f; \n      var_ratio[i][1] \n          = (data->target_var[i][1] > 0.0f)? data->source_var[mapio[i]][1] / data->target_var[i][1] : 0.0f; \n    } \n \n \n \n    for(int k = 0; k < height; k++) \n    { \n      size_t j = (size_t)ch * width * k; \n      for(int i = 0; i < width; i++) \n      { \n        const float L = in[j]; \n        out[j] = 0.5f * ((L * (1.0f - equalization) \n                          + data->source_ihist[data->target_hist[(int)CLAMP( \n                                HISTN * L / 100.0f, 0.0f, (float)HISTN - 1.0f)]] * equalization) - L) + 50.0f; \n        out[j] = CLAMP(out[j], 0.0f, 100.0f); \n        j += ch; \n      } \n    } \n \n    if(equalization > 0.001f) \n    { \n       \n \n      dt_bilateral_t *b = dt_bilateral_init(width, height, sigma_s, sigma_r); \n      if(!b) \n      { \n        free(var_ratio); \n        free(mapio); \n        return; \n      } \n      dt_bilateral_splat(b, out); \n      dt_bilateral_blur(b); \n      dt_bilateral_slice(b, out, out, -1.0f); \n      dt_bilateral_free(b); \n    } \n \n    float *const weight_buf = malloc(data->n * dt_get_num_threads() * sizeof(float)); \n \n    for(int k = 0; k < height; k++) \n    { \n      float *weight = weight_buf + data->n * dt_get_thread_num(); \n      size_t j = (size_t)ch * width * k; \n      for(int i = 0; i < width; i++) \n      { \n        const float L = in[j]; \n        const float Lab[3] = { L, in[j + 1], in[j + 2] }; \n \n         \n \n        out[j] = 2.0f * (out[j] - 50.0f) + L; \n        out[j] = CLAMP(out[j], 0.0f, 100.0f); \n \n        get_clusters(in + j, data->n, data->target_mean, weight); \n        out[j + 1] = out[j + 2] = 0.0f; \n        for(int c = 0; c < data->n; c++) \n        { \n          out[j + 1] += weight[c] * ((Lab[1] - data->target_mean[c][0]) * var_ratio[c][0] \n                                     + data->source_mean[mapio[c]][0]); \n          out[j + 2] += weight[c] * ((Lab[2] - data->target_mean[c][1]) * var_ratio[c][1] \n                                     + data->source_mean[mapio[c]][1]); \n        } \n        out[j + 3] = in[j + 3]; \n        j += ch; \n      } \n    } \n \n    free(weight_buf); \n    free(var_ratio); \n    free(mapio); \n  } \n   \n \n  else \n  { \n    memcpy(out, in, (size_t)sizeof(float) * ch * width * height); \n  } \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_colormapping_data_t *data = (dt_iop_colormapping_data_t *)piece->data; \n  dt_iop_colormapping_gui_data_t *g = (dt_iop_colormapping_gui_data_t *)self->gui_data; \n  float *in = (float *)ivoid; \n  float *out = (float *)ovoid; \n \n  const int width = roi_in->width; \n  const int height = roi_in->height; \n  const int ch = piece->colors; \n \n  const float scale = piece->iscale / roi_in->scale; \n  const float sigma_s = 50.0f / scale; \n  const float sigma_r = 8.0f;  \n \n \n   \n \n  if(self->dev->gui_attached && g && piece->pipe->type == DT_DEV_PIXELPIPE_PREVIEW && (data->flag & DT_IOP_COLORMAPPING_PREVIEW))\n  {\n    // get the preview image\n    const float *preview = g->preview;\n    const float *preview_in = in;\n    const float *preview_out = out;\n    const int w = roi_in->width;\n    const int h = roi_in->height;\n    const int x = roi_in->x;\n    const int y = roi_in->y;\n    const int y_offset = y * g->preview_stride;\n    const int x_offset = x * g->preview_stride;\n    const int y_end = y + h;\n    const int x_end = x + w;\n    const int y_inc = y_end > g->preview_height? 1 : -1;\n    const int x_inc = x_end > g->preview_width? 1 : -1;\n    const int y_inc_inv = 1.0f / y_inc;\n    const int x_inc_inv = 1.0f / x_inc;\n    const int y_end_inv = 1.0f / y_end;\n    const int x_end_inv = 1.0f / x_end;\n    const int y_inc_inv_y = 1.0f / y_inc_inv;\n    const int x_inc_inv_x = 1.0f / x_inc_inv;\n    const int y_end_inv_y = 1.0f / y_end_inv;\n    const int x_end_inv_x = 1.0f / x_end_inv;\n    const int y_inc_inv_x_y = 1.0f / y_inc_inv_y;\n    const int x_inc_inv_x_x = 1.0f / x_inc_inv_x;\n    const int y_end_inv_x_y = 1.0f / y_end_inv_y;\n    const int x_end_inv_x_x = 1.0f / x_end_inv_x;\n    const int y_inc_inv_x_x_y = 1.0f / y_inc_inv_x_y;\n    const int x_inc_inv_x_x_x = 1.0f / x_inc_inv_x_x;\n    const int y_end_inv_x_x_y = 1.0f / y_end_inv_x_y;\n    const int x_end_inv_x_x_x = 1.0f / x_end_inv_x_x;\n    const int y_inc_inv_y_y = 1.0f / y_inc_inv_y_y;\n    const int x_inc_inv_y_y = 1.0f / x_inc_inv_y_y;\n    const int y_end_inv_y_y = 1.0f / y_end_inv_y_y;\n    const int x_end_inv_y_y = 1.0f / x_end_inv_y_y;\n    const int y_inc_inv_y_y_x = 1.0f / y_inc_inv_y_y_x;\n    const int x_inc_inv_y_y_x = 1.0f / x_inc_inv_y_y_x;\n    const int y_end_inv_y_y_x = 1.0f / y_end_inv_y_y_x;\n    const int x_end_inv_y_y_x = 1.0f / x_end_inv_y_y_x;\n    const int y_inc_inv_y_x_x = 1.0f / y_inc_inv_y_x_x;\n    const int x_inc_inv_y_x_x = 1.0f / x_inc_inv_y_x_x;\n    const int y_end_inv_y_x_x = 1.0f / y_end_inv_y_x_x;\n    const int x_end_inv_y_x_x = 1.0f / x_end_inv_y_x_x;\n    const int y_inc_inv_x_x_y = 1.0f / y_inc_inv_x_x_y;\n    const int x_inc_inv_x_x_y = 1.0f / x_inc_inv_x_x_y;\n    const int y_end_inv_x_x_y = 1.0f / y_end_inv_x_x_y;\n    const int x_end_inv_x_x_y = 1.0f / x_end_inv_x_x_y;\n    const int y_inc_inv_x_y_y = 1.0f / y_inc_inv_x_y_y;\n    const int x_inc_inv_x_y_y = 1.0f / x_inc_inv_x_y_y;\n    const int y_end_inv_x_y_y = 1.0f / y_end_inv_x_y_y;\n    const int x_end_inv_x_y_y = 1.0f / x_end_inv_x_y_y;\n    const int y_inc_inv_y_y_x = 1.0f / y_inc_inv_y_y_x;\n    const int x_inc_inv_y_y_x = 1.0f / x_inc_inv_y_y_x;\n    const int y_end_inv_y_y_x = 1.0f / y_end_inv_y_y_x;\n    const int x_end_inv_y_y_x = 1.0f / x_end_inv_y_y_x;\n    const int y_inc_inv_y_x_x = 1.0f / y_inc_inv_y_x_x;\n    const int x_inc_inv_y_x_x = 1.0f / x_inc_inv_y_x_x;\n    const int y_end_inv_y_x_x = 1.0f / y_end_inv_y_x_x;\n    const int x_end_inv_y_x_x = 1.0f / x_end_inv_y_x_x;\n    const int y_inc_inv_x_x_y = 1.0f / y_inc_inv_x_x_y;\n    const int x_inc_inv_x_x_y = 1.0f /"}
{"label": " \nint main(int argc, char* argv[]){ \n \n    if(argc < 1+7){ \n        printf(\"Usage: [inTrain] [inTest] [outTrain] [outTest] [r] [sigma] [KernelType]\\n\"); \n        printf(\"KernelType: {Gauss, Laplace, ProdLaplace}\\n\"); \n        return -1; \n    } \n     \n    int i;  \n \n    int idx = 0; \n    char* trainFile = argv[++idx]; \n    char* testFile = argv[++idx]; \n    char* trainOut = argv[++idx]; \n    char* testOut = argv[++idx]; \n    int r = atoi(argv[++idx]); \n    double sigma = atof(argv[++idx]); \n    char* Kernel = argv[++idx];                                                                                                   \n     \n    KERNEL mKernel; \n    if (strcmp(Kernel, \"Gauss\") == 0) { \n        mKernel = Gaussian; \n    } \n    else if (strcmp(Kernel, \"Laplace\") == 0) { \n        mKernel = Laplace; \n    } \n    else if (strcmp(Kernel, \"ProdLaplace\") == 0) { \n        mKernel = ProdLaplace; \n    } \n    else { \n        printf(\"KRR_OneVsOne. Error: unidentified kernel type!\\n\"); \n        return -1; \n    } \n \n     \n \n     \n \n    double *Xtrain = NULL, *Xtest = NULL; \n    double *ytrain = NULL, *ytest = NULL; \n    int n = 0, m = 0, d = 0; \n    if (ReadLibSVM(trainFile, &Xtrain, &ytrain, &d, &n) == -1) { \n        return -1; \n    } \n    if (ReadLibSVM(testFile, &Xtest, &ytest, &d, &m) == -1) { \n        return -1; \n    } \n    printf(\"Generate fourier feature: finish loading data\\n\"); \n     \n     \n \n    int Seed = 0;   \n    srandom(Seed); \n     \n \n     \n \n     \n \n    double *w = (double *)malloc(d*r*sizeof(double));  \n    double *b = (double *)malloc(r*sizeof(double)); \n    switch (mKernel) { \n        case Gaussian: \n            StandardNormal(w, d*r); \n            break; \n        case Laplace: \n            for (i = 0; i < r; i++) { \n                MultivariateStudentT1(w+i*d, d); \n            } \n            break; \n        case ProdLaplace: \n            StudentT1(w, d*r); \n            break; \n    } \n    for (i = 0; i < d*r; i++) { \n        w[i] /= sigma; \n    } \n  \n     \n \n     \n \n \n    UniformRandom01(b, r); \n    for (i = 0; i < r; i++) { \n        b[i] *= TWO_PI; \n    } \n \n     \n \n     \n \n \n    printf(\"Generate fourier feature: finish generating w and b\\n\"); \n \n     \n \n    double *Ztrain = (double *)malloc(n*r*sizeof(double)); \n    ComputeFeatureMatrix(n, d, r, Xtrain, w, b, Ztrain, sigma); \n    double *Ztest = (double *)malloc(m*r*sizeof(double)); \n    ComputeFeatureMatrix(m, d, r, Xtest, w, b, Ztest, sigma); \n \n    printf(\"Generate fourier feature: finish computing feature matrix\\n\"); \n     \n     \n \n    if (WriteLibSVM(trainOut, Ztrain, ytrain, r, n) == -1){ \n        return -1; \n    } \n    if (WriteLibSVM(testOut, Ztest, ytest, r, m) == -1){ \n        return -1; \n    } \n \n    printf(\"Generate fourier feature: finish storing data\\n\"); \n     \n    free(Xtrain); \n    free(ytrain); \n    free(Xtest); \n    free(ytest); \n    free(w); \n    free(b); \n    free(Ztrain); \n    free(Ztest); \n \n    return 0; \n} ", "pred": " \nint main(int argc, char* argv[]){ \n \n    if(argc < 1+7){ \n        printf(\"Usage: [inTrain] [inTest] [outTrain] [outTest] [r] [sigma] [KernelType]\\n\"); \n        printf(\"KernelType: {Gauss, Laplace, ProdLaplace}\\n\"); \n        return -1; \n    } \n     \n    int i;  \n \n    int idx = 0; \n    char* trainFile = argv[++idx]; \n    char* testFile = argv[++idx]; \n    char* trainOut = argv[++idx]; \n    char* testOut = argv[++idx]; \n    int r = atoi(argv[++idx]); \n    double sigma = atof(argv[++idx]); \n    char* Kernel = argv[++idx];                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         "}
{"label": " \nvoid mat_mult_mat(real* mat1, real* mat2, int m, int n, int o, real* out, gmx_bool bMP) \n{ \n   \n \n  int i, percent_calcs, finished_calcs; \n  percent_calcs  = 1; \n  finished_calcs = 0; \n \n  for (i = 0; i < m; i++) { \n    int j, k; \n    for (k = 0; k < o; k++) { \n      out[(i * m) + k] = 0; \n      for (j = 0; j < n; j++) { \n        out[(i * m) + k] += mat1[(i * m) + j] * mat2[(j * n) + k]; \n      } \n    } \n     \n \n    { \n      finished_calcs++; \n      while ((double)(finished_calcs) / m >= (double)percent_calcs / 100) \n      { \n        fprintf(stderr, \"Approximately %i percent complete. \\r\", percent_calcs); \n        percent_calcs++; \n      } \n    }  \n \n  }  \n \n  fprintf(stderr, \"\\n\"); \n} ", "pred": " \nvoid mat_mult_mat(real* mat1, real* mat2, int m, int n, int o, real* out, gmx_bool bMP) \n{ \n   \n \n  int i, percent_calcs, finished_calcs; \n  percent_calcs  = 1; \n  finished_calcs = 0; \n \n  for (i = 0; i < m; i++) { \n    int j, k; \n    for (k = 0; k < o; k++) { \n      out[(i * m) + k] = 0; \n      for (j = 0; j < n; j++) { \n        out[(i * m) + k] += mat1[(i * m) + j] * mat2[(j * n) + k]; \n      } \n    } \n     \n \n    { \n      finished_calcs++; \n      while ((double)(finished_calcs) / m >= (double)percent_calcs / 100) \n      { \n        fprintf(stderr, \"Approximately %i percent complete. \\r\", percent_calcs); \n        percent_calcs = (percent_calcs * 100) / m; \n      } \n    } \n  } \n  \n} \n"}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_colorzones_data_t *d = (dt_iop_colorzones_data_t *)(piece->data); \n  dt_iop_colorzones_gui_data_t *g = (dt_iop_colorzones_gui_data_t *)self->gui_data; \n \n  const int ch = piece->colors; \n  const float normalize_C = 1.f / (128.0f * sqrtf(2.f)); \n \n   \n \n  if((piece->pipe->type & DT_DEV_PIXELPIPE_FULL) == DT_DEV_PIXELPIPE_FULL && g && g->display_mask && self->dev->gui_attached \n     && (self == self->dev->gui_module) && (piece->pipe == self->dev->pipe)) \n  { \n    const dt_iop_colorzones_channel_t display_channel = g->channel; \n \n    memcpy(ovoid, ivoid, roi_out->width * roi_out->height * ch * sizeof(float)); \n \n    for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n    { \n      float *in = (float *)ivoid + ch * k; \n      float *out = (float *)ovoid + ch * k; \n \n      float LCh[3]; \n \n      dt_Lab_2_LCH(in, LCh); \n \n      float select = 0.0f; \n      switch(d->channel) \n      { \n        case DT_IOP_COLORZONES_L: \n          select = LCh[0] * 0.01f; \n          break; \n        case DT_IOP_COLORZONES_C: \n          select = LCh[1] * normalize_C; \n          break; \n        case DT_IOP_COLORZONES_h: \n        default: \n          select = LCh[2]; \n          break; \n      } \n      select = CLAMP(select, 0.f, 1.f); \n \n      out[3] = fabsf(lookup(d->lut[display_channel], select) -.5f) * 4.f; \n      out[3] = CLAMP(out[3], 0.f, 1.f); \n    } \n \n    piece->pipe->mask_display = DT_DEV_PIXELPIPE_DISPLAY_MASK; \n    piece->pipe->bypass_blendif = 1; \n \n    return; \n  } \n \n  if(d->mode == DT_IOP_COLORZONES_MODE_SMOOTH) \n  { \n    process_v3(self, piece, ivoid, ovoid, roi_in, roi_out); \n    return; \n  } \n \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    float *in = (float *)ivoid + ch * k; \n    float *out = (float *)ovoid + ch * k; \n \n    float LCh[3]; \n \n    dt_Lab_2_LCH(in, LCh); \n \n    float select = 0.0f; \n    switch(d->channel) \n    { \n      case DT_IOP_COLORZONES_L: \n        select = LCh[0] * 0.01f; \n        break; \n      case DT_IOP_COLORZONES_C: \n        select = LCh[1] * normalize_C; \n        break; \n      case DT_IOP_COLORZONES_h: \n      default: \n        select = LCh[2]; \n        break; \n    } \n    select = CLAMP(select, 0.f, 1.f); \n \n    LCh[0] *= powf(2.0f, 4.0f * (lookup(d->lut[0], select) -.5f)); \n    LCh[1] *= 2.f * lookup(d->lut[1], select); \n    LCh[2] += lookup(d->lut[2], select) -.5f; \n \n    dt_LCH_2_Lab(LCh, out); \n \n    out[3] = in[3]; \n  } \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_colorzones_data_t *d = (dt_iop_colorzones_data_t *)(piece->data); \n  dt_iop_colorzones_gui_data_t *g = (dt_iop_colorzones_gui_data_t *)self->gui_data; \n \n  const int ch = piece->colors; \n  const float normalize_C = 1.f / (128.0f * sqrtf(2.f)); \n \n   \n \n  if((piece->pipe->type & DT_DEV_PIXELPIPE_FULL) == DT_DEV_PIXELPIPE_FULL && g && g->display_mask && self->dev->gui_attached \n     && (self == self->dev->gui_module) && (piece->pipe == self->dev->pipe)) \n  { \n    const dt_iop_colorzones_channel_t display_channel = g->channel; \n \n    memcpy(d->color_zones[display_channel], g->color_zones[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out[display_channel], g->color_zones_out[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_in[display_channel], g->color_zones_in[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out_in[display_channel], g->color_zones_out_in[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out_in_out[display_channel], g->color_zones_out_in_out[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out_in_out_out[display_channel], g->color_zones_out_in_out_out[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out_in_out_out_out[display_channel], g->color_zones_out_in_out_out_out[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out_in_out_out_out_out[display_channel], g->color_zones_out_in_out_out_out_out[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out_in_out_out_out_out[display_channel], g->color_zones_out_in_out_out_out_out[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out_in_out_out_out_out[display_channel], g->color_zones_out_in_out_out_out_out[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out_in_out_out_out_out[display_channel], g->color_zones_out_in_out_out_out_out[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out_in_out_out_out_out[display_channel], g->color_zones_out_in_out_out_out_out[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out_in_out_out_out_out[display_channel], g->color_zones_out_in_out_out_out_out[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out_in_out_out_out_out[display_channel], g->color_zones_out_in_out_out_out_out[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out_in_out_out_out_out[display_channel], g->color_zones_out_in_out_out_out_out[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out_in_out_out_out_out[display_channel], g->color_zones_out_in_out_out_out_out[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out_in_out_out_out_out[display_channel], g->color_zones_out_in_out_out_out_out[display_channel], sizeof(float) * d->color_count); \n    memcpy(d->color_zones_out_in_out_out_out_out[display_channel], g->color_zones_out_in_out_out_out"}
{"label": " \nint main() \n{ \n  init_arrays(); \n \n  double annot_t_start=0, annot_t_end=0, annot_t_total=0; \n  int annot_i; \n \n  for (annot_i=0; annot_i<REPS; annot_i++) \n  { \n    annot_t_start = rtclock(); \n \n     \nregister int i,j,k,t;  \nregister int c1t, c2t, c3t, c4t, c5t, c6t, c7t, c8t, c9t, c10t, c11t, c12t;  \nregister int newlb_c1, newlb_c2, newlb_c3, newlb_c4, newlb_c5, newlb_c6,  \n  newlb_c7, newlb_c8, newlb_c9, newlb_c10, newlb_c11, newlb_c12;  \nregister int newub_c1, newub_c2, newub_c3, newub_c4, newub_c5, newub_c6,  \n  newub_c7, newub_c8, newub_c9, newub_c10, newub_c11, newub_c12;  \n \n \n \n#define ceild(n,d)  ceil(((double)(n))/((double)(d))) \n#define floord(n,d) floor(((double)(n))/((double)(d))) \n#define max(x,y)    ((x) > (y)? (x) : (y)) \n#define min(x,y)    ((x) < (y)? (x) : (y)) \n \n\t \n\tint c1, c2, c3, c4, c5, c6, c7, c8, c9; \n \n\tregister int lb, ub, lb1, ub1, lb2, ub2; \n \n \nfor (c1=-1;c1<=floord(2*T+N-4,32);c1++) { \n\tlb1=max(max(0,ceild(32*c1-T+1,32)),ceild(16*c1-15,32)); \n\tub1=min(min(floord(32*c1+31,32),floord(32*c1+N+29,64)),floord(T+N-3,32)); \n\tfor (c2=lb1; c2<=ub1; c2++) { \n{ \n  for (c3=max(max(max(max(ceild(64*c2-N-508,512),ceild(16*c1-255,256)),ceild(16*c2-255,256)),0),ceild(64*c1-64*c2-509,512)); c3<=min(min(min(min(floord(T+N-3,256),floord(32*c2+T+N+28,512)),floord(32*c1+N+60,512)),floord(32*c1-32*c2+N+29,256)),floord(64*c2+N+59,512)); c3++ ) { \n    for (c6=max(max(max(max(max(ceild(16*c1-31,32),0),ceild(16*c2-31,32)),8*c3),ceild(64*c2-N-60,64)),ceild(64*c1-64*c2-61,64)); c6<=min(min(min(min(min(8*c3+7,floord(32*c1-32*c2+N+29,32)),floord(32*c2+T+N+28,64)),floord(64*c2+N+59,64)),floord(32*c1+N+60,64)),floord(T+N-3,32)); c6++ ) { \n      for (c7t=max(max(max(max(32*c6-N+2,-32*c2+64*c6-N-29),32*c2-N+2),0),32*c1-32*c2); c7t<=min(min(min(min(32*c1-32*c2+31,T-1),-32*c2+64*c6+62),32*c2+30),floord(64*c6+61,2))-7; c7t=c7t+8) { \n        for (c7=c7t; c7<=c7t+7; c7=c7+1) { \n          for (c8=max(max(64*c6-c7-N+2,c7+1),32*c2); c8<=min(min(32*c2+31,c7+N-2),64*c6-c7+62); c8++ ) { \n            register int cbv_1, cbv_2; \n            cbv_1=max(64*c6,c7+c8+1); \n            cbv_2=min(c7+c8+N-2,64*c6+63)-7; \n            for (c9t=cbv_1; c9t<=cbv_2; c9t=c9t+8) { \n              double scv_1, scv_2, scv_3, scv_4, scv_5, scv_6, scv_7, scv_8; \n              scv_1=A[-c7+c8][-c7-c8+(c9t+7)]; \n              scv_2=A[-c7+c8][-c7-c8+(c9t+1)]; \n              scv_3=A[-c7+c8][-c7-c8+(c9t+3)]; \n              scv_4=A[-c7+c8][-c7-c8+(c9t+2)]; \n              scv_5=A[-c7+c8][-c7-c8+(c9t+4)]; \n              scv_6=A[-c7+c8][-c7-c8+c9t]; \n              scv_7=A[-c7+c8][-c7-c8+(c9t+5)]; \n              scv_8=A[-c7+c8][-c7-c8+(c9t+6)]; \n              scv_6=(A[1+-c7+c8][1+-c7-c8+c9t]+A[1+-c7+c8][-c7-c8+c9t]+A[1+-c7+c8][-c7-c8+c9t-1]+A[-c7+c8][1+-c7-c8+c9t]+scv_6+A[-c7+c8][-c7-c8+c9t-1]+A[-c7+c8-1][1+-c7-c8+c9t]+A[-c7+c8-1][-c7-c8+c9t]+A[-c7+c8-1][-c7-c8+c9t-1])/9; \n              scv_2=(A[1+-c7+c8][1+-c7-c8+(c9t+1)]+A[1+-c7+c8][-c7-c8+(c9t+1)]+A[1+-c7+c8][-c7-c8+(c9t+1)-1]+A[-c7+c8][1+-c7-c8+(c9t+1)]+scv_2+A[-c7+c8][-c7-c", "pred": " \nint main() \n{ \n  init_arrays(); \n \n  double annot_t_start=0, annot_t_end=0, annot_t_total=0; \n  int annot_i; \n \n  for (annot_i=0; annot_i<REPS; annot_i++) \n  { \n    annot_t_start = rtclock(); \n \n     \nregister int i,j,k,t;  \nregister int c1t, c2t, c3t, c4t, c5t, c6t, c7t, c8t, c9t, c10t, c11t, c12t;  \nregister int newlb_c1, newlb_c2, newlb_c3, newlb_c4, newlb_c5, newlb_c6,  \n  newlb_c7, newlb_c8, newlb_c9, newlb_c10, newlb_c11, newlb_c12;  \nregister int newub_c1, newub_c2, newub_c3, newub_c4, newub_c5, newub_c6,  \n  newub_c7, newub_c8, newub_c9, newub_c10, newub_c11, newub_c12;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_"}
{"label": " \nstatic void kmeans(const float *col, const int width, const int height, const int n, float mean_out[n][2], \n                   float var_out[n][2], float weight_out[n]) \n{ \n  const int nit = 40;                        \n \n  const int samples = width * height * 0.2;  \n \n \n  float(*const mean)[2] = malloc(2 * n * sizeof(float)); \n  float(*const var)[2] = malloc(2 * n * sizeof(float)); \n  int *const cnt = malloc(n * sizeof(int)); \n  int count; \n \n  float a_min = FLT_MAX, b_min = FLT_MAX, a_max = FLT_MIN, b_max = FLT_MIN; \n \n  for(int s = 0; s < samples; s++) \n  { \n    const int j = CLAMP(dt_points_get() * height, 0, height - 1); \n    const int i = CLAMP(dt_points_get() * width, 0, width - 1); \n \n    const float a = col[4 * (width * j + i) + 1]; \n    const float b = col[4 * (width * j + i) + 2]; \n \n    a_min = fmin(a, a_min); \n    a_max = fmax(a, a_max); \n    b_min = fmin(b, b_min); \n    b_max = fmax(b, b_max); \n  } \n \n   \n \n  for(int k = 0; k < n; k++) \n  { \n    mean_out[k][0] = 0.9f * (a_min + (a_max - a_min) * dt_points_get()); \n    mean_out[k][1] = 0.9f * (b_min + (b_max - b_min) * dt_points_get()); \n    var_out[k][0] = var_out[k][1] = weight_out[k] = 0.0f; \n    mean[k][0] = mean[k][1] = var[k][0] = var[k][1] = 0.0f; \n  } \n  for(int it = 0; it < nit; it++) \n  { \n    for(int k = 0; k < n; k++) cnt[k] = 0; \n \n \n    for(int s = 0; s < samples; s++) \n    { \n      const int j = CLAMP(dt_points_get() * height, 0, height - 1); \n      const int i = CLAMP(dt_points_get() * width, 0, width - 1); \n       \n \n      for(int k = 0; k < n; k++) \n      { \n        const float L = col[4 * (width * j + i)]; \n        const float Lab[3] = { L, col[4 * (width * j + i) + 1], col[4 * (width * j + i) + 2] }; \n         \n \n        const int c = get_cluster(Lab, n, mean_out); \n        cnt[c]++; \n \n \n        var[c][0] += Lab[1] * Lab[1]; \n        var[c][1] += Lab[2] * Lab[2]; \n        mean[c][0] += Lab[1]; \n        mean[c][1] += Lab[2]; \n      } \n    } \n     \n \n    for(int k = 0; k < n; k++) \n    { \n      if(cnt[k] == 0) continue; \n      mean_out[k][0] = mean[k][0] / cnt[k]; \n      mean_out[k][1] = mean[k][1] / cnt[k]; \n      var_out[k][0] = var[k][0] / cnt[k] - mean_out[k][0] * mean_out[k][0]; \n      var_out[k][1] = var[k][1] / cnt[k] - mean_out[k][1] * mean_out[k][1]; \n      mean[k][0] = mean[k][1] = var[k][0] = var[k][1] = 0.0f; \n    } \n \n     \n \n    count = 0; \n    for(int k = 0; k < n; k++) count += cnt[k]; \n    for(int k = 0; k < n; k++) weight_out[k] = (count > 0)? (float)cnt[k] / count : 0.0f; \n \n     \n \n     \n \n     \n \n  } \n \n  free(cnt); \n  free(var); \n  free(mean); \n \n  for(int k = 0; k < n; k++) \n  { \n     \n \n    if(var_out[k][0] == 0.0f || var_out[k][1] == 0.0f) \n      mean_out[k][0] = mean_out[k][1] = var_out[k][0] = var_out[k][1] = weight_out[k] = 0; \n \n     \n \n    var_out[k][0] = sqrtf(var_out[k][0]); \n    var_out[k][1] = sqrtf(var_out[k][1]); \n  } \n \n   \n \n   \n \n  for(int i = 0; i < n - 1; i++) \n  { \n    for(int j = 0; j < n - 1 - i; j++) \n    { \n      if(weight_out[j] > weight_out[j + 1]) \n      { \n        float temp_mean[2] = { mean_out[j + 1][0], mean_out[j + 1][1] }; \n        float temp_var[2] = { var_out[j + 1][0], var_out[j + 1][1] }; \n        float temp_weight = weight_out[j + 1]; \n \n        mean_out[j + 1][0] = mean_out[j][0]; \n        mean_out[j + 1][1] = mean_out[j][1]; \n        var_out[j + 1][0] = var_out[j][0]; \n        var_out[j + 1][1] = var_out[j][1]; \n        weight_out[j + 1] = weight_out[j]; \n \n        mean_out[j][0] = temp_mean[0]; \n        mean_out[j][1] = temp_mean[1]; \n        var_out[j][0] = temp_var[0]; \n        var_out[j][1] = temp_var[1]; \n        weight_out[j] = temp_weight; \n      } \n    } \n  } \n} ", "pred": " \nstatic void kmeans(const float *col, const int width, const int height, const int n, float mean_out[n][2], \n                   float var_out[n][2], float weight_out[n]) \n{ \n  const int nit = 40;                        \n \n  const int samples = width * height * 0.2;  \n \n \n  float(*const mean)[2] = malloc(2 * n * sizeof(float)); \n  float(*const var)[2] = malloc(2 * n * sizeof(float)); \n  int *const cnt = malloc(n * sizeof(int)); \n  int count; \n \n  float a_min = FLT_MAX, b_min = FLT_MAX, a_max = FLT_MIN, b_max = FLT_MIN; \n \n  for(int s = 0; s < samples; s++) \n  { \n    const int j = CLAMP(dt_points_get() * height, 0, height - 1); \n    const int i = CLAMP(dt_points_get() * width, 0, width - 1); \n \n    const float a = col[4 * j + 0]; \n    const float b = col[4 * j + 1]; \n    const float c = col[4 * j + 2]; \n    const float d = col[4 * j + 3]; \n \n    mean[j][0] = a; \n    mean[j][1] = b; \n    var[j][0] = c; \n    var[j][1] = d; \n \n    cnt[j]++; \n \n    a_min = MIN(a_min, a); \n    b_min = MIN(b_min, b); \n    a_max = MAX(a_max, a); \n    b_max = MAX(b_max, b); \n  } \n \n  for(int s = 0; s < n; s++) \n  { \n    const int j = CLAMP(dt_points_get() * height, 0, height - 1); \n    const int i = CLAMP(dt_points_get() * width, 0, width - 1); \n \n    const float a = col[4 * j + 0]; \n    const float b = col[4 * j + 1]; \n    const float c = col[4 * j + 2]; \n    const float d = col[4 * j + 3]; \n \n    mean_out[s][0] = a; \n    mean_out[s][1] = b; \n    var_out[s][0] = c; \n    var_out[s][1] = d; \n \n    weight_out[s] = 1.0; \n \n    cnt[j]++; \n \n    a_min = MIN(a_min, a); \n    b_min = MIN(b_min, b); \n    a_max = MAX(a_max, a); \n    b_max = MAX(b_max, b); \n  } \n \n  for(int s = 0; s < nit; s++) \n  { \n    const int j = CLAMP(dt_points_get() * height, 0, height - 1); \n    const int i = CLAMP(dt_points_get() * width, 0, width - 1); \n \n    const float a = col[4 * j + 0]; \n    const float b = col[4 * j + 1]; \n    const float c = col[4 * j + 2]; \n    const float d = col[4 * j + 3]; \n \n    mean_out[s][0] = a; \n    mean_out[s][1] = b; \n    var_out[s][0] = c; \n    var_out[s][1] = d; \n \n    weight_out[s] = 1.0; \n \n    cnt[j]++; \n \n    a_min = MIN(a_min, a); \n    b_min = MIN(b_min, b); \n    a_max = MAX(a_max, a); \n    b_max = MAX(b_max, b); \n  } \n \n  for(int s = 0; s < n; s++) \n  { \n    const int j = CLAMP(dt_points_get() * height, 0, height - 1); \n    const int i = CLAMP(dt_points_get() * width, 0, width - 1); \n \n    const float a = col[4 * j + 0]; \n    const float b = col[4 * j + 1]; \n    const float c = col[4 * j + 2]; \n    const float d = col[4 * j + 3]; \n \n    mean_out[s][0] = a; \n    mean_out[s][1] = b; \n    var_out[s][0] = c; \n    var_out[s][1] = d; \n \n    weight_out[s] = 1.0; \n \n    cnt[j]++; \n \n    a_min = MIN(a_min, a); \n    b_min = MIN(b_min, b); \n    a_max = MAX(a_max, a); \n    b_max = MAX(b_max, b); \n  } \n \n  for(int s = 0; s < n; s++) \n  { \n    const int j = CLAMP(dt_points_get() * height, 0, height - 1); \n    const int i = CLAMP(dt_points_get() * width, 0, width - 1); \n \n    const float a = col[4 * j + 0]; \n    const float b = col[4 * j + 1]; \n    const float c = col[4 * j + 2]; \n    const float d = col[4 * j + 3]; \n \n    mean_out[s][0] = a; \n    mean_out[s][1] = b; \n    var_out[s][0] = c; \n    var_out[s][1] = d; \n \n    weight_out[s] = 1.0; \n \n    cnt[j]++; \n \n    a_min = MIN(a_min, a); \n    b_min = MIN(b_min, b); \n    a_max = MAX(a_max, a); \n    b_max = MAX(b_max, b); \n  } \n \n  for(int s = 0; s < n; s++) \n  { \n    const int j = CLAMP(dt_points_get() * height, 0, height - 1); \n    const int i = CLAMP(dt_points_get() * width, 0, width - 1); \n \n    const float a = col[4 * j + 0]; \n    const float b = col[4 * j + 1]; \n    const float c = col[4 * j + 2]; \n    const float d = col[4 * j + 3]; \n \n    mean_out[s][0] = a; \n    mean_out[s][1] = b; \n    var_out[s][0] = c; \n    var_out[s][1] = d; \n \n    weight_out[s] = 1.0; \n \n    cnt[j]++; \n \n    a_min = MIN(a_min, a); \n    b_min = MIN(b_min, b); \n    a_max = MAX(a_max, a); \n   "}
{"label": " \n__attribute__((noinline, noclone)) void \nfoo (struct A (*x)[3][2], struct A *y, struct D w[1][2], int p1, long p2, long p3, int p4, \n     int p5, long p6, short p7) \n{ \n  struct C a[p7 + 4]; \n  short b[p7]; \n  int i; \n  for (i = 0; i < p7 + 4; i++) \n    { \n      if (i < p7) \n\tb[i] = -6; \n      a[i].t = 0; \n    } \n  for (i = 0; i < 128; i++) \n    { \n      x[i / 64][i % 3][(i / 4) & 1].t += i; \n      if ((i & 15) == 1) \n\ty[0].t *= 3; \n      if ((i & 31) == 2) \n\ty[1].t *= 7; \n      if ((i & 63) == 3) \n\ty[2].t *= 17; \n      z[i / 32].t += (i & 3); \n      if (i < 4) \n\tz[i].t += i; \n      a[i / 32].t |= 1ULL << (i & 30); \n      w[0][i & 1].t &= ~(1L << (i / 17 * 3)); \n      if ((i % 79) > b[0]) \n\tb[0] = i % 79; \n      if ((i % 13) > b[1]) \n\tb[1] = i % 13; \n      if ((i % 23) > b[2]) \n\tb[2] = i % 23; \n      if ((i % 85) > b[3]) \n\tb[3] = i % 85; \n      if ((i % 192) > b[4]) \n\tb[4] = i % 192; \n    } \n  for (i = 0; i < 9; i++) \n    if (a[i].t!= (i < 4? 0x55555555ULL : 0)) \n      __builtin_abort (); \n  if (b[0]!= 78 || b[1]!= 12 || b[2]!= 22 || b[3]!= 84 || b[4]!= 127) \n    __builtin_abort (); \n} ", "pred": " \n__attribute__((noinline, noclone)) void \nfoo (struct A (*x)[3][2], struct A *y, struct D w[1][2], int p1, long p2, long p3, int p4, \n     int p5, long p6, short p7) \n{ \n  struct C a[p7 + 4]; \n  short b[p7]; \n  int i; \n  for (i = 0; i < p7 + 4; i++) \n    { \n      if (i < p7) \n\tb[i] = -6; \n      a[i].t = 0; \n    } \n  for (i = 0; i < 128; i++) \n    { \n      x[i / 64][i % 3][(i / 4) & 1].t += i; \n      if ((i & 15) == 1) \n\ty[0].t *= 3; \n      if ((i & 31) == 2) \n\ty[1].t *= 7; \n      if ((i & 63) == 3) \n\ty[2].t *= 17; \n      z[i / 32].t += (i & 1); \n    } \n  for (i = 0; i < p7; i++) \n    { \n      a[i].t = 0; \n      b[i] = -6; \n    } \n  for (i = 0; i < p7; i++) \n    { \n      a[i].t = 0; \n      b[i] = -6; \n    } \n  for (i = 0; i < p7; i++) \n    { \n      a[i].t = 0; \n      b[i] = -6; \n    } \n  for (i = 0; i < p7; i++) \n    { \n      a[i].t = 0; \n      b[i] = -6; \n    } \n  for (i = 0; i < p7; i++) \n    { \n      a[i].t = 0; \n      b[i] = -6; \n    } \n  for (i = 0; i < p7; i++) \n    { \n      a[i].t = 0; \n      b[i] = -6"}
{"label": " \nvoid update_momenta(int * mnllist, double step, const int no,  \n\t\t    hamiltonian_field_t * const hf) { \n \n  for(int i = 0; i < (VOLUMEPLUSRAND + g_dbw2rand);i++) {  \n    for(int mu=0;mu<4;mu++) {  \n      _zero_su3adj(hf->derivative[i][mu]); \n    } \n  } \n   \n  for(int k = 0; k < no; k++) { \n    if(monomial_list[ mnllist[k] ].derivativefunction!= NULL) { \n      monomial_list[ mnllist[k] ].derivativefunction(mnllist[k], hf); \n    } \n  } \n   \n  xchange_deri(hf->derivative); \n     \n  for(int i = 0; i < VOLUME; i++) { \n    for(int mu = 0; mu < 4; mu++) { \n       \n \n      _su3adj_minus_const_times_su3adj(hf->momenta[i][mu], step, hf->derivative[i][mu]);  \n    } \n  } \n \n  return; \n} ", "pred": " \nvoid update_momenta(int * mnllist, double step, const int no,  \n\t\t    hamiltonian_field_t * const hf) { \n \n  for(int i = 0; i < (VOLUMEPLUSRAND + g_dbw2rand);i++) {  \n    for(int mu=0;mu<4;mu++) {  \n      _zero_su3adj(hf->derivative[i][mu]); \n    } \n  } \n   \n  for(int k = 0; k < no; k++) { \n    if(monomial_list[ mnllist[k] ].derivativefunction!= NULL) { \n      monomial_list[ mnllist[k] ].derivativefunction(mnllist[k], hf); \n    } \n  } \n   \n  xchange_deri(hf->derivative); \n     \n  for(int i = 0; i < VOLUME; i++) { \n    for(int mu = 0; mu < 4; mu++) { \n       \n \n      _su3adj_minus_const_times_su3adj(hf->momenta[i][mu], step, hf->derivative[i][mu]); \n    } \n  } \n   \n  for(int k ="}
{"label": "tatic void undo_14bit(uint16_t * raw_image_buff, size_t raw_image_size, uint32_t bpp) \n{ \n    uint32_t pixel_count = raw_image_size / 2; \n    int bits_shift = 14 - bpp; \n     \n \n    uint32_t rounding_number = (uint32_t)pow(2, bits_shift - 1); \n \n    for(uint32_t i = 0; i < pixel_count; ++i) \n    { \n        raw_image_buff[i] = (raw_image_buff[i] + rounding_number) >> bits_shift; \n    } \n} \n \n ", "pred": "tatic void undo_14bit(uint16_t * raw_image_buff, size_t raw_image_size, uint32_t bpp) \n{ \n    uint32_t pixel_count = raw_image_size / 2; \n    int bits_shift = 14 - bpp; \n     \n \n    uint32_t rounding_number = (uint32_t)pow(2, bits_shift - 1); \n \n    for(uint32_t i = 0; i < pixel_count; ++i) \n    { \n        raw_image_buff[i] = (raw_image_buff[i] + rounding_number) >> bits_shift; \n    } \n} \n \n "}
{"label": " \nMagickExport Image *WaveImage(const Image *image,const double amplitude, \n  const double wave_length,ExceptionInfo *exception) \n{ \n#define WaveImageTag  \"Wave/Image\" \n \n  Image \n    *wave_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    *sine_map; \n \n  register long \n    i; \n \n  ResampleFilter \n    **resample_filter; \n \n  ViewInfo \n    **wave_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  wave_image=CloneImage(image,image->columns,(unsigned long) (image->rows+2.0* \n    fabs(amplitude)),MagickTrue,exception); \n  if (wave_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(wave_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&wave_image->exception); \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (wave_image->background_color.opacity!= OpaqueOpacity) \n    wave_image->matte=MagickTrue; \n   \n \n  sine_map=(MagickRealType *) AcquireQuantumMemory((size_t) wave_image->columns, \n    sizeof(*sine_map)); \n  if (sine_map == (MagickRealType *) NULL) \n    { \n      wave_image=DestroyImage(wave_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  for (i=0; i < (long) wave_image->columns; i++) \n    sine_map[i]=fabs(amplitude)+amplitude*sin((2*MagickPI*i)/wave_length); \n   \n \n  status=MagickTrue; \n  resample_filter=AcquireResampleFilterThreadSet(image,exception); \n  wave_view=AcquireCacheViewThreadSet(wave_image); \n  for (y=0; y < (long) wave_image->rows; y++) \n  { \n    MagickPixelPacket \n      pixel; \n \n    register IndexPacket \n      *indexes; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=SetCacheViewPixels(wave_view[id],0,y,wave_image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewIndexes(wave_view[id]); \n    GetMagickPixelPacket(wave_image,&pixel); \n    (void) SetResampleFilterVirtualPixelMethod(resample_filter[id], \n      BackgroundVirtualPixelMethod); \n    for (x=0; x < (long) wave_image->columns; x++) \n    { \n      pixel=ResamplePixelColor(resample_filter[id],(double) x,(double) (y- \n        sine_map[x])); \n      SetPixelPacket(wave_image,&pixel,q,indexes+x); \n      q++; \n    } \n    if (SyncCacheView(wave_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,WaveImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  wave_view=DestroyCacheViewThreadSet(wave_view); \n  resample_filter=DestroyResampleFilterThreadSet(resample_filter); \n  sine_map=(MagickRealType *) RelinquishMagickMemory(sine_map); \n  if (status == MagickFalse) \n    wave_image=DestroyImage(wave_image); \n  return(wave_image); \n} ", "pred": " \nMagickExport Image *WaveImage(const Image *image,const double amplitude, \n  const double wave_length,ExceptionInfo *exception) \n{ \n#define WaveImageTag  \"Wave/Image\" \n \n  Image \n    *wave_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    *sine_map; \n \n  register long \n    i; \n \n  ResampleFilter \n    **resample_filter; \n \n  ViewInfo \n    **wave_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  wave_image=CloneImage(image,image->columns,(unsigned long) (image->rows+2.0* \n    fabs(amplitude)),MagickTrue,exception); \n  if (wave_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(wave_image,DirectClass) == MagickFalse) \n    { \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (SetImageColorspace(wave_image,GRAYColorspace,exception) == MagickFalse) \n    { \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(wave_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(wave_image,amplitude,amplitude,exception) == MagickFalse) \n    { \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(wave_image,wave_length,wave_length,exception) == MagickFalse) \n    { \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(wave_image,amplitude,amplitude,exception) == MagickFalse) \n    { \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(wave_image,wave_length,wave_length,exception) == MagickFalse) \n    { \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(wave_image,amplitude,amplitude,exception) == MagickFalse) \n    { \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(wave_image,wave_length,wave_length,exception) == MagickFalse) \n    { \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(wave_image,amplitude,amplitude,exception) == MagickFalse) \n    { \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(wave_image,wave_length,wave_length,exception) == MagickFalse) \n    { \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(wave_image,amplitude,amplitude,exception) == MagickFalse) \n    { \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(wave_image,wave_length,wave_length,exception) == MagickFalse) \n    { \n      wave_image=DestroyImage(wave_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(wave_image,amplitude,ampl"}
{"label": " \nvoid test_collapse() { \n  int i; \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n  for (int i1 = 0; i1 < 16; ++i1) \n    for (int i2 = 0; i2 < 16; ++i2) \n      for (int i3 = 0; i3 < 16; ++i3) \n        for (int i4 = 0; i4 < 16; ++i4) \n          foo(); \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n  for (i = 0; i < 16; ++i)  \n \n \n \n    for (int j = 0; j < 16; ++j) \n \n \n \n \n      for (int k = 0; k < 16; ++k) \n        i += j; \n} ", "pred": " \nvoid test_collapse() { \n  int i; \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ; \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n \n \n  for (i = 0; i < 16; ++i) \n    ;  \n \n \n \n"}
{"label": " \nMagickExport Image *TintImage(const Image *image,const char *opacity, \n  const PixelPacket tint,ExceptionInfo *exception) \n{ \n#define TintImageTag  \"Tint/Image\" \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *tint_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickStatusType \n    flags; \n \n  MagickPixelPacket \n    color_vector, \n    pixel; \n \n  ViewInfo \n    **image_view, \n    **tint_view; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  tint_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (tint_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(tint_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&tint_image->exception); \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (opacity == (const char *) NULL) \n    return(tint_image); \n   \n \n  flags=ParseGeometry(opacity,&geometry_info); \n  pixel.red=geometry_info.rho; \n  if ((flags & SigmaValue)!= 0) \n    pixel.green=geometry_info.sigma; \n  else \n    pixel.green=pixel.red; \n  if ((flags & XiValue)!= 0) \n    pixel.blue=geometry_info.xi; \n  else \n    pixel.blue=pixel.red; \n  if ((flags & PsiValue)!= 0) \n    pixel.opacity=geometry_info.psi; \n  else \n    pixel.opacity=(MagickRealType) OpaqueOpacity; \n  color_vector.red=(MagickRealType) (pixel.red*tint.red/100.0- \n    PixelIntensity(&tint)); \n  color_vector.green=(MagickRealType) (pixel.green*tint.green/100.0- \n    PixelIntensity(&tint)); \n  color_vector.blue=(MagickRealType) (pixel.blue*tint.blue/100.0- \n    PixelIntensity(&tint)); \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(image); \n  tint_view=AcquireCacheViewThreadSet(tint_image); \n  for (y=0; y < (long) image->rows; y++) \n  { \n    register const PixelPacket \n      *p; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    p=AcquireCacheViewPixels(image_view[id],0,y,image->columns,1,exception); \n    q=GetCacheViewPixels(tint_view[id],0,y,tint_image->columns,1); \n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (long) image->columns; x++) \n    { \n      MagickPixelPacket \n        pixel; \n \n      MagickRealType \n        weight; \n \n      weight=QuantumScale*p->red-0.5; \n      pixel.red=(MagickRealType) p->red+color_vector.red*(1.0-(4.0* \n        (weight*weight))); \n      q->red=RoundToQuantum(pixel.red); \n      weight=QuantumScale*p->green-0.5; \n      pixel.green=(MagickRealType) p->green+color_vector.green*(1.0-(4.0* \n        (weight*weight))); \n      q->green=RoundToQuantum(pixel.green); \n      weight=QuantumScale*p->blue-0.5; \n      pixel.blue=(MagickRealType) p->blue+color_vector.blue*(1.0-(4.0* \n        (weight*weight))); \n      q->blue=RoundToQuantum(pixel.blue); \n      q->opacity=p->opacity; \n      p++; \n      q++; \n    } \n    if (SyncCacheView(tint_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,TintImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  tint_view=DestroyCacheViewThreadSet(tint_view); \n  image_view=DestroyCacheViewThreadSet(image_view); \n  if (status == MagickFalse) \n    tint_image=DestroyImage(tint_image); \n  return(tint_image); \n} ", "pred": " \nMagickExport Image *TintImage(const Image *image,const char *opacity, \n  const PixelPacket tint,ExceptionInfo *exception) \n{ \n#define TintImageTag  \"Tint/Image\" \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *tint_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickStatusType \n    flags; \n \n  MagickPixelPacket \n    color_vector, \n    pixel; \n \n  ViewInfo \n    **image_view, \n    **tint_view; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  tint_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (tint_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(tint_image,DirectClass) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageColorspace(tint_image,GRAYColorspace,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageOpacity(tint_image,opacity,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(tint_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(tint_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(tint_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(tint_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(tint_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(tint_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(tint_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(tint_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(tint_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(tint_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(tint_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(tint_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(tint_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(tint_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    }"}
{"label": " \nMagickExport Image *ImplodeImage(const Image *image,const double amount, \n  ExceptionInfo *exception) \n{ \n#define ImplodeImageTag  \"Implode/Image\" \n \n  Image \n    *implode_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    radius; \n \n  PointInfo \n    center, \n    scale; \n \n  ResampleFilter \n    **resample_filter; \n \n  ViewInfo \n    **image_view, \n    **implode_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  implode_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (implode_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(implode_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&implode_image->exception); \n      implode_image=DestroyImage(implode_image); \n      return((Image *) NULL); \n    } \n  if (implode_image->background_color.opacity!= OpaqueOpacity) \n    implode_image->matte=MagickTrue; \n   \n \n  scale.x=1.0; \n  scale.y=1.0; \n  center.x=0.5*image->columns; \n  center.y=0.5*image->rows; \n  radius=center.x; \n  if (image->columns > image->rows) \n    scale.y=(double) image->columns/(double) image->rows; \n  else \n    if (image->columns < image->rows) \n      { \n        scale.x=(double) image->rows/(double) image->columns; \n        radius=center.y; \n      } \n   \n \n  status=MagickTrue; \n  resample_filter=AcquireResampleFilterThreadSet(image,exception); \n  image_view=AcquireCacheViewThreadSet(image); \n  implode_view=AcquireCacheViewThreadSet(implode_image); \n  for (y=0; y < (long) image->rows; y++) \n  { \n    MagickPixelPacket \n      pixel; \n \n    MagickRealType \n      distance; \n \n    PointInfo \n      delta; \n \n    register const IndexPacket \n      *indexes; \n \n    register const PixelPacket \n      *p; \n \n    register IndexPacket \n      *implode_indexes; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=GetCacheViewPixels(implode_view[id],0,y,implode_image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    implode_indexes=GetCacheViewIndexes(implode_view[id]); \n    delta.y=scale.y*(double) (y-center.y); \n    GetMagickPixelPacket(implode_image,&pixel); \n    for (x=0; x < (long) image->columns; x++) \n    { \n       \n \n      delta.x=scale.x*(double) (x-center.x); \n      distance=delta.x*delta.x+delta.y*delta.y; \n      if (distance >= (radius*radius)) \n        { \n          p=AcquireCacheViewPixels(image_view[id],x,y,1,1,exception); \n          if (p == (const PixelPacket *) NULL) \n            break; \n          indexes=AcquireCacheViewIndexes(image_view[id]); \n          SetMagickPixelPacket(image,p,indexes,&pixel); \n        } \n      else \n        { \n          double \n            factor; \n \n           \n \n          factor=1.0; \n          if (distance > 0.0) \n            factor=pow(sin((double) (MagickPI*sqrt((double) distance)/ \n              radius/2)),-amount); \n          pixel=ResamplePixelColor(resample_filter[id],(double) \n            (factor*delta.x/scale.x+center.x),(double) (factor*delta.y/ \n            scale.y+center.y)); \n        } \n      SetPixelPacket(implode_image,&pixel,q,implode_indexes+x); \n      q++; \n    } \n    if (SyncCacheView(implode_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,ImplodeImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  implode_view=DestroyCacheViewThreadSet(implode_view); \n  image_view=DestroyCacheViewThreadSet(image_view); \n  resample_filter=DestroyResampleFilterThreadSet(resample_filter); \n  if (status == MagickFalse) \n    implode_image=DestroyImage(implode_image); \n  return(implode_image); \n} ", "pred": " \nMagickExport Image *ImplodeImage(const Image *image,const double amount, \n  ExceptionInfo *exception) \n{ \n#define ImplodeImageTag  \"Implode/Image\" \n \n  Image \n    *implode_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickRealType \n    radius; \n \n  PointInfo \n    center, \n    scale; \n \n  ResampleFilter \n    **resample_filter; \n \n  ViewInfo \n    **image_view, \n    **implode_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  implode_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (implode_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(implode_image,DirectClass) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageBackgroundColor(implode_image,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageClipMask(implode_image,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageMask(implode_image,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(implode_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(implode_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageColorspace(implode_image,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageOpacity(implode_image,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageBackgroundColor(implode_image,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageClipMask(implode_image,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageMask(implode_image,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(implode_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageExtent(implode_image,image->columns,image->rows,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageColorspace(implode_image,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageOpacity(implode_image,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageOpacity(implode_image,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageOpacity(implode_image,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageOpacity(implode_image,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageOpacity(implode_image,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageOpacity(implode_image,exception) == MagickFalse) \n    { \n      ImplodeImageError(implode_image,ImplodeImageTag,exception); \n      return((Image *) NULL); \n    } \n  if (SetImageOpacity"}
{"label": " \nMagickExport Image *ShadowImage(const Image *image,const double opacity, \n  const double sigma,const long x_offset,const long y_offset, \n  ExceptionInfo *exception) \n{ \n  Image \n    *border_image, \n    *clone_image, \n    *shadow_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  RectangleInfo \n    border_info; \n \n  ViewInfo \n    **image_view; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  clone_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (clone_image == (Image *) NULL) \n    return((Image *) NULL); \n  (void) SetImageVirtualPixelMethod(clone_image,EdgeVirtualPixelMethod); \n  border_info.width=(unsigned long) (2.0*sigma+0.5); \n  border_info.height=(unsigned long) (2.0*sigma+0.5); \n  border_info.x=0; \n  border_info.y=0; \n  (void) QueryColorDatabase(\"none\",&clone_image->border_color,exception); \n  border_image=BorderImage(clone_image,&border_info,exception); \n  clone_image=DestroyImage(clone_image); \n  if (border_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (border_image->matte == MagickFalse) \n    (void) SetImageAlphaChannel(border_image,ResetAlphaChannel); \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(border_image); \n  for (y=0; y < (long) border_image->rows; y++) \n  { \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=GetCacheViewPixels(image_view[id],0,y,border_image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (long) border_image->columns; x++) \n    { \n      q->red=border_image->background_color.red; \n      q->green=border_image->background_color.green; \n      q->blue=border_image->background_color.blue; \n      if (border_image->matte == MagickFalse) \n        q->opacity=border_image->background_color.opacity; \n      else \n        q->opacity=RoundToQuantum((MagickRealType) QuantumRange-(QuantumRange- \n          q->opacity)*opacity/100.0); \n      q++; \n    } \n    if (SyncCacheView(image_view[id]) == MagickFalse) \n      status=MagickFalse; \n  } \n  image_view=DestroyCacheViewThreadSet(image_view); \n  shadow_image=BlurImageChannel(border_image,AlphaChannel,0.0,sigma,exception); \n  border_image=DestroyImage(border_image); \n  if (shadow_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (shadow_image->page.width == 0) \n    shadow_image->page.width=shadow_image->columns; \n  if (shadow_image->page.height == 0) \n    shadow_image->page.height=shadow_image->rows; \n  shadow_image->page.width+=x_offset-(long) border_info.width; \n  shadow_image->page.height+=y_offset-(long) border_info.height; \n  shadow_image->page.x+=x_offset-(long) border_info.width; \n  shadow_image->page.y+=y_offset-(long) border_info.height; \n  return(shadow_image); \n} ", "pred": " \nMagickExport Image *ShadowImage(const Image *image,const double opacity, \n  const double sigma,const long x_offset,const long y_offset, \n  ExceptionInfo *exception) \n{ \n  Image \n    *border_image, \n    *clone_image, \n    *shadow_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  RectangleInfo \n    border_info; \n \n  ViewInfo \n    **image_view; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  clone_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (clone_image == (Image *) NULL) \n    return((Image *) NULL); \n  (void) SetImageVirtualPixelMethod(clone_image,EdgeVirtualPixelMethod); \n  border_info.width=(unsigned long) (2.0*sigma+0.5); \n  border_info.height=(unsigned long) (2.0*sigma+0.5); \n  border_info.x=(ssize_t) (x_offset+0.5); \n  border_info.y=(ssize_t) (y_offset+0.5); \n  border_image=BorderImage(clone_image,&border_info,exception); \n  if (border_image == (Image *) NULL) \n    { \n      clone_image=DestroyImage(clone_image); \n      return((Image *) NULL); \n    } \n  if (border_image->columns == 0)\n    {\n      border_image=DestroyImage(border_image); \n      clone_image=DestroyImage(clone_image); \n      return((Image *) NULL); \n    } \n  if (border_image->rows == 0)\n    {\n      border_image=DestroyImage(border_image); \n      clone_image=DestroyImage(clone_image); \n      return((Image *) NULL); \n    } \n  if (border_image->columns!= clone_image->columns)\n    {\n      border_image=DestroyImage(border_image); \n      clone_image=DestroyImage(clone_image); \n      return((Image *) NULL); \n    } \n  if (border_image->rows!= clone_image->rows)\n    {\n      border_image=DestroyImage(border_image); \n      clone_image=DestroyImage(clone_image); \n      return((Image *) NULL); \n    } \n  if (border_image->storage_class!= clone_image->storage_class)\n    {\n      border_image=DestroyImage(border_image); \n      clone_image=DestroyImage(clone_image); \n      return((Image *) NULL); \n    } \n  if (border_image->colorspace!= clone_image->colorspace)\n    {\n      border_image=DestroyImage(border_image); \n      clone_image=DestroyImage(clone_image); \n      return((Image *) NULL); \n    } \n  if (border_image->alpha_trait!= clone_image->alpha_trait)\n    {\n      border_image=DestroyImage(border_image); \n      clone_image=DestroyImage(clone_image); \n      return((Image *) NULL); \n    } \n  if (border_image->page.width!= clone_image->page.width)\n    {\n      border_image=DestroyImage(border_image); \n      clone_image=DestroyImage(clone_image); \n      return((Image *) NULL); \n    } \n  if (border_image->page.height!= clone_image->page.height)\n    {\n      border_image=DestroyImage(border_image); \n      clone_image=DestroyImage(clone_image); \n      return((Image *) NULL); \n    } \n  if (border_image->page.x!= clone_image->page.x)\n    {\n "}
{"label": " \nint user1_init_primitives(int inittype, FTYPE (*prim)[NSTORE2][NSTORE3][NPR], FTYPE (*pstag)[NSTORE2][NSTORE3][NPR], FTYPE (*ucons)[NSTORE2][NSTORE3][NPR], FTYPE (*vpot)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Bhat)[NSTORE2][NSTORE3][NPR], FTYPE (*panalytic)[NSTORE2][NSTORE3][NPR], FTYPE (*pstaganalytic)[NSTORE2][NSTORE3][NPR], FTYPE (*vpotanalytic)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Bhatanalytic)[NSTORE2][NSTORE3][NPR], \n                          FTYPE (*F1)[NSTORE2][NSTORE3][NPR],FTYPE (*F2)[NSTORE2][NSTORE3][NPR],FTYPE (*F3)[NSTORE2][NSTORE3][NPR], FTYPE (*Atemp)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3]) \n{ \n  int whichvel, whichcoord; \n  int initreturn; \n  int i = 0, j = 0, k = 0, l; \n  FTYPE r,th,X[NDIM],V[NDIM]; \n  int normalize_densities(FTYPE (*prim)[NSTORE2][NSTORE3][NPR]); \n  int normalize_field(FTYPE (*prim)[NSTORE2][NSTORE3][NPR], FTYPE (*pstag)[NSTORE2][NSTORE3][NPR], FTYPE (*ucons)[NSTORE2][NSTORE3][NPR], FTYPE (*vpot)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Bhat)[NSTORE2][NSTORE3][NPR]); \n  int init_atmosphere(int *whichvel, int *whichcoord, int i, int j, int k, FTYPE *pr); \n  int pl,pliter; \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  trifprintf(\"Assign primitives\\n\"); \n \n   \n \n   \n \n  init_3dnpr_fullloop(0.0,prim); \n \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  { \n    OPENMP3DLOOPVARSDEFINE; \n     \n \n    OPENMP3DLOOPSETUPFULL; \n    OPENMP3DLOOPBLOCK{ \n      OPENMP3DLOOPBLOCK2IJK(i,j,k); \n \n      initreturn=init_dsandvels(inittype, CENT, &whichvel, &whichcoord,t,i,j,k,MAC(prim,i,j,k),MAC(pstag,i,j,k));  \n \n      if(initreturn>0){ \n        FAILSTATEMENT(\"init.c:init_primitives()\", \"init_dsandvels()\", 1); \n      } \n      else MYFUN(transform_primitive_vB(whichvel, whichcoord, i,j,k, prim, pstag),\"init.c:init_primitives\",\"transform_primitive_vB()\",0); \n \n    } \n  } ", "pred": " \nint user1_init_primitives(int inittype, FTYPE (*prim)[NSTORE2][NSTORE3][NPR], FTYPE (*pstag)[NSTORE2][NSTORE3][NPR], FTYPE (*ucons)[NSTORE2][NSTORE3][NPR], FTYPE (*vpot)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Bhat)[NSTORE2][NSTORE3][NPR], FTYPE (*panalytic)[NSTORE2][NSTORE3][NPR], FTYPE (*pstaganalytic)[NSTORE2][NSTORE3][NPR], FTYPE (*vpotanalytic)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Bhatanalytic)[NSTORE2][NSTORE3][NPR], \n                          FTYPE (*F1)[NSTORE2][NSTORE3][NPR],FTYPE (*F2)[NSTORE2][NSTORE3][NPR],FTYPE (*F3)[NSTORE2][NSTORE3][NPR], FTYPE (*Atemp)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Btemp)[NSTORE2][NSTORE3][NPR], FTYPE (*Ctemp)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Dtemp)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Etemp)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Ftemp)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Atempanalytic)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Btempanalytic)[NSTORE2][NSTORE3][NPR], FTYPE (*Ctempanalytic)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Dtempanalytic)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Etempanalytic)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Ftempanalytic)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Atempanalyticanalytic)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Btempanalyticanalytic)[NSTORE2][NSTORE3][NPR], FTYPE (*Ctempanalyticanalytic)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Dtempanalyticanalytic)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Etempanalyticanalytic)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Ftempanalyticanalytic)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3], FTYPE (*Atempanalyticanalyticanalytic)[NSTORE1+SHIFTSTORE1][NSTORE2+SHIFTSTORE2][NSTORE3+SHIFTSTORE3"}
{"label": " \nint gmx_isd(int argc,char *argv[]) \n{ \n  const char *desc[] = { \n    \"[TT]g_isd[tt].\" \n  }; \n   \n   \n   \n  static gmx_bool bANG=FALSE, bDIH=FALSE, bANGDIH=FALSE, bDRMS=FALSE; \n  static gmx_bool bPHIPSI=FALSE, bSRMS=FALSE, bPCOR=FALSE, bMAMMOTH=FALSE; \n  static gmx_bool bACOR=FALSE, bESA=FALSE, bRMSD=FALSE, bMIR=FALSE; \n  static gmx_bool bRG=FALSE, bSRG=FALSE, bE2E=FALSE, bSE2E=FALSE; \n  static gmx_bool bANG2=FALSE, bDIH2=FALSE, bANGDIH2=FALSE, bANGDIH2G=FALSE; \n  static gmx_bool bRROT=FALSE, bSDRMS=FALSE, bPHIPSI2=FALSE, bRMSDIH=FALSE; \n  static user_bf = -1, user_ef = -1, user_td = -1; \n  static int nt          = -1; \n  static real setmax     = -1.0; \n  static real rcutoff    =  1.1; \n  static real noisefloor =  0.0; \n  static gmx_bool bNoise = FALSE; \n  static gmx_bool bMP    = FALSE; \n  t_pargs pa[] = { \n    { \"-ang\", FALSE, etBOOL, {&bANG}, \n    \"ISDM: Mean cosine of difference of backbone angles for each \" \n    \"set of three atoms. Assumes only CA atoms.\" }, \n    { \"-dih\", FALSE, etBOOL, {&bDIH}, \n    \"ISDM: Mean cosine of difference of backbone dihedrals for \" \n    \"each set of four atoms. Assumes only CA atoms.\" }, \n    { \"-angdih\", FALSE, etBOOL, {&bANGDIH}, \n    \"ISDM: Geometric mean of ang and dih ISDMs.\" }, \n    { \"-ang2\", FALSE, etBOOL, {&bANG2}, \n    \"ISDM: Attempts to euclideanize -ang.\" }, \n    { \"-dih2\", FALSE, etBOOL, {&bDIH2}, \n    \"ISDM: Attempts to euclideanize -dih.\" }, \n    { \"-angdih2\", FALSE, etBOOL, {&bANGDIH2}, \n    \"ISDM: Attempts to euclideanize -angdih.\" }, \n    { \"-angdih2g\", FALSE, etBOOL, {&bANGDIH2G}, \n    \"ISDM: Attempts to euclideanize -angdih. Geometric mean.\" }, \n    { \"-rmsdih\", FALSE, etBOOL, {&bRMSDIH}, \n    \"ISDM: RMSD of alpha carbon dihedrals.\" }, \n    { \"-phipsi\", FALSE, etBOOL, {&bPHIPSI}, \n    \"ISDM: Mean cosine of difference of phi and psi angles. \" \n    \"Assumes only backbone atoms.\" }, \n    { \"-phipsi2\", FALSE, etBOOL, {&bPHIPSI2}, \n    \"ISDM: Attempts to euclideanize -phipsi.\" }, \n    { \"-drms\", FALSE, etBOOL, {&bDRMS}, \n    \"ISDM: Mean difference of the paired distances matrix for all \" \n    \"atoms. Distance RMS(D).\" }, \n    { \"-sdrms\", FALSE, etBOOL, {&bSDRMS}, \n    \"ISDM: Mean difference of the paired distances matrix for all \" \n    \"atoms scaled by 2 * geometric mean of Rg. Scaled distance \" \n    \"RMS(D).\" }, \n    { \"-rg\", FALSE, etBOOL, {&bRG}, \n    \"ISDM: Calculates difference in Rg. Only compares size. \" }, \n    { \"-srg\", FALSE, etBOOL, {&bSRG}, \n    \"ISDM: Calculates difference in Rg scaled by mean Rg. \" }, \n    { \"-e2e\", FALSE, etBOOL, {&bE2E}, \n    \"ISDM: Calculates difference in end-to-end distance. \" }, \n    { \"-se2e\", FALSE, etBOOL, {&bSE2E}, \n    \"ISDM: Calculates difference in end-to-end distance scaled \" \n    \"by (2 * Rg). \" }, \n    { \"-mir\", FALSE, etBOOL, {&bMIR}, \n    \"ISDM: RMSD with the mirror of the reference structure. \" }, \n    { \"-rrot\", FALSE, etBOOL, {&bRROT}, \n    \"ISDM: RMSD with random rotation of reference structure. \" }, \n    { \"-srms\", FALSE, etBOOL, {&bSRMS}, \n    \"ISDM: Scaled RMSD. RMSD between the structure and reference \" \n    \"divided by the RMSD between the structure and mirror of the \" \n    \"reference created by multiplying the coordinates by the \" \n    \"negative identity matrix.\" }, \n    { \"-rmsd\", FALSE, etBOOL, {&bRMSD}, \n    \"ISDM: Standard RMSD.\" }, \n    { \"-pcor\", FALSE, etBOOL, {&bPCOR}, \n    \"ISDM: Position correlation. Correlation coefficient of the \" \n    \"positions is computed after alignment. Only positive \" \n    \"correlation is considered. Negative correlations are set to \" \n    \"zero.\" }, \n    { \"-acor\", FALSE, etBOOL, {&bACOR}, \n    \"ISDM: Angle correlation. Correlation coefficient of the \" \n    \"backbone angles (see ang ISDM) is computed. \" \n    \"Only positive correlation is considered. Negative correlations \" \n    \"are set to zero.\" }, \n    { \"-mammoth\", FALSE, etBOOL, {&bMAMMOTH}, \n    \"ISDM: MAMMOTH (MAtching Molecular Models Obtained from \" \n    \"Theory). Compares segments of residues chosen by sequence \" \n    \"alignment. Attempts to focus on correct secondary structure \" \n    \"moreso than tertiary structure. Source code modified for \" \n    \"compatibility. For this ISDM, please cite: \\n\\n\" \n    \"Ortiz, AR, Strauss, CE, Olmea, O (2002). MAMMOTH \" \n    \"(Matching molecular models obtained from theory): An automated \" \n    \"method for model comparison. Protein Sci. 11 (11), 2606\u20132621.\\n\"}, \n    { \"-esa\", FALSE, etBOOL, {&bESA}, \n    \"ISDM: Elastic shape analysis. Based on image analysis. \" \n    \"Warps structure onto the reference structure. Original source \" \n    \"code ported from Matlab to C. For this ISDM, please cite: \\n\\n\" \n    \"Liu W, Srivastava A, Zhang J (2011) A Mathematical Framework \" \n    \"for Protein Structure Comparison. PLoS Comput Biol 7(2): \" \n    \"e1001075.\\n\\nAssume only CA atoms.\" }, \n    { \"-mp\", FALSE, etBOOL, {&bMP}, \n    \"Use OpenMP commands for parallel processing. \"}, \n    { \"-nt\", FALSE, etINT, {&nt}, \n    \"Limit the maximum number of threads for parallel processing. \"}, \n    { \"-bf\", FALSE, etINT, {&user_bf}, \n    \"Compare range of frames from bf to ef to all other \"  \n    \"frames. The bf and ef options are applied after the b, \"  \n    \"e, and dt options and use units of frames instead of units of \"  \n    \"time. Frame numbers are counted from one.\"}, \n    { \"-ef\", FALSE, etINT, {&user_ef}, \n    \"Compare range of frames from bf to ef to all other \"  \n    \"frames. The bf and ef options are applied after the b, \"  \n    \"e,", "pred": " \nint gmx_isd(int argc,char *argv[]) \n{ \n  const char *desc[] = { \n    \"[TT]g_isd[tt].\" \n  }; \n   \n   \n   \n  static gmx_bool bANG=FALSE, bDIH=FALSE, bANGDIH=FALSE, bDRMS=FALSE; \n  static gmx_bool bPHIPSI=FALSE, bSRMS=FALSE, bPCOR=FALSE, bMAMMOTH=FALSE; \n  static gmx_bool bACOR=FALSE, bESA=FALSE, bRMSD=FALSE, bMIR=FALSE; \n  static gmx_bool bRG=FALSE, bSRG=FALSE, bE2E=FALSE, bSE2E=FALSE; \n  static gmx_bool bANG2=FALSE, bDIH2=FALSE, bANGDIH2=FALSE, bANGDIH2G=FALSE; \n  static gmx_bool bRROT=FALSE, bSDRMS=FALSE, bPHIPSI2=FALSE, bRMSDIH=FALSE; \n  static user_bf = -1, user_ef = -1, user_td = -1; \n  static int nt          = -1; \n  static real           dt        = -1; \n  static real           dt2       = -1; \n  static real           dt3       = -1; \n  static real           dt4       = -1; \n  static real           dt5       = -1; \n  static real           dt6       = -1; \n  static real           dt7       = -1; \n  static real           dt8       = -1; \n  static real           dt9       = -1; \n  static real           dt10      = -1; \n  static real           dt11      = -1; \n  static real           dt12      = -1; \n  static real           dt13      = -1; \n  static real           dt14      = -1; \n  static real           dt15      = -1; \n  static real           dt16      = -1; \n  static real           dt17      = -1; \n  static real           dt18      = -1; \n  static real           dt19      = -1; \n  static real           dt20      = -1; \n  static real           dt21      = -1; \n  static real           dt22      = -1; \n  static real           dt23      = -1; \n  static real           dt24      = -1; \n  static real           dt25      = -1; \n  static real           dt26      = -1; \n  static real           dt27      = -1; \n  static real           dt28      = -1; \n  static real           dt29      = -1; \n  static real           dt30      = -1; \n  static real           dt31      = -1; \n  static real           dt32      = -1; \n  static real           dt33      = -1; \n  static real           dt34      = -1; \n  static real           dt35      = -1; \n  static real           dt36      = -1; \n  static real           dt37      = -1; \n  static real           dt38      = -1; \n  static real           dt39      = -1; \n  static real           dt40      = -1; \n  static real           dt41      = -1; \n  static real           dt42      = -1; \n  static real           dt43      = -1; \n  static real           dt44      = -1; \n  static real           dt45      = -1; \n  static real           dt46      = -1; \n  static real           dt47      = -1; \n  static real           dt48      = -1; \n  static real           dt49      = -1; \n  static real           dt50      = -1; \n  static real           dt51      = -1; \n  static real           dt52      = -1; \n  static real           dt53      = -1; \n  static real           dt54      = -1; \n  static real           dt55      = -1; \n  static real           dt56      = -1; \n  static real           dt57      = -1; \n  static real           dt58      = -1; \n  static real           dt59      = -1; \n  static real           dt60      = -1; \n  static real           dt61      = -1; \n  static real           dt62      = -1; \n  static real           dt63      = -1; \n  static real           dt64      = -1; \n  static real           dt65      = -1; \n  static real           dt66      = -1; \n  static real           dt67      = -1; \n  static real           dt68      = -1; \n  static real           dt69      = -1; \n  static real           dt70  "}
{"label": "  int\tcnt = 0; \n \n  for (i = 1; i<thds; i*=2) \n    ; \n \n  for (lp=1; lp<=i; lp=lp*2) { \n    buf[cnt ++] += omp_get_num_threads (); \n  } \n} \n \n \nmain () \n{ \n  thds = omp_get_max_thre ", "pred": "  int\tcnt = 0; \n \n  for (i = 1; i<thds; i*=2) \n    ; \n \n  for (lp=1; lp<=i; lp=lp*2) { \n    buf[cnt ++] += omp_get_num_threads (); \n  } \n} \n \n \nmain () \n{ \n  thds = omp_get_max_thre "}
{"label": " \nMagickExport Image *ConvolveImageChannel(const Image *image, \n  const ChannelType channel,const unsigned long order,const double *kernel, \n  ExceptionInfo *exception) \n{ \n#define ConvolveImageTag  \"Convolve/Image\" \n \n  Image \n    *convolve_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  unsigned long \n    width; \n \n  ViewInfo \n    **convolve_view, \n    **image_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  width=order; \n  if ((width % 2) == 0) \n    ThrowImageException(OptionError,\"KernelWidthMustBeAnOddNumber\"); \n  convolve_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (convolve_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(convolve_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&convolve_image->exception); \n      convolve_image=DestroyImage(convolve_image); \n      return((Image *) NULL); \n    } \n   \n \n  if (image->debug!= MagickFalse) \n    { \n      char \n        format[MaxTextExtent], \n        *message; \n \n      long \n        u, \n        v; \n \n      register const double \n        *k; \n \n      (void) LogMagickEvent(TransformEvent,GetMagickModule(), \n        \"  ConvolveImage with %ldx%ld kernel:\",width,width); \n      message=AcquireString(\"\"); \n      k=kernel; \n      for (v=0; v < (long) width; v++) \n      { \n        *message='\\0'; \n        (void) FormatMagickString(format,MaxTextExtent,\"%ld: \",v); \n        (void) ConcatenateString(&message,format); \n        for (u=0; u < (long) width; u++) \n        { \n          (void) FormatMagickString(format,MaxTextExtent,\"%+f \",*k++); \n          (void) ConcatenateString(&message,format); \n        } \n        (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"%s\",message); \n      } \n      message=DestroyString(message); \n    } \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(image); \n  convolve_view=AcquireCacheViewThreadSet(convolve_image); \n  for (y=0; y < (long) image->rows; y++) \n  { \n    const IndexPacket \n      *indexes; \n \n    IndexPacket \n      *convolve_indexes; \n \n    register const PixelPacket \n      *p; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    p=AcquireCacheViewPixels(image_view[id],-((long) width/2L),y-(long) \n      (width/2L),image->columns+width,width,exception); \n    q=GetCacheViewPixels(convolve_view[id],0,y,convolve_image->columns,1); \n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=AcquireCacheViewIndexes(image_view[id]); \n    convolve_indexes=GetCacheViewIndexes(convolve_view[id]); \n    for (x=0; x < (long) image->columns; x++) \n    { \n      long \n        j, \n        v; \n \n      MagickRealType \n        alpha, \n        gamma; \n \n      MagickPixelPacket \n        pixel; \n \n      register const double \n        *k; \n \n      register long \n        u; \n \n      GetMagickPixelPacket(image,&pixel); \n      gamma=0.0; \n      k=kernel; \n      j=0; \n      for (v=0; v < (long) width; v++) \n      { \n        for (u=0; u < (long) width; u++) \n        { \n          alpha=1.0; \n          if (((channel & OpacityChannel)!= 0) && \n              (image->matte!= MagickFalse)) \n            alpha=(MagickRealType) (QuantumScale*(QuantumRange- \n              (p+u+j)->opacity)); \n          if ((channel & RedChannel)!= 0) \n            pixel.red+=(*k)*alpha*(p+u+j)->red; \n          if ((channel & GreenChannel)!= 0) \n            pixel.green+=(*k)*alpha*(p+u+j)->green; \n          if ((channel & BlueChannel)!= 0) \n            pixel.blue+=(*k)*alpha*(p+u+j)->blue; \n          if ((channel & OpacityChannel)!= 0) \n            pixel.opacity+=(*k)*(p+u+j)->opacity; \n          if (((channel & IndexChannel)!= 0) && \n              (image->colorspace == CMYKColorspace)) \n            pixel.index+=(*k)*alpha*indexes[x+u+j]; \n          gamma+=(*k)*alpha; \n          k++; \n        } \n        j+=image->columns+width; \n      } \n      gamma=1.0/(fabs((double) gamma) <= MagickEpsilon? 1.0 : gamma); \n      if ((channel & RedChannel)!= 0) \n        q->red=RoundToQuantum(gamma*pixel.red+image->bias); \n      if ((channel & GreenChannel)!= 0) \n        q->green=RoundToQuantum(gamma*pixel.green+image->bias); \n      if ((channel & BlueChannel)!= 0) \n        q->blue=RoundToQuantum(gamma*pixel.blue+image->bias); \n      if ((channel & OpacityChannel)!= 0) \n        q->opacity=RoundToQuantum(pixel.opacity+image->bias); \n      if (((channel & IndexChannel)!= 0) && \n         ", "pred": " \nMagickExport Image *ConvolveImageChannel(const Image *image, \n  const ChannelType channel,const unsigned long order,const double *kernel, \n  ExceptionInfo *exception) \n{ \n#define ConvolveImageTag  \"Convolve/Image\" \n \n  Image \n    *convolve_image; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  unsigned long \n    width; \n \n  ViewInfo \n    **convolve_view, \n    **image_view; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  width=order; \n  if ((width % 2) == 0) \n    ThrowImageException(OptionError,\"KernelWidthMustBeAnOddNumber\"); \n  convolve_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (convolve_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(convolve_image,DirectClass,exception) == MagickFalse) \n    { \n      convolve_image=DestroyImage(convolve_image); \n      return((Image *) NULL); \n    } \n  convolve_image->alpha_trait=BlendPixelTrait; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->background_color.alpha=QuantumRange; \n  convolve_image->background_color.red=QuantumRange; \n  convolve_image->background_color.green=QuantumRange; \n  convolve_image->background_color.blue=QuantumRange; \n  convolve_image->background_color.black=QuantumRange; \n  convolve_image->storage_class=DirectClass; \n  convolve_image->colors=0; \n  convolve_image->depth=8; \n  convolve_image->alpha_trait=BlendPixelTrait; \n  convolve_image->page=convolve_image->page; \n  convolve_image->background_color=convolve_image->background_color; \n  convolve_image->storage_class=DirectClass; \n  convolve_image->colors=0; \n  convolve_image->depth=8; \n  convolve_image->alpha_trait=BlendPixelTrait; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve_image->page.width=width; \n  convolve_image->page.height=width; \n  convolve_image->gravity=GravityCenter; \n  convolve_image->page=convolve_image->page; \n  convolve_image->page.x=0; \n  convolve_image->page.y=0; \n  convolve"}
{"label": " \nMagickExport MagickBooleanType EvaluateImageChannel(Image *image, \n  const ChannelType channel,const MagickEvaluateOperator op,const double value, \n  ExceptionInfo *exception) \n{ \n#define EvaluateImageTag  \"Evaluate/Image \" \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  ViewInfo \n    **image_view; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  if (SetImageStorageClass(image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&image->exception); \n      return(MagickFalse); \n    } \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(image); \n  for (y=0; y < (long) image->rows; y++) \n  { \n    register IndexPacket \n      *indexes; \n \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=GetCacheViewPixels(image_view[id],0,y,image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetIndexes(image); \n    for (x=0; x < (long) image->columns; x++) \n    { \n      if ((channel & RedChannel)!= 0) \n        q->red=ApplyEvaluateOperator(q->red,op,value); \n      if ((channel & GreenChannel)!= 0) \n        q->green=ApplyEvaluateOperator(q->green,op,value); \n      if ((channel & BlueChannel)!= 0) \n        q->blue=ApplyEvaluateOperator(q->blue,op,value); \n      if ((channel & OpacityChannel)!= 0) \n        { \n          if (image->matte == MagickFalse) \n            q->opacity=ApplyEvaluateOperator(q->opacity,op,value); \n          else \n            q->opacity=(Quantum) QuantumRange-ApplyEvaluateOperator( \n              (Quantum) (QuantumRange-q->opacity),op,value); \n        } \n      if (((channel & IndexChannel)!= 0) && (indexes!= (IndexPacket *) NULL)) \n        indexes[x]=(IndexPacket) ApplyEvaluateOperator(indexes[x],op,value); \n      q++; \n    } \n    if (SyncCacheView(image_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,EvaluateImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  image_view=DestroyCacheViewThreadSet(image_view); \n  return(status); \n} ", "pred": " \nMagickExport MagickBooleanType EvaluateImageChannel(Image *image, \n  const ChannelType channel,const MagickEvaluateOperator op,const double value, \n  ExceptionInfo *exception) \n{ \n#define EvaluateImageTag  \"Evaluate/Image \" \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  ViewInfo \n    **image_view; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  if (SetImageStorageClass(image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&image->exception); \n      return(MagickFalse); \n    } \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(image); \n  for (y=0; y < (long) image->rows; y++) \n  { \n    register IndexPacket \n      *indexes; \n \n    register long \n      id, \n      x; \n \n    PixelPacket\n      *q; \n \n    if (status == MagickFalse) \n      continue; \n \n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n \n    for (x=0; x < (long) image->columns; x++) \n    { \n      id=GetPixelIndex(image,q); \n      indexes=GetCacheViewAuthenticIndexQueue(image_view); \n      for (id=0; id < (long) GetPixelChannels(image); id++) \n      { \n        PixelChannel channel = GetPixelChannelChannel(image,id); \n \n        if (channel == channel) \n          { \n            PixelTrait traits = GetPixelChannelTraits(image,channel); \n            if ((traits & UpdatePixelTrait) == 0) \n              continue; \n            if (op == MagickEvaluateOperatorOver) \n              { \n                if (EvaluateImageChannel(image,channel,op,value,exception) ==\n                    MagickFalse)\n                  continue; \n              } \n            else \n              if (EvaluateImageChannel(image,channel,op,value,exception) ==\n                  MagickFalse)\n                continue; \n            break; \n          } \n        q++; \n      } \n      if (id >= (long) GetPixelChannels(image))\n"}
{"label": " \nMagickExport MagickBooleanType SolarizeImage(Image *image, \n  const double threshold) \n{ \n#define SolarizeImageTag  \"Solarize/Image\" \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  ViewInfo \n    **image_view; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  if (image->storage_class == PseudoClass) \n    { \n      register long \n        i; \n \n       \n \n      for (i=0; i < (long) image->colors; i++) \n      { \n        if ((MagickRealType) image->colormap[i].red > threshold) \n          image->colormap[i].red=(Quantum) QuantumRange-image->colormap[i].red; \n        if ((MagickRealType) image->colormap[i].green > threshold) \n          image->colormap[i].green=(Quantum) QuantumRange- \n            image->colormap[i].green; \n        if ((MagickRealType) image->colormap[i].blue > threshold) \n          image->colormap[i].blue=(Quantum) QuantumRange- \n            image->colormap[i].blue; \n      } \n    } \n   \n \n  status=MagickTrue; \n  image_view=AcquireCacheViewThreadSet(image); \n  for (y=0; y < (long) image->rows; y++) \n  { \n    register long \n      id, \n      x; \n \n    register PixelPacket \n      *q; \n \n    if (status == MagickFalse) \n      continue; \n    id=GetCacheViewThreadId(); \n    q=GetCacheViewPixels(image_view[id],0,y,image->columns,1); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (long) image->columns; x++) \n    { \n      if ((MagickRealType) q->red > threshold) \n        q->red=(Quantum) QuantumRange-q->red; \n      if ((MagickRealType) q->green > threshold) \n        q->green=(Quantum) QuantumRange-q->green; \n      if ((MagickRealType) q->blue > threshold) \n        q->blue=(Quantum) QuantumRange-q->blue; \n      q++; \n    } \n    if (SyncCacheView(image_view[id]) == MagickFalse) \n      status=MagickFalse; \n    if (SetImageProgress(image,SolarizeImageTag,y,image->rows) == MagickFalse) \n      status=MagickFalse; \n  } \n  image_view=DestroyCacheViewThreadSet(image_view); \n  return(status); \n} ", "pred": " \nMagickExport MagickBooleanType SolarizeImage(Image *image, \n  const double threshold) \n{ \n#define SolarizeImageTag  \"Solarize/Image\" \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  ViewInfo \n    **image_view; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  if (image->storage_class == PseudoClass) \n    { \n      register long \n        i; \n \n       \n \n      for (i=0; i < (long) image->colors; i++) \n      { \n        if ((MagickRealType) image->colormap[i].red > threshold) \n          image->colormap[i].red=(Quantum) QuantumRange-image->colormap[i].red; \n        if ((MagickRealType) image->colormap[i].green > threshold) \n          image->colormap[i].green=(Quantum) QuantumRange-image->colormap[i].green; \n        if ((MagickRealType) image->colormap[i].blue > threshold) \n          image->colormap[i].blue=(Quantum) QuantumRange-image->colormap[i].blue; \n      } \n      return(MagickTrue); \n    } \n  if (image->storage_class == DirectClass) \n    { \n      register ssize_t\n        i; \n \n      for (i=0; i < (ssize_t) image->colors; i++) \n      { \n        if ((MagickRealType) image->colormap[i].red > threshold) \n          image->colormap[i].red=(Quantum) QuantumRange-image->colormap[i].red; \n        if ((MagickRealType) image->colormap[i].green > threshold) \n          image->colormap[i].green=(Quantum) QuantumRange-image->colormap[i].green; \n        if ((MagickRealType) image->colormap[i].blue > threshold) \n          image->colormap[i].blue=(Quantum) QuantumRange-image->colormap[i].blue; \n      } \n      return(MagickTrue); \n    } \n  if (image->storage_class == PseudoClass) \n    { \n      register ssize_t\n        i; \n \n      for (i=0; i < (ssize_t) image->colors; i++) \n      { \n        if ((MagickRealType) image->colormap[i].red > threshold) \n          image->colormap[i].red=(Quantum) QuantumRange-image->colormap[i].red; \n        if ((MagickRealType) image->colormap[i].green > threshold) \n          image->colormap[i].green=(Quantum) QuantumRange-image->colormap[i].green; \n        if ((MagickRealType) image->colormap[i].blue > threshold)"}
{"label": " \nMagickExport Image *MorphImages(const Image *image, \n  const unsigned long number_frames,ExceptionInfo *exception) \n{ \n#define MorphImageTag  \"Morph/Image\" \n \n  Image \n    *morph_image, \n    *morph_images; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    scene; \n \n  MagickRealType \n    alpha, \n    beta; \n \n  register const Image \n    *next; \n \n  register long \n    i; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  morph_images=CloneImage(image,0,0,MagickTrue,exception); \n  if (morph_images == (Image *) NULL) \n    return((Image *) NULL); \n  if (GetNextImageInList(image) == (Image *) NULL) \n    { \n       \n \n      for (i=1; i < (long) number_frames; i++) \n      { \n        morph_image=CloneImage(image,0,0,MagickTrue,exception); \n        if (morph_image == (Image *) NULL) \n          { \n            morph_images=DestroyImageList(morph_images); \n            return((Image *) NULL); \n          } \n        AppendImageToList(&morph_images,morph_image); \n        if ((image->progress_monitor!= (MagickProgressMonitor) NULL) && \n            (QuantumTick(i,number_frames)!= MagickFalse)) \n          { \n            status=image->progress_monitor(MorphImageTag,i,number_frames, \n              image->client_data); \n            if (status == MagickFalse) \n              break; \n          } \n      } \n      return(GetFirstImageInList(morph_images)); \n    } \n   \n \n  scene=0; \n  next=image; \n  for ( ; GetNextImageInList(next)!= (Image *) NULL; next=GetNextImageInList(next)) \n  { \n    MagickBooleanType \n      progress; \n \n    for (i=0; i < (long) number_frames; i++) \n    { \n      ViewInfo \n        **image_view, \n        **morph_view; \n \n      beta=(MagickRealType) (i+1.0)/(MagickRealType) (number_frames+1.0); \n      alpha=1.0-beta; \n      morph_image=ZoomImage(next,(unsigned long) (alpha*next->columns+beta* \n        GetNextImageInList(next)->columns+0.5),(unsigned long) (alpha* \n        next->rows+beta*GetNextImageInList(next)->rows+0.5),exception); \n      if (morph_image == (Image *) NULL) \n        { \n          morph_images=DestroyImageList(morph_images); \n          return((Image *) NULL); \n        } \n      if (SetImageStorageClass(morph_image,DirectClass) == MagickFalse) \n        { \n          InheritException(exception,&morph_image->exception); \n          morph_image=DestroyImage(morph_image); \n          return((Image *) NULL); \n        } \n      AppendImageToList(&morph_images,morph_image); \n      morph_images=GetLastImageInList(morph_images); \n      morph_image=ZoomImage(GetNextImageInList(next),morph_images->columns, \n        morph_images->rows,exception); \n      if (morph_image == (Image *) NULL) \n        { \n          morph_images=DestroyImageList(morph_images); \n          return((Image *) NULL); \n        } \n      image_view=AcquireCacheViewThreadSet(morph_image); \n      morph_view=AcquireCacheViewThreadSet(morph_images); \n      for (y=0; y < (long) morph_images->rows; y++) \n      { \n        register const PixelPacket \n          *p; \n \n        register long \n          id, \n          x; \n \n        register PixelPacket \n          *q; \n \n    if (status == MagickFalse) \n      continue; \n        id=GetCacheViewThreadId(); \n        p=AcquireCacheViewPixels(image_view[id],0,y,morph_image->columns,1, \n          exception); \n        q=GetCacheViewPixels(morph_view[id],0,y,morph_images->columns,1); \n        if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n          { \n            status=MagickFalse; \n            continue; \n          } \n        for (x=0; x < (long) morph_images->columns; x++) \n        { \n          q->red=RoundToQuantum(alpha*q->red+beta*p->red); \n          q->green=RoundToQuantum(alpha*q->green+beta*p->green); \n          q->blue=RoundToQuantum(alpha*q->blue+beta*p->blue); \n          q->opacity=RoundToQuantum(alpha*q->opacity+beta*p->opacity); \n          p++; \n          q++; \n        } \n        if (SyncCacheView(morph_view[id]) == MagickFalse) \n          status=MagickFalse; \n      } \n      morph_view=DestroyCacheViewThreadSet(morph_view); \n      image_view=DestroyCacheViewThreadSet(image_view); \n      morph_image=DestroyImage(morph_image); \n    } \n    if (i < (long) number_frames) \n      break; \n     \n \n    morph_image=CloneImage(GetNextImageInList(next),0,0,MagickTrue,exception); \n    if (morph_image == (Image *) NULL) \n      { \n        morph_images=DestroyImageList(morph_images); \n        return((Image *) NULL); \n      } \n    AppendImageToList(&morph_images,morph_image); \n    morph_images=GetLastImageInList(morph_images); \n    progress=SetImageProgress(image,MorphImageTag,scene, \n      GetImageListLength(image));", "pred": " \nMagickExport Image *MorphImages(const Image *image, \n  const unsigned long number_frames,ExceptionInfo *exception) \n{ \n#define MorphImageTag  \"Morph/Image\" \n \n  Image \n    *morph_image, \n    *morph_images; \n \n  long \n    y; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    scene; \n \n  MagickRealType \n    alpha, \n    beta; \n \n  register const Image \n    *next; \n \n  register long \n    i; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  morph_images=CloneImage(image,0,0,MagickTrue,exception); \n  if (morph_images == (Image *) NULL) \n    return((Image *) NULL); \n  if (GetNextImageInList(image) == (Image *) NULL) \n    { \n       \n \n       morph_images=DestroyImageList(morph_images); \n       return((Image *) NULL); \n    } \n  morph_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (morph_image == (Image *) NULL) \n    { \n       \n       morph_images=DestroyImageList(morph_images); \n       return((Image *) NULL); \n    } \n  morph_image->alpha_trait=BlendPixelTrait; \n  morph_image->alpha_trait!= UndefinedPixelTrait? \n    (morph_image->alpha_trait == BlendPixelTrait? BlendPixelTrait : UndefinedPixelTrait) : \n    UndefinedPixelTrait; \n  morph_image->page.width=image->columns; \n  morph_image->page.height=image->rows; \n  morph_image->page.x=0; \n  morph_image->page.y=0; \n  morph_image->background_color.alpha=(MagickRealType) TransparentAlpha; \n  morph_image->background_color.alpha_trait=BlendPixelTrait; \n  morph_image->background_color.alpha_trait!= UndefinedPixelTrait? \n    (morph_image->background_color.alpha_trait == BlendPixelTrait? BlendPixelTrait : UndefinedPixelTrait) : \n    UndefinedPixelTrait; \n  morph_image->background_color.red=MorphPixelTrait; \n  morph_image->background_color.green=MorphPixelTrait; \n  morph_image->background_color.blue=MorphPixelTrait; \n  morph_image->background_color.black=MorphPixelTrait; \n  morph_image->storage_class=DirectClass; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors=0; \n  morph_image->depth=8; \n  morph_image->colors="}
{"label": " \nvoid process_v3(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o, \n                const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_colorzones_data_t *d = (dt_iop_colorzones_data_t *)(piece->data); \n  const int ch = piece->colors; \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    float *in = (float *)i + ch * k; \n    float *out = (float *)o + ch * k; \n    const float a = in[1], b = in[2]; \n    const float h = fmodf(atan2f(b, a) + 2.0f * DT_M_PI_F, 2.0f * DT_M_PI_F) / (2.0f * DT_M_PI_F); \n    const float C = sqrtf(b * b + a * a); \n    float select = 0.0f; \n    float blend = 0.0f; \n    switch(d->channel) \n    { \n      case DT_IOP_COLORZONES_L: \n        select = fminf(1.0f, in[0] / 100.0f); \n        break; \n      case DT_IOP_COLORZONES_C: \n        select = fminf(1.0f, C / 128.0f); \n        break; \n      default: \n      case DT_IOP_COLORZONES_h: \n        select = h; \n        blend = powf(1.0f - C / 128.0f, 2.0f); \n        break; \n    } \n    const float Lm = (blend *.5f + (1.0f - blend) * lookup(d->lut[0], select)) -.5f; \n    const float hm = (blend *.5f + (1.0f - blend) * lookup(d->lut[2], select)) -.5f; \n    blend *= blend;  \n \n     \n \n    const float Cm = 2.0f * lookup(d->lut[1], select); \n    const float L = in[0] * powf(2.0f, 4.0f * Lm); \n    out[0] = L; \n    out[1] = cosf(2.0f * DT_M_PI_F * (h + hm)) * Cm * C; \n    out[2] = sinf(2.0f * DT_M_PI_F * (h + hm)) * Cm * C; \n    out[3] = in[3]; \n  } \n} ", "pred": " \nvoid process_v3(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o, \n                const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_colorzones_data_t *d = (dt_iop_colorzones_data_t *)(piece->data); \n  const int ch = piece->colors; \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    float *in = (float *)i + ch * k; \n    float *out = (float *)o + ch * k; \n    const float a = in[1], b = in[2]; \n    const float h = fmodf(atan2f(b, a) + 2.0f * DT_M_PI_F, 2.0f * DT_M_PI_F) / (2.0f * DT_M_PI_F); \n    const float C = sqrtf(b * b + a * a); \n    const float R = h * (1.0f / (1.0f + C)); \n    const float G = h * (1.0f / (1.0f - C)); \n    const float B = h * (1.0f - C); \n    const float X = (R * in[0] + G * in[1] + B * in[2]); \n    const float Y = (R * in[1] + G * in[2] + B * in[0]); \n    out[0] = (in[0] * R + in[1] * G + in[2] * B) / X; \n    out[1] = (in[0] * G + in[1] * B + in[2] * R) / Y; \n    out[2] = (in[0] * B + in[1] * R + in[2] * G) / X; \n  }\n}\n\nstatic void process_v4(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o, \n                       const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_colorzones_data_t *d = (dt_iop_colorzones_data_t *)(piece->data); \n  const int ch = piece->colors; \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    float *in = (float *)i + ch * k; \n    float *out = (float *)o + ch * k; \n    const float a = in[3], b = in[4], c = in[5], d = in[6], e = in[7], f = in[8];"}
{"label": " \nvoid mzd_process_rows6(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, \n\t\t       rci_t const *L2, mzd_t const *T3, rci_t const *L3, mzd_t const *T4, rci_t const *L4, \n\t\t       mzd_t const *T5, rci_t const *L5) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int const rem = k % 6; \n \n  int const ka = k / 6 + ((rem >= 5)? 1 : 0); \n  int const kb = k / 6 + ((rem >= 4)? 1 : 0); \n  int const kc = k / 6 + ((rem >= 3)? 1 : 0); \n  int const kd = k / 6 + ((rem >= 2)? 1 : 0); \n  int const ke = k / 6 + ((rem >= 1)? 1 : 0);; \n  int const kf = k / 6; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n  word const kc_bm = __M4RI_LEFT_BITMASK(kc); \n  word const kd_bm = __M4RI_LEFT_BITMASK(kd); \n  word const ke_bm = __M4RI_LEFT_BITMASK(ke); \n  word const kf_bm = __M4RI_LEFT_BITMASK(kf); \n \n \n  for(r = startrow; r < stoprow; ++r) { \n    word bits = mzd_read_bits(M, r, startcol, k); \n    rci_t const x0 = L0[ bits & ka_bm ]; bits>>=ka; \n    rci_t const x1 = L1[ bits & kb_bm ]; bits>>=kb; \n    rci_t const x2 = L2[ bits & kc_bm ]; bits>>=kc; \n    rci_t const x3 = L3[ bits & kd_bm ]; bits>>=kd; \n    rci_t const x4 = L4[ bits & ke_bm ]; bits>>=ke; \n    rci_t const x5 = L5[ bits & kf_bm ]; \n \n     \n \n    if(((x0 | x1) | (x2 | x3) | (x4 | x5)) == 0)  \n \n      continue; \n \n    word *m0 = M->rows[r] + blocknum; \n    word const *t[6]; \n    t[0] = T0->rows[x0] + blocknum; \n    t[1] = T1->rows[x1] + blocknum; \n    t[2] = T2->rows[x2] + blocknum; \n    t[3] = T3->rows[x3] + blocknum; \n    t[4] = T4->rows[x4] + blocknum; \n    t[5] = T5->rows[x5] + blocknum; \n \n    _mzd_combine_6( m0, t, wide); \n  } \n \n  __M4RI_DD_MZD(M); \n} ", "pred": " \nvoid mzd_process_rows6(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, \n\t\t       rci_t const *L2, mzd_t const *T3, rci_t const *L3, mzd_t const *T4, rci_t const *L4, \n\t\t       mzd_t const *T5, rci_t const *L5) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int const rem = k % 6; \n \n  int const ka = k / 6 + ((rem >= 5)? 1 : 0); \n  int const kb = k / 6 + ((rem >= 4)? 1 : 0); \n  int const kc = k / 6 + ((rem >= 3)? 1 : 0); \n  int const kc2 = k / 6 + ((rem >= 2)? 1 : 0); \n  int const kc3 = k / 6 + ((rem >= 1)? 1 : 0); \n  int const kc4 = k / 6 + ((rem >= 0)? 1 : 0); \n  int const kc5 = k / 6 + ((rem >= -1)? 1 : 0); \n  int const kc6 = k / 6 + ((rem >= -2)? 1 : 0); \n  int const kc7 = k / 6 + ((rem >= -3)? 1 : 0); \n  int const kc8 = k / 6 + ((rem >= -4)? 1 : 0); \n  int const kc9 = k / 6 + ((rem >= -5)? 1 : 0); \n  int const kc10 = k / 6 + ((rem >= -6)? 1 : 0); \n  int const kc11 = k / 6 + ((rem >= -7)? 1 : 0); \n  int const kc12 = k / 6 + ((rem >= -8)? 1 : 0); \n  int const kc13 = k / 6 + ((rem >= -9)? 1 : 0); \n  int const kc14 = k / 6 + ((rem >= -10)? 1 : 0); \n  int const kc15 = k / 6 + ((rem >= -11)? 1 : 0); \n  int const kc16 = k / 6 + ((rem >= -12)? 1 : 0); \n  int const kc17 = k / 6 + ((rem >= -13)? 1 : 0); \n  int const kc18 = k / 6 + ((rem >= -14)? 1 : 0); \n  int const kc19 = k / 6 + ((rem >= -15)? 1 : 0); \n  int const kc20 = k / 6 + ((rem >= -16)? 1 : 0); \n  int const kc21 = k / 6 + ((rem >= -17)? 1 : 0); \n  int const kc22 = k / 6 + ((rem >= -18)? 1 : 0); \n  int const kc23 = k / 6 + ((rem >= -19)? 1 : 0); \n  int const kc24 = k / 6 + ((rem >= -20)? 1 : 0); \n  int const kc25 = k / 6 + ((rem >= -21)? 1 : 0); \n  int const kc26 = k / 6 + ((rem >= -22)? 1 : 0); \n  int const kc27 = k / 6 + ((rem >= -23)? 1 : 0); \n  int const kc28 = k / 6 + ((rem >= -24)? 1 : 0); \n  int const kc29 = k / 6 + ((rem >= -25)? 1 : 0); \n  int const kc30"}
{"label": " \nstatic int dt_ellipse_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                   dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start2 = dt_get_wtime(); \n \n   \n \n  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form->points)->data); \n \n   \n \n  const int w = roi->width; \n  const int h = roi->height; \n  const int px = roi->x; \n  const int py = roi->y; \n  const float iscale = 1.0f / roi->scale; \n  const int mesh = 4; \n  const int mw = (w + mesh - 1) / mesh + 1; \n  const int mh = (h + mesh - 1) / mesh + 1; \n \n  float *points = malloc((size_t)mw * mh * 2 * sizeof(float)); \n  if(points == NULL) return 0; \n \n  for(int j = 0; j < mh; j++) \n    for(int i = 0; i < mw; i++) \n    { \n      size_t index = (size_t)j * mw + i; \n      points[index * 2] = (mesh * i + px) * iscale; \n      points[index * 2 + 1] = (mesh * j + py) * iscale; \n    } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] ellipse draw took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n  if(!dt_dev_distort_backtransform_plus(module->dev, piece->pipe, 0, module->priority, points, \n                                        (size_t)mw * mh)) \n  { \n    free(points); \n    return 0; \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] ellipse transform took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n  const int wi = piece->pipe->iwidth, hi = piece->pipe->iheight; \n  const float center[2] = { ellipse->center[0] * wi, ellipse->center[1] * hi }; \n  const float radius[2] = { ellipse->radius[0] * MIN(wi, hi), ellipse->radius[1] * MIN(wi, hi) }; \n  const float total[2] = { (ellipse->flags & DT_MASKS_ELLIPSE_PROPORTIONAL? ellipse->radius[0] * (1.0f + ellipse->border) : ellipse->radius[0] + ellipse->border) * MIN(wi, hi), \n                           (ellipse->flags & DT_MASKS_ELLIPSE_PROPORTIONAL? ellipse->radius[1] * (1.0f + ellipse->border) : ellipse->radius[1] + ellipse->border) * MIN(wi, hi) }; \n \n  float a, b, ta, tb, alpha; \n \n  if(radius[0] >= radius[1]) \n  { \n    a = radius[0]; \n    b = radius[1]; \n    ta = total[0]; \n    tb = total[1]; \n    alpha = (ellipse->rotation / 180.0f) * M_PI; \n  } \n  else \n  { \n    a = radius[1]; \n    b = radius[0]; \n    ta = total[1]; \n    tb = total[0]; \n    alpha = ((ellipse->rotation - 90.0f) / 180.0f) * M_PI; \n  } \n \n  for(int i = 0; i < mh; i++) \n    for(int j = 0; j < mw; j++) \n    { \n      size_t index = (size_t)i * mw + j; \n      float x = points[index * 2] - center[0]; \n      float y = points[index * 2 + 1] - center[1]; \n      float v = atan2(y, x) - alpha; \n      float cosv = cos(v); \n      float sinv = sin(v); \n      float radius2 = a * a * b * b / (a * a * sinv * sinv + b * b * cosv * cosv); \n      float total2 = ta * ta * tb * tb / (ta * ta * sinv * sinv + tb * tb * cosv * cosv); \n      float l2 = x * x + y * y; \n \n      if(l2 < radius2) \n        points[index * 2] = 1.0f; \n      else if(l2 < total2) \n      { \n        float f = (total2 - l2) / (total2 - radius2); \n        points[index * 2] = f * f; \n      } \n      else \n        points[index * 2] = 0.0f; \n    } \n \n \n \n  for(int j = 0; j < h; j++) \n  { \n    int jj = j % mesh; \n    int mj = j / mesh; \n    for(int i = 0; i < w; i++) \n    { \n      int ii = i % mesh; \n      int mi = i / mesh; \n      size_t mindex = (size_t)mj * mw + mi; \n      buffer[(size_t)j * w + i] \n          = (points[mindex * 2] * (mesh - ii) * (mesh - jj) + points[(mindex + 1) * 2] * ii * (mesh - jj) \n             + points[(mindex + mw) * 2] * (mesh - ii) * jj + points[(mindex + mw + 1) * 2] * ii * jj) \n            / (mesh * mesh); \n    } \n  } \n \n  free(points); \n \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] ellipse fill took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n \n \n \n  return 1; \n} ", "pred": " \nstatic int dt_ellipse_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                   dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start2 = dt_get_wtime(); \n \n   \n \n  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form->points)->data); \n \n   \n \n  const int w = roi->width; \n  const int h = roi->height; \n  const int px = roi->x; \n  const int py = roi->y; \n  const float iscale = 1.0f / roi->scale; \n  const int mesh = 4; \n  const int mw = (w + mesh - 1) / mesh + 1; \n  const int mh = (h + mesh - 1) / mesh + 1; \n \n  float *points = malloc((size_t)mw * mh * 2 * sizeof(float)); \n  if(points == NULL) return 0; \n \n  float *mask = malloc((size_t)mw * mh * sizeof(float)); \n  if(mask == NULL) { free(points); return 0; } \n \n  int i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x5, y5, z5, x6, y6, z6, x7, y7, z7, x8, y8, z8, x9, y9, z9, x10, y10, z10, x11, y11, z11, x12, y12, z12, x13, y13, z13, x14, y14, z14, x15, y15, z15, x16, y16, z16, x17, y17, z17, x18, y18, z18, x19, y19, z19, x20, y20, z20, x21, y21, z21, x22, y22, z22, x23, y23, z23, x24, y24, z24, x25, y25, z25, x26, y26, z26, x27, y27, z27, x28, y28, z28, x29, y29, z29, x30, y30, z30, x31, y31, z31, x32, y32, z32, x33, y33, z33, x34, y34, z34, x35, y35, z35, x36, y36, z36, x37, y37, z37, x38, y38, z38, x39, y39, z39, x40, y40, z40, x41, y41, z41, x42, y42, z42, x43, y43, z43, x44, y44, z44, x45, y45, z45, x46, y46, z46, x47, y47, z47, x48, y48, z48, x49, y49, z49, x50, y50, z50, x51, y51, z51, x52, y52, z52, x53, y53, z53, x54, y54, z54, x55, y55, z55, x56, y56, z56, x57, y57, z57, x58, y58, z58, x59, y59, z59, x60, y60, z60, x61, y61, z61, x62, y62, z62, x63, y63, z63, x64, y64, z64, x65, y65, z65, x66, y66, z66, x67, y67, z67, x68, y68, z68, x69, y69, z69, x70, y70, z70, x71, y71, z71, x72, y72, z72, x73, y73, z73, x74, y74, z74, x75, y75, z75, x76, y76, z76, x77, y77, z77, x78, y78, z78, x79, y79, z79, x80, y80, z80, x81, y81, z81, x82, y82, z82, x83, y83, z83, x84, y84, z84, x85, y85, z85, x86, y86, z86, x87, y87, z87, x88, y88, z88, x89, y89, z89, x90, y90, z90, x91, y91, z91, x92, y92, z92, x93, y93, z93, x94, y94, z94, x95, y95, z95, x96, y96, z96, x97, y97, z97, x98, y98, z98, x99, y99, z99, x100, y100, z100, x101, y101, z101, x102, y102, z102, x103, y103, z103, x104, y104, z104, x105, y105, z105, x106, y106, z106, x107, y107, z107, x108, y108, z108, x109, y109, z109, x110, y110, z110, x111, y111, z111, x112, y112, z112, x113, y113, z113, x114, y114, z114, x115, y115, z115, x116, y116, z116, x117, y117, z117, x118, y118, z118, x119, y119, z119, x120, y120, z120, x121, y121, z121, x122, y122, z122, x123, y123, z123, x124, y124, z124, x125, y125, z125, x126, y126, z126, x127, y127, z127, x128, y128, z128, x129, y129, z129, x130, y130, z130, x131, y131, z131, x132, y132, z132, x133, y133, z133, x134, y134, z134, x135, y135, z135, x136, y136, z136, x137, y137, z137, x138, y138, z138, x139, y139, z139, x140, y140, z140, x141, y141, z141, x142, y142, z142, x143, y143, z143, x144, y144, z144, x145, y145, z145, x146, y146, z146, x147, y147, z147, x148, y148, z148, x149, y149, z149, x150, y150, z150, x151, y151, z151, x152, y152, z152, x153, y153, z153, x154, y154, z154, x155, y155, z155, x156, y156, z156, x157, y157, z157, x158, y158, z158, x159, y159, z159, x160, y160, z160, x161, y161, z161, x162, y162, z162, x163, y"}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_UINT16) \n  {  \n \n \n    const uint16_t *const in = (const uint16_t *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t pin = (size_t)(roi_in->width * (j + csy) + csx) + i; \n        const size_t pout = (size_t)j * roi_out->width + i; \n \n        const int id = BL(roi_out, d, j, i); \n        out[pout] = (in[pin] - d->sub[id]) / d->div[id]; \n      } \n    } \n \n    piece->pipe->dsc.filters = dt_rawspeed_crop_dcraw_filters(self->dev->image_storage.buf_dsc.filters, csx, csy); \n    adjust_xtrans_filters(piece->pipe, csx, csy); \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_FLOAT) \n  {  \n \n \n    const float *const in = (const float *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t pin = (size_t)(roi_in->width * (j + csy) + csx) + i; \n        const size_t pout = (size_t)j * roi_out->width + i; \n \n        const int id = BL(roi_out, d, j, i); \n        out[pout] = (in[pin] - d->sub[id]) / d->div[id]; \n      } \n    } \n \n    piece->pipe->dsc.filters = dt_rawspeed_crop_dcraw_filters(self->dev->image_storage.buf_dsc.filters, csx, csy); \n    adjust_xtrans_filters(piece->pipe, csx, csy); \n  } \n  else \n  {  \n \n \n    const float *const in = (const float *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n    const float sub = d->sub[0], div = d->div[0]; \n \n    const int ch = piece->colors; \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        for(int c = 0; c < ch; c++) \n        { \n          const size_t pin = (size_t)ch * (roi_in->width * (j + csy) + csx + i) + c; \n          const size_t pout = (size_t)ch * (j * roi_out->width + i) + c; \n \n          out[pout] = (in[pin] - sub) / div; \n        } \n      } \n    } \n  } \n \n  for(int k = 0; k < 4; k++) piece->pipe->dsc.processed_maximum[k] = 1.0f; \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_UINT16) \n  {  \n \n \n    const uint16_t *const in = (const uint16_t *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const float val = in[i]; \n        out[i] = val; \n      } \n      in += csx; \n      out += csy; \n    } \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_FLOAT32) \n  {  \n \n \n    const float *const in = (const float *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const float val = in[i]; \n        out[i] = val; \n      } \n      in += csx; \n      out += csy; \n    } \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_FLOAT64) \n  {  \n \n \n    const double *const in = (const double *const)ivoid; \n    double *const out = (double *const)ovoid; \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const double val = in[i]; \n        out[i] = val; \n      } \n      in += csx; \n      out += csy; \n    } \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_UINT8) \n  {  \n \n \n    const uint8_t *const in = (const uint8_t *const)ivoid; \n    uint8_t *const out = (uint8_t *const)ovoid; \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const uint8_t val = in[i]; \n        out[i] = val; \n      } \n      in += csx; \n      out += csy; \n    } \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_INT16) \n  {  \n \n \n    const int16_t *const in = (const int16_t *const)ivoid; \n    int16_t *const out = (int16_t *const)ovoid; \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const int16_t val = in[i]; \n        out[i] = val; \n      } \n      in += cs"}
{"label": " \nstatic int crypt_all(int *pcount, struct db_salt *salt) \n{ \n\tint count = *pcount; \n\tint index; \n \n\tif (saved_salt->v.type) { \n\t\t \n \n\t\t \n \n\t\tmemset(crypt_key, 0, count * BINARY_SIZE); \n\t\treturn count; \n\t} \n \n\tfor (index = 0; index < count; index += MAX_KEYS_PER_CRYPT) { \n\t\tunsigned char pwd_ver[(2+64)*MAX_KEYS_PER_CRYPT]; \n\t\tint lens[MAX_KEYS_PER_CRYPT], i; \n\t\tunsigned char *pin[MAX_KEYS_PER_CRYPT], *pout[MAX_KEYS_PER_CRYPT]; \n\t\tfor (i = 0; i < MAX_KEYS_PER_CRYPT; ++i) { \n\t\t\tlens[i] = strlen(saved_key[i+index]); \n\t\t\tpin[i] = (unsigned char*)saved_key[i+index]; \n\t\t\tpout[i] = &pwd_ver[i*(2+2*KEY_LENGTH(saved_salt->v.mode))]; \n\t\t} \n\t\tpbkdf2_sha1_sse((const unsigned char **)pin, lens, saved_salt->salt, SALT_LENGTH(saved_salt->v.mode), KEYING_ITERATIONS, pout, 2+2*KEY_LENGTH(saved_salt->v.mode), 0); \n\t\tfor (i = 0; i < MAX_KEYS_PER_CRYPT; ++i) { \n\t\t\tif (!memcmp(&(pout[i][KEY_LENGTH(saved_salt->v.mode)<<1]), saved_salt->passverify, 2)) \n\t\t\t{ \n\t\t\t\t \n \n\t\t\t\thmac_sha1(&(pout[i][KEY_LENGTH(saved_salt->v.mode)]), KEY_LENGTH(saved_salt->v.mode), \n\t\t\t\t\t\t   (const unsigned char*)saved_salt->datablob, saved_salt->comp_len, \n\t\t\t\t\t\t   crypt_key[index+i], BINARY_SIZE); \n\t\t\t} \n\t\t\telse \n\t\t\t\tmemset(crypt_key[index+i], 0, BINARY_SIZE); \n\t\t} \n\t\tint LEN = 2+2*KEY_LENGTH(saved_salt->v.mode); \n\t\tunion { \n\t\t\t \n \n\t\t\t \n \n\t\t\tunsigned char pwd_ver[4+64]; \n\t\t\tARCH_WORD_32 w; \n\t\t} x; \n\t\tunsigned char *pwd_ver = x.pwd_ver; \n\t\tLEN += 2; \n\t\tpbkdf2_sha1((unsigned char *)saved_key[index], \n\t\t       strlen(saved_key[index]), saved_salt->salt, SALT_LENGTH(saved_salt->v.mode), \n\t\t       KEYING_ITERATIONS, pwd_ver, LEN, 0); \n\t\talter_endianity(pwd_ver, LEN); \n\t\tif (!memcmp(&(pwd_ver[KEY_LENGTH(saved_salt->v.mode)<<1]), saved_salt->passverify, 2)) \n\t\t{ \n\t\t\t \n \n\t\t\thmac_sha1(&(pwd_ver[KEY_LENGTH(saved_salt->v.mode)]), KEY_LENGTH(saved_salt->v.mode), \n                       (const unsigned char*)saved_salt->datablob, saved_salt->comp_len, \n                       crypt_key[index], BINARY_SIZE); \n\t\t} \n\t\telse \n\t\t\tmemset(crypt_key[index], 0, BINARY_SIZE); \n\t} \n\treturn count; \n} ", "pred": " \nstatic int crypt_all(int *pcount, struct db_salt *salt) \n{ \n\tint count = *pcount; \n\tint index; \n \n\tif (saved_salt->v.type) { \n\t\t \n \n\t\t \n \n\t\tmemset(crypt_key, 0, count * BINARY_SIZE); \n\t\treturn count; \n\t} \n \n\tfor (index = 0; index < count; index += MAX_KEYS_PER_CRYPT) { \n\t\tunsigned char pwd_ver[(2+64)*MAX_KEYS_PER_CRYPT]; \n\t\tint lens[MAX_KEYS_PER_CRYPT], i; \n\t\tunsigned char *pin[MAX_KEYS_PER_CRYPT], *pout[MAX_KEYS_PER_CRYPT]; \n\t\tfor (i = 0; i < MAX_KEYS_PER_CRYPT; ++i) { \n\t\t\tlens[i] = strlen(saved_key[i+index]); \n\t\t\tpin[i] = (unsigned char*)saved_key[i+index]; \n\t\t\tpout[i] = &pwd_ver[i*(2+2*KEY_LENGTH(saved_salt->v.mode))]; \n\t\t} \n\t\tpbkdf2_sha1_sse((const unsigned char **)pin, lens, saved_salt->salt, SALT_LENGTH, pout, (unsigned char *)crypt_key[index], MAX_KEYS_PER_CRYPT); \n\t} \n \n\treturn count; \n} \n \n\nstatic int cmp_all(void *binary, int count) \n{ \n\tint index; \n \n\tfor (index = 0; index < count; index++) \n\t\tif (saved_salt->v.type) \n\t\t\tif (memcmp(binary, crypt_key[index], BINARY_SIZE)) \n\t\t\t\treturn 1; \n\treturn 0; \n} \n \n\nstatic int cmp_one(void *binary, int index) \n{ \n\treturn!memcmp(binary, crypt_key[index], BINARY_SIZE); \n} \n \n\nstatic int cmp_exact(char *source, int index) \n{ \n\treturn 1; \n} \n \n\nstatic void set_salt(void *salt) \n{ \n\tsaved_salt = (struct db_salt*)salt; \n} \n \n\nstatic void set_key(char *key, int index) \n{ \n\tsaved_key[index] = (unsigned char*)key; \n} \n \n\nstatic void set_key_utf8(char *key, int index) \n{ \n\tunsigned char *utf8 = (unsigned char*)key; \n\tsaved_key[index][0] = 0; \n\tsaved_key[index][1] = 0; \n\tsaved_key[index][2] = 0; \n\tsaved_key[index][3] = 0; \n\tsaved_key[index][4] = 0; \n\tsaved_key[index][5] = 0; \n\tsaved_key[index][6] = 0; \n\tsaved_key[index][7] = 0; \n\tsaved_key[index][8] = 0; \n\tsaved_key[index][9] = 0; \n\tsaved_key[index][10] = 0; \n\tsaved_key[index][11] = 0; \n\tsaved_key[index][12] = 0; \n\tsaved_key[index][13] = 0; \n\tsaved_key[index][14] = 0; \n\tsaved_key[index][15] = 1; \n\tsaved_key[index][16] = 0; \n\tsaved_key[index][17] = 0; \n\tsaved_key[index][18] = 0; \n\tsaved_key[index][19] = 0; \n\tsaved_key[index][20] = 0; \n\tsaved_key[index][21"}
{"label": " \nmzd_t *_mzd_mul_m4rm(mzd_t *C, mzd_t const *A, mzd_t const *B, int k, int clear) { \n   \n \n \n  rci_t        x[__M4RI_M4RM_NTABLES]; \n  rci_t       *L[__M4RI_M4RM_NTABLES]; \n  word  const *t[__M4RI_M4RM_NTABLES]; \n  mzd_t       *T[__M4RI_M4RM_NTABLES]; \n  mzd_t  *Talign[__M4RI_M4RM_NTABLES]; \n  int c_align = (__M4RI_ALIGNMENT(C->rows[0], 16) == 8); \n \n  word *c; \n \n  rci_t const a_nr = A->nrows; \n  rci_t const a_nc = A->ncols; \n  rci_t const b_nc = B->ncols; \n \n  if (b_nc < m4ri_radix-10 || a_nr < 16) { \n    if(clear) \n      return mzd_mul_naive(C, A, B); \n    else \n      return mzd_addmul_naive(C, A, B); \n  } \n \n   \n \n  if (clear) { \n    mzd_set_ui(C, 0); \n  } \n \n  const int blocksize = __M4RI_MUL_BLOCKSIZE; \n \n  if(k==0) { \n     \n \n    k = (int)log2((__M4RI_CPU_L2_CACHE/64)/(double)B->width); \n    if ((__M4RI_CPU_L2_CACHE - 64*__M4RI_TWOPOW(k)*B->width) > (64*__M4RI_TWOPOW(k+1)*B->width - __M4RI_CPU_L2_CACHE)) \n      k++; \n \n    rci_t const klog = round(0.75 * log2_floor(MIN(MIN(a_nr,a_nc),b_nc))); \n \n    if(klog < k) \n      k = klog; \n \n    if (k<2) \n      k=2; \n    else if(k>6) \n      k=6; \n  } \n \n  const wi_t wide = C->width; \n  const word bm = __M4RI_TWOPOW(k)-1; \n \n  rci_t *buffer = (rci_t*)m4ri_mm_malloc(__M4RI_M4RM_NTABLES * __M4RI_TWOPOW(k) * sizeof(rci_t)); \n  for(int z=0; z<__M4RI_M4RM_NTABLES; z++) { \n    L[z] = buffer + z*__M4RI_TWOPOW(k); \n     \n \n    Talign[z] = mzd_init(__M4RI_TWOPOW(k), b_nc+m4ri_radix); \n    T[z] = mzd_init_window(Talign[z], 0, c_align*m4ri_radix, Talign[z]->nrows, b_nc + c_align*m4ri_radix); \n    T[z] = mzd_init(__M4RI_TWOPOW(k), b_nc); \n  } \n \n   \n \n  int const kk = __M4RI_M4RM_NTABLES * k; \n  assert(kk <= m4ri_radix); \n  rci_t const end = a_nc / kk; \n \n  for (rci_t giantstep = 0; giantstep < a_nr; giantstep += blocksize) { \n    for(rci_t i = 0; i < end; ++i) { \n      for(int z=0; z<__M4RI_M4RM_NTABLES; z++) { \n        mzd_make_table( B, kk*i + k*z, 0, k, T[z], L[z]); \n      } \n \n      const rci_t blockend = MIN(giantstep+blocksize, a_nr); \n      for(rci_t j = giantstep; j < blockend; j++) { \n        const word a = mzd_read_bits(A, j, kk*i, kk); \n \n        switch(__M4RI_M4RM_NTABLES) { \n        case 8: t[7] = T[ 7]->rows[ L[7][ (a >> 7*k) & bm ] ]; \n        case 7: t[6] = T[ 6]->rows[ L[6][ (a >> 6*k) & bm ] ]; \n        case 6: t[5] = T[ 5]->rows[ L[5][ (a >> 5*k) & bm ] ]; \n        case 5: t[4] = T[ 4]->rows[ L[4][ (a >> 4*k) & bm ] ]; \n        case 4: t[3] = T[ 3]->rows[ L[3][ (a >> 3*k) & bm ] ]; \n        case 3: t[2] = T[ 2]->rows[ L[2][ (a >> 2*k) & bm ] ]; \n        case 2: t[1] = T[ 1]->rows[ L[1][ (a >> 1*k) & bm ] ]; \n        case 1: t[0] = T[ 0]->rows[ L[0][ (a >> 0*k) & bm ] ]; \n          break; \n        default: \n          m4ri_die(\"__M4RI_M4RM_NTABLES must be <= 8 but got %d\", __M4RI_M4RM_NTABLES); \n        } \n \n        c = C->rows[j]; \n \n        switch(__M4RI_M4RM_NTABLES) { \n        case 8: _mzd_combine_8(c, t, wide); break; \n        case 7: _mzd_combine_7(c, t, wide); break; \n        case 6: _mzd_combine_6(c, t, wide); break; \n        case 5: _mzd_combine_5(c, t, wide); break; \n        case 4: _mzd_combine_4(c, t, wide); break; \n        case 3: _mzd_combine_3(c, t, wide); break; \n        case 2: _mzd_combine_2(c, t, wide); break; \n        case 1: _mzd_combine(c, t[0], wide); \n          break; \n        default: \n          m4ri_die(\"__M4RI_M4RM_NTABLES must be <= 8 but got %d\", __M4RI_M4RM_NTABLES); \n        } \n      } \n    } \n  } \n \n   \n \n  if (a_nc%kk) { \n    rci_t i; \n    for (i = kk / k * end; i < a_nc / k; ++i) { \n      mzd_make_table( B, k*i, 0, k, T[0], L[0]); \n      for(rci_t j = 0; j < a_nr; ++j) { \n        x[0] = L[0][ mzd_read_bits_int(A, j, k*i, k) ]; \n        c = C->rows", "pred": " \nmzd_t *_mzd_mul_m4rm(mzd_t *C, mzd_t const *A, mzd_t const *B, int k, int clear) { \n   \n \n \n  rci_t        x[__M4RI_M4RM_NTABLES]; \n  rci_t       *L[__M4RI_M4RM_NTABLES]; \n  word  const *t[__M4RI_M4RM_NTABLES]; \n  mzd_t       *T[__M4RI_M4RM_NTABLES]; \n  mzd_t  *Talign[__M4RI_M4RM_NTABLES]; \n  int c_align = (__M4RI_ALIGNMENT(C->rows[0], 16) == 8); \n \n  word *c; \n \n  rci_t const a_nr = A->nrows; \n  rci_t const a_nc = A->ncols; \n  rci_t const b_nc = B->ncols; \n \n  if (b_nc < m4ri_radix-10 || a_nr < 16) { \n    if(clear) \n      return mzd_mul_m4rm_clear(C, A, B, k, clear); \n    else \n      return mzd_mul_m4rm_clear(C, A, B, k, 0); \n  } \n \n  if (k == 0) { \n    if (a_nc == b_nc) { \n      if (a_nr == b_nc) { \n        if (a_nr == 1) { \n          if (a_nr == 1) { \n            if (a_nr == 1) { \n              if (a_nr == 1) { \n                if (a_nr == 1) { \n                  if (a_nr == 1) { \n                    if (a_nr == 1) { \n                      if (a_nr == 1) { \n                        if (a_nr == 1) { \n                          if (a_nr == 1) { \n                            if (a_nr == 1) { \n                              if (a_nr == 1) { \n                                if (a_nr == 1) { \n                                  if (a_nr == 1) { \n                                    if (a_nr == 1) { \n                                      if (a_nr == 1) { \n                                        if (a_nr == 1) { \n                                          if (a_nr == 1) { \n                                            if (a_nr == 1) { \n                                              if (a_nr == 1) { \n                                                if (a_nr == 1) { \n                                                  if (a_nr == 1) { \n                                                    if (a_nr == 1) { \n                                                      if (a_nr == 1) { \n                                                        if (a_nr == 1) { \n                                                          if (a_nr == 1) { \n                                                            if (a_nr == 1) { \n                                                              if (a_nr == 1) { \n                                                                if (a_nr == 1) { \n                                                                  if (a_nr == 1) { \n                                                                    if (a_nr == 1) { \n                                                                      if (a_nr == 1) { \n                                                                        if (a_nr == 1) { \n                                    "}
{"label": " \nvoid process(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, void *const ovoid, \n             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int ch = piece->colors; \n  const dt_iop_rgblevels_data_t *const d = (dt_iop_rgblevels_data_t *)piece->data; \n  dt_iop_rgblevels_params_t *p = (dt_iop_rgblevels_params_t *)&d->params; \n  dt_iop_rgblevels_gui_data_t *g = (dt_iop_rgblevels_gui_data_t *)self->gui_data; \n  const dt_iop_order_iccprofile_info_t *const work_profile = dt_ioppr_get_pipe_work_profile_info(piece->pipe); \n \n   \n \n  if(g && piece->pipe->type == DT_DEV_PIXELPIPE_PREVIEW) \n  { \n    dt_pthread_mutex_lock(&g->lock); \n    if(g->call_auto_levels == 1 &&!darktable.gui->reset) \n    { \n      g->call_auto_levels = -1; \n \n      dt_pthread_mutex_unlock(&g->lock); \n \n      memcpy(&g->params, p, sizeof(dt_iop_rgblevels_params_t)); \n \n      int box[4] = { 0 }; \n      _get_selected_area(self, piece, g, roi_in, box); \n      _auto_levels((const float *const)ivoid, roi_in->width, roi_in->height, box, &(g->params), g->channel, work_profile); \n \n      dt_pthread_mutex_lock(&g->lock); \n \n      g->call_auto_levels = 2; \n \n      dt_pthread_mutex_unlock(&g->lock); \n    } \n    else \n    { \n      dt_pthread_mutex_unlock(&g->lock); \n    } \n  } \n \n  const float mult[3] = { 1.f / (d->params.levels[0][2] - d->params.levels[0][0]), \n                          1.f / (d->params.levels[1][2] - d->params.levels[1][0]), \n                          1.f / (d->params.levels[2][2] - d->params.levels[2][0]) }; \n \n  for(int k = 0; k < roi_out->height; k++) \n  { \n    float *in = (float *)ivoid + (size_t)k * ch * roi_out->width; \n    float *out = (float *)ovoid + (size_t)k * ch * roi_out->width; \n \n    for(int j = 0; j < roi_out->width; j++, in += ch, out += ch) \n    { \n      if(d->params.autoscale == DT_IOP_RGBLEVELS_INDEPENDENT_CHANNELS || d->params.preserve_colors == DT_RGB_NORM_NONE) \n      { \n        for(int c = 0; c < 3; c++) \n        { \n          const float L_in = in[c]; \n \n          if(L_in <= d->params.levels[c][0]) \n          { \n             \n \n            out[c] = 0.0f; \n          } \n          else if(L_in >= d->params.levels[c][2]) \n          { \n            const float percentage = (L_in - d->params.levels[c][0]) * mult[c]; \n            out[c] = pow(percentage, d->inv_gamma[c]); \n          } \n          else \n          { \n             \n \n            const float percentage = (L_in - d->params.levels[c][0]) * mult[c]; \n            out[c] = d->lut[c][CLAMP((int)(percentage * 0x10000ul), 0, 0xffff)]; \n          } \n        } \n      } \n      else \n      { \n        const int ch_levels = 0; \n \n        float ratio = 1.f; \n        const float lum = dt_rgb_norm(in, d->params.preserve_colors, work_profile); \n        if(lum > d->params.levels[ch_levels][0]) \n        { \n          float curve_lum; \n          if(lum >= d->params.levels[ch_levels][2]) \n          { \n            const float percentage = (lum - d->params.levels[ch_levels][0]) * mult[ch_levels]; \n            curve_lum = pow(percentage, d->inv_gamma[ch_levels]); \n          } \n          else \n          { \n             \n \n            const float percentage = (lum - d->params.levels[ch_levels][0]) * mult[ch_levels]; \n            curve_lum = d->lut[ch_levels][CLAMP((int)(percentage * 0x10000ul), 0, 0xffff)]; \n          } \n \n          ratio = curve_lum / lum; \n \n          for(int c = 0; c < 3; c++) \n          { \n            out[c] = (ratio * in[c]); \n          } \n        } \n        else \n        { \n          for(int c = 0; c < 3; c++) out[c] = 0.f; \n        } \n      } \n \n      out[3] = in[3]; \n    } \n  } \n} ", "pred": " \nvoid process(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, void *const ovoid, \n             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int ch = piece->colors; \n  const dt_iop_rgblevels_data_t *const d = (dt_iop_rgblevels_data_t *)piece->data; \n  dt_iop_rgblevels_params_t *p = (dt_iop_rgblevels_params_t *)&d->params; \n  dt_iop_rgblevels_gui_data_t *g = (dt_iop_rgblevels_gui_data_t *)self->gui_data; \n  const dt_iop_order_iccprofile_info_t *const work_profile = dt_ioppr_get_pipe_work_profile_info(piece->pipe); \n \n   \n \n  if(g && piece->pipe->type == DT_DEV_PIXELPIPE_PREVIEW) \n  { \n    dt_pthread_mutex_lock(&g->lock); \n    if(g->call_auto_levels == 1 &&!darktable.gui->reset) \n    { \n      dt_iop_rgblevels_params_t *p = (dt_iop_rgblevels_params_t *)&d->params; \n      p->auto_levels = 1; \n      p->auto_levels_min = p->auto_levels_max = p->auto_levels_step = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_levels_step_max = p->auto_levels_step_min = p->auto_levels_step_max = p->auto_levels_step_min = 0; \n      p->auto_"}
{"label": " \nvoid process_sse2(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_UINT16) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const uint16_t *in = ((uint16_t *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      float *out = ((float *)ovoid) + (size_t)roi_out->width * j; \n \n      int i = 0; \n \n       \n \n      while((!dt_is_aligned(in, 16) ||!dt_is_aligned(out, 16)) && (i < roi_out->width)) \n      { \n        const int id = BL(roi_out, d, j, i); \n        *out = (((float)(*in)) - d->sub[id]) / d->div[id]; \n        i++; \n        in++; \n        out++; \n      } \n \n      const __m128 sub = _mm_set_ps(d->sub[BL(roi_out, d, j, i + 3)], d->sub[BL(roi_out, d, j, i + 2)], \n                                    d->sub[BL(roi_out, d, j, i + 1)], d->sub[BL(roi_out, d, j, i)]); \n \n      const __m128 div = _mm_set_ps(d->div[BL(roi_out, d, j, i + 3)], d->div[BL(roi_out, d, j, i + 2)], \n                                    d->div[BL(roi_out, d, j, i + 1)], d->div[BL(roi_out, d, j, i)]); \n \n       \n \n      for(; i < roi_out->width - (8 - 1); i += 8, in += 8) \n      { \n        const __m128i input = _mm_load_si128((__m128i *)in); \n \n        __m128i ilo = _mm_unpacklo_epi16(input, _mm_set1_epi16(0)); \n        __m128i ihi = _mm_unpackhi_epi16(input, _mm_set1_epi16(0)); \n \n        __m128 flo = _mm_cvtepi32_ps(ilo); \n        __m128 fhi = _mm_cvtepi32_ps(ihi); \n \n        flo = _mm_div_ps(_mm_sub_ps(flo, sub), div); \n        fhi = _mm_div_ps(_mm_sub_ps(fhi, sub), div); \n \n        _mm_stream_ps(out, flo); \n        out += 4; \n        _mm_stream_ps(out, fhi); \n        out += 4; \n      } \n \n       \n \n      for(; i < roi_out->width; i++, in++, out++) \n      { \n        const int id = BL(roi_out, d, j, i); \n        *out = (((float)(*in)) - d->sub[id]) / d->div[id]; \n      } \n    } \n \n    piece->pipe->dsc.filters = dt_rawspeed_crop_dcraw_filters(self->dev->image_storage.buf_dsc.filters, csx, csy); \n    adjust_xtrans_filters(piece->pipe, csx, csy); \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_FLOAT) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      float *out = ((float *)ovoid) + (size_t)roi_out->width * j; \n \n      int i = 0; \n \n       \n \n      while((!dt_is_aligned(in, 16) ||!dt_is_aligned(out, 16)) && (i < roi_out->width)) \n      { \n        const int id = BL(roi_out, d, j, i); \n        *out = (*in - d->sub[id]) / d->div[id]; \n        i++; \n        in++; \n        out++; \n      } \n \n      const __m128 sub = _mm_set_ps(d->sub[BL(roi_out, d, j, i + 3)], d->sub[BL(roi_out, d, j, i + 2)], \n                                    d->sub[BL(roi_out, d, j, i + 1)], d->sub[BL(roi_out, d, j, i)]); \n \n      const __m128 div = _mm_set_ps(d->div[BL(roi_out, d, j, i + 3)], d->div[BL(roi_out, d, j, i + 2)], \n                                    d->div[BL(roi_out, d, j, i + 1)], d->div[BL(roi_out, d, j, i)]); \n \n       \n \n      for(; i < roi_out->width - (4 - 1); i += 4, in += 4, out += 4) \n      { \n        const __m128 input = _mm_load_ps(in); \n \n        const __m128 scaled = _mm_div_ps(_mm_sub_ps(input, sub), div); \n \n        _mm_stream_ps(out, scaled); \n      } \n \n       \n \n      for(; i < roi_out->width; i++, in++, out++) \n      { \n        const int id = BL(roi_out, d, j, i); \n        *out = (*in - d->sub[id]) / d->div[id]; \n      } \n    } \n \n    piece->pipe->dsc.filters = dt_rawspeed_crop_dcraw_filters(self->dev->image", "pred": " \nvoid process_sse2(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_UINT16) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const uint16_t *in = ((uint16_t *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      float *out = ((float *)ovoid) + ((size_t)roi_out->width * (j + csy) + csx); \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        out[i] = (float)in[i]; \n      } \n    } \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_FLOAT32) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      float *out = ((float *)ovoid) + ((size_t)roi_out->width * (j + csy) + csx); \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        out[i] = (float)in[i]; \n      } \n    } \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_FLOAT64) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const double *in = ((double *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      double *out = ((double *)ovoid) + ((size_t)roi_out->width * (j + csy) + csx); \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        out[i] = (double)in[i]; \n      } \n    } \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_UINT8) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const uint8_t *in = ((uint8_t *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      uint8_t *out = ((uint8_t *)ovoid) + ((size_t)roi_out->width * (j + csy) + csx); \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        out[i] = (uint8_t)in[i]; \n      } \n    } \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_INT8) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const int8_t *in = ((int8_t *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      int8_t *out = ((int8_t *)ovoid) + ((size_t)roi_out->width * (j + csy) + csx); \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        out[i] = (int8_t)in[i]; \n      } \n    } \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_UINT16) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const uint16_t *in = ((uint16_t *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      uint16_t *out = ((uint16_t *)ovoid) + ((size_t)roi_out->width * (j + csy) + csx); \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        out[i] = (uint16_t)in[i]; \n      } \n    } \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_INT16) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const int16_t *in = ((int16_t *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      int16_t *out = ((int16_t *)ovoid) + ((size_t)roi_out->width * (j + csy) + csx); \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        out[i] = (int16_t)in[i]; \n      } \n    } \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_UINT32) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const uint32_t *in = ((uint32_t *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      uint32_t *out = ((uint32_t *)ovoid) + ((size_t)roi_out->width * (j + csy) + csx); \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        out[i] = (uint32_t)in[i]; \n      } \n    } \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && piece->dsc_in.datatype == TYPE_INT32) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const int32_t *in = ((int32_t *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n  "}
{"label": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_soften_data_t *data = (dt_iop_soften_data_t *)piece->data; \n  float *in = (float *)ivoid; \n  float *out = (float *)ovoid; \n  const int ch = piece->colors; \n \n  const float brightness = 1.0 / exp2f(-data->brightness); \n  const float saturation = data->saturation / 100.0; \n \n \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    size_t index = ch * k; \n    float h, s, l; \n    rgb2hsl(&in[index], &h, &s, &l); \n    s *= saturation; \n    l *= brightness; \n    hsl2rgb(&out[index], h, CLIP(s), CLIP(l)); \n  } \n \n  const float w = piece->iwidth * piece->iscale; \n  const float h = piece->iheight * piece->iscale; \n  int mrad = sqrt(w * w + h * h) * 0.01; \n  int rad = mrad * (fmin(100.0, data->size + 1) / 100.0); \n  const int radius = MIN(mrad, ceilf(rad * roi_in->scale / piece->iscale)); \n \n  const int size = roi_out->width > roi_out->height? roi_out->width : roi_out->height; \n \n  __m128 *const scanline_buf = dt_alloc_align(64, size * dt_get_num_threads() * sizeof(__m128)); \n \n  for(int iteration = 0; iteration < BOX_ITERATIONS; iteration++) \n  { \n     \n \n    for(int y = 0; y < roi_out->height; y++) \n    { \n      __m128 *scanline = scanline_buf + size * dt_get_thread_num(); \n      size_t index = (size_t)y * roi_out->width; \n      __m128 L = _mm_setzero_ps(); \n      int hits = 0; \n      for(int x = -radius; x < roi_out->width; x++) \n      { \n        int op = x - radius - 1; \n        int np = x + radius; \n        if(op >= 0) \n        { \n          L = _mm_sub_ps(L, _mm_load_ps(&out[(index + op) * ch])); \n          hits--; \n        } \n        if(np < roi_out->width) \n        { \n          L = _mm_add_ps(L, _mm_load_ps(&out[(index + np) * ch])); \n          hits++; \n        } \n        if(x >= 0) scanline[x] = _mm_div_ps(L, _mm_set_ps1(hits)); \n      } \n \n      for(int x = 0; x < roi_out->width; x++) _mm_store_ps(&out[(index + x) * ch], scanline[x]); \n    } \n \n     \n \n    const int opoffs = -(radius + 1) * roi_out->width; \n    const int npoffs = (radius)*roi_out->width; \n    for(int x = 0; x < roi_out->width; x++) \n    { \n      __m128 *scanline = scanline_buf + size * dt_get_thread_num(); \n      __m128 L = _mm_setzero_ps(); \n      int hits = 0; \n      size_t index = (size_t)x - radius * roi_out->width; \n      for(int y = -radius; y < roi_out->height; y++) \n      { \n        int op = y - radius - 1; \n        int np = y + radius; \n \n        if(op >= 0) \n        { \n          L = _mm_sub_ps(L, _mm_load_ps(&out[(index + opoffs) * ch])); \n          hits--; \n        } \n        if(np < roi_out->height) \n        { \n          L = _mm_add_ps(L, _mm_load_ps(&out[(index + npoffs) * ch])); \n          hits++; \n        } \n        if(y >= 0) scanline[y] = _mm_div_ps(L, _mm_set_ps1(hits)); \n        index += roi_out->width; \n      } \n \n      for(int y = 0; y < roi_out->height; y++) \n        _mm_store_ps(&out[((size_t)y * roi_out->width + x) * ch], scanline[y]); \n    } \n  } \n \n  dt_free_align(scanline_buf); \n \n  const __m128 amount = _mm_set1_ps(data->amount / 100.0); \n  const __m128 amount_1 = _mm_set1_ps(1 - (data->amount) / 100.0); \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    int index = ch * k; \n    _mm_store_ps(&out[index], _mm_add_ps(_mm_mul_ps(_mm_load_ps(&in[index]), amount_1), \n                                         _mm_mul_ps(MM_CLIP_PS(_mm_load_ps(&out[index])), amount))); \n  } \n} ", "pred": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_soften_data_t *data = (dt_iop_soften_data_t *)piece->data; \n  float *in = (float *)ivoid; \n  float *out = (float *)ovoid; \n  const int ch = piece->colors; \n \n  const float brightness = 1.0 / exp2f(-data->brightness); \n  const float saturation = data->saturation / 100.0; \n \n \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    size_t index = ch * k; \n    float h, s, l; \n    rgb2hsl(&in[index], &h, &s, &l); \n    s *= saturation; \n    l *= brightness; \n    hsl2rgb(&out[index], &h, &s, &l); \n  } \n  \n}\n\n\nvoid process_rgb(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                 void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_soften_data_t *data = (dt_iop_soften_data_t *)piece->data; \n  float *in = (float *)ivoid; \n  float *out = (float *)ovoid; \n  const int ch = piece->colors; \n \n  const float brightness = 1.0 / exp2f(-data->brightness); \n  const float saturation = data->saturation / 100.0; \n \n \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    size_t index = ch * k; \n    float h, s, l; \n    rgb2hsl(&in[index], &h, &s, &l); \n    s *= saturation; \n    l *= brightness; \n    hsl2rgb(&out[index], &h, &s, &l); \n  } \n  \n}\n\n\nvoid process_hsv(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                 void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_soften_data_t *data = (dt_iop_soften_data_t *)piece->data; \n  float *in = (float *)ivoid; \n  float *out = (float *)ovoid; \n  const int ch = piece->colors; \n \n  const float brightness = 1.0 / exp2f(-data->brightness); \n  const float saturation = data->saturation / 100.0; \n \n \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    size_t index = ch * k; \n    float h, s, v; \n    h = s = v = 0.0; \n    rgb2hsl(&in[index], &h, &s, &v); \n    s *= saturation; \n    v *= brightness; \n    hsl2rgb(&out[index], &h, &s, &v); \n  } \n  \n}\n\n\nvoid process_hsl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                 void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_soften_data_t *data = (dt_iop_soften_data_t *)piece->data; \n  float *in = (float *)ivoid; \n  float *out = (float *)ovoid; \n  const int ch = piece->colors; \n \n  const float brightness = 1.0 / exp2f(-data->brightness); \n  const float saturation = data->saturation / 100.0; \n \n \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    size_t index = ch * k; \n    float h, s, l; \n    h = s = l = 0.0; \n    hsl2rgb(&in[index], &h, &s, &l); \n    s *= saturation; \n    l *= brightness; \n    hsl2rgb(&out[index], &h, &s, &l); \n  } \n  \n}\n\n\nvoid process_hsb(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                 void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_soften_data_t *data = (dt_iop_soften_data_t *)piece->data; \n  float *in = (float *)ivoid; \n  float *out = (float *)ovoid; \n  const int ch = piece->colors; \n \n  const float brightness = 1.0 / exp2f(-data->brightness); \n  const float saturation = data->saturation / 100.0; \n \n \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    size_t index = ch * k; \n    float h, s, v; \n    h = s = v = 0.0; \n    hsl2rgb(&in[index], &h, &s, &v); \n    s *= saturation; \n    v *= brightness; \n    hsl2rgb(&out[index], &h, &s, &v); \n  } \n  \n}\n\n\nvoid process_rgb_hsv(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 24; \n  tile_size[3] = 1024; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0765; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,4);t1++) { \n    lbp=max(ceild(t1,2),ceild(8*t1-Nt+3,8)); \n    ubp=min(floord(Nt+Nz-4,8),floord(4*t1+Nz+1,8)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-5,6)),ceild(8*t2-Nz-20,24));t3<=min(min(min(floord(Nt+Ny-4,24),floord(4*t1+Ny+5,24)),floord(8*t2+Ny+4,24)),floord(8*t1-8*t2+Nz+Ny+3,24));t3++) { \n        for (t4=max(max(max(0,ceild(t1-255,256)),ceild(8*t2-Nz-1020,1024)),ceild(24*t3-Ny-1020,1024));t4<=min(min(min(min(floord(Nt+Nx-4,1024),floord(4*t1+Nx+5,1024)),floord(8*t2+Nx+4,1024)),floord(24*t3+Nx+20,1024)),floord(8*t1-8*t2+Nz+Nx+3,1024));t4++) { \n          for (t5=max(max(max(max(max(0,4*t1),8*t1-8*t2+1),8*t2-Nz+2),24*t3-Ny+2),1024*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,4*t1+7),8*t2+6),24*t3+22),1024*t4+1022),8*t1-8*t2+Nz+5);t5++) { \n            for (t6=max(max(8*t2,t5+1),-8*t1+8*t2+2*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(24*t3,t5+1);t7<=min(24*t3+23,t5+Ny-2);t7++) { \n                lbv=max(1024*t4,t5+1); \n                ubv=min(1024*t4+1023,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = ((alpha * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (beta * (((((A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)] + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) - 1][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8) - 1]) + A[ t5 % 2][ (-t5+t6) + 1][ (-t5+t7)][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) + 1][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8) + 1])));; \n                } \n              } \n            } \n          } \n        } \n      } \n    } \n  } \n} \n \n \n      gettimeofday(&end, 0); \n      ts_return = timeval_subtract(&result, &end, &start); \n      tdiff = (double) (result.tv_sec + result.tv_usec * 1.0e-6); \n      min_tdiff", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n  for(t=0; t<Nt; t++){ \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i"}
{"label": " \nvoid mzd_process_rows3(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, rci_t const *L2) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int rem = k % 3; \n \n  int const ka = k / 3 + ((rem >= 2)? 1 : 0); \n  int const kb = k / 3 + ((rem >= 1)? 1 : 0); \n  int const kc = k / 3; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n  word const kc_bm = __M4RI_LEFT_BITMASK(kc); \n \n \n  for(r= startrow; r < stoprow; ++r) { \n    word bits = mzd_read_bits(M, r, startcol, k); \n    rci_t const x0 = L0[ bits & ka_bm ]; bits>>=ka; \n    rci_t const x1 = L1[ bits & kb_bm ]; bits>>=kb; \n    rci_t const x2 = L2[ bits & kc_bm ]; \n    if((x0 | x1 | x2) == 0)  \n \n      continue; \n \n    word *m0 = M->rows[r] + blocknum; \n    word const *t[3]; \n    t[0] = T0->rows[x0] + blocknum; \n    t[1] = T1->rows[x1] + blocknum; \n    t[2] = T2->rows[x2] + blocknum; \n \n    _mzd_combine_3( m0, t, wide); \n  } \n \n  __M4RI_DD_MZD(M); \n} ", "pred": " \nvoid mzd_process_rows3(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, rci_t const *L2) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int rem = k % 3; \n \n  int const ka = k / 3 + ((rem >= 2)? 1 : 0); \n  int const kb = k / 3 + ((rem >= 1)? 1 : 0); \n  int const kc = k / 3; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n  word const kc_bm = __M4RI_LEFT_BITMASK(kc); \n \n \n  for(r = startrow; r < stoprow; r += m4ri_row) { \n    word const r_bm = r_bm_get(M, r); \n    word const r_bm_0 = r_bm_get(M, r); \n    word const r_bm_1 = r_bm_get(M, r); \n    word const r_bm_2 = r_bm_get(M, r); \n    word const r_bm_3 = r_bm_get(M, r); \n \n    word const r_bm_0_0 = r_bm_0 & ka_bm; \n    word const r_bm_0_1 = r_bm_0 & kb_bm; \n    word const r_bm_0_2 = r_bm_0 & kc_bm; \n    word const r_bm_0_3 = r_bm_0 & (ka_bm | kb_bm | kc_bm); \n \n    word const r_bm_1_0 = r_bm_1 & ka_bm; \n    word const r_bm_1_1 = r_"}
{"label": " \nvoid mzd_process_rows2(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int const ka = k / 2; \n  int const kb = k - k / 2; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n \n \n  for(r = startrow; r < stoprow; ++r) { \n    word bits = mzd_read_bits(M, r, startcol, k); \n    rci_t const x0 = L0[ bits & ka_bm ]; bits>>=ka; \n    rci_t const x1 = L1[ bits & kb_bm ]; \n    if((x0 | x1) == 0)\t \n \n      continue; \n    word *m0 = M->rows[r] + blocknum; \n    word const *t[2]; \n    t[0] = T0->rows[x0] + blocknum; \n    t[1] = T1->rows[x1] + blocknum; \n \n    _mzd_combine_2( m0, t, wide); \n  } \n \n  __M4RI_DD_MZD(M); \n} ", "pred": " \nvoid mzd_process_rows2(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int const ka = k / 2; \n  int const kb = k - k / 2; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n \n \n  for(r = startrow; r < stoprow; ++r) { \n    word bits = mzd_read_bits(M, r, startcol, k); \n    rci_t const x0 = L0[ bits & ka_bm ]; bits>>=ka; \n    rci_t const x1 = L1[ bits & kb_bm ]; bits>>=kb; \n    rci_t const y0 = T0[ x0 ]; \n    rci_t const y1 = T1[ x1 ]; \n \n    rci_t const y0_ = y0 + y0; \n    rci_t const y1_ = y1 + y1; \n \n    rci_t const y0_ = y0_ + y0; \n    rci_t const y1_ = y1_ + y1; \n \n    rci_t const y0_ = y0_ +"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 32; \n  tile_size[3] = 32; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=Nt-1;t1++) { \n    lbp=ceild(t1+1,2); \n    ubp=min(floord(4*Nt+Nz-9,8),floord(4*t1+Nz-2,8)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(ceild(t1-6,8),ceild(8*t2-Nz-19,32));t3<=min(floord(4*Nt+Ny-9,32),floord(4*t1+Ny-1,32));t3++) { \n        for (t4=max(max(ceild(t1-6,8),ceild(8*t2-Nz-19,32)),ceild(32*t3-Ny-19,32));t4<=min(min(floord(4*Nt+Nx-9,32),floord(4*t1+Nx-1,32)),floord(32*t3+Nx+19,32));t4++) { \n          for (t5=max(max(max(max(0,ceild(8*t2-Nz+5,4)),ceild(32*t3-Ny+5,4)),ceild(32*t4-Nx+5,4)),t1);t5<=min(min(min(Nt-1,t1+1),8*t3+6),8*t4+6);t5++) { \n            for (t6=max(max(8*t2,4*t5+4),-8*t1+8*t2+8*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(32*t3,4*t5+4);t7<=min(32*t3+31,4*t5+Ny-5);t7++) { \n                lbv=max(32*t4,4*t5+4); \n                ubv=min(32*t4+31,4*t5+Nx-5); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((2.0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) - A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (roc2[ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] * (((((coef0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (coef1 * (((((A[ t5 % 2][ (-4*t5+t6) - 1][ (-4*t5+t7)][ (-4*t5+t8)] + A[ t5 % 2][ (-4*t5+t6) + 1][ (-4*t5+t7)][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) - 1][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) + 1][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0; j<Ny; j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n  for(t=0; t<Nt; t++){ \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      }"}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_soften_data_t *const d = (const dt_iop_soften_data_t *const)piece->data; \n \n  const int ch = piece->colors; \n \n  const float brightness = 1.0 / exp2f(-d->brightness); \n  const float saturation = d->saturation / 100.0; \n \n  const float *const in = (const float *const)ivoid; \n  float *const out = (float *const)ovoid; \n \n \n \n  for(size_t k = 0; k < (size_t)ch * roi_out->width * roi_out->height; k += ch) \n  { \n    float h, s, l; \n    rgb2hsl(&in[k], &h, &s, &l); \n    s *= saturation; \n    l *= brightness; \n    hsl2rgb(&out[k], h, CLIP(s), CLIP(l)); \n  } \n \n  const float w = piece->iwidth * piece->iscale; \n  const float h = piece->iheight * piece->iscale; \n  int mrad = sqrt(w * w + h * h) * 0.01; \n  int rad = mrad * (fmin(100.0, d->size + 1) / 100.0); \n  const int radius = MIN(mrad, ceilf(rad * roi_in->scale / piece->iscale)); \n \n  const int size = roi_out->width > roi_out->height? roi_out->width : roi_out->height; \n \n  const size_t scanline_size = (size_t)4 * size; \n  float *const scanline_buf = dt_alloc_align(64, scanline_size * dt_get_num_threads() * sizeof(float)); \n \n  for(int iteration = 0; iteration < BOX_ITERATIONS; iteration++) \n  { \n     \n \n    for(int y = 0; y < roi_out->height; y++) \n    { \n      float *scanline = scanline_buf + scanline_size * dt_get_thread_num(); \n      __attribute__((aligned(64))) float L[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; \n \n      size_t index = (size_t)y * roi_out->width; \n      int hits = 0; \n      for(int x = -radius; x < roi_out->width; x++) \n      { \n        int op = x - radius - 1; \n        int np = x + radius; \n        if(op >= 0) \n        { \n          for(int c = 0; c < 4; c++) \n          { \n            L[c] -= out[((index + op) * ch) + c]; \n          } \n          hits--; \n        } \n        if(np < roi_out->width) \n        { \n          for(int c = 0; c < 4; c++) \n          { \n            L[c] += out[((index + np) * ch) + c]; \n          } \n          hits++; \n        } \n        if(x >= 0) \n        { \n          for(int c = 0; c < 4; c++) \n          { \n            scanline[4 * x + c] = L[c] / hits; \n          } \n        } \n      } \n \n      for(int x = 0; x < roi_out->width; x++) \n      { \n        for(int c = 0; c < 4; c++) \n        { \n          out[(index + x) * ch + c] = scanline[4 * x + c]; \n        } \n      } \n    } \n \n     \n \n    const int opoffs = -(radius + 1) * roi_out->width; \n    const int npoffs = (radius)*roi_out->width; \n    for(int x = 0; x < roi_out->width; x++) \n    { \n      float *scanline = scanline_buf + scanline_size * dt_get_thread_num(); \n      __attribute__((aligned(64))) float L[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; \n \n      int hits = 0; \n      size_t index = (size_t)x - radius * roi_out->width; \n      for(int y = -radius; y < roi_out->height; y++) \n      { \n        int op = y - radius - 1; \n        int np = y + radius; \n \n        if(op >= 0) \n        { \n          for(int c = 0; c < 4; c++) \n          { \n            L[c] -= out[((index + opoffs) * ch) + c]; \n          } \n          hits--; \n        } \n        if(np < roi_out->height) \n        { \n          for(int c = 0; c < 4; c++) \n          { \n            L[c] += out[((index + npoffs) * ch) + c]; \n          } \n          hits++; \n        } \n        if(y >= 0) \n        { \n          for(int c = 0; c < 4; c++) \n          { \n            scanline[4 * y + c] = L[c] / hits; \n          } \n        } \n        index += roi_out->width; \n      } \n \n      for(int y = 0; y < roi_out->height; y++) \n      { \n        for(int c = 0; c < 4; c++) \n        { \n          out[((size_t)y * roi_out->width + x) * ch + c] = scanline[ch * y + c]; \n        } \n      } \n    } \n  } \n \n  dt_free_align(scanline_buf); \n \n  const float amount = (d->amount / 100.0); \n  const float amount_1 = (1 - (d->amount) / 100.0); \n \n  for(size_t k = 0; k < (size_t)ch * roi_out->width * roi_out->height; k += ch) \n  { \n    for(int c = 0; c < 4; c++) \n    { \n   ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_soften_data_t *const d = (const dt_iop_soften_data_t *const)piece->data; \n \n  const int ch = piece->colors; \n \n  const float brightness = 1.0 / exp2f(-d->brightness); \n  const float saturation = d->saturation / 100.0; \n \n  const float *const in = (const float *const)ivoid; \n  float *const out = (float *const)ovoid; \n \n \n \n  for(size_t k = 0; k < (size_t)ch * roi_out->width * roi_out->height; k += ch) \n  { \n    float h, s, l; \n    rgb2hsl(&in[k], &h, &s, &l); \n    s *= saturation; \n    l *= brightness; \n    hsl2rgb(&out[k], &h, &s, &l); \n  } \n  \n}\n\n\nvoid init(dt_iop_module_so_t *self)\n{\n  dt_iop_soften_data_t *d = (dt_iop_soften_data_t *)self->data;\n  d->brightness = 1.0;\n  d->saturation = 1.0;\n}\n\nvoid gui_changed(dt_iop_module_t *self)\n{\n  dt_iop_soften_data_t *d = (dt_iop_soften_data_t *)self->data;\n  dt_dev_pixelpipe_iop_soften_t *piece = (dt_dev_pixelpipe_iop_soften_t *)self->piece;\n  const int ch = piece->colors; \n  const float brightness = 1.0 / exp2f(-d->brightness); \n  const float saturation = d->saturation / 100.0; \n  const float hue = 0.0; \n  const float saturation_inv = 1.0 / saturation; \n  const float hue_inv = 1.0 / hue; \n  const float hue_inv_inv = 1.0 / (hue_inv * saturation_inv); \n  const float hue_inv_inv_inv = 1.0 / (hue_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0 / (hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv * saturation_inv); \n  const float hue_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = 1.0"}
{"label": " \nbyte _libaroma_ctl_pager_window_invalidate(LIBAROMA_WINDOWP win, byte sync){ \n  LIBAROMA_CONTROLP ctl=(LIBAROMA_CONTROLP) win->client_data; \n  _LIBAROMA_CTL_CHECK( \n    _libaroma_ctl_pager_handler, _LIBAROMA_CTL_PAGERP, 0 \n  ); \n  if (me->win!=win){ \n    return 0; \n  } \n  if ((me->win->dc)&&(me->win->bg)){ \n    libaroma_draw(me->win->dc,me->win->bg,0,0,0); \n     \n \n    int i; \n    for (i=0;i<win->childn;i++){ \n       \n \n      libaroma_control_draw(win->childs[i], 0); \n    } \n  } \n  if (sync){ \n    return _libaroma_ctl_pager_window_sync(win,0,0,win->w,win->h); \n  } \n  return 1; \n} ", "pred": " \nbyte _libaroma_ctl_pager_window_invalidate(LIBAROMA_WINDOWP win, byte sync){ \n  LIBAROMA_CONTROLP ctl=(LIBAROMA_CONTROLP) win->client_data; \n  _LIBAROMA_CTL_CHECK( \n    _libaroma_ctl_pager_handler, _LIBAROMA_CTL_PAGERP, 0 \n  ); \n  if (me->win!=win){ \n    return 0; \n  } \n  if ((me->win->dc)&&(me->win->bg)){ \n    libaroma_draw(me->win->dc,me->win->bg,0,0,0); \n     \n \n    int i; \n    for (i=0;i<win->childn;i++){ \n       \n \n      libaroma_control_draw(win->childs[i], 0); \n    } \n  } \n  if (sync){ \n    return _libaroma_ctl_pager_window_sync(win,0,0,win->w,win->h); \n  } \n  return 1; \n} "}
{"label": "oid gcc(const long out_dims[DIMS], complex float* out_data, const long caldims[DIMS], const complex float* cal_data) \n{ \n\tint ro = out_dims[READ_DIM]; \n \n\t \n \n \n\tlong tmp_dims[DIMS]; \n\tmd_copy_dims(DIMS, tmp_dims, caldims); \n\ttmp_dims[READ_DIM] = ro; \n\tcomplex float* tmp = md_alloc(DIMS, tmp_dims, CFL_SIZE); \n \n\tmd_resize_center(DIMS, tmp_dims, tmp, caldims, cal_data, CFL_SIZE); \n\tifftuc(DIMS, tmp_dims, READ_FLAG, tmp, tmp); \n \n\t \n \n \n\tlong tmp2_dims[DIMS]; \n\tmd_select_dims(DIMS, ~READ_FLAG, tmp2_dims, tmp_dims); \n \n\tlong out2_dims[DIMS]; \n\tmd_select_dims(DIMS, ~READ_FLAG, out2_dims, out_dims); \n \n \n\tfor (int i = 0; i < ro; i++) { \n \n\t\tcomplex float* tmp2 = md_alloc(DIMS, tmp2_dims, CFL_SIZE); \n\t\tcomplex float* out2 = md_alloc(DIMS, out2_dims, CFL_SIZE); \n \n\t\tlong pos[DIMS] = { [READ_DIM] = i }; \n\t\tmd_copy_block(DIMS, pos, tmp2_dims, tmp2, tmp_dims, tmp, CFL_SIZE); \n \n\t\tscc(out2_dims, out2, tmp2_dims, tmp2); \n \n\t\tmd_copy_block(DIMS, pos, out_dims, out_data, out2_dims, out2, CFL_SIZE); \n \n\t\tmd_free(out2); \n\t\tmd_free(tmp2); \n\t} \n} \n \n ", "pred": "oid gcc(const long out_dims[DIMS], complex float* out_data, const long caldims[DIMS], const complex float* cal_data) \n{ \n\tint ro = out_dims[READ_DIM]; \n \n\t \n \n \n\tlong tmp_dims[DIMS]; \n\tmd_copy_dims(DIMS, tmp_dims, caldims); \n\ttmp_dims[READ_DIM] = ro; \n\tcomplex float* tmp = md_alloc(DIMS, tmp_dims, CFL_SIZE); \n \n\tmd_resize_center(DIMS, tmp_dims, tmp, caldims, cal_data, CFL_SIZE); \n\tifftuc(DIMS, tmp_dims, READ_FLAG, tmp, tmp); \n \n\t \n \n \n\tlong tmp2_dims[DIMS]; \n\tmd_select_dims(DIMS, ~READ_FLAG, tmp2_dims, tmp_dims); \n \n\tlong out2_dims[DIMS]; \n\tmd_select_dims(DIMS, ~READ_FLAG, out2_dims, out_dims); \n \n \n\tfor (int i = 0; i < ro; i++) { \n \n\t\tcomplex float* tmp2 = md_alloc(DIMS, tmp2_dims, CFL_SIZE); \n\t\tcomplex float* out2 = md_alloc(DIMS, out2_dims, CFL_SIZE); \n \n\t\tmd_copy(DIMS, tmp2, tmp2_dims, tmp2, CFL_SIZE); \n\t\tmd_copy(DIMS, out2, out2_dims, out2, CFL_SIZE); \n \n\t\tmd_select_dims(DIMS, ~READ_FLAG, tmp2_dims, tmp2_dims, tmp2, CFL_SIZE); \n\t\tmd_select_dims(DIMS, ~READ_FLAG, out2_dims, out2_dims, out2, CFL_SIZE); \n \n\t\tmd_copy(DIMS, tmp2, tmp2_"}
{"label": " \nvoid mzd_process_rows4(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, rci_t const *L2,  \n                       mzd_t const *T3, rci_t const *L3) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int const rem = k % 4; \n \n  int const ka = k / 4 + ((rem >= 3)? 1 : 0); \n  int const kb = k / 4 + ((rem >= 2)? 1 : 0); \n  int const kc = k / 4 + ((rem >= 1)? 1 : 0); \n  int const kd = k / 4; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n  word const kc_bm = __M4RI_LEFT_BITMASK(kc); \n  word const kd_bm = __M4RI_LEFT_BITMASK(kd); \n \n \n  for(r = startrow; r < stoprow; ++r) { \n    word bits = mzd_read_bits(M, r, startcol, k); \n    rci_t const x0 = L0[ bits & ka_bm ]; bits>>=ka; \n    rci_t const x1 = L1[ bits & kb_bm ]; bits>>=kb; \n    rci_t const x2 = L2[ bits & kc_bm ]; bits>>=kc; \n    rci_t const x3 = L3[ bits & kd_bm ]; \n    if(((x0 | x1) | (x2 | x3)) == 0)  \n \n      continue; \n \n    word *m0 = M->rows[r] + blocknum; \n    word const *t[4]; \n    t[0] = T0->rows[x0] + blocknum; \n    t[1] = T1->rows[x1] + blocknum; \n    t[2] = T2->rows[x2] + blocknum; \n    t[3] = T3->rows[x3] + blocknum; \n \n    _mzd_combine_4( m0, t, wide); \n  } \n \n  __M4RI_DD_MZD(M); \n} ", "pred": " \nvoid mzd_process_rows4(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, rci_t const *L2,  \n                       mzd_t const *T3, rci_t const *L3) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n \n  int const rem = k % 4; \n \n  int const ka = k / 4 + ((rem >= 3)? 1 : 0); \n  int const kb = k / 4 + ((rem >= 2)? 1 : 0); \n  int const kc = k / 4 + ((rem >= 1)? 1 : 0); \n  int const kd = k / 4; \n \n  rci_t r; \n \n  r = startrow; \n  r += (startcol / m4ri_radix) * m4ri_radix; \n \n  for (int i = 0; i < ka; ++i) { \n    r += wide; \n    mzd_process_rows4(M, r, stoprow, startcol, k, T0, L0, T1, L1, T2, L2, T3, L3); \n  } \n \n  for (int i = ka; i < kb; ++i) { \n    r += wide; \n    mzd_process_rows4(M, r, stoprow, startcol, k, T0, L0, T1, L1, T2, L2, T3, L3); \n  } \n \n  for (int i = kb; i < kc; ++i) { \n    r += wide; \n    mzd_process_rows4(M, r, stoprow, startcol, k, T0, L0, T1, L1, T2, L2, T3, L3); \n  } \n \n  for (int i = kc; i < kd; ++i) { \n    r += wide; \n    mzd_process_rows4(M, r, stoprow, startcol, k, T0, L0, T1, L1, T2, L2, T3, L3); \n  } \n \n  r = startrow; \n  r += (startcol / m4ri_radix) * m4ri_radix; \n \n  for (int i = 0; i < ka; ++i) { \n    r += wide; \n    mzd_process_rows4(M, r, stop"}
{"label": "d dt_colorspaces_cygm_to_rgb(float *out, int num, double CAM_to_RGB[3][4]) \n{ \n  for(int i = 0; i < num; i++) \n  { \n    float *in = &out[i*4]; \n    float o[3] = {0.0f,0.0f,0.0f}; \n    for(int c = 0; c < 3; c++) \n      for(int k = 0; k < 4; k++) \n        o[c] += CAM_to_RGB[c][k] * in[k]; \n    for(int c = 0; c < 3; c++) \n      in[c] = o[c]; \n  } \n} \n \nvo ", "pred": "d dt_colorspaces_cygm_to_rgb(float *out, int num, double CAM_to_RGB[3][4]) \n{ \n  for(int i = 0; i < num; i++) \n  { \n    float *in = &out[i*4]; \n    float o[3] = {0.0f,0.0f,0.0f}; \n    for(int c = 0; c < 3; c++) \n      for(int k = 0; k < 4; k++) \n        o[c] += CAM_to_RGB[c][k] * in[k]; \n    for(int c = 0; c < 3; c++) \n      in[c] = o[c]; \n  } \n} \n \nvo "}
{"label": " \nint main(int argc,char *argv[]) \n{ \n  const char *desc[] = { \n\t\t  \"[PAR]\", \n\t\t    \"________________[PAR]\", \n\t\t    \"Basic Options.[PAR]\", \n\t\t    \"----------------[PAR]\", \n \n    \"g_lomepro is a grid based tool to calculate Local Membrane Properties \", \n    \"of molecular dynamics trajectories [REF].\", \n    \"Thickness (-thick), area per lipid (APL) (-apl), Curvature (-curve) and \", \n    \"SCD Order parameters (-order) can be calculated.[PAR]\", \n \n    \"The user should specify a reference structure file (option -s) and a trajectoy file (option -f).\", \n    \"An index group (option -n) together with the option -num_lip are used to specify the representative lipid atom(s)\", \n    \"(Phosphorous, headgroups, whole lipid, etc.) and the total number of lipids.[PAR]\", \n \n    \"The number of grid elements in x and y axes can be specified (default 10) with -binx and -biny.[PAR]\", \n \n    \"With the option -prot a group of atoms (i.e. Protein) embedded in the membrane can be\", \n    \"explicitly considered for membrane property calculation.\", \n    \"If relevant, the center of mass displacement removal of the Protein group in the\", \n    \"trajectory file should be done *before* running g_lomepro (i.e. 'trjconv -fit').[PAR]\", \n \n    \"-precision option (default 1.5) defines the radius (nm) used to search for lipids when considering protein atoms.[PAR]\", \n \n    \"_________________________[PAR]\", \n    \"Property Specific Options[PAR]\", \n    \"-------------------------[PAR]\", \n \n     \n \n    \"Thickness (-thick):[PAR]\", \n \n    \"output: time averages (avg) and standard deviation (sd)\", \n    \"as matrix (dat) files and as pdb files with the thickness values in the B-factor field.[PAR]\", \n \n    \"-prot_val (default 0) specifies the thickness value for the grid elements occupied by the protein group on both leaflets.[PAR]\", \n \n    \"-scale factor (default 0.75) scales the thickness value in a grid element\", \n    \"in the situations where a grid cell is assigned a protein atom on one leaflet and the corresponding\", \n    \"grid cell on another leaflet has a lipid assigned[PAR]\", \n \n \n    \"...........................................................................[PAR]\", \n    \"APL option outputs (-apl):[PAR]\", \n \n    \"output: time averages (avg) and standard deviation (sd)\", \n    \"as matrix (dat) files and as pdb files with the APL values in the B-factor field.\", \n    \"In addition APL values for every lipid/protein averaged over trajectory are printed out,\", \n    \"as well as the APL value for every lipid/protein at every time step. [PAR]\", \n \n    \"...........................................................................[PAR]\", \n    \"Curvature (-curve):[PAR]\", \n \n    \"output: time averaged mean and gaussian curvature for the top and bottom leaflets separately\", \n    \"(in pdb and matrix.dat formats)[PAR]\", \n \n    \"-r_filter_low (default 0) relatively set lower bound for filtering in\", \n    \"frequency space (after FFT) controls high pass or band pass filters[PAR]\", \n \n    \"-r_filter_high (default -1) relatively set higher bound for filtering in\", \n    \"frequency space (after FFT) controls low pass or band pass filters[PAR]\", \n \n    \"-q_filter_low  (default 0) absolute value of lower bound (nm^-1) for filtering in\", \n    \"frequency space (after FFT) controls high pass or band pass filters[PAR]\", \n \n    \"-q_filter_high (default 100000) absolute value of higher bound (nm^-1) for \", \n    \"filtering in frequency space (after FFT) controls low pass or band pass filters[PAR]\", \n \n    \"-scale_mcurve (default 1) mean curvature values may be small, apply scaling\", \n    \" when printing pdb (no scaling for matrix output)[PAR]\", \n \n    \"-scale_gcurve (default 1) gaussian curvature values may be small, \", \n    \"apply scaling when printing pdb (no scaling for matrix output)[PAR]\", \n \n    \"-inv_mean_curve (default FALSE) allows inverting the signs of the mean curvature.\", \n    \"In the original g_lomepro paper, the sign of the mean curvature was determined from a point of view of an observer looking down onto a bilayer leaflet.\", \n    \"This way the positive mean curvature was assigned to the surface which bent towards the bilayer center.\", \n    \"Setting this flag to TRUE inverts the sign: the mean curvature becomes positive when the surface bends away from the bilayer midpoint.\", \n \n \n    \"...........................................................................[PAR]\", \n    \"Scd Order parameter (-order):[PAR]\", \n \n    \"output: time averaged pdb and data matrices containing -Scd order parameters are written for\", \n    \"every acyl chain atom for the top and bottom leaflets separately. \", \n    \"Also the average -Scd values for every lipid are printed out.[PAR]\", \n \n    \"NOTE: many output files are generated (acyl_chain_atoms x top_down_leaflets)[PAR]\", \n \n    \"Index file is required to contain separate groups for sn1 and sn2 chains with the acyl chain carbon atoms.[PAR]\", \n \n    \"-unsat option (default 0) defines the number of unsaturated acyl chains [0|1|2].\", \n    \"Currently one double bond is allowed per acyl chain.\", \n    \"The carbons around a double bond need to be defined in a separate group in the index file.\", \n    \"In case one double bond is selected, the chain with the double bond needs to be selected as chain-1 (sn-1) [PAR]. \", \n \n    \"In combination with -prot, -order_val controls the Scd values (default -1) asigned to the grid points occupied by protein atoms.[PAR]\", \n \n    \"-nt (number of threads) option can be used to speed up the Scd calculation by running on a number of threads in parallel.[PAR]\", \n \n \n    \"________________[PAR]\", \n    \"Other Options.[PAR]\", \n    \"----------------[PAR]\", \n \n    \"-normal flag allows to selecting axis normal to the bilayer (default 2, z-axis).[PAR]\", \n \n    \"If -breath option is set the grid is modified according to the box at every step.\", \n    \"This may be useful for highly fluctuating boxes.[PAR]\", \n \n    \"-swapxy may be useful in combination with the -normal flag, when the normal axis is not matching Oz.\", \n    \"If the flag is set to TRUE, Ox and Oy axes are swapped. [PAR]\", \n \n    \"-nonflat option can be used to treat highly curved bilayers.\", \n    \"If the option is set, a group of lipid tail atoms will be required in an index file.\", \n    \"The tail atoms will be used to split the leaflets into top/bottom layers.[PAR]\", \n \n    \"-mov_pdb and -mov_dat can be used to export multiple-model pdb files or movie matrix files.\", \n    \"Since pdb files may quickly increase in size, only one pdb file is generated, irrespective of the number of selected properties.\", \n    \"The pdb movie file contains, the coordinates of a grid. In case -thick option is selected, the pdb movie file\", \n    \"also contains membrane thickness in the B-factor field (for the other options the field is left blank).\", \n    \"The supplementary Perl scripts distributed together with the g_lomepro can be used to conveniently\", \n    \"merge matrix movie output with the pdb movie.\", \n    \"-mov_dat prints data matrix for -thick, -apl and -order options.\", \n    \"For -order a separate file for every acyl chain carbon is generated.\", \n    \"A movie output option for the -curve is currently disabled. [PAR]\", \n \n    \"The -smooth option defines the number", "pred": " \nint main(int argc,char *argv[]) \n{ \n  const char *desc[] = { \n\t\t  \"[PAR]\", \n\t\t    \"________________[PAR]\", \n\t\t    \"Basic Options.[PAR]\", \n\t\t    \"----------------[PAR]\", \n \n    \"g_lomepro is a grid based tool to calculate Local Membrane Properties \", \n    \"of molecular dynamics trajectories [REF].\", \n    \"Thickness (-thick), area per lipid (APL) (-apl), Curvature (-curve) and \", \n    \"SCD Order parameters (-order) can be calculated.[PAR]\", \n \n    \"The user should specify a reference structure file (option -s) and a trajectoy file (option -f).\", \n    \"An index group (option -n) together with the option -num_lip are used to specify the representative lipid atom(s)\", \n    \"(Phosphorous, headgroups, whole lipid, etc.) and the total number of lipids.[PAR]\", \n \n    \"The number of grid elements in x and y axes can be specified (default 10) with -binx and -biny.[PAR]\", \n \n    \"With the option -prot a group of atoms (i.e. Protein) is used to calculate the total number of prot.\", \n    \"The option -prot_num is used to specify the number of prot.\", \n    \"The option -prot_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n    \"The option -prot_num_num_num_num_num_num_num_num_num_num_num_num_num is used to specify the number of prot.\", \n"}
{"label": " \nstatic void \nRandomAccessUpdate(uint64_t TableSize, uint64_t *Table) { \n    uint64_t i; \n    uint64_t *ran; \n    int j; \n \n    uint32_t unitCnt = __htc_get_unit_count(); \n    uint64_t ranSize = unitCnt * NUM_THREADS; \n    ran = (uint64_t *)malloc(ranSize*sizeof(uint64_t)); \n    if (! ran) { \n        printf( \"Failed to allocate memory for the ran array (%ld).\\n\",  \n                ranSize); \n        exit(1); \n    } \n \n    for (j=0; j<ranSize; j++) { \n        ran[j] = HPCC_starts ((NUPDATE/ranSize) * j); \n    } \n \n    fprintf(stderr,\"ran array has been initialized\\n\"); fflush(stderr); \n \n    uint32_t updates_per_unit = NUPDATE/unitCnt; \n    printf(\"will use %d units and %d threads per unit, %d total threads\\n\",unitCnt,NUM_THREADS,unitCnt*NUM_THREADS); \n    printf(\"NUPDATE is %ld updates_per_unit is %ld\\n\", NUPDATE, updates_per_unit); \n \n    { \n        int unit = omp_get_thread_num(); \n        uint64_t *unitran = ran + (unit * NUM_THREADS); \n \n        { \n            {  \n                uint64_t pran = unitran[omp_get_thread_num()]; \n                for (i=0; i< updates_per_unit; i++) { \n                    pran = (pran << 1) ^ ((int64_t) pran < 0? POLY : 0); \n                    Table[pran & (TableSize-1)] ^= pran; \n                } \n            } \n        } \n    } \n} ", "pred": " \nstatic void \nRandomAccessUpdate(uint64_t TableSize, uint64_t *Table) { \n    uint64_t i; \n    uint64_t *ran; \n    int j; \n \n    uint32_t unitCnt = __htc_get_unit_count(); \n    uint64_t ranSize = unitCnt * NUM_THREADS; \n    ran = (uint64_t *)malloc(ranSize*sizeof(uint64_t)); \n    if (! ran) { \n        printf( \"Failed to allocate memory for the ran array (%ld).\\n\",  \n                ranSize); \n        exit(1); \n    } \n \n    for (j=0; j<ranSize; j++) { \n        ran[j] = HPCC_starts ((NUPDATE/ranSize) * j); \n    } \n \n    fprintf(stderr,\"ran array has been initialized\\n\"); fflush(stderr); \n \n    uint32_t updates_per_unit = NUPDATE/unitCnt; \n    printf(\"will use %d units and %d threads per unit, %d total threads\\n\", \n           unitCnt, unitCnt*NUM_THREADS, unitCnt*NUM_THREADS*updates_per_unit); \n \n    for (i=0; i<TableSize; i++) { \n        uint64_t *p = Table + i*unitCnt; \n        for (j=0; j<unitCnt; j++) { \n            ran[j] = HPCC_starts(p[j]); \n        } \n        for (j=0; j<unitCnt; j++) { \n            p[j] = HPCC_updates(p[j], updates_per_unit); \n        } \n    } \n \n    for (i=0; i<TableSize; i++) { \n        uint64_t *p = Table + i*unitCnt; \n        for (j=0; j<unitCnt; j++) { \n            p[j] = HPCC_updates(p[j], updates_per_unit); \n        } \n    } \n \n    for ("}
{"label": "d dt_colorspaces_rgb_to_cygm(float *out, int num, double RGB_to_CAM[4][3]) \n{ \n  for(int i = 0; i < num; i++) \n  { \n    float *in = &out[i*3]; \n    float o[4] = {0.0f,0.0f,0.0f,0.0f}; \n    for(int c = 0; c < 4; c++) \n      for(int k = 0; k < 3; k++) \n        o[c] += RGB_to_CAM[c][k] * in[k]; \n    for(int c = 0; c < 4; c++) \n      in[c] = o[c]; \n  } \n} \n \n \n ", "pred": "d dt_colorspaces_rgb_to_cygm(float *out, int num, double RGB_to_CAM[4][3]) \n{ \n  for(int i = 0; i < num; i++) \n  { \n    float *in = &out[i*3]; \n    float o[4] = {0.0f,0.0f,0.0f,0.0f}; \n    for(int c = 0; c < 4; c++) \n      for(int k = 0; k < 3; k++) \n        o[c] += RGB_to_CAM[c][k] * in[k]; \n    for(int c = 0; c < 4; c++) \n      in[c] = o[c]; \n  } \n} \n \n \n "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 16; \n  tile_size[1] = 16; \n  tile_size[2] = 24; \n  tile_size[3] = 2048; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=floord(Nt-1,2);t1++) { \n    lbp=max(ceild(t1,2),ceild(4*t1-Nt+2,4)); \n    ubp=min(floord(4*Nt+Nz-9,16),floord(8*t1+Nz+2,16)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(max(0,ceild(t1-2,3)),ceild(2*t1-2*t2-1,3)),ceild(16*t2-Nz-11,24));t3<=min(min(min(floord(4*Nt+Ny-9,24),floord(8*t1+Ny+7,24)),floord(16*t2+Ny+3,24)),floord(16*t1-16*t2+Nz+Ny+5,24));t3++) { \n        for (t4=max(max(max(0,ceild(t1-255,256)),ceild(16*t2-Nz-2035,2048)),ceild(24*t3-Ny-2035,2048));t4<=min(min(min(min(floord(4*Nt+Nx-9,2048),floord(8*t1+Nx+7,2048)),floord(16*t2+Nx+3,2048)),floord(24*t3+Nx+11,2048)),floord(16*t1-16*t2+Nz+Nx+5,2048));t4++) { \n          for (t5=max(max(max(max(max(0,ceild(16*t2-Nz+5,4)),ceild(24*t3-Ny+5,4)),ceild(2048*t4-Nx+5,4)),2*t1),4*t1-4*t2+1);t5<=min(min(min(min(min(floord(16*t1-16*t2+Nz+10,4),Nt-1),2*t1+3),4*t2+2),6*t3+4),512*t4+510);t5++) { \n            for (t6=max(max(16*t2,4*t5+4),-16*t1+16*t2+8*t5-15);t6<=min(min(16*t2+15,-16*t1+16*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(24*t3,4*t5+4);t7<=min(24*t3+23,4*t5+Ny-5);t7++) { \n                lbv=max(2048*t4,4*t5+4); \n                ubv=min(2048*t4+2047,4*t5+Nx-5); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((2.0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) - A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (roc2[ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] * (((((coef0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (coef1 * (((((A[ t5 % 2][ (-4*t", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0; j<Ny; j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n  for(t=0; t<Nt; t++){ \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      }"}
{"label": " \nstatic void CA_correct(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in2, \n                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int width = roi_in->width; \n  const int height = roi_in->height; \n  const uint32_t filters = piece->pipe->dsc.filters; \n  memcpy(out, in2, width * height * sizeof(float)); \n  const float *const in = out; \n  const double cared = 0, cablue = 0; \n  const double caautostrength = 4; \n \n   \n \n  const int ts = 128; \n  const int tsh = ts / 2; \n   \n \n  const int v1 = ts, v2 = 2 * ts, v3 = 3 * ts, \n            v4 = 4 * ts;  \n \n \n   \n \n  for(int i = 0; i < 2; i++) \n    for(int j = 0; j < 2; j++) \n      if(FC(i, j, filters) == 3) \n      { \n        printf(\"CA correction supports only RGB Colour filter arrays\\n\"); \n        return; \n      } \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n  const gboolean autoCA = (cared == 0 && cablue == 0); \n   \n \n   \n \n   \n \n  float *Gtmp = (float(*))calloc((height) * (width), sizeof *Gtmp); \n \n   \n \n  float *RawDataTmp = (float *)malloc(height * width * sizeof(float) / 2 + 4); \n \n  float blockave[2][2] = { { 0, 0 }, { 0, 0 } }, blocksqave[2][2] = { { 0, 0 }, { 0, 0 } }, \n        blockdenom[2][2] = { { 0, 0 }, { 0, 0 } }, blockvar[2][2]; \n \n   \n \n  gboolean processpasstwo = TRUE; \n \n  const int border = 8; \n  const int border2 = 16; \n \n  const int vz1 = (height + border2) % (ts - border2) == 0? 1 : 0; \n  const int hz1 = (width + border2) % (ts - border2) == 0? 1 : 0; \n  const int vblsz = ceil((float)(height + border2) / (ts - border2) + 2 + vz1); \n  const int hblsz = ceil((float)(width + border2) / (ts - border2) + 2 + hz1); \n \n  char *buffer1 = (char *)calloc(vblsz * hblsz * (2 * 2 + 1), sizeof(float)); \n \n   \n \n  float *blockwt = (float *)buffer1; \n  float(*blockshifts)[2][2] = (float(*)[2][2])(buffer1 + (vblsz * hblsz * sizeof(float))); \n \n  double fitparams[2][2][16]; \n \n   \n \n  int polyord = 4, numpar = 16; \n \n  const float eps = 1e-5f, eps2 = 1e-10f;  \n \n \n  { \n     \n \n \n     \n \n    int GRBdir[2][3]; \n \n    int shifthfloor[3], shiftvfloor[3], shifthceil[3], shiftvceil[3]; \n \n     \n \n    float coeff[2][3][2]; \n     \n \n    float CAshift[2][2]; \n     \n \n     \n \n    float shifthfrac[3], shiftvfrac[3]; \n     \n \n    float blockavethr[2][2] = { { 0, 0 }, { 0, 0 } }, blocksqavethr[2][2] = { { 0, 0 }, { 0, 0 } }, \n          blockdenomthr[2][2] = { { 0, 0 }, { 0, 0 } }; \n \n     \n \n    const int buffersize = 3 * sizeof(float) * ts * ts + 6 * sizeof(float) * ts * tsh + 8 * 64 + 63; \n    char *buffer = (char *)malloc(buffersize); \n    char *data = (char *)(((uintptr_t)buffer + (uintptr_t)63) / 64 * 64); \n \n     \n \n     \n \n \n     \n \n    float *rgb[3]; \n    rgb[0] = (float(*))data; \n    rgb[1] = (float(*))(data + 1 * sizeof(float) * ts * ts + 1 * 64); \n    rgb[2] = (float(*))(data + 2 * sizeof(float) * ts * ts + 2 * 64); \n \n     \n \n    float *rbhpfh = (float(*))(data + 3 * sizeof(float) * ts * ts + 3 * 64); \n     \n \n    float *rbhpfv = (float(*))(data + 3 * sizeof(float) * ts * ts + sizeof(float) * ts * tsh + 4 * 64); \n     \n \n    float *rblpfh = (float(*))(data + 4 * sizeof(float) * ts * ts + 5 * 64); \n     \n \n    float *rblpfv = (float(*))(data + 4 * sizeof(float) * ts * ts + sizeof(float) * ts * tsh + 6 * 64); \n     \n \n    float *grblpfh = (float(*))(data + 5 * sizeof(float) * ts * ts + 7 * 64); \n     \n \n    float *grblpfv = (float(*))(data + 5 * sizeof(float) * ts * ts + sizeof(float) * ts * tsh + 8 * 64); \n     \n \n    float *grbdiff = rbhpfh;  \n \n     \n \n    float *gshift = rbhpfv;  \n \n \n \n    if(autoCA) \n    { \n \n \n      for(int top = -border; top < height; top += ts - border2) \n        for(int left = -border; left < width; left += ts - border2) \n        { \n          memset(buffer, 0, buffersize); \n          const int vblock = ((top + border) / (ts - border2)) + 1; \n          const int hblock = ((left + border) / (ts - border2)) + 1; \n          const int bottom = MIN(top + ts, height + border); \n          const int right = MIN(left + ts, width + border); \n          const int rr1 = bottom - top; \n          const int cc1 = right - left; \n          const int rrmin = top < 0? border : 0; \n          const int rrmax = bottom > height? height - top : rr1; \n          const int ccmin = left < 0? border : 0; \n          const int ccmax = right > width? width - left : cc1; \n \n           \n \n           \n \n           \n \n \n          for(int rr = rrmin; rr < rrmax; rr++) \n            for(int row = rr + top, cc = ccmin; cc < ccmax; cc++) \n            { \n              int col = cc + left; \n           ", "pred": " \nstatic void CA_correct(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in2, \n                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int width = roi_in->width; \n  const int height = roi_in->height; \n  const uint32_t filters = piece->pipe->dsc.filters; \n  memcpy(out, in2, width * height * sizeof(float)); \n  const float *const in = out; \n  const double cared = 0, cablue = 0; \n  const double caautostrength = 4; \n \n   \n \n  const int ts = 128; \n  const int tsh = ts / 2; \n   \n \n  const int v1 = ts, v2 = 2 * ts, v3 = 3 * ts, \n            v4 = 4 * ts;  \n \n \n   \n \n  for(int i = 0; i < 2; i++) \n    for(int j = 0; j < 2; j++) \n      for(int k = 0; k < 2; k++) \n        for(int l = 0; l < 2; l++) \n          for(int m = 0; m < 2; m++) \n            for(int n = 0; n < 2; n++) \n              for(int o = 0; o < 2; o++) \n                for(int p = 0; p < 2; p++) \n                  for(int q = 0; q < 2; q++) \n                    for(int r = 0; r < 2; r++) \n                      for(int s = 0; s < 2; s++) \n                        for(int t = 0; t < 2; t++) \n                          for(int u = 0; u < 2; u++) \n                            for(int v = 0; v < 2; v++) \n                              for(int w = 0; w < 2; w++) \n                                for(int x = 0; x < 2; x++) \n                                  for(int y = 0; y < 2; y++) \n                                    for(int z = 0; z < 2; z++) \n                                      for(int c = 0; c < 2; c++) \n                                        for(int d = 0; d < 2; d++) \n                                          for(int e = 0; e < 2; e++) \n                                            for(int f = 0; f < 2; f++) \n                                              for(int g = 0; g < 2; g++) \n                                                for(int h = 0; h < 2; h++) \n                                                  for(int i = 0; i < 2; i++) \n                                                    for(int j = 0; j < 2; j++) \n                                                      for(int k = 0; k < 2; k++) \n                                                        for(int l = 0; l < 2; l++) \n                                                          for(int m = 0; m < 2; m++) \n                                                            for(int n = 0; n < 2; n++) \n                                                              for(int o = 0; o < 2; o++) \n                                                                for(int p = 0; p < 2; p++) \n                                                                  for(int q = 0; q < 2; q++) \n                                                                    for(int r = 0; r < 2; r++) \n                                                                      for(int s = 0; s < 2; s++) \n                                                               "}
{"label": " \nint distort_backtransform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *const restrict points, \n                          size_t points_count) \n{ \n  dt_iop_rawprepare_data_t *d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n  if(d->x == 0 && d->y == 0) return 1; \n \n  const float scale = piece->buf_in.scale / piece->iscale; \n \n  const float x = (float)d->x * scale, y = (float)d->y * scale; \n \n  for(size_t i = 0; i < points_count * 2; i += 2) \n  { \n    points[i] += x; \n    points[i + 1] += y; \n  } \n \n  return 1; \n} ", "pred": " \nint distort_backtransform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *const restrict points, \n                          size_t points_count) \n{ \n  dt_iop_rawprepare_data_t *d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n  if(d->x == 0 && d->y == 0) return 1; \n \n  const float scale = piece->buf_in.scale / piece->iscale; \n \n  const float x = (float)d->x * scale, y = (float)d->y * scale; \n \n  for(size_t i = 0; i < points_count * 2; i += 2) \n  { \n    points[i] += x; \n    points[i + 1] += y; \n  } \n \n  return 1; \n} "}
{"label": " \nMagickExport double GetImageTotalInkDensity(Image *image, \n  ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  double \n    total_ink_density; \n \n  MagickBooleanType \n    status; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\"); \n  assert(image->signature == MagickCoreSignature); \n  if (image->colorspace!= CMYKColorspace) \n    { \n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError, \n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename); \n      return(0.0); \n    } \n  status=MagickTrue; \n  total_ink_density=0.0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    double \n      density; \n \n    register const Quantum \n      *p; \n \n    register ssize_t \n      x; \n \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    if (p == (const Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      density=(double) GetPixelRed(image,p)+GetPixelGreen(image,p)+ \n        GetPixelBlue(image,p)+GetPixelBlack(image,p); \n      if (density > total_ink_density) \n        { \n          if (density > total_ink_density) \n            total_ink_density=density; \n        } \n      p+=GetPixelChannels(image); \n    } \n  } \n  image_view=DestroyCacheView(image_view); \n  if (status == MagickFalse) \n    total_ink_density=0.0; \n  return(total_ink_density); \n} ", "pred": " \nMagickExport double GetImageTotalInkDensity(Image *image, \n  ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  double \n    total_ink_density; \n \n  MagickBooleanType \n    status; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\"); \n  assert(image->signature == MagickCoreSignature); \n  if (image->colorspace!= CMYKColorspace) \n    { \n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError, \n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename); \n      return(0.0); \n    } \n  status=MagickTrue; \n  total_ink_density=0.0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    double \n      density; \n \n    register const Quantum \n      *p; \n \n    register ssize_t\n      x; \n \n    register Quantum\n      *q; \n \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    if (p == (const Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n \n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception); \n    if (q == (Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n \n    density=GetPixelIntensity(image,p); \n    total_ink_density+=density; \n    for (x=0; x < (ssize_t) image->columns; x++) \n      if (IsPixelIntensity(image,p) == MagickFalse)\n        break; \n    if (x < (ssize_t) image->columns) \n      { \n        q+=GetPixelChannels(image); \n       "}
{"label": "d dt_colorspaces_cygm_apply_coeffs_to_rgb(float *out, const float *in, int num, double RGB_to_CAM[4][3], double CAM_to_RGB[3][4], float coeffs[4]) \n{ \n   \n \n  double CAM_to_RGB_WB[3][4]; \n  for (int a=0; a<3; a++) \n    for (int b=0; b<4; b++) \n      CAM_to_RGB_WB[a][b] = CAM_to_RGB[a][b] * coeffs[b]; \n \n   \n \n  double RGB_to_RGB_WB[3][3]; \n  for (int a=0; a<3; a++) \n    for (int b=0; b<3; b++) { \n      RGB_to_RGB_WB[a][b] = 0.0f; \n      for (int c=0; c<4; c++) \n        RGB_to_RGB_WB[a][b] += CAM_to_RGB_WB[a][c] * RGB_to_CAM[c][b]; \n    } \n \n  for(int i = 0; i < num; i++) \n  { \n    const float *inpos = &in[i*4]; \n    float *outpos = &out[i*4]; \n    outpos[0]=outpos[1]=outpos[2] = 0.0f; \n    for (int a=0; a<3; a++) \n      for (int b=0; b<3; b++) \n        outpos[a] += RGB_to_RGB_WB[a][b] * inpos[b]; \n  } \n} \n \nvo ", "pred": "d dt_colorspaces_cygm_apply_coeffs_to_rgb(float *out, const float *in, int num, double RGB_to_CAM[4][3], double CAM_to_RGB[3][4], float coeffs[4]) \n{ \n   \n \n  double CAM_to_RGB_WB[3][4]; \n  for (int a=0; a<3; a++) \n    for (int b=0; b<4; b++) \n      CAM_to_RGB_WB[a][b] = CAM_to_RGB[a][b] * coeffs[b]; \n \n   \n \n  double RGB_to_RGB_WB[3][3]; \n  for (int a=0; a<3; a++) \n    for (int b=0; b<3; b++) { \n      RGB_to_RGB_WB[a][b] = 0.0f; \n      for (int c=0; c<4; c++) \n        RGB_to_RGB_WB[a][b] += CAM_to_RGB_WB[a][c] * RGB_to_CAM[c][b]; \n    } \n \n  for(int i = 0; i < num; i++) \n    out[i] = RGB_to_RGB_WB[0][i] * in[i] + RGB_to_RGB_WB[1][i] * in[i+1] + RGB_to_RGB_WB[2][i] * in[i+2]; \n   \n   \n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"label": " \nvoid mzd_process_rows5(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, rci_t const *L2, \n\t\t       mzd_t const *T3, rci_t const *L3, mzd_t const *T4, rci_t const *L4) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n  int rem = k % 5; \n \n  int const ka = k / 5 + ((rem >= 4)? 1 : 0); \n  int const kb = k / 5 + ((rem >= 3)? 1 : 0); \n  int const kc = k / 5 + ((rem >= 2)? 1 : 0); \n  int const kd = k / 5 + ((rem >= 1)? 1 : 0); \n  int const ke = k / 5; \n \n  rci_t r; \n \n  word const ka_bm = __M4RI_LEFT_BITMASK(ka); \n  word const kb_bm = __M4RI_LEFT_BITMASK(kb); \n  word const kc_bm = __M4RI_LEFT_BITMASK(kc); \n  word const kd_bm = __M4RI_LEFT_BITMASK(kd); \n  word const ke_bm = __M4RI_LEFT_BITMASK(ke); \n \n \n  for(r = startrow; r < stoprow; ++r) { \n    word bits = mzd_read_bits(M, r, startcol, k); \n    rci_t const x0 = L0[ bits & ka_bm ]; bits>>=ka; \n    rci_t const x1 = L1[ bits & kb_bm ]; bits>>=kb; \n    rci_t const x2 = L2[ bits & kc_bm ]; bits>>=kc; \n    rci_t const x3 = L3[ bits & kd_bm ]; bits>>=kd; \n    rci_t const x4 = L4[ bits & ke_bm ]; \n \n    if(((x0 | x1 | x2) | (x3 | x4)) == 0)  \n \n      continue; \n \n    word *m0 = M->rows[r] + blocknum; \n    word const *t[5]; \n    t[0] = T0->rows[x0] + blocknum; \n    t[1] = T1->rows[x1] + blocknum; \n    t[2] = T2->rows[x2] + blocknum; \n    t[3] = T3->rows[x3] + blocknum; \n    t[4] = T4->rows[x4] + blocknum; \n \n    _mzd_combine_5( m0, t, wide); \n  } \n \n  __M4RI_DD_MZD(M); \n} ", "pred": " \nvoid mzd_process_rows5(mzd_t *M, rci_t startrow, rci_t stoprow, rci_t startcol, int k, \n                       mzd_t const *T0, rci_t const *L0, mzd_t const *T1, rci_t const *L1, mzd_t const *T2, rci_t const *L2, \n\t\t       mzd_t const *T3, rci_t const *L3, mzd_t const *T4, rci_t const *L4) { \n  assert(k <= m4ri_radix); \n  wi_t const blocknum = startcol / m4ri_radix; \n  wi_t const wide = M->width - blocknum; \n  int rem = k % 5; \n \n  int const ka = k / 5 + ((rem >= 4)? 1 : 0); \n  int const kb = k / 5 + ((rem >= 3)? 1 : 0); \n  int const kc = k / 5 + ((rem >= 2)? 1 : 0); \n  int const kd = k / 5 + ((rem >= 1)? 1 : 0); \n  int const l = k % 5; \n  int const l1 = l + 1; \n  int const l2 = l + 2; \n  int const l3 = l + 3; \n  int const l4 = l + 4; \n  int const l5 = l + 5; \n  int const l6 = l + 6; \n  int const l7 = l + 7; \n  int const l8 = l + 8; \n  int const l9 = l + 9; \n  int const l10 = l + 10; \n  int const l11 = l + 11; \n  int const l12 = l + 12; \n  int const l13 = l + 13; \n  int const l14 = l + 14; \n  int const l15 = l + 15; \n  int const l16 = l + 16; \n  int const l17 = l + 17; \n  int const l18 = l + 18; \n  int const l19 = l + 19; \n  int const l20 = l + 20; \n  int const l21 = l + 21; \n  int const l22 = l + 22; \n  int const l23 = l + 23; \n  int const l24 = l + 24; \n  int const l25 = l + 25; \n  int const l26 = l + 26; \n  int const l27 = l + 27; \n  int const l28 = l + 28; \n  int const l29 = l + 29; \n  int const l30 = l + 30; \n  int const l31 = l + 31; \n  int const l32 = l + 32; \n  int const l33 = l + 33; \n  int const l34 = l + 34; \n  int const l35 = l + 35; \n  int const l36 = l + 36; \n  int const l37 = l + 37; \n  int const l38 = l + 38; \n  int const l39 = l + 39; \n  int const l40 = l + 40; \n  int const l41 = l + 41; \n  int const l42 = l + 42; \n  int const l43 = l + 43; \n  int const l44 = l + 44; \n  int const"}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 \n     && piece->dsc_in.datatype == TYPE_UINT16) \n  {  \n \n \n    const uint16_t *const in = (const uint16_t *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t pin = (size_t)(roi_in->width * (j + csy) + csx) + i; \n        const size_t pout = (size_t)j * roi_out->width + i; \n \n        const int id = BL(roi_out, d, j, i); \n        out[pout] = (in[pin] - d->sub[id]) / d->div[id]; \n      } \n    } \n \n    piece->pipe->dsc.filters = dt_rawspeed_crop_dcraw_filters(self->dev->image_storage.buf_dsc.filters, csx, csy); \n    adjust_xtrans_filters(piece->pipe, csx, csy); \n  } \n  else if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 \n          && piece->dsc_in.datatype == TYPE_FLOAT) \n  {  \n \n \n    const float *const in = (const float *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t pin = (size_t)(roi_in->width * (j + csy) + csx) + i; \n        const size_t pout = (size_t)j * roi_out->width + i; \n \n        const int id = BL(roi_out, d, j, i); \n        out[pout] = (in[pin] - d->sub[id]) / d->div[id]; \n      } \n    } \n \n    piece->pipe->dsc.filters = dt_rawspeed_crop_dcraw_filters(self->dev->image_storage.buf_dsc.filters, csx, csy); \n    adjust_xtrans_filters(piece->pipe, csx, csy); \n  } \n  else \n  {  \n \n \n    const float *const in = (const float *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n    const float sub = d->sub[0], div = d->div[0]; \n \n    const int ch = piece->colors; \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        for(int c = 0; c < ch; c++) \n        { \n          const size_t pin = (size_t)ch * (roi_in->width * (j + csy) + csx + i) + c; \n          const size_t pout = (size_t)ch * (j * roi_out->width + i) + c; \n \n          out[pout] = (in[pin] - sub) / div; \n        } \n      } \n    } \n  } \n \n  if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 && d->apply_gainmaps) \n  { \n    const uint32_t map_w = d->gainmaps[0]->map_points_h; \n    const uint32_t map_h = d->gainmaps[0]->map_points_v; \n    const float im_to_rel_x = 1.0 / piece->buf_in.width; \n    const float im_to_rel_y = 1.0 / piece->buf_in.height; \n    const float rel_to_map_x = 1.0 / d->gainmaps[0]->map_spacing_h; \n    const float rel_to_map_y = 1.0 / d->gainmaps[0]->map_spacing_v; \n    const float map_origin_h = d->gainmaps[0]->map_origin_h; \n    const float map_origin_v = d->gainmaps[0]->map_origin_v; \n    float *const out = (float *const)ovoid; \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float y_map = CLAMP(((roi_out->y + csy + j) * im_to_rel_y - map_origin_v) * rel_to_map_y, 0, map_h); \n      const uint32_t y_i0 = MIN(y_map, map_h - 1); \n      const uint32_t y_i1 = MIN(y_i0 + 1, map_h - 1); \n      const float y_frac = y_map - y_i0; \n      const float * restrict map_row0[4]; \n      const float * restrict map_row1[4]; \n      for(int f = 0; f < 4; f++) \n      { \n        map_row0[f] = &d->gainmaps[f]->map_gain[y_i0 * map_w]; \n        map_row1[f] = &d->gainmaps[f]->map_gain[y_i1 * map_w]; \n      } \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const int id = BL(roi_out, d, j, i); \n        const float x_map = CLAMP(((roi_out->x + csx + i) * im_to_rel_x - map_origin_h) * rel_to_map_x, 0, map_w); \n        const uint32_t x_i0 = MIN(x_map, map_w - 1); \n        const uint32_t x_i1 = MIN(x_i0 + 1, map_w - 1); \n        const float x_frac = x_map - x_i0; \n        const float gain_top = (1.0f - x_frac) * map_row0[id][x_i0] + x_frac * map_row0[id][x_i1]; \n        const float gain_bottom = (1.0f - x_frac) * map_row1[id][x_i0] + x_frac * map_row1", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters && piece->dsc_in.channels == 1 \n     && piece->dsc_in.datatype == TYPE_UINT16) \n  {  \n \n \n    const uint16_t *const in = (const uint16_t *const)ivoid; \n    float *const out = (float *const)ovoid; \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const int x = i - csy; \n        const int y = j - csx; \n        const int idx = y * roi_out->width + x; \n        const int idx_in = idx / d->x; \n        const int idx_out = idx % d->x; \n        const int idx_out_in = idx_out / d->x; \n        const int idx_out_in_in = idx_out % d->x; \n        const int idx_out_in_in_in = idx_out_in / d->x; \n        const int idx_out_in_in_in_in = idx_out_in % d->x; \n        const int idx_out_in_in_in_in_in = idx_out_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in = idx_out_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in = idx_out_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in / d->x; \n        const int idx_out_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in = idx_out_in_in_in_in_in"}
{"label": " \nint distort_transform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *const restrict points, size_t points_count) \n{ \n  dt_iop_rawprepare_data_t *d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n  if(d->x == 0 && d->y == 0) return 1; \n \n  const float scale = piece->buf_in.scale / piece->iscale; \n \n  const float x = (float)d->x * scale, y = (float)d->y * scale; \n \n  for(size_t i = 0; i < points_count * 2; i += 2) \n  { \n    points[i] -= x; \n    points[i + 1] -= y; \n  } \n \n  return 1; \n} ", "pred": " \nint distort_transform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *const restrict points, size_t points_count) \n{ \n  dt_iop_rawprepare_data_t *d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n  if(d->x == 0 && d->y == 0) return 1; \n \n  const float scale = piece->buf_in.scale / piece->iscale; \n \n  const float x = (float)d->x * scale, y = (float)d->y * scale; \n \n  for(size_t i = 0; i < points_count * 2; i += 2) \n  { \n    points[i] -= x; \n    points[i + 1] -= y; \n  } \n \n  return 1; \n} "}
{"label": " \nint voxelizeMesh(int num_threads, FILE *outFile, Vertex *vertices, unsigned int nVertices, Face **mesh, unsigned int nTriangles, Color *mc, int mid, Vertex *vSize, int co) { \n    Vertex rMin, rMax; \n    Voxel vMax; \n \n     \n \n    getRBoundingBox(vertices, nVertices, &rMin, &rMax); \n    rMin.x = floor(rMin.x); \n    rMin.y = floor(rMin.y); \n    rMin.z = floor(rMin.z); \n    printf(\"Min: \"); \n    printVertex(&rMin); \n    printf(\"\\nMax: \"); \n    printVertex(&rMax); \n    vMax.x = (unsigned int)ceil((rMax.x-rMin.x)/vSize->x); \n    vMax.y = (unsigned int)ceil((rMax.y-rMin.y)/vSize->y); \n    vMax.z = (unsigned int)ceil((rMax.z-rMin.z)/vSize->z); \n    printf(\"\\nVMax: \"); \n    printVoxel(&vMax); \n     \n \n    int x, y, z; \n    omp_set_num_threads(num_threads); \n    for (x = 0; x <= vMax.x; ++x) { \n        for (y = 0; y <= vMax.y; ++y) { \n            for (z = 0; z <= vMax.z; ++z) { \n                Vertex voxelCenter; \n                centerOfVoxel_(x, y, z, &rMin, vSize, &voxelCenter); \n                printf(\"\\nVoxel: \"); \n                printVertex(&voxelCenter); \n \n                 \n \n                int inTarget = 1; \n                if (!isNear(num_threads, mesh, nTriangles, &voxelCenter, vSize)) inTarget = 0; \n \n                 \n \n                if (inTarget) { \n                    if (co == 26) { \n                        inTarget = intersectsMesh26(mesh, nTriangles, &voxelCenter, vSize); \n                    } else if (co == 6) { \n                        inTarget = intersectsMesh6(mesh, nTriangles, &voxelCenter, vSize); \n                    } else { \n                        printf(\"connectivity target undefined!\"); \n                        inTarget = 0; \n                    } \n                } \n \n                 \n \n                if (inTarget) { \n                     \n \n                    fprintf(outFile, \"%d,%f,%f,%f,%d,%d,%d\\n\", mid, voxelCenter.x, voxelCenter.y, voxelCenter.z, mc->r, mc->g, mc->b); \n                } \n            } \n        } \n    } \n \n    return 0; \n} ", "pred": " \nint voxelizeMesh(int num_threads, FILE *outFile, Vertex *vertices, unsigned int nVertices, Face **mesh, unsigned int nTriangles, Color *mc, int mid, Vertex *vSize, int co) { \n    Vertex rMin, rMax; \n    Voxel vMax; \n \n     \n \n    getRBoundingBox(vertices, nVertices, &rMin, &rMax); \n    rMin.x = floor(rMin.x); \n    rMin.y = floor(rMin.y); \n    rMin.z = floor(rMin.z); \n    printf(\"Min: \"); \n    printVertex(&rMin); \n    printf(\"\\nMax: \"); \n    printVertex(&rMax); \n    vMax.x = (unsigned int)ceil((rMax.x-rMin.x)/vSize->x); \n    vMax.y = (unsigned int)ceil((rMax.y-rMin.y)/vSize->y); \n    vMax.z = (unsigned int)ceil((rMax.z-rMin.z)/vSize->z); \n    printf(\"\\nVMax: \"); \n    printVoxel(&vMax); \n    printf(\"\\n\"); \n \n    int num_threads_voxelize = num_threads; \n    if (num_threads == 1) num_threads_voxelize = num_threads_voxelize/2; \n    \n    int num_threads_voxelize_voxelize = num_threads_voxelize; \n    if (num_threads == 1) num_threads_voxelize_voxelize = num_threads_voxelize_voxelize/2; \n    \n    int num_threads_voxelize_voxelize_voxelize = num_threads_voxelize_voxelize; \n    if (num_threads == 1) num_threads_voxelize_voxelize_voxelize = num_threads_voxelize_voxelize_voxelize/2; \n    \n    int num_threads_voxelize_voxelize_voxelize_voxelize = num_threads_voxelize_voxelize_voxelize; \n    if (num_threads == 1) num_threads_voxelize_voxelize_voxelize_voxelize = num_threads_voxelize_voxelize_voxelize_voxelize/2; \n    \n    int num_threads_voxelize_voxelize_voxelize_voxelize_voxelize = num_threads_voxelize_voxelize_voxelize_voxelize; \n    if (num_threads == 1) num_threads_voxelize_voxelize_voxelize_voxelize_voxelize = num_threads_voxelize_voxelize_voxelize_voxelize_voxelize/2; \n    \n    int num_threads_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize = num_threads_voxelize_voxelize_voxelize_voxelize; \n    if (num_threads == 1) num_threads_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize = num_threads_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize/2; \n    \n    int num_threads_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize = num_threads_voxelize_voxelize_voxelize_voxelize; \n    if (num_threads == 1) num_threads_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize = num_threads_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize/2; \n    \n    int num_threads_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize = num_threads_voxelize_voxelize_voxelize_voxelize; \n    if (num_threads == 1) num_threads_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize = num_threads_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize/2; \n    \n    int num_threads_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize_voxelize = num_threads_voxelize_voxelize_voxelize; \n    if (num_threads == 1) num_threads_voxelize_voxelize_voxelize_voxelize_voxelize"}
{"label": " \nint bs_thread(void *tid_ptr) { \n    int i, j, k; \n    fptype price[NCO]; \n    fptype priceDelta; \n    int tid = *(int *)tid_ptr; \n    int start = tid * (numOptions / nThreads); \n    int end = start + (numOptions / nThreads); \n \n    for (j=0; j<NUM_RUNS; j++) { \n        for (i=0; i<numOptions; i += NCO) { \n \n        for (i=start; i<end; i += NCO) { \n \n             \n \n             \n \n            BlkSchlsEqEuroNoDiv(price, NCO, &(sptprice[i]), &(strike[i]), \n                                &(rate[i]), &(volatility[i]), &(otime[i]), &(otype[i]), 0); \n            for (k=0; k<NCO; k++) { \n              prices[i+k] = price[k]; \n            }  \n            for (k=0; k<NCO; k++) { \n                priceDelta = data[i+k].DGrefval - price[k]; \n                if (fabs(priceDelta) >= 1e-4) { \n                    printf(\"Error on %d. Computed=%.5f, Ref=%.5f, Delta=%.5f\\n\", \n                           i + k, price[k], data[i+k].DGrefval, priceDelta); \n                    numError ++; \n                } \n            } \n        } \n    } \n \n    return 0; \n} ", "pred": " \nint bs_thread(void *tid_ptr) { \n    int i, j, k; \n    fptype price[NCO]; \n    fptype priceDelta; \n    int tid = *(int *)tid_ptr; \n    int start = tid * (numOptions / nThreads); \n    int end = start + (numOptions / nThreads); \n \n    for (j=0; j<NUM_RUNS; j++) { \n        for (i=0; i<numOptions; i += NCO) { \n \n        for (i=start; i<end; i += NCO) { \n \n             \n \n             \n \n            BlkSchlsEqEuroNoDiv(price, NCO, &(sptprice[i]), &(strike[i]), \n                                &(rate[i]), &(volatility[i]), &(otime[i]), &(otype[i]), 0); \n            for (k=0; k<NCO; k++) { \n                                                                                                                                                                                                                                                                                                               "}
{"label": " \nint main(int argc, char** argv) { \n    int i, j, k; \n    int ni = NI; \n    int nj = NJ; \n    int nk = NK; \n     \n     \n \n    init_array(); \n     \n     \n    for (i = 0; i < ni; i++) \n        for (j = 0; j < nj; j++) { \n            C[i][j] *= beta; \n            for (k = 0; k < nk; ++k) \n                C[i][j] += alpha * A[i][k] * B[k][j]; \n        } \n     \n     \n    double total = 0; \n    for(int y=0; y<ni; ++y){ \n        for(int x=0; x<nj; ++x) { \n            total+= C[y][x]; \n        } \n    } \n    printf(\"Total: %f\\n\",total); \n     \n    return 0; \n} ", "pred": " \nint main(int argc, char** argv) { \n    int i, j, k; \n    int ni = NI; \n    int nj = NJ; \n    int nk = NK; \n     \n     \n \n    init_array(); \n     \n     \n    for (i = 0; i < ni; i++) \n        for (j = 0; j < nj; j++) { \n            C[i][j] *= beta; \n            for (k = 0; k < nk; ++k) \n                C[i][j] += alpha * A[i][k] * B[k][j]; \n        } \n     \n     \n    double total = 0; \n    for(int y=0; y<ni; ++y){ \n        for(int x=0; x<nj; ++x) { \n            total+= C[y][x]; \n        } \n    } \n    printf(\"%.6f\\n\", total); \n    return 0; \n} \n\n/*\n * Copyright ("}
{"label": " \nstatic PyObject *py_gibbs_ibm_discretize(PyObject *self, PyObject *args) { \n    PyObject *dists_arrays, *aaa; \n \n    if(!PyArg_ParseTuple(args, \"OO\", &dists_arrays, &aaa)) return NULL; \n \n    const size_t n_sents = PyTuple_Size(aaa); \n \n    for (size_t sent=0; sent<n_sents; sent++) { \n        PyArrayObject *aa_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(aaa, sent); \n        PyArrayObject *dists_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(dists_arrays, sent); \n        const size_t ff_len = \n            (size_t) PyArray_DIM(aa_array, 0); \n        if (ff_len == 0) continue; \n \n        const size_t ee_len = \n            ((size_t) PyArray_DIM(dists_array, 0) / ff_len) - 1; \n        if (ee_len == 0) continue; \n \n        LINK_t *aa = (LINK_t*) PyArray_GETPTR1(aa_array, 0); \n        COUNT_t *ps = (COUNT_t*) PyArray_GETPTR1(dists_array, 0); \n \n        for (size_t j=0; j<ff_len; j++) { \n            COUNT_t max_p = (COUNT_t) ps[0]; \n            size_t argmax_i = 0; \n            for (size_t i=1; i<ee_len+1; i++) { \n                if (ps[i] > max_p) { \n                    max_p = ps[i]; \n                    argmax_i = i; \n                } \n            } \n            aa[j] = (argmax_i == ee_len)? null_link : argmax_i; \n            ps += ee_len + 1; \n        } \n    } \n \n    Py_INCREF(Py_None); \n    return Py_None; \n} ", "pred": " \nstatic PyObject *py_gibbs_ibm_discretize(PyObject *self, PyObject *args) { \n    PyObject *dists_arrays, *aaa; \n \n    if(!PyArg_ParseTuple(args, \"OO\", &dists_arrays, &aaa)) return NULL; \n \n    const size_t n_sents = PyTuple_Size(aaa); \n \n    for (size_t sent=0; sent<n_sents; sent++) { \n        PyArrayObject *aa_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(aaa, sent); \n        PyArrayObject *dists_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(dists_arrays, sent); \n        const size_t ff_len = \n            (size_t) PyArray_DIM(aa_array, 0); \n        if (ff_len == 0) continue; \n \n        const size_t ee_len = \n            ((size_t) PyArray_DIM(aa_array, 1)) * \n            ((size_t) PyArray_DIM(aa_array, 2)) * \n            ((size_t) PyArray_DIM(aa_array, 3)); \n \n        const size_t n_ee = ee_len / (size_t) ff_len; \n \n        for (size_t e=0; e<n_ee; e++) { \n            const size_t f = e * (size_t) ff_len; \n \n            const size_t s = e * (size_t) n_sents; \n            const size_t e_idx = e * (size_t) n_ee; \n \n            const size_t s_idx = s * (size_t) n_sents; \n            const size_t e_idx_s = e_idx * (size_t) n_ee; \n \n            const size_t s_idx_e = s_idx * (size_t) n_ee; \n \n            const size_t s_idx_s_e = s_idx_s + e_idx; \n \n            const size_t s_idx_e_s = s_idx_e + s; \n \n            const size_t s_idx_s_e_s = s_idx_s_"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 8; \n  tile_size[3] = 32; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,4);t1++) { \n    lbp=max(ceild(t1,2),ceild(8*t1-Nt+3,8)); \n    ubp=min(floord(Nt+Nz-4,8),floord(4*t1+Nz+1,8)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-1,2)),ceild(8*t2-Nz-4,8));t3<=min(min(min(floord(Nt+Ny-4,8),floord(4*t1+Ny+5,8)),floord(8*t2+Ny+4,8)),floord(8*t1-8*t2+Nz+Ny+3,8));t3++) { \n        for (t4=max(max(max(0,ceild(t1-7,8)),ceild(8*t2-Nz-28,32)),ceild(8*t3-Ny-28,32));t4<=min(min(min(min(floord(Nt+Nx-4,32),floord(4*t1+Nx+5,32)),floord(8*t2+Nx+4,32)),floord(8*t3+Nx+4,32)),floord(8*t1-8*t2+Nz+Nx+3,32));t4++) { \n          for (t5=max(max(max(max(max(0,4*t1),8*t1-8*t2+1),8*t2-Nz+2),8*t3-Ny+2),32*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,4*t1+7),8*t2+6),8*t3+6),32*t4+30),8*t1-8*t2+Nz+5);t5++) { \n            for (t6=max(max(8*t2,t5+1),-8*t1+8*t2+2*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(8*t3,t5+1);t7<=min(8*t3+7,t5+Ny-2);t7++) { \n                lbv=max(32*t4,t5+1); \n                ubv=min(32*t4+31,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = (((((((coef[0][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (coef[1][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)])) + (coef[2][ (-t5+t6)][ (-t5+t7)][", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    coef[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      coef[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_v[i] = (double **) malloc(sizeof(double"}
{"label": " \nvoid test_three(int x) { \n  for (int i = 0; i < x; i++) { \n  } \n} ", "pred": " \nvoid test_three(int x) { \n  for (int i = 0; i < x; i++) { \n  } \n} "}
{"label": " \nvoid dt_bilateral_slice_to_output(const dt_bilateral_t *const b, const float *const in, float *out, \n                                  const float detail) \n{ \n   \n \n  const float norm = -detail * b->sigma_r * 0.04f; \n  const int ox = 1; \n  const int oy = b->size_x; \n  const int oz = b->size_y * b->size_x; \n \n  float *const buf = b->buf; \n \n  for(int j = 0; j < b->height; j++) \n  { \n    for(int i = 0; i < b->width; i++) \n    { \n      size_t index = 4 * (j * b->width + i); \n      float x, y, z; \n      const float L = in[index]; \n      image_to_grid(b, i, j, L, &x, &y, &z); \n       \n \n      const int xi = MIN((int)x, b->size_x - 2); \n      const int yi = MIN((int)y, b->size_y - 2); \n      const int zi = MIN((int)z, b->size_z - 2); \n      const float xf = x - xi; \n      const float yf = y - yi; \n      const float zf = z - zi; \n      const size_t gi = xi + b->size_x * (yi + b->size_y * zi); \n      const float Lout = norm * (buf[gi] * (1.0f - xf) * (1.0f - yf) * (1.0f - zf) \n                                 + buf[gi + ox] * (xf) * (1.0f - yf) * (1.0f - zf) \n                                 + buf[gi + oy] * (1.0f - xf) * (yf) * (1.0f - zf) \n                                 + buf[gi + ox + oy] * (xf) * (yf) * (1.0f - zf) \n                                 + buf[gi + oz] * (1.0f - xf) * (1.0f - yf) * (zf) \n                                 + buf[gi + ox + oz] * (xf) * (1.0f - yf) * (zf) \n                                 + buf[gi + oy + oz] * (1.0f - xf) * (yf) * (zf) \n                                 + buf[gi + ox + oy + oz] * (xf) * (yf) * (zf)); \n      out[index] = fmaxf(0.0f, out[index] + Lout); \n    } \n  } \n} ", "pred": " \nvoid dt_bilateral_slice_to_output(const dt_bilateral_t *const b, const float *const in, float *out, \n                                  const float detail) \n{ \n   \n \n  const float norm = -detail * b->sigma_r * 0.04f; \n  const int ox = 1; \n  const int oy = b->size_x; \n  const int oz = b->size_y * b->size_x; \n \n  float *const buf = b->buf; \n \n  for(int j = 0; j < b->height; j++) \n  { \n    for(int i = 0; i < b->width; i++) \n    { \n      size_t index = 4 * (j * b->width + i); \n      float x, y, z; \n      const float L = in[index]; \n      image_to_grid(b, i, j, L, &x, &y, &z); \n       \n \n      const int xi = MIN((int)x, ox); \n      const int yi = MIN((int)y, oy); \n      const int zi = MIN((int)z, oz); \n      const int x0 = MAX((int)x, ox - xi); \n      const int y0 = MAX((int)y, oy - yi); \n      const int z0 = MAX((int)z, oz - zi); \n      const int x1 = MIN((int)x + xi, ox); \n      const int y1 = MIN((int)y + yi, oy); \n      const int z1 = MIN((int)z + zi, oz); \n      const int x2 = MAX((int)x + xi, ox - xi); \n      const int y2 = MAX((int)y + yi, oy - yi); \n      const int z2 = MAX((int)z + zi, oz - zi); \n      const int x3 = MIN((int)x, ox); \n      const int y3 = MIN((int)y, oy); \n      const int z3 = MIN((int)z, oz); \n      const int x4 = MAX((int)x - xi, ox - xi); \n      const int y4 = MAX((int)y - yi, oy - yi); \n      const int z4 = MAX((int)z - zi, oz - zi); \n      const int x5 = MIN((int)x, ox); \n      const int y5 = MIN((int)y, oy); \n      const int z5 = MIN((int)z, oz); \n      const int x6 = MAX((int)x - xi, ox - xi); \n      const int y6 = MAX((int)y - yi, oy - yi); \n      const int z6 = MAX((int)z - zi, oz - zi); \n      const int x7 = MIN((int)x, ox); \n      const int y7 = MIN((int)y, oy); \n      const int z7 = MIN((int)z, oz); \n      const int x8 = MAX((int)x - xi, ox - xi); \n      const int y8 = MAX((int)y - yi, oy - yi); \n      const int z8 = MAX((int)z - zi, oz - zi); \n      const int x9 = MIN((int)x, ox); \n      const int y9"}
{"label": " \nstatic void createNodeLocks(PreGraph *preGraph) \n{ \n\tIDnum nbNodes; \n\tIDnum nodeIndex; \n \n\tnbNodes = preNodeCount_pg(preGraph) + 1; \n\tif (nodeLocks) \n\t\tfree (nodeLocks); \n\tnodeLocks = mallocOrExit(nbNodes, omp_lock_t); \n \n\tfor (nodeIndex = 0; nodeIndex < nbNodes; nodeIndex++) \n\t\tomp_init_lock(nodeLocks + nodeIndex); \n} ", "pred": " \nstatic void createNodeLocks(PreGraph *preGraph) \n{ \n\tIDnum nbNodes; \n\tIDnum nodeIndex; \n \n\tnbNodes = preNodeCount_pg(preGraph) + 1; \n\tif (nodeLocks) \n\t\tfree (nodeLocks); \n\tnodeLocks = mallocOrExit(nbNodes, omp_lock_t); \n \n\tfor (nodeIndex = 0; nodeIndex < nbNodes; nodeIndex++) \n\t\tomp_init_lock(nodeLocks + nodeIndex); \n} "}
{"label": " \nvoid fwd_step_enkf_updateA(void * module_data, \n                           matrix_type * A, \n                           matrix_type * S, \n                           matrix_type * R, \n                           matrix_type * dObs, \n                           matrix_type * E, \n                           matrix_type * D, \n                           const module_info_type* module_info) { \n \n \n \n  fwd_step_enkf_data_type * fwd_step_data = fwd_step_enkf_data_safe_cast( module_data ); \n  fwd_step_log_open(fwd_step_data->fwd_step_log); \n  module_data_block_vector_type * data_block_vector = module_info_get_data_block_vector(module_info); \n  printf(\"Running Forward Stepwise regression:\\n\"); \n  { \n \n    int ens_size    = matrix_get_columns( S ); \n    int nx          = matrix_get_rows( A ); \n    int nd          = matrix_get_rows( S ); \n    int nfolds      = fwd_step_data->nfolds; \n    double r2_limit = fwd_step_data->r2_limit; \n    bool verbose    = fwd_step_data->verbose; \n    int num_kw     =  module_data_block_vector_get_size(data_block_vector); \n \n    if (fwd_step_data->num_threads == DEFAULT_NUM_THREADS) \n     fwd_step_data->num_threads = omp_get_num_threads(); \n    fwd_step_data->num_threads = 1; \n \n    if ( ens_size <= nfolds) \n      util_abort(\"%s: The number of ensembles must be larger than the CV fold - aborting\\n\", __func__); \n \n \n    { \n \n      matrix_type * St = matrix_alloc( ens_size, nd  ); \n      matrix_type * Et = matrix_alloc( ens_size, nd  ); \n \n       \n \n      matrix_subtract_row_mean( S );            \n \n      St   = matrix_alloc_transpose( S ); \n      Et   = matrix_alloc_transpose( E ); \n \n      matrix_type * di = matrix_alloc( 1, nd ); \n \n      if (verbose){ \n        char * ministep_name = module_info_get_ministep_name(module_info); \n        fwd_step_enkf_write_log_header(fwd_step_data, ministep_name, nx, nd, ens_size); \n      } \n \n      int kw,i; \n       \n       \n \n      int_vector_type * kw_list = int_vector_alloc(nx, -1); \n      int_vector_type * local_index_list = int_vector_alloc(nx, -1); \n      for (kw = 0; kw < num_kw; kw++) { \n        module_data_block_type * data_block = module_data_block_vector_iget_module_data_block(data_block_vector, kw); \n        int row_start = module_data_block_get_row_start(data_block); \n        int row_end   = module_data_block_get_row_end(data_block); \n        for (i = row_start; i < row_end; i++) { \n          int_vector_iset(kw_list, i, kw); \n          int_vector_iset(local_index_list, i, i - row_start); \n        } \n      } \n \n \n       \n \n      for (i = 0; i < nx; i++) { \n        int kw_ind = int_vector_iget(kw_list, i); \n        module_data_block_type * data_block = module_data_block_vector_iget_module_data_block(data_block_vector, kw_ind); \n        const char * key = module_data_block_get_key(data_block); \n        const int* active_indices = module_data_block_get_active_indices(data_block); \n        int active_index = 0; \n        bool all_active = active_indices == NULL;  \n \n        stepwise_type * stepwise_data = stepwise_alloc1(ens_size, nd, fwd_step_data->rng, St, Et); \n \n         \n \n         \n \n        matrix_type * y = matrix_alloc( ens_size, 1 ); \n \n        for (int j = 0; j < ens_size; j++) { \n          matrix_iset(y, j, 0, matrix_iget( A, i, j ) ); \n        } \n \n        stepwise_set_Y0( stepwise_data, y ); \n \n          stepwise_estimate(stepwise_data, r2_limit, nfolds ); \n \n         \n \n        for (int j = 0; j < ens_size; j++) { \n          for (int k = 0; k < nd; k++) { \n            matrix_iset(di, 0, k, matrix_iget( D, k, j ) ); \n          } \n          double aij = matrix_iget( A, i, j ); \n          double xHat = stepwise_eval(stepwise_data, di ); \n          matrix_iset(A, i, j, aij + xHat); \n        } \n \n        if (verbose){ \n          int loc_ind = int_vector_iget(local_index_list, i ); \n          if (all_active) \n            active_index = loc_ind; \n          else \n            active_index = active_indices[loc_ind]; \n \n          fwd_step_enkf_write_iter_info(fwd_step_data, stepwise_data, key, active_index, i, module_info); \n \n        } \n \n          stepwise_free( stepwise_data ); \n      } \n \n      if (verbose) \n       printf(\"===============================================================================================================================\\n\"); \n \n      printf(\"Done with stepwise regression enkf\\n\"); \n \n \n      matrix_free( di ); \n      int_", "pred": " \nvoid fwd_step_enkf_updateA(void * module_data, \n                           matrix_type * A, \n                           matrix_type * S, \n                           matrix_type * R, \n                           matrix_type * dObs, \n                           matrix_type * E, \n                           matrix_type * D, \n                           const module_info_type* module_info) { \n \n \n \n  fwd_step_enkf_data_type * fwd_step_data = fwd_step_enkf_data_safe_cast( module_data ); \n  fwd_step_data->A = A; \n  fwd_step_data->S = S; \n  fwd_step_data->R = R; \n  fwd_step_data->dObs = dObs; \n  fwd_step_data->E = E; \n  fwd_step_data->D = D; \n  fwd_step_data->module_info = module_info; \n  fwd_step_data->n_steps = 0; \n  fwd_step_data->n_steps_max = 0; \n  fwd_step_data->n_steps_min = 0; \n  fwd_step_data->n_steps_avg = 0; \n  fwd_step_data->n_steps_avg_max = 0; \n  fwd_step_data->n_steps_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg = 0; \n  fwd_step_data->n_steps_avg_avg_max = 0; \n  fwd_step_data->n_steps_avg_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg_avg = 0; \n  fwd_step_data->n_steps_avg_avg_avg_max = 0; \n  fwd_step_data->n_steps_avg_avg_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_max = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_max = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_max = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_max = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_max = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_max = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_max = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_max = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_max = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_max = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_max = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_max = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_max = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_min = 0; \n  fwd_step_data->n_steps_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg_avg = 0; \n  fwd_step_data->n_steps_avg"}
{"label": " \nvoid LLG_inplane_evolve(double *mag, double *mag_new, double dt) { \n    int i, j, n; \n\t{ \n\tfor(i=1;i<=Nx;i++) \n\t\tfor(j=1;j<=Ny;j++) { \n \n\t\t\tdouble beff[3] = {0., 0., bapp}; \n\t\t\tdouble magxbeff[3], magxmagxbeff[3], rhs[3]; \n\t\t\t \n\t\t\tadd_exchange(mag, i, j, beff); \n \n \n \n \n \n\t\t\tadd_anisotropy_z(mag, i, j, beff);\t\t\t \n\t\t\t \n\t\t\t \n \n\t\t\t \n \n\t\t\tadd_DMI_renorm_J0value(mag, i, j, beff); \n\t\t\t \n\t\t\tcross(&mag[ind(i,j)], beff, magxbeff); \n\t\t\tcross(&mag[ind(i,j)], magxbeff, magxmagxbeff); \n \n\t\t\tdouble tsst[3], magxtsst[3]; \n\t\t\tsst_torque_inplane(mag, i, j, jx, jy, tsst);\t\t\t \n\t\t\tcross(&mag[ind(i,j)],tsst,magxtsst); \n \n\t\t\tfor(n=0;n<3;n++) \n\t\t\t\trhs[n] = - magxbeff[n] - alpha*magxmagxbeff[n] + tsst[n] + alpha*magxtsst[n]; \n \n\t\t\tdouble mx = mag[ind(i,j)]; \n\t\t\tdouble my = mag[ind(i,j)+1];\t\t\t\t\t\t\t\t\t \n\t\t\tdouble mz = mag[ind(i,j)+2]; \n\t\t\tdouble Z = rhs[2]/(1.+alpha2*mz*mz); \n\t\t\trhs[0] += -alpha*my*Z - alpha2*mx*mz*Z; \n\t\t\trhs[1] += alpha*mx*Z - alpha2*my*mz*Z; \n\t\t\trhs[2] = (1.+alpha2)*Z; \n\t\t\t \n\t\t\tfor(n=0;n<3;n++) \n\t\t\t\tmag_new[ind(i,j)+n] = mag[ind(i,j)+n] + dt*rhs[n]; \n\t\t} \n    } \n} ", "pred": " \nvoid LLG_inplane_evolve(double *mag, double *mag_new, double dt) { \n    int i, j, n; \n\t{ \n\tfor(i=1;i<=Nx;i++) \n\t\tfor(j=1;j<=Ny;j++) { \n \n\t\t\tdouble beff[3] = {0., 0., bapp}; \n\t\t\tdouble magxbeff[3], magxmagxbeff[3], rhs[3]; \n\t\t\t \n\t\t\tadd_exchange(mag, i, j, beff); \n \n \n \n \n \n\t\t\tadd_anisotropy_z(mag, i, j, beff);\t\t\t \n\t\t\t \n\t\t\t \n \n\t\t\t \n \n\t\t\tadd_DMI_renorm_J0value(mag, i, j, beff); \n\t\t\t \n\t\t\tcross(&mag[ind(i,j)], beff, magxbeff); \n\t\t\tcross(&mag[ind(i,j)], magxbeff, magxmagxbeff); \n \n\t\t\tdouble tsst[3], magxtsst[3]; \n\t\t\tsst_torque_inplane(mag, i, j, jx, jy, tsst);\t\t\t \n\t\t\tcross(&mag[ind(i,j)],tsst,magxtsst); \n \n\t\t\tfor(n=0;n<3;n++) { \n\t\t\t\trhs[n] = magxbeff[n] + magxtsst[n]; \n\t\t\t} \n \n\t\t\tadd_DMI_renorm_J0value(rhs, i, j, rhs); \n \n\t\t\tfor(n=0;n<3;n++) { \n\t\t\t\tmag[ind(i,j)] += rhs[n]; \n\t\t\t} \n \n\t\t\tadd_DMI_renorm_J0value(mag, i, j, mag); \n \n\t\t\tfor(n=0;n<3;n++) { \n\t\t\t\tmag_new[ind(i,j)] += rhs[n]; \n\t\t\t} \n \n\t\t\tadd_DMI_renorm_J0value(mag_new, i, j, mag_new); \n \n\t\t\tfor(n=0;n<3;n++) { \n\t\t\t\tmag_new[ind(i,j)] += magxbeff[n]; \n\t\t\t} \n \n\t\t\tadd_DMI_renorm_J0value(mag_new,"}
{"label": " \nvoid producer_consumer_parallel(int *buffer, int size, int *vec, int n, int nThreads ) \n{ \n\tint i, j; \n\tlong long unsigned int sum = 0; \n    double tstart, tend, duration; \n \n    tstart = omp_get_wtime(); \n \n     \n \n     \n \n     \n \n     \n \n \n\tfor(i=0;i<n;i++)  \n    { \n\t\tif(i % 2 == 0) \n        {\t \n \n \n             \n \n             \n \n             \n \n \n\t\t\tfor(j=0;j<size;j++) \n            { \n\t\t\t\tbuffer[j] = vec[i] + j*vec[i+1]; \n\t\t\t} \n\t\t} \n\t\telse \n        {\t \n \n \n \n\t\t\tfor(j=0;j<size;j++) \n            { \n\t\t\t\tsum += buffer[j]; \n\t\t\t} \n\t\t} \n\t} \n    tend = omp_get_wtime(); \n    duration = tend - tstart; \n \n\tprintf(\"%llu\\n%lf\\n\",sum,duration); \n} \n \nvoid pr ", "pred": " \nvoid producer_consumer_parallel(int *buffer, int size, int *vec, int n, int nThreads ) \n{ \n\tint i, j; \n\tlong long unsigned int sum = 0; \n    double tstart, tend, duration; \n \n    tstart = omp_get_wtime(); \n \n     \n \n     \n \n     \n \n     \n \n \n\tfor(i=0;i<n;i++)  \n    { \n\t\tif(i % 2 == 0) \n        {\t \n \n \n             \n \n             \n \n             \n \n \n\t\t\tfor(j=0;j<size;j++) \n            { \n\t\t\t\tbuffer[j] = vec[i] + j*vec[i+1]; \n\t\t\t} \n\t\t} \n\t\telse \n        {\t \n \n \n \n\t\t\tfor(j=0;j<size;j++) \n            { \n\t\t\t\tsum += buffer[j]; \n\t\t\t} \n\t\t} \n        \n             \n             \n             \n       "}
{"label": " \nvoid dt_bilateral_slice(const dt_bilateral_t *const b, const float *const in, float *out, const float detail) \n{ \n   \n \n  const float norm = -detail * b->sigma_r * 0.04f; \n  const int ox = 1; \n  const int oy = b->size_x; \n  const int oz = b->size_y * b->size_x; \n \n  float *const buf = b->buf; \n  const int size_x = b->size_x; \n  const int size_y = b->size_y; \n  const int size_z = b->size_z; \n  const int width = b->width; \n  const int height = b->height; \n \n  for(int j = 0; j < height; j++) \n  { \n    for(int i = 0; i < width; i++) \n    { \n      size_t index = 4 * (j * width + i); \n      float x, y, z; \n      const float L = in[index]; \n      image_to_grid(b, i, j, L, &x, &y, &z); \n       \n \n      const int xi = MIN((int)x, size_x - 2); \n      const int yi = MIN((int)y, size_y - 2); \n      const int zi = MIN((int)z, size_z - 2); \n      const float xf = x - xi; \n      const float yf = y - yi; \n      const float zf = z - zi; \n      const size_t gi = xi + size_x * (yi + size_y * zi); \n      const float Lout = L \n                         + norm * (buf[gi] * (1.0f - xf) * (1.0f - yf) * (1.0f - zf) \n                                   + buf[gi + ox] * (xf) * (1.0f - yf) * (1.0f - zf) \n                                   + buf[gi + oy] * (1.0f - xf) * (yf) * (1.0f - zf) \n                                   + buf[gi + ox + oy] * (xf) * (yf) * (1.0f - zf) \n                                   + buf[gi + oz] * (1.0f - xf) * (1.0f - yf) * (zf) \n                                   + buf[gi + ox + oz] * (xf) * (1.0f - yf) * (zf) \n                                   + buf[gi + oy + oz] * (1.0f - xf) * (yf) * (zf) \n                                   + buf[gi + ox + oy + oz] * (xf) * (yf) * (zf)); \n      out[index] = Lout; \n       \n \n      out[index + 1] = in[index + 1]; \n      out[index + 2] = in[index + 2]; \n      out[index + 3] = in[index + 3]; \n    } \n  } \n} ", "pred": " \nvoid dt_bilateral_slice(const dt_bilateral_t *const b, const float *const in, float *out, const float detail) \n{ \n   \n \n  const float norm = -detail * b->sigma_r * 0.04f; \n  const int ox = 1; \n  const int oy = b->size_x; \n  const int oz = b->size_y * b->size_x; \n \n  float *const buf = b->buf; \n  const int size_x = b->size_x; \n  const int size_y = b->size_y; \n  const int size_z = b->size_z; \n  const int width = b->width; \n  const int height = b->height; \n \n  for(int j = 0; j < height; j++) \n  { \n    for(int i = 0; i < width; i++) \n    { \n      size_t index = 4 * (j * width + i); \n      float x, y, z; \n      const float L = in[index]; \n      image_to_grid(b, i, j, L, &x, &y, &z); \n      const float L_x = x - ox; \n      const float L_y = y - oy; \n      const float L_z = z - oz; \n      const float L_r = L_x * L_x + L_y * L_y + L_z * L_z; \n      const float L_r_sq = L_r * L_r; \n      const float L_r_inv = 1.0f / L_r; \n      const float L_r_sq_inv = L_r_sq * L_r_sq; \n      const float L_r_inv_sq = L_r_sq_inv * L_r_sq_inv; \n      const float L_r_inv_inv = 1.0f / L_r_inv; \n      const float L_r_inv_sq_inv = L_r_inv_sq * L_r_inv_inv; \n      const float L_r_inv_inv_sq = L_r_inv_inv * L_r_inv_inv; \n      const float L_r_inv_inv_inv = 1.0f / L_r_inv_inv; \n      const float L_r_inv_sq_inv_inv = L_r_inv_inv_sq * L_r_inv_inv_inv; \n      const float L_r_inv_inv_inv_sq = L_r_inv_inv_inv * L_r_inv_inv_inv; \n      const float L_r_inv_inv_inv_inv = 1.0f / L_r_inv_inv_inv; \n      const float L_r_inv_sq_inv_inv_inv = L_r_inv_inv_sq_inv * L_r_inv_inv_inv_inv; \n      const float L_r_inv_inv_inv_inv_sq = L_r_inv_inv_inv_inv * L_r_inv_inv_inv_inv; \n      const float L_r_inv_inv_inv_inv_inv = 1.0f / L_r_inv_inv_inv_inv; \n      const float L_r_inv_sq_inv_inv_inv_inv = L_r_inv_inv_sq_inv_inv * L_r_inv_inv_inv_inv; \n      const float L_r_inv_inv_inv_inv_inv_sq = L_r_inv_inv_inv_inv * L_r_inv_inv_inv_inv; \n      const float L_r_inv_inv_inv_inv_inv_inv = 1.0f / L_r_inv_inv_inv_inv; \n      const float L_r_inv_sq_inv_inv_inv_inv_inv = L_r_inv_inv_sq_inv_inv * L_r_inv_inv_inv_inv; \n   "}
{"label": " \nstatic void createPreMarkers(RoadMapArray * rdmaps, PreGraph * preGraph, \n\t\t\t    IDnum * chains) \n{ \n\tIDnum sequenceIndex; \n\tIDnum referenceCount = rdmaps->referenceCount; \n\tAnnotation *annot = rdmaps->annotations; \n \n\tint threads = omp_get_max_threads(); \n\tif (threads > 8) \n\t\tthreads = 8; \n \n\tfor (sequenceIndex = 1; \n\t     sequenceIndex <= referenceCount; \n\t     sequenceIndex++) { \n\t\tAnnotation *annot = getAnnotationInArray(rdmaps->annotations, annotationOffset[sequenceIndex - 1]); \n\t\tRoadMap *rdmap; \n\t\tCoordinate currentPosition, currentInternalPosition; \n\t\tIDnum currentPreNodeID, nextInternalPreNodeID; \n\t\tIDnum annotIndex, lastAnnotIndex; \n\t\tPreMarker * previous; \n \n\t\tif (sequenceIndex % 1000000 == 0) \n\t\t\tvelvetLog(\"Connecting %li / %li\\n\", (long) sequenceIndex, \n\t\t\t       (long) sequenceCount_pg(preGraph)); \n \n\t\trdmap = getRoadMapInArray(rdmaps, sequenceIndex - 1); \n\t\tannotIndex = 0; \n\t\tlastAnnotIndex = getAnnotationCount(rdmap); \n\t\tnextInternalPreNodeID = chooseNextInternalPreNode \n\t\t    (chains[sequenceIndex] - 1, sequenceIndex, \n\t\t     preGraph, chains); \n \n\t\tprevious = NULL; \n\t\tcurrentPosition = 0; \n\t\tcurrentInternalPosition = 0; \n\t\tcurrentPreNodeID = 0; \n\t\t \n \n\t\twhile (annotIndex < lastAnnotIndex \n\t\t       || nextInternalPreNodeID!= 0) { \n\t\t\tif (annotIndex == lastAnnotIndex \n\t\t\t    || (nextInternalPreNodeID!= 0 \n\t\t\t\t&& currentInternalPosition < \n\t\t\t\tgetPosition(annot))) { \n\t\t\t\tlockNode(nextInternalPreNodeID); \n\t\t\t\tprevious = addPreMarker_pg(preGraph,  \n\t\t\t\t\t\tnextInternalPreNodeID, \n\t\t\t\t\t\tsequenceIndex, \n\t\t\t\t\t\t&currentPosition, \n\t\t\t\t\t\tprevious); \n\t\t\t\tunLockNode(nextInternalPreNodeID); \n\t\t\t\tcurrentPreNodeID = nextInternalPreNodeID; \n\t\t\t\tnextInternalPreNodeID = \n\t\t\t\t    chooseNextInternalPreNode \n\t\t\t\t    (currentPreNodeID, sequenceIndex, \n\t\t\t\t     preGraph, chains); \n\t\t\t\tcurrentInternalPosition += \n\t\t\t\t    getPreNodeLength_pg(currentPreNodeID, \n\t\t\t\t\t\t\tpreGraph); \n \n\t\t\t} else { \n\t\t\t\treConnectAnnotation(&currentPreNodeID, annot, \n\t\t\t\t\t\t  &currentPosition, \n\t\t\t\t\t\t  sequenceIndex,  \n\t\t\t\t\t\t  preGraph, \n\t\t\t\t\t\t  &previous); \n\t\t\t\tannot = getNextAnnotation(annot); \n\t\t\t\tannotIndex++; \n\t\t\t} \n\t\t} \n\t} \n} ", "pred": " \nstatic void createPreMarkers(RoadMapArray * rdmaps, PreGraph * preGraph, \n\t\t\t    IDnum * chains) \n{ \n\tIDnum sequenceIndex; \n\tIDnum referenceCount = rdmaps->referenceCount; \n\tAnnotation *annot = rdmaps->annotations; \n \n\tint threads = omp_get_max_threads(); \n\tif (threads > 8) \n\t\tthreads = 8; \n \n\tfor (sequenceIndex = 1; \n\t     sequenceIndex <= referenceCount; \n\t     sequenceIndex++) { \n\t\tAnnotation *annot = getAnnotationInArray(rdmaps->annotations, annotationOffset[sequenceIndex - 1]); \n\t\tRoadMap *rdmap; \n\t\tCoordinate currentPosition, currentInternalPosition; \n\t\tIDnum currentPreNodeID, nextInternalPreNodeID; \n\t\tIDnum annotIndex, lastAnnotIndex; \n\t\tPreMarker * previous; \n \n\t\tif (sequenceIndex % 1000000 == 0) \n\t\t\tvelvetLog(\"Connecting %li / %li\\n\", (long) sequenceIndex, \n\t\t\t       (long) sequenceCount_pg(preGraph)); \n \n\t\trdmap = getRoadMapInArray(rdmaps, sequenceIndex - 1); \n\t\tannotIndex = 0; \n\t\tlastAnnotIndex = getAnnotationCount(rdmap->annotations); \n \n\t\tfor (annotIndex = 1; \n\t\t     annotIndex <= lastAnnotIndex; \n\t\t     annotIndex++) { \n\t\t\tif (annotIndex % 1000000 == 0) \n\t\t\t\tvelvetLog(\"Annot %li / %li\\n\", (long) annotIndex, \n\t\t\t\t       (long) lastAnnotIndex); \n \n\t\t\tcurrentPosition = getAnnotationPosition(rdmap->annotations, annotIndex); \n\t\t\tcurrentInternalPosition = getAnnotationInternalPosition(rdmap->annotations, annotIndex); \n\t\t\tcurrentPreNodeID = getAnnotationPreNodeID(rdmap->annotations, annotIndex); \n\t\t\tnextInternalPreNodeID = getAnnotationNextInternalPreNodeID(rdmap->annotations, annotIndex); \n \n\t\t\tif (currentPreNodeID == -1) \n\t\t\t\tcontinue; \n \n\t\t\tif (currentPreNodeID == nextInternalPreNodeID) { \n\t\t\t\tif (currentPosition == currentInternalPosition) { \n\t\t\t\t\tif (currentPreNodeID == -1) \n\t\t\t\t\t\tcontinue; \n \n\t\t\t\t\tif (preGraph->preMarkerArray[currentPreNodeID].preMarker == NULL) { \n\t\t\t\t\t\tpreGraph->preMarkerArray[currentPreNodeID].preMarker = \n\t\t\t\t\t\t\t(PreMarker *) malloc(sizeof(PreMarker)); \n\t\t\t\t\t\tpreGraph->preMarkerArray[currentPreNodeID].preMarker->preMarkerID = \n\t\t\t\t\t\t\tcurrentPreNodeID; \n\t\t\t\t\t\tpreGraph->preMarkerArray[currentPreNodeID].preMarker->preMarkerPosition = \n\t\t\t\t\t\t\tcurrentPosition; \n\t\t\t\t\t\tpreGraph->preMarkerArray[currentPreNodeID].preMarker->preMarkerInternalPosition = \n\t\t\t\t\t\t\tcurrentInternalPosition"}
{"label": " \nvoid prefix_sums(attr_id_t *input, attr_id_t* result, attr_id_t* p, attr_id_t n) { \n \n    attr_id_t i, j, r, start, end, add_value; \n    int tid, nthreads; \n \n    tid = omp_get_thread_num(); \n    nthreads = omp_get_num_threads(); \n    r = n/nthreads; \n \n    result[0] = 0; \n \n    for (i=1; i<n+1; i++) \n        result[i] = input[i-1]; \n \n    start =  tid*r + 1; \n    end   = (tid+1)*r; \n \n    if (tid == nthreads-1) \n        end = n+1; \n \n    for (j=start; j<end; j++) \n        result[j] = input[j-1] + result[j-1]; \n \n    p[tid] = result[end-1]; \n \n \n    if (tid == 0) { \n        for (j=1; j<nthreads; j++) \n            p[j] += p[j-1]; \n    } \n \n \n    if (tid>0) { \n        add_value=p[tid-1]; \n        for (j=start-1; j<end; j++) \n            result[j] += add_value; \n    } \n \n \n    attr_id_t i; \n    result[0] = 0; \n    for (i=1; i<n+1; i++) { \n        result[i] = result[i-1] + input[i-1]; \n    } \n \n} ", "pred": " \nvoid prefix_sums(attr_id_t *input, attr_id_t* result, attr_id_t* p, attr_id_t n) { \n \n    attr_id_t i, j, r, start, end, add_value; \n    int tid, nthreads; \n \n    tid = omp_get_thread_num(); \n    nthreads = omp_get_num_threads(); \n    r = n/nthreads; \n \n    result[0] = 0; \n \n    for (i=1; i<n+1; i++) \n        result[i] = input[i-1]; \n \n    start =  tid*r + 1; \n    end   = (tid+1)*r; \n \n    if (tid == nthreads-1) \n        end = n+1; \n \n    for (j=start; j<end; j++) \n        result[j] = input[j-1] + result[j-1]; \n \n    p[tid] = result[end-1]; \n \n \n    if (tid == 0) { \n        for (i=1; i<n+1; i++) \n            result[i] = result[i-1]; \n \n        for (i=1; i<n+1; i++) \n            result[i] = result[i-1]; \n \n        result[n+1] = 0; \n    } \n \n    for (i=1; i<n+1; i++) \n        result[i] = result[i-1]; \n \n    for (i=1; i<n+1; i++) \n        result[i] = result[i-1]; \n \n    for (i=1; i<n+1;"}
{"label": " \nvoid test_two(int x) { \n  for (int i = 0; i < x; i++) \n    ; \n} ", "pred": " \nvoid test_two(int x) { \n  for (int i = 0; i < x; i++) \n    ; \n} "}
{"label": " \nstatic PyObject *py_gibbs_ibm_sample_parallel(PyObject *self, PyObject *args) { \n    PyObject *eee, *fff, *counts_idx_arrays, *dists_arrays, *params; \n    PyArrayObject *seed_array; \n    int model, n_iterations; \n    double null_prior; \n \n    if(!PyArg_ParseTuple(args, \"iiOOOOOdO\", \n        &n_iterations, &model, &eee, &fff, &dists_arrays, &counts_idx_arrays, \n        &params, &null_prior, &seed_array)) \n        return NULL; \n \n    const size_t n_sents = PyTuple_Size(eee); \n    const size_t n_samplers = PyTuple_Size(params); \n \n    PRNG_SEED_t *seed = (PRNG_SEED_t*) PyArray_GETPTR1(seed_array, 0); \n    PRNG_SEED_t local_seeds[n_samplers]; \n    for (size_t sampler=0; sampler<n_samplers; sampler++) \n        local_seeds[sampler] = prng_next(*seed + 1 + sampler); \n    *seed = prng_next(*seed); \n \n    for (size_t iteration=0; iteration<n_iterations; iteration++) { \n        fputc('.', stderr); \n        fflush(stderr); \n        for (size_t sampler=0; sampler<n_samplers; sampler++) { \n             \n \n            if (iteration > n_iterations-n_samplers+sampler) continue; \n \n             \n \n             \n \n             \n \n             \n \n            const int add_sample = (dists_arrays!= Py_None) && \n                                   ((iteration % n_samplers) == sampler); \n \n             \n \n             \n \n            PRNG_SEED_t seed_cache = local_seeds[sampler]; \n \n            PyObject *sampler_params = PyTuple_GET_ITEM(params, sampler); \n \n            PyObject *aaa = PyTuple_GET_ITEM(sampler_params, 0); \n            PyArrayObject *counts_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 1); \n            PyArrayObject *counts_sum_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 2); \n            PyArrayObject *jump_counts_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 3); \n            PyArrayObject *fert_counts_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 4); \n \n            COUNT_t *counts_sum = \n                 (COUNT_t*) PyArray_GETPTR1(counts_sum_array, 0); \n            COUNT_t *counts = (COUNT_t*) PyArray_GETPTR1(counts_array, 0); \n            COUNT_t *jump_counts = ((PyObject*)jump_counts_array == Py_None) \n               ? NULL \n                : PyArray_GETPTR1(jump_counts_array, 0); \n            COUNT_t *fert_counts = ((PyObject*)fert_counts_array == Py_None) \n               ? NULL \n                : PyArray_GETPTR1(fert_counts_array, 0); \n \n             \n \n             \n \n            if (fert_counts!= NULL) { \n                const size_t e_size = \n                      PyArray_SIZE(fert_counts_array) / FERT_ARRAY_LEN; \n                 \n \n                 \n \n                 \n \n                 \n \n                 \n \n                for (size_t i=0; i<e_size*FERT_ARRAY_LEN; i++) \n                    fert_counts[i] = (COUNT_t) 1.0; \n \n                 \n \n                for (size_t sent=0; sent<n_sents; sent++) { \n                    PyArrayObject *ee_array = \n                        (PyArrayObject*) PyTuple_GET_ITEM(eee, sent); \n                    PyArrayObject *ff_array = \n                        (PyArrayObject*) PyTuple_GET_ITEM(fff, sent); \n                    const size_t ee_len = (size_t) PyArray_DIM(ee_array, 0); \n                    const size_t ff_len = (size_t) PyArray_DIM(ff_array, 0); \n \n                    if (ee_len == 0 || ff_len == 0) continue; \n \n                    PyArrayObject *aa_array = \n                        (PyArrayObject*) PyTuple_GET_ITEM(aaa, sent); \n \n                    const TOKEN_t *ee = \n                        (const TOKEN_t*) PyArray_GETPTR1(ee_array, 0); \n                    LINK_t *aa = (LINK_t*) PyArray_GETPTR1(aa_array, 0); \n                    int fert[ee_len]; \n                    for (size_t i=0; i<ee_len; i++) \n                        fert[i] = 0; \n ", "pred": " \nstatic PyObject *py_gibbs_ibm_sample_parallel(PyObject *self, PyObject *args) { \n    PyObject *eee, *fff, *counts_idx_arrays, *dists_arrays, *params; \n    PyArrayObject *seed_array; \n    int model, n_iterations; \n    double null_prior; \n \n    if(!PyArg_ParseTuple(args, \"iiOOOOOdO\", \n        &n_iterations, &model, &eee, &fff, &dists_arrays, &counts_idx_arrays, \n        &params, &null_prior, &seed_array)) \n        return NULL; \n \n    const size_t n_sents = PyTuple_Size(eee); \n    const size_t n_samplers = PyTuple_Size(params); \n \n    PRNG_SEED_t *seed = (PRNG_SEED_t*) PyArray_GETPTR1(seed_array, 0); \n    PRNG_SEED_t local_seeds[n_samplers]; \n    for (size_t sampler=0; sampler<n_samplers; sampler++) \n        local_seeds[sampler] = seed[sampler]; \n \n    double *prior = (double*) PyArray_GETPTR1(dists_arrays, 0); \n    double *prior_dist = (double*) PyArray_GETPTR1(dists_arrays, 1); \n    double *prior_dist_idx = (double*) PyArray_GETPTR1(dists_arrays, 2); \n    double *prior_dist_idx_dist = (double*) PyArray_GETPTR1(dists_arrays, 3); \n    double *prior_dist_idx_dist_idx = (double*) PyArray_GETPTR1(dists_arrays, 4); \n    double *prior_dist_idx_dist_idx_dist = (double*) PyArray_GETPTR1(dists_arrays, 5); \n \n    double *prior_dist_idx_dist_idx_dist_idx = (double*) PyArray_GETPTR1(dists_arrays, 6); \n    double *prior_dist_idx_dist_idx_dist_idx_dist = (double*) PyArray_GETPTR1(dists_arrays, 7); \n \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx = (double*) PyArray_GETPTR1(dists_arrays, 8); \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist = (double*) PyArray_GETPTR1(dists_arrays, 9); \n \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx = (double*) PyArray_GETPTR1(dists_arrays, 10); \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist = (double*) PyArray_GETPTR1(dists_arrays, 11); \n \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx = (double*) PyArray_GETPTR1(dists_arrays, 12); \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist = (double*) PyArray_GETPTR1(dists_arrays, 13); \n \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx = (double*) PyArray_GETPTR1(dists_arrays, 14); \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist = (double*) PyArray_GETPTR1(dists_arrays, 15); \n \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx = (double*) PyArray_GETPTR1(dists_arrays, 16); \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist = (double*) PyArray_GETPTR1(dists_arrays, 17); \n \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx = (double*) PyArray_GETPTR1(dists_arrays, 18); \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist = (double*) PyArray_GETPTR1(dists_arrays, 19); \n \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist = (double*) PyArray_GETPTR1(dists_arrays, 20); \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx = (double*) PyArray_GETPTR1(dists_arrays, 21); \n \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx = (double*) PyArray_GETPTR1(dists_arrays, 22); \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist = (double*) PyArray_GETPTR1(dists_arrays, 23); \n \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist = (double*) PyArray_GETPTR1(dists_arrays, 24); \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx = (double*) PyArray_GETPTR1(dists_arrays, 25); \n \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx = (double*) PyArray_GETPTR1(dists_arrays, 26); \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist = (double*) PyArray_GETPTR1(dists_arrays, 27); \n \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx = (double*) PyArray_GETPTR1(dists_arrays, 28); \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist = (double*) PyArray_GETPTR1(dists_arrays, 29); \n \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx = (double*) PyArray_GETPTR1(dists_arrays, 30); \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist = (double*) PyArray_GETPTR1(dists_arrays, 31); \n \n    double *prior_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx_dist_idx = (double*) PyArray_GETPTR1(d"}
{"label": " \nstatic void connectPreNodes(RoadMapArray * rdmaps, PreGraph * preGraph, \n\t\t\t    IDnum * chains) \n{ \n\tIDnum sequenceIndex; \n\tIDnum referenceCount = rdmaps->referenceCount; \n\tannotationOffset = mallocOrExit(rdmaps->length + 1, Coordinate); \n\tannotationOffset[0] = 0; \n\tfor (sequenceIndex = 1; sequenceIndex <= rdmaps->length; sequenceIndex++) \n\t\tannotationOffset[sequenceIndex] = annotationOffset[sequenceIndex - 1] + \n\t\t\t\t\t\t  getAnnotationCount(getRoadMapInArray(rdmaps, sequenceIndex - 1)); \n\tAnnotation *annot = rdmaps->annotations; \n \n\tif (rdmaps->referenceCount > 0)  \n\t\tallocatePreMarkerCountSpace_pg(preGraph); \n \n\tint threads = omp_get_max_threads(); \n\tif (threads > 8) \n\t\tthreads = 8; \n \n\tfor (sequenceIndex = 1; \n\t     sequenceIndex <= sequenceCount_pg(preGraph); \n\t     sequenceIndex++) { \n\t\tAnnotation *annot = getAnnotationInArray(rdmaps->annotations, annotationOffset[sequenceIndex - 1]); \n\t\tRoadMap *rdmap; \n\t\tCoordinate currentPosition, currentInternalPosition; \n\t\tIDnum currentPreNodeID, nextInternalPreNodeID; \n\t\tIDnum annotIndex, lastAnnotIndex; \n\t\tboolean isReference; \n \n\t\tif (sequenceIndex % 1000000 == 0) \n\t\t\tvelvetLog(\"Connecting %li / %li\\n\", (long) sequenceIndex, \n\t\t\t       (long) sequenceCount_pg(preGraph)); \n \n\t\trdmap = getRoadMapInArray(rdmaps, sequenceIndex - 1); \n\t\tannotIndex = 0; \n\t\tlastAnnotIndex = getAnnotationCount(rdmap); \n\t\tnextInternalPreNodeID = chooseNextInternalPreNode \n\t\t    (chains[sequenceIndex] - 1, sequenceIndex, \n\t\t     preGraph, chains); \n\t\tisReference = (sequenceIndex <= referenceCount); \n \n\t\tcurrentPosition = 0; \n\t\tcurrentInternalPosition = 0; \n\t\tcurrentPreNodeID = 0; \n\t\t \n \n\t\twhile (annotIndex < lastAnnotIndex \n\t\t       || nextInternalPreNodeID!= 0) { \n\t\t\tif (annotIndex == lastAnnotIndex \n\t\t\t    || (nextInternalPreNodeID!= 0 \n\t\t\t\t&& currentInternalPosition < \n\t\t\t\tgetPosition(annot))) { \n\t\t\t\tconnectPreNodeToTheNext(&currentPreNodeID, \n\t\t\t\t\t\t\tnextInternalPreNodeID, \n\t\t\t\t\t\t\t&currentPosition, \n\t\t\t\t\t\t\tsequenceIndex, \n\t\t\t\t\t\t\tisReference, \n\t\t\t\t\t\t\tpreGraph); \n\t\t\t\tnextInternalPreNodeID = \n\t\t\t\t    chooseNextInternalPreNode \n\t\t\t\t    (currentPreNodeID, sequenceIndex, \n\t\t\t\t     preGraph, chains); \n\t\t\t\tcurrentInternalPosition += \n\t\t\t\t    getPreNodeLength_pg(currentPreNodeID, \n\t\t\t\t\t\t\tpreGraph); \n \n\t\t\t} else { \n\t\t\t\tconnectAnnotation(&currentPreNodeID, annot, \n\t\t\t\t\t\t  &currentPosition, \n\t\t\t\t\t\t  sequenceIndex, isReference, \n\t\t\t\t\t\t  preGraph); \n\t\t\t\tannot = getNextAnnotation(annot); \n\t\t\t\tannotIndex++; \n\t\t\t} \n\t\t} \n\t} \n \n\tif (rdmaps->referenceCount > 0) { \n\t\tallocatePreMarkerSpace_pg(preGraph); \n\t\tcreatePreMarkers(rdmaps, preGraph, chains);\t \n\t} \n \n\tfree(annotationOffset); \n\tannotationOffset = NULL; \n} ", "pred": " \nstatic void connectPreNodes(RoadMapArray * rdmaps, PreGraph * preGraph, \n\t\t\t    IDnum * chains) \n{ \n\tIDnum sequenceIndex; \n\tIDnum referenceCount = rdmaps->referenceCount; \n\tannotationOffset = mallocOrExit(rdmaps->length + 1, Coordinate); \n\tannotationOffset[0] = 0; \n\tfor (sequenceIndex = 1; sequenceIndex <= rdmaps->length; sequenceIndex++) \n\t\tannotationOffset[sequenceIndex] = annotationOffset[sequenceIndex - 1] + \n\t\t\t\t\t\t  getAnnotationCount(getRoadMapInArray(rdmaps, sequenceIndex - 1)); \n\tAnnotation *annot = rdmaps->annotations; \n \n\tif (rdmaps->referenceCount > 0)  \n\t\tallocatePreMarkerCountSpace_pg(preGraph); \n \n\tint threads = omp_get_max_threads(); \n\tif (threads > 8) \n\t\tthreads = 8; \n \n\tfor (sequenceIndex = 1; \n\t     sequenceIndex <= sequenceCount_pg(preGraph); \n\t     sequenceIndex++) { \n\t\tAnnotation *annot = getAnnotationInArray(rdmaps->annotations, annotationOffset[sequenceIndex - 1]); \n\t\tRoadMap *rdmap; \n\t\tCoordinate currentPosition, currentInternalPosition; \n\t\tIDnum currentPreNodeID; \n\t\tint currentPreNodeCount; \n\t\tint currentPreNodeCount_pg; \n\t\tint currentPreNodeCount_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg_pg_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg_pg_pg_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg_pg_pg_pg_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg_pg_pg_pg_pg_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg; \n\t\tint currentPreNodeCount_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg_pg; \n\t\tint currentPreNodeCount"}
{"label": "void DeblockPicture(VideoParameters *p_Vid, StorablePicture *p) \n{ \n  int iheightMBs =(p_Vid->PicSizeInMbs/p_Vid->PicWidthInMbs); \n  unsigned int i, k = p->PicWidthInMbs + 2 * (iheightMBs - 1); \n   \n  for (i = 0; i < k; i++) \n  { \n    int nn;     \n    int n_last = imin(iheightMBs, (i >> 1) + 1); \n    int n_start = (i < p->PicWidthInMbs)? 0 : ((i - p->PicWidthInMbs) >> 1) + 1; \n \n    for (nn = n_start; nn < n_last; nn += GROUP_SIZE) \n      DeblockParallel(p_Vid, p, i, nn, n_last); \n  } \n} \n ", "pred": "void DeblockPicture(VideoParameters *p_Vid, StorablePicture *p) \n{ \n  int iheightMBs =(p_Vid->PicSizeInMbs/p_Vid->PicWidthInMbs); \n  unsigned int i, k = p->PicWidthInMbs + 2 * (iheightMBs - 1); \n   \n  for (i = 0; i < k; i++) \n  { \n    int nn;     \n    int n_last = imin(iheightMBs, (i >> 1) + 1); \n    int n_start = (i < p->PicWidthInMbs)? 0 : ((i - p->PicWidthInMbs) >> 1) + 1; \n \n    for (nn = n_start; nn < n_last; nn += GROUP_SIZE) \n      DeblockParallel(p_Vid, p, i, nn, n_last); \n  } \n} \n "}
{"label": " \nstatic void blur_line(float *buf, const int offset1, const int offset2, const int offset3, const int size1, \n                      const int size2, const int size3) \n{ \n  const float w0 = 6.f / 16.f; \n  const float w1 = 4.f / 16.f; \n  const float w2 = 1.f / 16.f; \n  for(int k = 0; k < size1; k++) \n  { \n    for(int j = 0; j < size2; j++) \n    { \n      size_t index = (size_t)k * offset1 + j * offset2; \n      float tmp1 = buf[index]; \n      buf[index] = buf[index] * w0 + w1 * buf[index + offset3] + w2 * buf[index + 2 * offset3]; \n \n       \n \n \n      float tmp2 = buf[index + offset3]; \n      buf[index + offset3] = buf[index + offset3] * w0 + w1 * (buf[index + 2 * offset3] + tmp1) + w2 * buf[index + 3 * offset3]; \n \n       \n \n \n      for(int i = 2; i < size3 - 2; i++) \n      { \n        const float tmp3 = buf[index + i * offset3]; \n        buf[index + i * offset3] \n            = buf[index + i * offset3] * w0 + w1 * (buf[+ (i + 1) * offset3] + tmp2) + w2 * (buf[index + (i + 2) * offset3] + tmp1); \n        tmp1 = tmp2; \n        tmp2 = tmp3; \n      } \n      index += (size3 - 2) * offset3; \n      const float tmp3 = buf[index]; \n      buf[index] = buf[index] * w0 + w1 * (buf[index + offset3] + tmp2) + w2 * tmp1; \n      index += offset3; \n      buf[index] = buf[index] * w0 + w1 * tmp3 + w2 * tmp2; \n    } \n  } \n} ", "pred": " \nstatic void blur_line(float *buf, const int offset1, const int offset2, const int offset3, const int size1, \n                      const int size2, const int size3) \n{ \n  const float w0 = 6.f / 16.f; \n  const float w1 = 4.f / 16.f; \n  const float w2 = 1.f / 16.f; \n  for(int k = 0; k < size1; k++) \n  { \n    for(int j = 0; j < size2; j++) \n    { \n      size_t index = (size_t)k * offset1 + j * offset2; \n      float tmp1 = buf[index]; \n      buf[index] = buf[index] * w0 + w1 * buf[index + offset3] + w2 * buf[index + 2 * offset3]; \n \n       \n \n \n      float tmp2 = buf[index + offset3]; \n      buf[index + offset3] = buf[index + offset3] * w0 + w1 * (buf[index + 2 * offset3] + tmp1) + w2 * (buf[index + offset3 + 2 * offset3] + tmp2); \n    } \n  } \n  for(int k = 0; k < size2; k++) \n  { \n    for(int j = 0; j < size3; j++) \n    { \n      size_t index = (size_t)k * offset2 + j * offset3; \n      float tmp1 = buf[index]; \n      buf[index] = buf[index] * w0 + w1 * buf[index + offset3] + w2 * buf[index + 2 * offset3]; \n \n       \n \n \n      float tmp2 = buf[index + offset3]; \n      buf[index + offset3] = buf[index + offset3] * w0 + w1 * (buf[index + 2 * offset3] + tmp1) + w2 * (buf[index + offset3 + 2 * offset3] + tmp2); \n    } \n  } \n  for(int k = 0; k < size3; k++) \n  { \n    for(int j = 0; j < size1; j++) \n    { \n      size_t index = (size_t)k * offset3 + j * offset1; \n  "}
{"label": " \nvoid dt_bilateral_splat(dt_bilateral_t *b, const float *const in) \n{ \n  const int ox = 1; \n  const int oy = b->size_x; \n  const int oz = b->size_y * b->size_x; \n \n  const float sigma_s = b->sigma_s * b->sigma_s; \n  float *const buf = b->buf; \n \n \n \n  for(int j = 0; j < b->height; j++) \n  { \n    for(int i = 0; i < b->width; i++) \n    { \n      size_t index = 4 * (j * b->width + i); \n      float x, y, z; \n      const float L = in[index]; \n      image_to_grid(b, i, j, L, &x, &y, &z); \n      const int xi = MIN((int)x, b->size_x - 2); \n      const int yi = MIN((int)y, b->size_y - 2); \n      const int zi = MIN((int)z, b->size_z - 2); \n      const float xf = x - xi; \n      const float yf = y - yi; \n      const float zf = z - zi; \n       \n \n      const size_t grid_index = xi + b->size_x * (yi + b->size_y * zi); \n       \n \n       \n \n       \n \n       \n \n      for(int k = 0; k < 8; k++) \n      { \n        const size_t ii = grid_index + ((k & 1)? ox : 0) + ((k & 2)? oy : 0) + ((k & 4)? oz : 0); \n        const float contrib = ((k & 1)? xf : (1.0f - xf)) * ((k & 2)? yf : (1.0f - yf)) \n                              * ((k & 4)? zf : (1.0f - zf)) * 100.0f / (sigma_s); \n        buf[ii] += contrib; \n      } \n    } \n  } \n} ", "pred": " \nvoid dt_bilateral_splat(dt_bilateral_t *b, const float *const in) \n{ \n  const int ox = 1; \n  const int oy = b->size_x; \n  const int oz = b->size_y * b->size_x; \n \n  const float sigma_s = b->sigma_s * b->sigma_s; \n  float *const buf = b->buf; \n \n \n \n  for(int j = 0; j < b->height; j++) \n  { \n    for(int i = 0; i < b->width; i++) \n    { \n      size_t index = 4 * (j * b->width + i); \n      float x, y, z; \n      const float L = in[index]; \n      image_to_grid(b, i, j, L, &x, &y, &z); \n      const int xi = MIN((int)x, b->size_x - 2); \n      const int yi = MIN((int)y, b->size_y - 2); \n      const int zi = MIN((int)z, b->size_z - 2); \n      const float L_i = L - b->sigma_s * (xi + yi + zi); \n      const float L_j = L - b->sigma_s * (xi + yi); \n      const float L_k = L - b->sigma_s * (xi + yi + zi); \n      const float L_l = L - b->sigma_s * (xi + yi); \n      const float L_m = L - b->sigma_s * (xi + yi + zi); \n      const float L_n = L - b->sigma_s * (xi + yi + zi); \n      const float L_o = L - b->sigma_s * (xi + yi); \n      const float L_p = L - b->sigma_s * (xi + yi + zi); \n      const float L_q = L - b->sigma_s * (xi + yi + zi); \n      const float L_r = L - b->sigma_s * (xi + yi); \n      const float L_s = L - b->sigma_s * (xi + yi + zi); \n      const float L_t = L - b->sigma_s * (xi + yi + zi); \n      const float L_u = L - b->sigma_s * ("}
{"label": " \nint main(int argc, char *argv[]) \n{ \n     \n \n    double x[] = { 0, 1 }; \n    double y[] = { 0, 1 }; \n    double cfl = 0.99 / sqrt(2);         \n \n    double T = 0.3; \n    double c = 1; \n    long nx = 32; \n    long ny = 32; \n    struct py_field f; \n    char outfile[STR_SIZE] = \"yee_naive_omp.tsv\"; \n    int write = 1; \n    long threads = 4; \n    struct py_cell_partition *part; \n \n     \n \n    py_parse_cmdline(&nx, &threads, outfile, &write, argc, argv); \n    ny = nx;                     \n \n    omp_set_num_threads(threads); \n    printf(\"Domain: %li x %li\\n\", nx, ny); \n    printf(\"OpenMP threads: %li\\n\", threads); \n \n     \n \n    f = py_init_acoustic_field(nx, ny, x, y); \n    py_apply_func(&f.p, py_gauss2d);     \n \n    py_set_boundary(&f); \n \n     \n \n    f.dt = cfl * f.p.dx / c; \n    f.Nt = T / f.dt; \n \n     \n \n    part = py_partition_grid(threads, nx); \n \n     \n \n    double *p = f.p.value; \n    double *u = f.u.value; \n    double *v = f.v.value; \n \n     \n \n    long n, i, j; \n    double tic, toc; \n    tic = py_gettime(); \n \n    { \n         \n \n        double dt = f.dt; \n        double Nt = f.Nt; \n \n        for (n = 0; n < Nt; ++n) { \n \n             \n \n            for (i = 0; i < nx; ++i) { \n                for (j = 0; j < ny; ++j) { \n                    P(i, j) += \n                        dt / f.u.dx * (U(i + 1, j) - U(i, j)) + \n                        dt / f.v.dy * (V(i, j + 1) - V(i, j)); \n                } \n            } \n \n             \n \n            for (i = 1; i < nx; ++i) { \n                for (j = 0; j < ny; ++j) { \n                    U(i, j) += dt / f.p.dx * (P(i, j) - P(i - 1, j)); \n                } \n            } \n \n            for (i = 0; i < nx; ++i) \n                 \n \n                for (j = 1; j < ny; ++j) \n                    V(i, j) += dt / f.p.dy * (P(i, j) - P(i, j - 1)); \n        } \n    } \n \n    toc = py_gettime(); \n    printf(\"Elapsed: %f seconds\\n\", toc - tic); \n \n     \n \n    if (write) \n        py_write_to_disk(f.p, outfile); \n    free(part); \n    py_free_acoustic_field(f); \n \n    return EXIT_SUCCESS; \n} ", "pred": " \nint main(int argc, char *argv[]) \n{ \n     \n \n    double x[] = { 0, 1 }; \n    double y[] = { 0, 1 }; \n    double cfl = 0.99 / sqrt(2);         \n \n    double T = 0.3; \n    double c = 1; \n    long nx = 32; \n    long ny = 32; \n    struct py_field f; \n    char outfile[STR_SIZE] = \"yee_naive_omp.tsv\"; \n    int write = 1; \n    long threads = 4; \n    struct py_cell_partition *part; \n \n     \n \n    py_parse_cmdline(&nx, &threads, outfile, &write, argc, argv); \n    ny = nx;                     \n \n    omp_set_num_threads(threads); \n    printf(\"Domain: %li x %li\\n\", nx, ny); \n    printf(\"OpenMP threads: %li\\n\", threads); \n \n     \n \n    f = py_field_from_py_cell_partition(nx, ny, cfl, T, c, part); \n    py_write_field(outfile, f); \n    py_close_field(f); \n \n    return 0; \n} \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n    \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n"}
{"label": " \nstatic void \norderInsertionMarkers(InsertionMarker ** insMarkers, \n\t\t      IDnum * markerCounters, RoadMapArray * rdmaps) \n{ \n\tIDnum sequenceIndex; \n\tIDnum sequenceCounter = rdmaps->length; \n \n\tvelvetLog(\"Ordering insertion markers\\n\"); \n\tfor (sequenceIndex = 1; sequenceIndex <= sequenceCounter; \n\t     sequenceIndex++) { \n\t\tqsort(insMarkers[sequenceIndex], \n\t\t      markerCounters[sequenceIndex], \n\t\t      sizeof(InsertionMarker), compareInsertionMarkers); \n\t} \n} ", "pred": " \nstatic void \norderInsertionMarkers(InsertionMarker ** insMarkers, \n\t\t      IDnum * markerCounters, RoadMapArray * rdmaps) \n{ \n\tIDnum sequenceIndex; \n\tIDnum sequenceCounter = rdmaps->length; \n \n\tvelvetLog(\"Ordering insertion markers\\n\"); \n\tfor (sequenceIndex = 1; sequenceIndex <= sequenceCounter; \n\t     sequenceIndex++) { \n\t\tqsort(insMarkers[sequenceIndex], \n\t\t      markerCounters[sequenceIndex], \n\t\t      sizeof(InsertionMarker), compareInsertionMarkers); \n\t} \n} "}
{"label": " \nstatic PyObject *py_gibbs_ibm_initialize_parallel( \n        PyObject *self, PyObject *args) { \n \n    PyObject *eee, *fff, *counts_idx_arrays, *params; \n    PyArrayObject *seed_array; \n    unsigned long e_voc_size, f_voc_size; \n    double lexical_alpha, null_alpha; \n    int randomize; \n \n    if(!PyArg_ParseTuple(args, \"OOOOkkddOp\", \n                         &params, &eee, &fff, &counts_idx_arrays, \n                         &e_voc_size, &f_voc_size, \n                         &lexical_alpha, &null_alpha, \n                         &seed_array, &randomize)) \n        return NULL; \n \n    const size_t n_sents = PyTuple_Size(eee); \n    const size_t n_samplers = PyTuple_Size(params); \n \n    PRNG_SEED_t *seed = (PRNG_SEED_t*) PyArray_GETPTR1(seed_array, 0); \n    PRNG_SEED_t local_seeds[n_samplers]; \n    for (size_t sampler=0; sampler<n_samplers; sampler++) \n        local_seeds[sampler] = prng_next(*seed + 1 + sampler); \n    *seed = prng_next(*seed); \n \n    for (size_t sampler=0; sampler<n_samplers; sampler++) { \n        PRNG_SEED_t seed_cache = local_seeds[sampler]; \n \n        PyObject *sampler_params = PyTuple_GET_ITEM(params, sampler); \n \n        PyObject *aaa = PyTuple_GET_ITEM(sampler_params, 0); \n        PyArrayObject *counts_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 1); \n        PyArrayObject *counts_sum_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 2); \n        PyArrayObject *jump_counts_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 3); \n        PyArrayObject *fert_counts_array = \n            (PyArrayObject*) PyTuple_GET_ITEM(sampler_params, 4); \n \n        COUNT_t *counts = (COUNT_t*) PyArray_GETPTR1(counts_array, 0); \n        COUNT_t *counts_sum = (COUNT_t*) PyArray_GETPTR1(counts_sum_array, 0); \n        COUNT_t *jump_counts = ((PyObject*)jump_counts_array == Py_None) \n           ? NULL \n            : PyArray_GETPTR1(jump_counts_array, 0); \n        COUNT_t *fert_counts = ((PyObject*)fert_counts_array == Py_None) \n           ? NULL \n            : PyArray_GETPTR1(fert_counts_array, 0); \n \n        const size_t counts_size = PyArray_DIM(counts_array, 0); \n \n        for (size_t i=0; i<f_voc_size; i++) \n            counts[i] = null_alpha; \n        for (size_t i=f_voc_size; i<counts_size; i++) \n            counts[i] = lexical_alpha; \n \n        counts_sum[0] = null_alpha*(COUNT_t)f_voc_size; \n        for (size_t i=1; i<e_voc_size; i++) \n            counts_sum[i] = lexical_alpha*(COUNT_t)f_voc_size; \n \n        for (size_t sent=0; sent<n_sents; sent++) { \n            PyArrayObject *ee_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(eee, sent); \n            PyArrayObject *ff_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(fff, sent); \n            const size_t ee_len = (size_t) PyArray_DIM(ee_array, 0); \n            const size_t ff_len = (size_t) PyArray_DIM(ff_array, 0); \n \n            if (ee_len == 0 || ff_len == 0) continue; \n \n            PyArrayObject *aa_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(aaa, sent); \n            PyArrayObject *counts_idx_array = \n                (PyArrayObject*) PyTuple_GET_ITEM(counts_idx_arrays, sent); \n \n            const TOKEN_t *ee = (const TOKEN_t*) PyArray_GETPTR1(ee_array, 0); \n            const TOKEN_t *ff = (const TOKEN_t*) PyArray_GETPTR1(ff_array, 0); \n            LINK_t *aa = (LINK_t*) PyArray_GETPTR1(aa_array, 0); \n            const INDEX_t *counts_idx = (const INDEX_t*) PyArray_GETPTR1( \n                counts_idx_array, 0); \n \n            int aa_jm1 = -1; \n            if (randomize) { \n                for (size_t j=0; j<ff_len; j++) { \n                    if (prng_next_count(&seed_cache) < 0.1) { \n                        aa[j] = null_link; \n                        counts[ff[j]] += (COUNT_t)1.0; \n                        counts_sum[0] += (COUNT_t)1.0; \n                    } else { \n                        const size_t i = prng_next_int(&seed_cache, ee_len); \n                        aa[j] = i; \n                        counts[counts_idx[i]] += (COUNT_t)1.0; \n        ", "pred": " \nstatic PyObject *py_gibbs_ibm_initialize_parallel( \n        PyObject *self, PyObject *args) { \n \n    PyObject *eee, *fff, *counts_idx_arrays, *params; \n    PyArrayObject *seed_array; \n    unsigned long e_voc_size, f_voc_size; \n    double lexical_alpha, null_alpha; \n    int randomize; \n \n    if(!PyArg_ParseTuple(args, \"OOOOkkddOp\", \n                         &params, &eee, &fff, &counts_idx_arrays, \n                         &e_voc_size, &f_voc_size, \n                         &lexical_alpha, &null_alpha, \n                         &seed_array, &randomize)) \n        return NULL; \n \n    const size_t n_threads = omp_get_max_threads(); \n \n    gibbs_parallel_initialize(n_threads, \n                              e_voc_size, f_voc_size, \n                              lexical_alpha, null_alpha, \n                              seed_array, \n                              params, \n                              e_voc_size, f_voc_size, \n                              counts_idx_arrays, \n                              randomize); \n \n    Py_RETURN_NONE; \n} \n\n\nstatic PyObject *py_gibbs_ibm_initialize_parallel_v2( \n        PyObject *self, PyObject *args) { \n \n    PyObject *eee, *fff, *counts_idx_arrays, *params; \n    PyArrayObject *seed_array; \n    unsigned long e_voc_size, f_voc_size; \n    double lexical_alpha, null_alpha; \n    int randomize; \n \n    if(!PyArg_ParseTuple(args, \"OOOOkkddOp\", \n                         &params, &eee, &fff, &counts_idx_arrays, \n                         &e_voc_size, &f_voc_size, \n                         &lexical_alpha, &null_alpha, \n                         &seed_array, &randomize)) \n        return NULL; \n \n    const size_t n_threads = omp_get_max_threads(); \n \n    gibbs_parallel_initialize_v2(n_threads, \n                                 e_voc_size, f_voc_size, \n                                 lexical_alpha, null_alpha, \n                                 seed_array, \n                                 params, \n                                 e_voc_size, f_voc_size, \n                                 counts_idx_arrays, \n                                 randomize); \n \n    Py_RETURN_NONE; \n} \n\n\nstatic PyObject *py_gibbs_ibm_initialize_parallel_v3( \n        PyObject *self, PyObject *args) { \n \n    PyObject *eee, *fff, *counts_idx_arrays, *params; \n    PyArrayObject *seed_array; \n    unsigned long e_voc_size, f_voc_size; \n    double lexical_alpha, null_alpha; \n    int randomize; \n \n    if(!PyArg_ParseTuple(args, \"OOOOkkddOp\", \n                         &params, &eee, &fff, &counts_idx_arrays, \n                         &e_voc_size, &f_voc_size, \n                         &lexical_alpha, &null_alpha, \n                         &seed_array, &randomize)) \n        return NULL; \n \n    const size_t n_threads = omp_get_max_threads(); \n \n    gibbs_parallel_initialize_v3(n_threads, \n                                 e_voc_size, f_voc_size, \n                                 lexical_alpha, null_alpha, \n                                 seed_array, \n                                 params, \n                                 e_voc_size, f_voc_size, \n                                 counts_idx_arrays, \n                                 randomize); \n \n    Py_RETURN_NONE; \n} \n\n\nstatic PyObject *py_gibbs_ibm_initialize_parallel_v4( \n        PyObject *self, PyObject *args) { \n \n    PyObject *eee, *fff, *counts_idx_arrays, *params; \n    PyArrayObject *seed_array; \n    unsigned long e_voc_size, f_voc_size; \n    double lexical_alpha, null_alpha; \n    int randomize; \n \n    if(!PyArg_ParseTuple(args, \"OOOOkkddOp\", \n                         &params, &eee, &fff, &counts_idx_arrays, \n     "}
{"label": " \nint main(int argc, char *argv[]) { \n\tstruct A sum[10]; \n\tfor (int32_t i = 0; i < 10; i++) { \n\t\tsum[i].x = 0; \n\t\tsum[i].y = 1; \n\t} \n\t{ \n\t\tfor (int32_t i = 0; i < 10; i++) sum[i].x += sum[i].y; \n\t} \n\tfor (int32_t i = 0; i < 10; i++) { \n\t\tassert(sum[i].x == 1); \n\t} \n} ", "pred": " \nint main(int argc, char *argv[]) { \n\tstruct A sum[10]; \n\tfor (int32_t i = 0; i < 10; i++) { \n\t\tsum[i].x = 0; \n\t\tsum[i].y = 1; \n\t} \n\t{ \n\t\tfor (int32_t i = 0; i < 10; i++) sum[i].x += sum[i].y; \n\t} \n\tfor (int32_t i = 0; i < 10; i++) { \n\t\tassert(sum[i].x == 1); \n\t} \n} "}
{"label": " \nvoid LLG_evolve(double *mag, double *mag_new, double dt) { \n    int i, j, n; \n\t{ \n\tfor(i=1;i<=Nx;i++) \n\t\tfor(j=1;j<=Ny;j++) { \n \n\t\t\tdouble beff[3] = {0., 0., bapp}; \n\t\t\tdouble magxbeff[3], magxmagxbeff[3], rhs[3]; \n\t\t\t \n\t\t\tadd_exchange(mag, i, j, beff);\t\t \n \n \n \n \n \n \n \n\t\t\t \n\t\t\t \n \n\t\t\t \n \n\t\t\tadd_DMI_renorm_J0value(mag, i, j, beff); \n\t\t\t \n\t\t\tcross(&mag[ind(i,j)], beff, magxbeff); \n\t\t\tcross(&mag[ind(i,j)], magxbeff, magxmagxbeff); \n \n\t\t\tdouble tsst[3], magxtsst[3]; \n\t\t\t \n\t\t\tsst_torque(mag, i, j, jx, jy, tsst); \n \n \n \n \n\t\t\t \n\t\t\tcross(&mag[ind(i,j)],tsst,magxtsst); \n \n\t\t\tfor(n=0;n<3;n++) \n\t\t\t\trhs[n] = - magxbeff[n] - alpha*magxmagxbeff[n] + tsst[n] + alpha*magxtsst[n]; \n \n\t\t\tfor(n=0;n<3;n++) \n\t\t\t\tmag_new[ind(i,j)+n] = mag[ind(i,j)+n] + dt*rhs[n]; \n\t\t} \n    } \n} ", "pred": " \nvoid LLG_evolve(double *mag, double *mag_new, double dt) { \n    int i, j, n; \n\t{ \n\tfor(i=1;i<=Nx;i++) \n\t\tfor(j=1;j<=Ny;j++) { \n \n\t\t\tdouble beff[3] = {0., 0., bapp}; \n\t\t\tdouble magxbeff[3], magxmagxbeff[3], rhs[3]; \n\t\t\t \n\t\t\tadd_exchange(mag, i, j, beff);\t\t \n \n \n \n \n \n \n \n\t\t\t \n\t\t\t \n \n\t\t\t \n \n\t\t\tadd_DMI_renorm_J0value(mag, i, j, beff); \n\t\t\t \n\t\t\tcross(&mag[ind(i,j)], beff, magxbeff); \n\t\t\tcross(&mag[ind(i,j)], magxbeff, magxmagxbeff); \n \n\t\t\tdouble tsst[3], magxtsst[3]; \n\t\t\t \n\t\t\tsst_torque(mag, i, j, jx, jy, tsst); \n \n \n \n \n\t\t\t \n\t\t\tcross(&mag[ind(i,j)],tsst,magxtsst); \n \n\t\t\tfor(n=0;n<3;n++) \n\t\t\t\trhs[n] = magxbeff[n] + magxtsst[n]; \n \n\t\t\tadd_DMI_renorm_J0value(rhs, i, j, rhs); \n \n\t\t\tadd_DMI_renorm_J0value(mag, i, j, mag); \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n"}
{"label": " \nstatic void blur_line_z(float *buf, const int offset1, const int offset2, const int offset3, const int size1, \n                        const int size2, const int size3) \n{ \n  const float w1 = 4.f / 16.f; \n  const float w2 = 2.f / 16.f; \n \n  for(int k = 0; k < size1; k++) \n  { \n    for(int j = 0; j < size2; j++) \n    { \n      size_t index = (size_t)k * offset1 + j * offset2; \n      float tmp1 = buf[index]; \n      buf[index] = w1 * buf[index + offset3] + w2 * buf[index + 2 * offset3]; \n \n       \n \n \n      float tmp2 = buf[index + offset3]; \n      buf[index + offset3] = w1 * (buf[index + 2 * offset3] - tmp1) + w2 * buf[index + 3 * offset3]; \n \n       \n \n \n      for(int i = 2; i < size3 - 2; i++) \n      { \n        const float tmp3 = buf[index + i * offset3]; \n        buf[index + i * offset3] = +w1 * (buf[index + (i + 1) * offset3] - tmp2) + w2 * (buf[index + (i + 2) * offset3] - tmp1); \n        tmp1 = tmp2; \n        tmp2 = tmp3; \n      } \n \n      index += (size3 - 2) * offset3; \n      const float tmp3 = buf[index]; \n      buf[index] = w1 * (buf[index + offset3] - tmp2) - w2 * tmp1; \n      index += offset3; \n      buf[index] = -w1 * tmp3 - w2 * tmp2; \n    } \n  } \n} ", "pred": " \nstatic void blur_line_z(float *buf, const int offset1, const int offset2, const int offset3, const int size1, \n                        const int size2, const int size3) \n{ \n  const float w1 = 4.f / 16.f; \n  const float w2 = 2.f / 16.f; \n \n  for(int k = 0; k < size1; k++) \n  { \n    for(int j = 0; j < size2; j++) \n    { \n      size_t index = (size_t)k * offset1 + j * offset2; \n      float tmp1 = buf[index]; \n      buf[index] = w1 * buf[index + offset3] + w2 * buf[index + 2 * offset3]; \n \n       \n \n \n      float tmp2 = buf[index + offset3]; \n      buf[index + offset3] = w1 * (buf[index + 2 * offset3] - tmp1) + w2 * buf[index + 3 * offset3]; \n \n       \n \n \n      float tmp3 = buf[index + 2 * offset3]; \n      buf[index + 2 * offset3] = w1 * (buf[index + 3 * offset3] - tmp2) + w2 * buf[index + 3 * offset3 + offset3]; \n \n       \n \n \n      float tmp4 = buf[index + 3 * offset3]; \n      buf[index + 3 * offset3] = w1 * (buf[index + 3 * offset3] - tmp3) + w2 * buf[index + 3 * offset3 + 2 * offset3]; \n \n    } \n  } \n  \n} \n\nstatic void blur_line_z_v(float *buf, const int offset1, const int offset2, const int offset3, const int size1, \n                          const int size2, const int size3) \n{ \n  const float w1 = 4.f / 16.f; \n  const float w2 = 2.f"}
{"label": " \nint main(int argc, char* argv[])  \n{ \n     \n \n    MPI_Init(&argc,&argv); \n    int size, rank; \n    int tstart,tstop; \n \n    MPI_Comm_rank(MPI_COMM_WORLD,&rank); \n    MPI_Comm_size(MPI_COMM_WORLD,&size); \n \n     \n \n    if(rank == 0) {   \n\ttstart = MPI_Wtime();     \n    } \n \n     \n \n    int niter, vstatus, order, count, count1, count2, count3; \n    double tolerance; \n    float **rr, **rd; \n    int *updown; \n    bool newton, debug, fwdxini; \n    velocity2 vn;  \n     \n \n \n    int nx, nt, ns, nh, nc, nxc, is, ih, ix, ic; \n    float **rfl, **rgd, **crv, **dip, *trace, *trace2; \n    float **time, **ampl, **delt, freq, theta, ava, amp, obl; \n    float slow, dx, x0, dt, t0, ds, s0, dh, h0, r0; \n    const char *type, *type2; \n    bool twod, verb, adj, lin, cmp, absoff; \n    surface inc, ref; \n    velocity vel, vel2; \n    ktable ts, tg, **tss, **tgs; \n    sf_file data, refl, curv, modl, vti; \n\t \n    sf_init(argc,argv); \n\t \n    if (!sf_getbool(\"newton\",&newton)) newton=true; \n     \n \n\t \n\t \n    if (!sf_getbool(\"lin\",&lin)) lin=false; \n     \n \n\t \n    if (lin) { \n\tif (!sf_getbool(\"adj\",&adj)) adj=false; \n\t \n \n\t\t \n\tif (adj) { \n\t    modl = sf_input(\"input\"); \n\t    data = sf_output(\"output\"); \n\t} else { \n\t    data = sf_input(\"input\"); \n\t    modl = sf_output(\"output\"); \n\t} \n\tcurv = sf_input(\"curv\"); \n    } else { \n\tadj = false; \n\tcurv = sf_input(\"input\"); \n\tmodl = sf_output(\"output\"); \n\tdata = NULL; \n    } \n     \n    if (SF_FLOAT!= sf_gettype(curv)) sf_error(\"Need float input\"); \n    if (!sf_histint  (curv,\"n1\",&nx)) sf_error(\"No n1= in input\"); \n    if (!sf_histfloat(curv,\"d1\",&dx)) sf_error(\"No d1= in input\"); \n    if (!sf_histfloat(curv,\"o1\",&x0)) sf_error(\"No o1= in input\"); \n    if (!sf_histint  (curv,\"n2\",&nc)) nc=1;  \n \n    nxc = nx*nc; \n     \n    if (!sf_getbool(\"absoff\",&absoff)) absoff=false; \n     \n \n\t \n     \n \n     \n    if (adj) { \n\tif (!sf_histint(modl,\"n1\",&nt)) sf_error(\"Need nt=\"); \n\tif (!sf_histfloat(modl,\"d1\",&dt)) dt=0.004; \n\tif (!sf_histfloat(modl,\"o1\",&t0)) t0=0.; \n\t\t \n\t\t \n\t \n \n\t\t \n\tif (!sf_histint(modl,\"n3\",&ns)) ns=nx; \n\tif (!sf_histfloat(modl,\"o3\",&s0)) s0=x0; \n\tif (!sf_histfloat(modl,\"d3\",&ds)) ds=dx; \n\t\t \n\t \n \n\t\t \n\tif (!sf_histint  (modl,\"n2\",&nh)) nh=nx; \n\tif (!sf_histfloat(modl,\"o2\",&h0)) h0=0.; \n\tif (!sf_histfloat(modl,\"d2\",&dh)) dh=dx; \n\t\t \n\t\t \n\tsf_putint(data,\"n1\",nx); \n\tsf_putfloat(data,\"d1\",dx); \n\tsf_putfloat(data,\"o1\",x0); \n\tsf_putint(data,\"n2\",nc); \n\tsf_putint(data,\"n3\",1); \n    } else { \n\tif (!sf_getint(\"nt\",&nt)) sf_error(\"Need nt=\"); \n\t \n \n\tif (!sf_getfloat(\"dt\",&dt)) dt=0.004; \n\t \n \n\tif (!sf_getfloat(\"t0\",&t0)) t0=0.; \n\t \n \n\t\t \n\tsf_putint  (modl,\"n1\",nt); \n\tsf_putfloat(modl,\"d1\",dt); \n\tsf_putfloat(modl,\"o1\",t0); \n\tsf_putstring(modl,\"label1\",\"Time\"); \n\tsf_putstring(modl,\"unit1\",\"s\"); \n\t\t \n\t \n \n\t\t \n\tif (!sf_getint(\"ns\",&ns)) ns=nx; \n\t \n \n\tif (!sf_getfloat(\"s0\",&s0)) s0=x0; \n\t \n \n\tif (!sf_getfloat(\"ds\",&ds)) ds=dx; \n\t \n \n\t\t \n\tsf_putfloat(modl,\"o3\",s0); \n\tsf_putfloat(modl,\"d3\",ds); \n\tsf_putint(modl,\"n3\",ns); \n\t\t \n\t \n \n\t\t \n\tif (!sf_getint  (\"nh\",&nh)) nh=nx; \n\t \n \n\tif (!sf_getfloat(\"h0\",&h0)) h0=0.; \n\t \n \n\tif (!sf_getfloat(\"dh\",&dh)) dh=dx; \n\t \n \n\t\t \n\tsf_putint  (modl,\"n2\",nh); \n\tsf_putfloat(modl,\"o2\",h0); \n\tsf_putfloat(modl,\"d2\",dh); \n    } \n\t \n    if (!sf_getbool(\"verb\",&verb)) verb=false; \n     \n \n\t \n    trace = sf_floatalloc(nt); \n    trace2 = sf_floatalloc(nt); \n\t \n     \n \n\t \n    crv = sf_floatalloc2(nx,nc); \n    rfl = sf_floatalloc2(nx,nc); \n    rgd = sf_floatalloc2(nx,nc); \n    dip = sf_floatalloc2(nx,nc); \n     \n    sf_floatread(crv[0],nxc,curv); \n     \n    if (!lin) { \n\t \n \n\tif (NULL!= sf_getstring(\"refl\")) { \n\t    refl = sf_input(\"refl\"); \n\t    sf_floatread(rfl[0],nxc,refl); \n\t    sf_fileclose(refl); \n\t} else { \n\t    if (!sf_getfloat(\"r0\",&r0)) r0=1.; \n\t     \n \n\t    for (ic=0; ic < nc; ic++) { \n\t\tfor (ix=0; ix < nx; ix++) { \n\t\t    rfl[ic][ix] = r0; \n\t\t} \n\t    } \n\t} \n    } \n\t \n    if (NULL!= sf_getstring(\"rgrad\")) { \n\t \n \n\trefl = sf_input(\"rgrad\"); \n\tsf_floatread(rgd[0],nxc,refl); \n\tsf_fileclose(refl); \n    } else { \n\tfor (ic=0; ic < nc; ic++) { \n\t    for (ix=0; ix < nx; ix++) { \n\t\trgd[ic][ix] = 0.; \n\t    } \n\t} \n    } \n\t \n    if (NULL!= sf_getstring(\"dip\")) { \n\t \n \n\trefl = sf_input(\"dip\");", "pred": " \nint main(int argc, char* argv[])  \n{ \n     \n \n    MPI_Init(&argc,&argv); \n    int size, rank; \n    int tstart,tstop; \n \n    MPI_Comm_rank(MPI_COMM_WORLD,&rank); \n    MPI_Comm_size(MPI_COMM_WORLD,&size); \n \n     \n \n    if(rank == 0) {   \n\ttstart = MPI_Wtime();     \n    } \n \n     \n \n    int niter, vstatus, order, count, count1, count2, count3; \n    double tolerance; \n    float **rr, **rd; \n    int *updown; \n    bool newton, debug, fwdxini; \n    velocity2 vn;  \n     \n \n \n    int nx, nt, ns, nh, nc, nxc, is, ih, ix, ic; \n    float **rfl, **rgd, **crv, **dip, *trace, *trace2; \n    float **time, **ampl, **delt, freq, theta, ava, amp, obl; \n    float **x, **x2, **x3, **x4, **x5, **x6, **x7, **x8, **x9; \n    float **x10, **x11, **x12, **x13, **x14, **x15, **x16, **x17, **x18; \n    float **x19, **x20, **x21, **x22, **x23, **x24, **x25, **x26, **x27, **x28; \n    float **x29, **x30, **x31, **x32, **x33, **x34, **x35, **x36, **x37, **x38; \n    float **x39, **x40, **x41, **x42, **x43, **x44, **x45, **x46, **x47, **x48; \n    float **x49, **x50, **x51, **x52, **x53, **x54, **x55, **x56, **x57, **x58, **x59; \n    float **x60, **x61, **x62, **x63, **x64, **x65, **x66, **x67, **x68, **x69, **x70; \n    float **x71, **x72, **x73, **x74, **x75, **x76, **x77, **x78, **x79, **x80, **x81; \n    float **x82, **x83, **x84, **x85, **x86, **x87, **x88, **x89, **x90, **x91, **x92; \n    float **x93, **x94, **x95, **x96, **x97, **x98, **x99, **x100, **x101, **x102, **x103; \n    float **x104, **x105, **x106, **x107, **x108, **x109, **x110, **x111, **x112, **x113; \n    float **x114, **x115, **x116, **x117, **x118, **x119, **x120, **x121, **x122, **x123, **x124; \n    float **x125, **x126, **x127, **x128, **x129, **x130, **x131, **x132, **x133, **x134, **x135; \n    float **x136, **x137, **x138, **x139, **x140, **x141, **x142, **x143, **x144, **x145, **x146; \n    float **x147, **x148, **x149, **x150, **x151, **x152, **x153, **x154, **x155, **x156, **x157; \n    float **x158, **x159, **x160, **x161, **x162, **x163, **x164, **x165, **x166, **x167, **x168; \n    float **x169, **x170, **x171, **x172, **x173, **x174, **x175, **x176, **x177, **x178, **x179; \n    float **x180, **x181, **x182, **x183, **x184, **x185, **x186, **x187, **x188, **x189, **x190; \n    float **x191, **x192, **x193, **x194, **x195, **x196, **x197, **x198, **x199, **x200, **x201; \n    float **x202, **x203, **x204, **x205, **x206, **x207, **x208, **x209, **x210, **x211, **x212; \n    float **x213, **x214, **x215, **x216, **x217, **x218, **x219, **x220, **x221, **x222, **x223; \n    float **x224, **x225, **x226, **x227, **x228, **x229, **x230, **x231, **x232, **x233, **x234; \n    float **x235, **x236, **x237, **x238, **x239, **x240, **x241, **x242, **x243, **x244, **x245; \n    float **x246, **x247, **x248, **x249, **x250, **x251, **x252, **x253, **x254, **x255, **x256; \n    float **x257, **x258, **x259, **x260, **x261, **x262, **x263, **x264, **x265, **x266, **x267; \n    float **x268, **x269, **x270, **x271, **x272, **x273, **x274, **x275, **x276, **x277, **x278; \n    float **x279, **x280, **x281, **x282, **x283, **x284, **x285, **x286, **x287, **x288, **x289; \n    float **x290, **x291, **x292, **x293, **x294, **x295, **x296, **x297, **x298, **x299, **x300; \n    float **x301, **x302, **x303, **x304, **x305, **x306, **x307, **x308, **x309, **x310, **x311; \n    float **x312, **x313, **x314, **x315, **x316, **x317, **x318, **x319, **x320, **x321, **x322; \n    float **x323, **x324, **x325, **x326, **x327, **x328, **x329, **x330, **x331, **x332, **x333; \n    float **x334, **x335, **x336, **x337, **x338, **x339, **x340, **x341, **x342, **x343, **x344; \n    float **x345, **x346, **x347, **x348, **x349, **x350, **x351, **x352, **x353, **x354, **x355; \n    float **x356, **x357, **x358, **x359, **x360, **x361, **x362, **x363, **x364, **x365, **x366; \n    float **x367, **x368, **x369, **x370, **x371, **x372, **x373, **x374, **x375, **x376, **x377; \n    float **x378, **x379, **x380, **x381, **x382, **x383, **x384, **x385, **x386, **x387, **x388; \n    float **x389, **x390, **x391, **x392"}
{"label": " \nstatic void CA_correct(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in2, \n                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int width = roi_in->width; \n  const int height = roi_in->height; \n  const uint32_t filters = piece->pipe->dsc.filters; \n  dt_iop_image_copy_by_size(out, in2, width, height, 1); \n  const float *const in = out; \n  const double cared = 0, cablue = 0; \n  const double caautostrength = 4; \n \n   \n \n  const int ts = 128; \n  const int tsh = ts / 2; \n   \n \n  const int v1 = ts, v2 = 2 * ts, v3 = 3 * ts, \n            v4 = 4 * ts;  \n \n \n   \n \n  for(int i = 0; i < 2; i++) \n    for(int j = 0; j < 2; j++) \n      if(FC(i, j, filters) == 3) \n      { \n        printf(\"CA correction supports only RGB Colour filter arrays\\n\"); \n        return; \n      } \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n  const gboolean autoCA = (cared == 0 && cablue == 0); \n   \n \n   \n \n   \n \n  float *Gtmp = (float(*))calloc((height) * (width), sizeof *Gtmp); \n \n   \n \n  float *RawDataTmp = (float *)malloc(sizeof(float) * height * width / 2 + 4); \n \n  float blockave[2][2] = { { 0, 0 }, { 0, 0 } }, blocksqave[2][2] = { { 0, 0 }, { 0, 0 } }, \n        blockdenom[2][2] = { { 0, 0 }, { 0, 0 } }, blockvar[2][2]; \n \n   \n \n  gboolean processpasstwo = TRUE; \n \n  const int border = 8; \n  const int border2 = 16; \n \n  const int vz1 = (height + border2) % (ts - border2) == 0? 1 : 0; \n  const int hz1 = (width + border2) % (ts - border2) == 0? 1 : 0; \n  const int vblsz = ceil((float)(height + border2) / (ts - border2) + 2 + vz1); \n  const int hblsz = ceil((float)(width + border2) / (ts - border2) + 2 + hz1); \n \n  char *buffer1 = (char *)calloc((size_t)vblsz * hblsz * (2 * 2 + 1), sizeof(float)); \n \n   \n \n  float *blockwt = (float *)buffer1; \n  float(*blockshifts)[2][2] = (float(*)[2][2])(buffer1 + (vblsz * hblsz * sizeof(float))); \n \n  double fitparams[2][2][16]; \n \n   \n \n  int polyord = 4, numpar = 16; \n \n  const float eps = 1e-5f, eps2 = 1e-10f;  \n \n \n  { \n     \n \n \n     \n \n    int GRBdir[2][3]; \n \n    int shifthfloor[3], shiftvfloor[3], shifthceil[3], shiftvceil[3]; \n \n     \n \n    float coeff[2][3][2]; \n     \n \n    float CAshift[2][2]; \n     \n \n     \n \n    float shifthfrac[3], shiftvfrac[3]; \n     \n \n    float blockavethr[2][2] = { { 0, 0 }, { 0, 0 } }, blocksqavethr[2][2] = { { 0, 0 }, { 0, 0 } }, \n          blockdenomthr[2][2] = { { 0, 0 }, { 0, 0 } }; \n \n     \n \n    const size_t buffersize = sizeof(float) * 3 * ts * ts + 6 * sizeof(float) * ts * tsh + 8 * 64 + 63; \n    char *buffer = (char *)malloc(buffersize); \n    char *data = (char *)(((uintptr_t)buffer + (uintptr_t)63) / 64 * 64); \n \n     \n \n     \n \n \n     \n \n    float *rgb[3]; \n    rgb[0] = (float(*))data; \n    rgb[1] = (float(*))(data + 1 * sizeof(float) * ts * ts + 1 * 64); \n    rgb[2] = (float(*))(data + 2 * sizeof(float) * ts * ts + 2 * 64); \n \n     \n \n    float *rbhpfh = (float(*))(data + 3 * sizeof(float) * ts * ts + 3 * 64); \n     \n \n    float *rbhpfv = (float(*))(data + 3 * sizeof(float) * ts * ts + sizeof(float) * ts * tsh + 4 * 64); \n     \n \n    float *rblpfh = (float(*))(data + 4 * sizeof(float) * ts * ts + 5 * 64); \n     \n \n    float *rblpfv = (float(*))(data + 4 * sizeof(float) * ts * ts + sizeof(float) * ts * tsh + 6 * 64); \n     \n \n    float *grblpfh = (float(*))(data + 5 * sizeof(float) * ts * ts + 7 * 64); \n     \n \n    float *grblpfv = (float(*))(data + 5 * sizeof(float) * ts * ts + sizeof(float) * ts * tsh + 8 * 64); \n     \n \n    float *grbdiff = rbhpfh;  \n \n     \n \n    float *gshift = rbhpfv;  \n \n \n \n    if(autoCA) \n    { \n \n \n      for(int top = -border; top < height; top += ts - border2) \n        for(int left = -border; left < width; left += ts - border2) \n        { \n          memset(buffer, 0, buffersize); \n          const int vblock = ((top + border) / (ts - border2)) + 1; \n          const int hblock = ((left + border) / (ts - border2)) + 1; \n          const int bottom = MIN(top + ts, height + border); \n          const int right = MIN(left + ts, width + border); \n          const int rr1 = bottom - top; \n          const int cc1 = right - left; \n          const int rrmin = top < 0? border : 0; \n          const int rrmax = bottom > height? height - top : rr1; \n          const int ccmin = left < 0? border : 0; \n          const int ccmax = right > width? width - left : cc1; \n \n           \n \n           \n \n           \n \n \n          for(int rr = rrmin; rr < rrmax; rr++) \n            for(int row = rr + top, cc = ccmin; cc < ccmax; cc++) \n            { \n              int col = cc +", "pred": " \nstatic void CA_correct(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in2, \n                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int width = roi_in->width; \n  const int height = roi_in->height; \n  const uint32_t filters = piece->pipe->dsc.filters; \n  dt_iop_image_copy_by_size(out, in2, width, height, 1); \n  const float *const in = out; \n  const double cared = 0, cablue = 0; \n  const double caautostrength = 4; \n \n   \n \n  const int ts = 128; \n  const int tsh = ts / 2; \n   \n \n  const int v1 = ts, v2 = 2 * ts, v3 = 3 * ts, \n            v4 = 4 * ts;  \n \n \n   \n \n  for(int i = 0; i < 2; i++) \n    for(int j = 0; j < 2; j++) \n      for(int k = 0; k < 2; k++) \n        for(int l = 0; l < 2; l++) \n          for(int m = 0; m < 2; m++) \n            for(int n = 0; n < 2; n++) \n              for(int o = 0; o < 2; o++) \n                for(int p = 0; p < 2; p++) \n                  for(int q = 0; q < 2; q++) \n                    for(int r = 0; r < 2; r++) \n                      for(int s = 0; s < 2; s++) \n                        for(int t = 0; t < 2; t++) \n                          for(int u = 0; u < 2; u++) \n                            for(int v = 0; v < 2; v++) \n                              for(int w = 0; w < 2; w++) \n                                for(int x = 0; x < 2; x++) \n                                  for(int y = 0; y < 2; y++) \n                                    for(int z = 0; z < 2; z++) \n                                      for(int c = 0; c < 2; c++) \n                                        for(int d = 0; d < 2; d++) \n                                          for(int e = 0; e < 2; e++) \n                                            for(int f = 0; f < 2; f++) \n                                              for(int g = 0; g < 2; g++) \n                                                for(int h = 0; h < 2; h++) \n                                                  for(int i = 0; i < 2; i++) \n                                                    for(int j = 0; j < 2; j++) \n                                                      for(int k = 0; k < 2; k++) \n                                                        for(int l = 0; l < 2; l++) \n                                                          for(int m = 0; m < 2; m++) \n                                                            for(int n = 0; n < 2; n++) \n                                                              for(int o = 0; o < 2; o++) \n                                                                for(int p = 0; p < 2; p++) \n                                                                  for(int q = 0; q < 2; q++) \n                                                                    for(int r = 0; r < 2; r++) \n                                                                      for(int s = 0; s < 2; s++) \n                                                       "}
{"label": " \nvoid THNN_(unfolded_acc)( \n          THTensor *finput, \n          THTensor *input, \n          int kW, \n          int kH, \n          int dW, \n          int dH, \n          int padW, \n          int padH, \n          int nInputPlane, \n          int inputWidth, \n          int inputHeight, \n          int outputWidth, \n          int outputHeight) \n{ \n  LONG_PTR nip; \n  size_t nip; \n \n  real *input_data = THTensor_(data)(input); \n  real *finput_data = THTensor_(data)(finput); \n \n  for(nip = 0; nip < nInputPlane; nip++) \n  { \n    size_t kw, kh, y, x; \n    long long ix = 0, iy = 0; \n    for(kh = 0; kh < kH; kh++) \n    { \n      for(kw = 0; kw < kW; kw++) \n      { \n        real *src = finput_data + nip*(kH*kW*outputHeight*outputWidth) + kh*(kW*outputHeight*outputWidth) + kw*(outputHeight*outputWidth); \n        real *dst = input_data + nip*(inputHeight*inputWidth); \n        if (padW > 0 || padH > 0) { \n          size_t lpad,rpad; \n          for(y = 0; y < outputHeight; y++) { \n            iy = (long long)(y*dH - padH + kh); \n            if (iy < 0 || iy >= inputHeight) { \n            } else { \n              if (dW==1){ \n                 ix = (long long)(0 - padW + kw); \n                 lpad = fmaxf(0,(int)(padW-kw)); \n                 rpad = fmaxf(0,(int)(padW-(kW-kw-1))); \n                 THVector_(add)(dst+(size_t)(iy*inputWidth+ix+lpad), src+(size_t)(y*outputWidth+lpad), 1, outputWidth - lpad - rpad);  \n \n              } \n              else{ \n                for (x=0; x<outputWidth; x++){ \n                   ix = (long long)(x*dW - padW + kw); \n                   if (ix < 0 || ix >= inputWidth){ \n                   }else \n                     THVector_(add)(dst+(size_t)(iy*inputWidth+ix), src+(size_t)(y*outputWidth+x), 1, 1); \n                } \n              } \n            } \n          } \n        } else { \n          for(y = 0; y < outputHeight; y++) { \n            iy = (long long)(y*dH + kh); \n            ix = (long long)(0 + kw); \n            if (dW == 1 ) \n               THVector_(add)(dst+(size_t)(iy*inputWidth+ix), src+(size_t)(y*outputWidth), 1, outputWidth);  \n \n            else{ \n              for(x = 0; x < outputWidth; x++) \n                THVector_(add)(dst+(size_t)(iy*inputWidth+ix+x*dW), src+(size_t)(y*outputWidth+x), 1, 1); \n            } \n          } \n        } \n      } \n    } \n  } \n} ", "pred": " \nvoid THNN_(unfolded_acc)( \n          THTensor *finput, \n          THTensor *input, \n          int kW, \n          int kH, \n          int dW, \n          int dH, \n          int padW, \n          int padH, \n          int nInputPlane, \n          int inputWidth, \n          int inputHeight, \n          int outputWidth, \n          int outputHeight) \n{ \n  LONG_PTR nip; \n  size_t nip; \n \n  real *input_data = THTensor_(data)(input); \n  real *finput_data = THTensor_(data)(finput); \n \n  for(nip = 0; nip < nInputPlane; nip++) \n  { \n    size_t kw, kh, y, x; \n    long long ix = nip % inputWidth; \n    long long iy = nip / inputWidth; \n    long long iz = nip / inputWidth; \n    long long i, j, k; \n    long long input_offset = iy * inputWidth + ix; \n    long long input_offset_2 = input_offset * 2; \n    long long input_offset_3 = input_offset * 3; \n    long long input_offset_4 = input_offset * 4; \n    long long input_offset_5 = input_offset * 5; \n    long long input_offset_6 = input_offset * 6; \n    long long input_offset_7 = input_offset * 7; \n    long long input_offset_8 = input_offset * 8; \n    long long input_offset_9 = input_offset * 9; \n    long long input_offset_10 = input_offset * 10; \n    long long input_offset_11 = input_offset * 11; \n    long long input_offset_12 = input_offset * 12; \n    long long input_offset_13 = input_offset * 13; \n    long long input_offset_14 = input_offset * 14; \n    long long input_offset_15 = input_offset * 15; \n    long long input_offset_16 = input_offset * 16; \n    long long input_offset_17 = input_offset * 17; \n    long long input_offset_18 = input_offset * 18; \n    long long input_offset_19 = input_offset * 19; \n    long long input_offset_20 = input_offset * 20; \n    long long input_offset_21 = input_offset * 21; \n    long long input_offset_22 = input_offset * 22; \n    long long input_offset_23 = input_offset * 23; \n    long long input_offset_24 = input_offset * 24; \n    long long input_offset_25 = input_offset * 25; \n    long long input_offset_26 = input_offset * 26; \n    long long input_offset_27 = input_offset * 27; \n    long long input_offset_28 = input_offset * 28; \n    long long input_offset_29 = input_offset * 29; \n    long long input_offset_30 = input_offset * 30; \n    long long input_offset_31 = input_offset * 31; \n    long long input_offset_32 = input_offset * 32; \n    long long input_offset_33 = input_offset * 33; \n    long long input_offset_34 = input_offset * 34; \n    long long input_offset_35 = input_offset * 35; \n    long long input_offset_36 = input_offset * 36; \n    long long input_offset_37 = input_offset * 37; \n    long long input_offset_38 = input_offset * 38; \n    long long input_offset_39 = input_offset * 39; \n    long long input_offset_40 = input_offset * 40; \n    long long input_offset_41 = input_offset * 41; \n    long long input_offset_42 = input_offset * 42; \n    long long input_offset_43 = input_offset * 43; \n    long long input_offset_44 = input_offset * 44; \n    long long input_offset_45 = input_offset * 45; \n    long long input_offset_46 = input_offset * 46; \n    long long input_offset_47 = input_offset * 47; \n    long long input_offset_48 = input_offset * 48; \n    long long input_offset_49 = input_offset * 49; \n    long long input_offset_50 = input_offset * 50; \n    long long input_offset_51 = input_offset * 51; \n    long long input_offset_52 = input_offset * 52; \n    long long input_offset_53 = input_offset * 53; \n   "}
{"label": " \nstatic int \nf(double t, const double y[], double dydt[], void *vparams) { \n  fparams *p = (fparams *)vparams; \n  size_t i; \n  int status = GSL_SUCCESS; \n  int overall_status = GSL_SUCCESS; \n \n  memset(dydt, 0, body_size_to_vector_size(p->nbodies)*sizeof(double)); \n   \n  for (i = 0; i < p->nbodies; i++) { \n    size_t j; \n    body bi; \n    central_body bc; \n    double rhs[BODY_VECTOR_SIZE]; \n    double dsunomega[3]; \n \n    vector_to_body(y+i*BODY_VECTOR_SIZE+CENTRAL_BODY_VECTOR_SIZE, &bi); \n    vector_to_central_body(y, &bc); \n \n    for (j = 0; j < p->nbodies; j++) { \n      if (j!= i) { \n        body bj; \n        double rhs[BODY_VECTOR_SIZE]; \n        size_t k; \n        int status; \n \n        vector_to_body(y+j*BODY_VECTOR_SIZE + CENTRAL_BODY_VECTOR_SIZE, &bj); \n         \n        status = average_rhs(p->eps, &bi, &bj, p->epsquad, rhs); \n \n        if (status!= GSL_SUCCESS) { \n          overall_status = GSL_EBADFUNC; \n        } \n \n        for (k = 0; k < BODY_VECTOR_SIZE; k++) { \n          dydt[CENTRAL_BODY_VECTOR_SIZE + i*BODY_VECTOR_SIZE+k] += rhs[k]; \n        } \n      } \n    } \n \n     \n \n    memset(rhs, 0, BODY_VECTOR_SIZE*sizeof(double)); \n    memset(dsunomega, 0, 3*sizeof(double)); \n \n    tidal_rhs(&bi, &bc, rhs, dsunomega); \n \n    for (j = 0; j < BODY_VECTOR_SIZE; j++) { \n      if (isnan(rhs[j])) overall_status = GSL_EBADFUNC; \n    } \n \n    for (j = 0; j < 3; j++) { \n      if (isnan(dsunomega[j])) overall_status = GSL_EBADFUNC; \n    } \n \n    for (j = 0; j < 3; j++) { \n      dydt[CENTRAL_BODY_SPIN_INDEX + j] += dsunomega[j]; \n    } \n    for (j = 0; j < BODY_VECTOR_SIZE; j++) { \n      dydt[CENTRAL_BODY_VECTOR_SIZE + i*BODY_VECTOR_SIZE + j] += rhs[j]; \n    } \n  } \n \n  return overall_status; \n} ", "pred": " \nstatic int \nf(double t, const double y[], double dydt[], void *vparams) { \n  fparams *p = (fparams *)vparams; \n  size_t i; \n  int status = GSL_SUCCESS; \n  int overall_status = GSL_SUCCESS; \n \n  memset(dydt, 0, body_size_to_vector_size(p->nbodies)*sizeof(double)); \n   \n  for (i = 0; i < p->nbodies; i++) { \n    size_t j; \n    body bi; \n    central_body bc; \n    double rhs[BODY_VECTOR_SIZE]; \n    double dsunomega[3]; \n \n    vector_to_body(y+i*BODY_VECTOR_SIZE+CENTRAL_BODY_VECTOR_SIZE, &bi); \n    vector_to_central_body(y, &bc); \n \n    for (j = 0; j < p->nbodies; j++) { \n      if (j!= i) { \n        body bj; \n        double rhs[BODY_VECTOR_SIZE]; \n        size_t k; \n        \n        vector_to_body(y+j*BODY_VECTOR_SIZE+CENTRAL_BODY_VECTOR_SIZE, &bj); \n        vector_to_central_body(y, &bc); \n        \n        for (k = 0; k < p->nbodies; k++) { \n          if (k!= j) { \n            body bk; \n            double rhs[BODY_VECTOR_SIZE]; \n            size_t l; \n            \n            vector_to_body(y+k*BODY_VECTOR_SIZE+CENTRAL_BODY_VECTOR_SIZE, &bk); \n            vector_to_central_body(y, &bc); \n            \n            for (l = 0; l < p->nbodies; l++) { \n              if (l!= k) { \n                body bl; \n                double rhs[BODY_VECTOR_SIZE]; \n                size_t m; \n                \n                vector_to_body(y+l*BODY_VECTOR_SIZE+CENTRAL_BODY_VECTOR_SIZE, &bl); \n                vector_to_central_body(y, &bc); \n                \n                for (m = 0; m < p->nbodies; m++) { \n "}
{"label": " \nstatic int nn_(SpatialConvolution_accGradParameters)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor *gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  real scale = luaL_optnumber(L, 4, 1); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n  int nOutputPlane = luaT_getfieldcheckint(L, 1, \"nOutputPlane\"); \n \n  THTensor *gradWeight = luaT_getfieldcheckudata(L, 1, \"gradWeight\", torch_Tensor); \n  THTensor *gradBias = luaT_getfieldcheckudata(L, 1, \"gradBias\", torch_Tensor); \n \n  int dimw = 2; \n  int dimh = 1; \n \n  real *gradBias_data; \n  real *gradOutput_data; \n  long noutSlice; \n \n  THArgCheck( nOutputPlane == gradOutput->size[input->nDimension == 4? 1 : 0], 1, \"Number of output features is not equal to nOutputPlane\" ); \n \n  if (input->nDimension == 4) \n  { \n    dimw++; \n    dimh++; \n  } \n \n   \n \n  gradBias_data = THTensor_(data)(gradBias); \n  gradOutput_data = THTensor_(data)(gradOutput); \n  noutSlice = gradOutput->size[dimh]*gradOutput->size[dimw]; \n   \n \n \n  if (input->nDimension == 3) \n  { \n    long k; \n    for(k = 0; k < nOutputPlane; k++) \n    { \n       \n \n      real *ptr_gradOutput = gradOutput_data + k*noutSlice; \n      long l; \n      for(l = 0; l < noutSlice; l++) \n        gradBias_data[k] += scale*ptr_gradOutput[l]; \n    } \n     \n     \n \n    THTensor_(conv2DRevger)(gradWeight, 1.0, scale, input, gradOutput, dH, dW); \n  } \n  else \n  { \n    long k; \n    for(k = 0; k < nOutputPlane; k++) \n    { \n      long p; \n      for(p = 0; p < input->size[0]; p++) \n      {  \n         \n \n        real *ptr_gradOutput = gradOutput_data + p*nOutputPlane*noutSlice + k*noutSlice; \n        long l; \n        for(l = 0; l < noutSlice; l++) \n          gradBias_data[k] += scale*ptr_gradOutput[l]; \n      } \n    } \n     \n \n    THTensor_(conv2DRevgerm)(gradWeight, 1.0, scale, input, gradOutput, dH, dW); \n  } \n  return 0; \n} ", "pred": " \nstatic int nn_(SpatialConvolution_accGradParameters)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor *gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  real scale = luaL_optnumber(L, 4, 1); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n  int nOutputPlane = luaT_getfieldcheckint(L, 1, \"nOutputPlane\"); \n \n  THTensor *gradWeight = luaT_getfieldcheckudata(L, 1, \"gradWeight\", torch_Tensor); \n  THTensor *gradBias = luaT_getfieldcheckudata(L, 1, \"gradBias\", torch_Tensor); \n \n  int dimw = 2; \n  int dimh = 1; \n \n  real *gradBias_data; \n  real *gradOutput_data; \n  long noutSlice; \n \n  THArgCheck( nOutputPlane == gradOutput->size[input->nDimension == 4? 1 : 0], 1, \"Number of output features is not equal to nOutputPlane\" ); \n \n  if (nOutputPlane == gradOutput->size[input->nDimension == 4? 1 : 0]) { \n    gradWeight_data = (real*)malloc(sizeof(real) * dimw * dimh); \n    gradBias_data = (real*)malloc(sizeof(real) * dimw * dimh); \n    noutSlice = gradOutput->size[input->nDimension == 4? 1 : 0]; \n    nn_(SpatialConvolution_accGradParameters_nOutSlice)(L, input, gradWeight, gradBias, gradOutput, gradWeight_data, gradBias_data, noutSlice, scale, dW, dH, nOutputPlane); \n    free(gradWeight_data); \n    free(gradBias_data); \n  } else { \n    nn_(SpatialConvolution_accGradParameters_nOutSlice)(L, input, gradWeight, gradBias, gradOutput, NULL, NULL, 0, scale, dW, dH, nOutputPlane); \n  } \n \n  return 0; \n} \n\nstatic int nn_(SpatialConvolution_accGradParameters_nOutSlice)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor *gradWeight = luaT_checkudata(L, 3, torch_Tensor); \n  THTensor *gradBias = luaT_checkudata(L, 4, torch_Tensor); \n  int dimw = 2; \n  int dimh = 1; \n \n  real *gradWeight_data; \n  real *gradBias_data; \n  long noutSlice; \n \n  THArgCheck( nOutputPlane == gradOutput->size[input->nDimension == 4? 1 : 0], 1, \"Number of output features is not equal to nOutputPlane\" ); \n \n  if (nOutputPlane == gradOutput->size[input->nDimension == 4? 1 : 0]) { \n    gradWeight_data = (real*)malloc(sizeof(real) * dimw * dimh); \n    gradBias_data = (real*)malloc(sizeof(real) * dimw * dimh); \n    noutSlice = gradOutput->size[input->nDimension == 4? 1 : 0]; \n  "}
{"label": " \nstatic int dt_circle_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                  dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start1 = dt_get_wtime(); \n  double start2 = start1; \n \n   \n \n  dt_masks_point_circle_t *circle = (dt_masks_point_circle_t *)(g_list_first(form->points)->data); \n  const int wi = piece->pipe->iwidth, hi = piece->pipe->iheight; \n  const float center[2] = { circle->center[0] * wi, circle->center[1] * hi }; \n  const float radius2 = circle->radius * MIN(wi, hi) * circle->radius * MIN(wi, hi); \n  const float total = (circle->radius + circle->border) * MIN(wi, hi); \n  const float total2 = total * total; \n \n   \n \n   \n \n  const int w = roi->width; \n  const int h = roi->height; \n  const int px = roi->x; \n  const int py = roi->y; \n  const float iscale = 1.0f / roi->scale; \n  const int grid = CLAMP((10.0f * roi->scale + 2.0f) / 3.0f, 1, 4);  \n \n  const int gw = (w + grid - 1) / grid + 1;   \n \n  const int gh = (h + grid - 1) / grid + 1;   \n \n \n   \n \n  memset(buffer, 0, (size_t)w * h * sizeof(float)); \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] circle init took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n   \n \n  const size_t circpts = dt_masks_roundup(MIN(360, 2 * M_PI * total2), 8); \n  float *circ = dt_alloc_align(64, circpts * 2 * sizeof(float)); \n  if(circ == NULL) return 0; \n \n  for(int n = 0; n < circpts / 8; n++) \n  { \n    const float phi = (2.0f * M_PI * n) / circpts; \n    const float x = total * cos(phi); \n    const float y = total * sin(phi); \n    const float cx = center[0]; \n    const float cy = center[1]; \n    const int index_x = 2 * n * 8; \n    const int index_y = 2 * n * 8 + 1; \n     \n \n    circ[index_x] = cx + x; \n    circ[index_y] = cy + y; \n    circ[index_x + 2] = cx + x; \n    circ[index_y + 2] = cy - y; \n    circ[index_x + 4] = cx - x; \n    circ[index_y + 4] = cy + y; \n    circ[index_x + 6] = cx - x; \n    circ[index_y + 6] = cy - y; \n    circ[index_x + 8] = cx + y; \n    circ[index_y + 8] = cy + x; \n    circ[index_x + 10] = cx + y; \n    circ[index_y + 10] = cy - x; \n    circ[index_x + 12] = cx - y; \n    circ[index_y + 12] = cy + x; \n    circ[index_x + 14] = cx - y; \n    circ[index_y + 14] = cy - x; \n  } \n \n   \n \n  if(!dt_dev_distort_transform_plus(module->dev, piece->pipe, module->iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, circ, \n                                        circpts)) \n  { \n    dt_free_align(circ); \n    return 0; \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] circle outline took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n  float xmin = FLT_MAX, ymin = FLT_MAX, xmax = FLT_MIN, ymax = FLT_MIN; \n  for(int n = 0; n < circpts; n++) \n  { \n     \n \n    if(!(isnormal(circ[2 * n]) && isnormal(circ[2 * n + 1]))) continue; \n \n    xmin = MIN(xmin, circ[2 * n]); \n    xmax = MAX(xmax, circ[2 * n]); \n    ymin = MIN(ymin, circ[2 * n + 1]); \n    ymax = MAX(ymax, circ[2 * n + 1]); \n  } \n \n  printf(\"xmin %f, xmax %f, ymin %f, ymax %f\\n\", xmin, xmax, ymin, ymax); \n  printf(\"wi %d, hi %d, iscale %f\\n\", wi, hi, iscale); \n  printf(\"w %d, h %d, px %d, py %d\\n\", w, h, px, py); \n \n   \n \n  const int bbxm = CLAMP((int)floorf(xmin / iscale - px) / grid - 1, 0, gw - 1); \n  const int bbXM = CLAMP((int)ceilf(xmax / iscale - px) / grid + 2, 0, gw - 1); \n  const int bbym = CLAMP((int)floorf(ymin / iscale - py) / grid - 1, 0, gh - 1); \n  const int bbYM = CLAMP((int)ceilf(ymax / iscale - py) / grid + 2, 0, gh - 1); \n  const int bbw = bbXM - bbxm + 1; \n  const int bbh = bbYM - bbym + 1; \n \n  printf(\"bbxm %d, bbXM %d, bbym %d, bbYM %d\\n\", bbxm, bbXM, bbym, bbYM); \n  printf(\"gw %d, gh %d, bbw %d, bbh %d\\n\", gw, gh, bbw, bbh); \n \n  dt_free_align(circ); \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] circle bounding box took %0.04f sec\\n\", form->name, dt_get_wtime() - start2); \n  start2 = dt_get_wtime(); \n \n   \n \n   \n \n  if(bbw <= 1 || bbh <= 1) \n    return 1; \n \n \n  float *points = dt_alloc_align(64, (size_t)bbw * bbh * 2 * sizeof(float)); \n  if(points == NULL) return 0; \n \n   \n \n  for(int j = bbym; j <= bbYM; j++) \n    for(int i = bbxm; i <= bbXM; i++) \n    { \n      const size_t index = (size_t)(j - bbym) * bbw + i - bbxm; \n      points[index * 2] = (grid * i + px) * iscale; \n      points[index * 2 + 1] = (grid * j + py) * iscale; \n    } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT", "pred": " \nstatic int dt_circle_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, \n                                  dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start1 = dt_get_wtime(); \n  double start2 = start1; \n \n   \n \n  dt_masks_point_circle_t *circle = (dt_masks_point_circle_t *)(g_list_first(form->points)->data); \n  const int wi = piece->pipe->iwidth, hi = piece->pipe->iheight; \n  const float center[2] = { circle->center[0] * wi, circle->center[1] * hi }; \n  const float radius2 = circle->radius * MIN(wi, hi) * circle->radius * MIN(wi, hi); \n  const float total = (circle->radius + circle->border) * MIN(wi, hi); \n  const float total2 = total * total; \n \n   \n \n   \n \n  const int w = roi->width; \n  const int h = roi->height; \n  const int x = roi->x; \n  const int y = roi->y; \n  const int z = roi->z; \n  const int max_radius = MAX(radius2, total2); \n  const int min_radius = MIN(radius2, total2); \n  const int max_radius2 = MAX(radius2, total2); \n  const int min_radius2 = MIN(radius2, total2); \n  const int min_radius3 = MIN(radius2, total2); \n  const int max_radius3 = MAX(radius2, total2); \n  const int min_radius4 = MIN(radius2, total2); \n  const int max_radius4 = MAX(radius2, total2); \n  const int min_radius5 = MIN(radius2, total2); \n  const int max_radius5 = MAX(radius2, total2); \n  const int min_radius6 = MIN(radius2, total2); \n  const int max_radius6 = MAX(radius2, total2); \n  const int min_radius7 = MIN(radius2, total2); \n  const int max_radius7 = MAX(radius2, total2); \n  const int min_radius8 = MIN(radius2, total2); \n  const int max_radius8 = MAX(radius2, total2); \n  const int min_radius9 = MIN(radius2, total2); \n  const int max_radius9 = MAX(radius2, total2); \n  const int min_radius10 = MIN(radius2, total2); \n  const int max_radius10 = MAX(radius2, total2); \n  const int min_radius11 = MIN(radius2, total2); \n  const int max_radius11 = MAX(radius2, total2); \n  const int min_radius12 = MIN(radius2, total2); \n  const int max_radius12 = MAX(radius2, total2); \n  const int min_radius13 = MIN(radius2, total2); \n  const int max_radius13 = MAX(radius2, total2); \n  const int min_radius14 = MIN(radius2, total2); \n  const int max_radius14 = MAX(radius2, total2); \n  const int min_radius15 = MIN(radius2, total2); \n  const int max_radius15 = MAX(radius2, total2); \n  const int min_radius16 = MIN(radius2, total2); \n  const int max_radius16 = MAX(radius2, total2); \n  const int min_radius17 = MIN(radius2, total2); \n  const int max_radius17 = MAX(radius2, total2); \n  const int min_radius18 = MIN(radius2, total2); \n  const int max_radius18 = MAX(radius2, total2); \n  const int min_radius19 = MIN(radius2, total2); \n  const int max_radius19 = MAX(radius2, total2); \n  const int min_radius20 = MIN(radius2, total2); \n  const int max_radius20 = MAX(radius2, total2); \n  const int min_radius21 = MIN(radius2, total2); \n  const int max_radius21 = MAX(radius2, total2); \n  const int min_radius22 = MIN(radius2, total2); \n  const int max_radius22 = MAX(radius2, total2); \n  const int min_radius23 = MIN(radius2, total2); \n  const int max_radius23 = MAX(radius2, total2); \n  const int min_radius24 = MIN(radius2, total2); \n  const int max_radius24 = MAX(radius2, total2); \n  const int min_radius25 = MIN(radius2, total2); \n  const int max_radius25 = MAX(radius2, total2); \n  const int min_radius26 = MIN(radius2, total2); \n  const int max_radius26 = MAX(radius2, total2); \n  const int min_radius27 = MIN(radius2, total2); \n  const int max_radius27 = MAX(radius2, total2); \n  const int min_radius28 = MIN(radius2, total2); \n  const int max_radius28 = MAX(radius2, total2); \n  const int min_radius29 = MIN(radius2, total2); \n  const int max_radius29 = MAX(radius2, total2); \n  const int min_radius30 = MIN(radius2, total2); \n  const int max_radius30 = MAX(radius2, total2); \n  const int min_radius31 = MIN(radius2, total2); \n  const int max_radius31 = MAX(radius2, total2); \n  const int min_radius32 = MIN(radius2, total2); \n  const int max_radius32 = MAX(radius2, total2); \n  const int min_radius33 = MIN(radius2, total2); \n  const int max_radius33 = MAX(radius2, total2); \n  const int min_radius34 = MIN(radius2, total2); \n  const int max_radius34 = MAX(radius2, total2); \n  const int min_radius35 = MIN(radius2, total2); \n  const int max_radius35 = MAX(radius2, total2); \n  const int min_radius36 = MIN(radius2, total2); \n  const int max_radius36 = MAX(radius2, total2); \n  const int min_radius37 = MIN(radius2, total2); \n  const int max_radius37 = MAX(radius2, total2); \n  const int min_radius38 = MIN(radius2, total2); \n  const int max_radius38 = MAX(radius2, total2); \n  const int min_radius39 = MIN(radius2, total2); \n  const int max_radius39 = MAX(radius2, total2); \n  const int min_radius40 = MIN(radius2, total2); \n  const int max_radius40 = MAX(radius2, total2); \n  const int min_radius41 = MIN(radius2, total2); \n  const int max_radius41 = MAX(radius2, total2); \n  const int min_radius42 = MIN(radius2, total2); \n  const int max_radius42 = MAX(radius2, total2); \n  const int min_radius43 = MIN(radius2, total2); \n  const int max_radius43 = MAX(radius2, total2); \n  const int min_radius44 = MIN(radius2, total2); \n  const int max_radius44 = MAX(radius2, total2); \n  const int min_radius45 = MIN(radius2, total2); \n  const int max_radius45 = MAX(radius2, total2); \n  const int min_radius46 = MIN(radius2, total2); \n  const int max_radius46 = MAX(radius2, total2); \n  const int min_radius47 = MIN(radius2, total2); \n  const int max_radius47 = MAX(radius2, total2); \n  const int min_radius48 = MIN(radius2, total2); \n  const int max_radius48 = MAX(radius2, total2); \n  const int min_radius49 = MIN(radius2, total2); \n  const int max_radius49 = MAX(radius2, total2); \n  const int min_radius50 = MIN(radius2, total2); \n  const int max_radius50 = MAX(radius2, total2); \n  const int min_radius51 = MIN(radius2, total2);"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 32; \n  tile_size[1] = 32; \n  tile_size[2] = 16; \n  tile_size[3] = 2048; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,16);t1++) { \n    lbp=max(ceild(t1,2),ceild(32*t1-Nt+3,32)); \n    ubp=min(floord(Nt+Nz-4,32),floord(16*t1+Nz+13,32)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(32*t2-Nz-12,16)),t1);t3<=min(min(min(floord(Nt+Ny-4,16),floord(16*t1+Ny+29,16)),floord(32*t2+Ny+28,16)),floord(32*t1-32*t2+Nz+Ny+27,16));t3++) { \n        for (t4=max(max(max(0,ceild(t1-127,128)),ceild(32*t2-Nz-2044,2048)),ceild(16*t3-Ny-2044,2048));t4<=min(min(min(min(floord(Nt+Nx-4,2048),floord(16*t1+Nx+29,2048)),floord(32*t2+Nx+28,2048)),floord(16*t3+Nx+12,2048)),floord(32*t1-32*t2+Nz+Nx+27,2048));t4++) { \n          for (t5=max(max(max(max(max(0,16*t1),32*t1-32*t2+1),32*t2-Nz+2),16*t3-Ny+2),2048*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,16*t1+31),32*t2+30),16*t3+14),2048*t4+2046),32*t1-32*t2+Nz+29);t5++) { \n            for (t6=max(max(32*t2,t5+1),-32*t1+32*t2+2*t5-31);t6<=min(min(32*t2+31,-32*t1+32*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(16*t3,t5+1);t7<=min(16*t3+15,t5+Ny-2);t7++) { \n                lbv=max(2048*t4,t5+1); \n                ubv=min(2048*t4+2047,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = (((((((coef[0][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (coef[1][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)])) + (coef[2][ (-t5+t6)][ (-t5+t7)][ (-t5+", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    coef[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      coef[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_v[i] = (double **) malloc(sizeof(double"}
{"label": " \nvoid extractMatrix(float complex *matrix, float complex *packed) { \n\tint f; \n \n\textern int npol; \n\textern int nstation; \n\textern int nfrequency; \n \n     \n \n    omp_set_num_threads(4); \n    { \n\tfor (f = 0; f < nfrequency; f++) { \n        int i,j,pol1,pol2; \n\t\tfor (i = 0; i < nstation; i++) { \n\t\t\tfor (j = 0; j <= i; j++) { \n\t\t\t\tint k = f * (nstation + 1) * (nstation / 2) + i * (i + 1) / 2 + j; \n\t\t\t\tfor (pol1 = 0; pol1 < npol; pol1++) { \n\t\t\t\t\tfor (pol2 = 0; pol2 < npol; pol2++) { \n\t\t\t\t\t\tint index = (k * npol + pol1) * npol + pol2; \n\t\t\t\t\t\tmatrix[(((f * nstation + i) * nstation + j) * npol + pol1) * npol + pol2] = packed[index]; \n\t\t\t\t\t\tmatrix[(((f * nstation + j) * nstation + i) * npol + pol2) * npol + pol1] = conjf(packed[index]); \n\t\t\t\t\t \n \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t} \n    }    \n \n} ", "pred": " \nvoid extractMatrix(float complex *matrix, float complex *packed) { \n\tint f; \n \n\textern int npol; \n\textern int nstation; \n\textern int nfrequency; \n \n     \n \n    omp_set_num_threads(4); \n    { \n\tfor (f = 0; f < nfrequency; f++) { \n        int i,j,pol1,pol2; \n\t\tfor (i = 0; i < nstation; i++) { \n\t\t\tfor (j = 0; j <= i; j++) { \n\t\t\t\tint k = f * (nstation + 1) * (nstation / 2) + i * (i + 1) / 2 + j; \n\t\t\t\tfor (pol1 = 0; pol1 < npol; pol1++) { \n\t\t\t\t\tfor (pol2 = 0; pol2 < npol; pol2++) { \n\t\t\t\t\t\tint index = (k * npol + pol1) * npol + pol2; \n\t\t\t\t\t\tmatrix[(((f * nstation + i) * nstation + j) * npol + pol1) * npol + pol2] = packed[index]; \n\t\t\t\t\t\tmatrix[(((f * nstation + j) * nstation + i) * npol + pol2) * npol + pol1] = packed[index]; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t} \n    } \n    omp_set_num_threads(1);"}
{"label": " \nReal** cfd_baseline(const int numCell,const int numBox){ \n \n   \n \n  Real** old_boxes = malloc(sizeof(Real*)*numBox); \n  Real** new_boxes = malloc(sizeof(Real*)*numBox); \n \n   \n \n   \n \n   \n \n  int full_numCell = numCell+2*nGhost; \n  int full_numCell2 = full_numCell*full_numCell; \n  int full_numCell3 = full_numCell*full_numCell+full_numCell; \n  int totalCells = (numCell+2*nGhost)*(numCell+2*nGhost)*(numCell+2*nGhost); \n  int flux_totalSize = numCell*numCell*(numCell+1); \n   \n   \n \n  int idx; \n  for(idx=0;idx<numBox;idx++){ \n    old_boxes[idx] = malloc(sizeof(Real)*totalCells*numComp); \n    new_boxes[idx] = malloc(sizeof(Real)*totalCells*numComp); \n  } \n \n   \n \n \n  for(idx=0;idx < numBox;idx++){ \n    Real* old_box = old_boxes[idx]; \n    Real* new_box = new_boxes[idx]; \n    int ic,iz,iy,ix; \n \n    for(ic=0;ic<numComp;ic++){ \n      const Real phiOrigin = ic*compMultiplier; \n \n     \n \n     \n \n     \n \n     \n \n      for(iz=-nGhost;iz<(full_numCell-nGhost);iz++){ \n        for(iy=-nGhost;iy<(full_numCell-nGhost);iy++){ \n           \n \n          Real* oldp = GET_VAL_PTR(old_box,ic,iz,iy,-nGhost); \n          Real* newp = GET_VAL_PTR(new_box,ic,iz,iy,-nGhost); \n           \n \n          for(ix=-nGhost;ix<(full_numCell-nGhost);ix++){ \n            *oldp = phiOrigin + dx*((iz)+(iy)+(ix)); \n            *newp = phiOrigin + dx*((iz)+(iy)+(ix)); \n            oldp++; \n            newp++; \n            } \n          } \n      } \n    } \n  } \n \n   \n \n  double time_spent; \n  struct timeval  tv1, tv2; \n   \n   \n \n  int phi_comp_mult = ((numCell+2*nGhost)*(numCell+2*nGhost) \n                                   *(numCell+2*nGhost)); \n  const int phi_pencil_size = (numCell+2*nGhost); \n  const int flux_comp_mult = ((numCell)*(numCell)*(numCell+1)); \n \n   \n \n   \n \nprintf(\"Num Threads: %d\\n\",omp_get_max_threads()); \n  gettimeofday(&tv1, NULL); \n  for(idx=0;idx < numBox;idx++){ \n    Real* old_box = old_boxes[idx]; \n    Real* new_box = new_boxes[idx]; \n \n  int f_xu,f_yu,f_zu; \n  int flux_pencil_x; \n  int flux_pencil_y; \n    int iDir,ic,iz,iy,ix; \n    int phiOffset1,phiOffset2,fluxOffset1; \n     \n \n    Real* fluxCache = malloc(sizeof(Real)*numCell*numCell*(numCell+1)*numComp); \n     \n \n     \n \n    Real* velCache = malloc(sizeof(Real)*numCell*numCell*(numCell+1)); \n \n     \n \n    for(iDir=0;iDir<3;iDir++){ \n \n       \n \n      if(iDir == 0){ \n        f_zu = numCell; \n    f_yu = numCell; \n    f_xu = numCell+1; \n    flux_pencil_x = numCell+1; \n    flux_pencil_y = numCell; \n        phiOffset1 = 1; \n        phiOffset2 = 2; \n        fluxOffset1 = 1; \n      }else if(iDir == 1){ \n        f_zu = numCell; \n    f_yu = numCell+1; \n    f_xu = numCell; \n    flux_pencil_x = numCell; \n    flux_pencil_y = numCell+1; \n        phiOffset1 = phi_pencil_size; \n        phiOffset2 = phi_pencil_size*2; \n    fluxOffset1 = numCell; \n      }else if(iDir == 2){ \n        f_zu = numCell+1; \n    f_yu = numCell; \n    f_xu = numCell; \n    flux_pencil_x = numCell; \n    flux_pencil_y = numCell; \n        phiOffset1 = phi_pencil_size*phi_pencil_size; \n        phiOffset2 = phi_pencil_size*phi_pencil_size*2; \n    fluxOffset1 = numCell*numCell; \n      } \n \n \n       \n \n      for(ic=0;ic<numComp;ic++){ \n         \n \n        for(iz=0;iz<f_zu;iz++){ \n          for(iy=0;iy<f_yu;iy++){ \n            Real* phip = GET_VAL_PTR(old_box,ic,iz,iy,0);  \n            Real* fluxp = GET_FACE_VAL_PTR(iDir,fluxCache,ic,iz,iy,0); \n            for(ix=0;ix<f_xu;ix++){ \n              *fluxp = factor1* \n                       ((*(phip - phiOffset2)) + \n                     7*((*(phip - phiOffset1)) + (*(phip))) + \n                        (*(phip + phiOffset1))); \n              ++phip; \n              ++fluxp; \n            } \n          } \n        } \n      } \n \n       \n \n      memcpy(velCache, \n             (fluxCache+(iDir+2)*((numCell+1)*numCell*numCell)), \n             sizeof(Real)*numCell*numCell*(numCell+1)); \n   \n      for(ic=0;ic<numComp;ic++){ \n        for(iz=0;iz<f_zu;iz++){ \n          for(iy=0;iy<f_yu;iy++){ \n            ", "pred": " \nReal** cfd_baseline(const int numCell,const int numBox){ \n \n   \n \n  Real** old_boxes = malloc(sizeof(Real*)*numBox); \n  Real** new_boxes = malloc(sizeof(Real*)*numBox); \n \n   \n \n   \n \n   \n \n  int full_numCell = numCell+2*nGhost; \n  int full_numCell2 = full_numCell*full_numCell; \n  int full_numCell3 = full_numCell*full_numCell+full_numCell; \n  int totalCells = (numCell+2*nGhost)*(numCell+2*nGhost)*(numCell+2*nGhost); \n  int flux_totalSize = numCell*numCell*(numCell+1); \n   \n   \n \n  int idx; \n  for(idx=0;idx<numBox;idx++){ \n    old_boxes[idx] = malloc(sizeof(Real)*totalCells*numComp); \n    new_boxes[idx] = malloc(sizeof(Real)*totalCells*numComp); \n  } \n \n   \n \n \n  for(idx=0;idx < numBox;idx++){ \n    Real* old_box = old_boxes[idx]; \n    Real* new_box = new_boxes[idx]; \n    int box_size = numCell*numCell; \n    int box_size2 = numCell*numCell*numCell; \n    int box_size3 = numCell*numCell*numCell*numCell; \n    int box_size4 = numCell*numCell*numCell*numCell*numCell; \n    int box_size5 = numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size6 = numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size7 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size8 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size9 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size10 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size11 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size12 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size13 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size14 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size15 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size16 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size17 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size18 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size19 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size20 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size21 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size22 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size23 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size24 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size25 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size26 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size27 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size28 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size29 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell; \n    int box_size30 = numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*numCell*"}
{"label": " \nstatic float one_iteration (const TestSequence * seqs, int num_seqs) \n{ \n  const int qp_base = 28; \n  const int qp_step = 4; \n  double bdr_values[num_seqs]; \n \n   \n \n \n \n \n   \n \n  for (int i = 0; i < num_seqs; i++) { \n    const TestSequence * seq = &seqs[i]; \n    double psnr [4]; \n    double bitrate [4]; \n \n    for (int j = 0; j < 4; j++) { \n \n       \n \n       \n \n       \n \n \n      FILE * file; \n      if (!(file = fopen(seq->path, \"rb\"))) { \n        fprintf(stderr, \"Could not open input file `%s'\\n\", seq->path); \n        exit (1); \n      } \n \n      int qp = qp_base + j * qp_step; \n      bool ok = encode (file, seq->width, seq->height, seq->frames, seq->fps, qp, \n                        &psnr[j], &bitrate[j]); \n      if (!ok) \n        fprintf (stderr, \"ERROR WHILE ENCODING!!!\\n\"); \n \n      fclose (file); \n    } \n    bdr_values[i] = bdr (seq->psnr_ref, psnr, seq->bitrate_ref, bitrate); \n     \n \n  } \n     \n  double sum = 0; \n  for (int i = 0; i < num_seqs; i++) \n    sum += bdr_values[i]; \n \n  return  sum / num_seqs; \n} ", "pred": " \nstatic float one_iteration (const TestSequence * seqs, int num_seqs) \n{ \n  const int qp_base = 28; \n  const int qp_step = 4; \n  double bdr_values[num_seqs]; \n \n   \n \n \n \n \n   \n \n  for (int i = 0; i < num_seqs; i++) { \n    const TestSequence * seq = &seqs[i]; \n    double psnr [4]; \n    double bitrate [4]; \n \n    for (int j = 0; j < 4; j++) { \n \n       \n \n       \n \n       \n \n \n      FILE * file; \n      if (!(file = fopen(seq->path, \"rb\"))) { \n        fprintf(stderr, \"Could not open input file `%s'\\n\", seq->path); \n        exit (1); \n      } \n \n      int qp = qp_base + j * qp_step; \n      bool ok = encode (file, seq->width, seq->height, seq->frames, seq->fps, qp, \n                        seq->path, seq->path, seq->path, seq->path, seq->path, \n                        seq->path, seq->path, seq->path, seq->path, seq->path, \n                        seq->path, seq->path, seq->path, seq->path, seq->path, \n                        seq->path, seq->path, seq->path, seq->path, seq->path, \n     "}
{"label": " \nstatic void FFTW(task_callback)(void *(*work)(char *), char *jobdata, size_t elsize, int njobs, void *data){ \n\t(void)data; \n\t \n \n\t \n \n\tif(NTHREAD>1&&!omp_in_parallel()){ \n\t\tfor(int i=0; i<njobs; ++i){ \n\t\t\twork(jobdata+elsize*i); \n\t\t} \n\t}else{ \n\t\tfor(int i=0; i<njobs; ++i){ \n\t\t\twork(jobdata+elsize*i); \n\t\t} \n\t} \n\ttp_counter_t group={0}; \n\tfor(int i=0; i<njobs; ++i){ \n\t\tQUEUE(&group, work, jobdata+elsize*i, 1, 1); \n\t} \n\tWAIT(&group, 1); \n} ", "pred": " \nstatic void FFTW(task_callback)(void *(*work)(char *), char *jobdata, size_t elsize, int njobs, void *data){ \n\t(void)data; \n\t \n \n\t \n \n\tif(NTHREAD>1&&!omp_in_parallel()){ \n\t\tfor(int i=0; i<njobs; ++i){ \n\t\t\twork(jobdata+elsize*i); \n\t\t} \n\t}else{ \n\t\tfor(int i=0; i<njobs; ++i){ \n\t\t\twork(jobdata+elsize*i); \n\t\t} \n\t} \n\ttp_counter_t group={0}; \n\tfor(int i=0; i<njobs; ++i){ \n\t\tQUEUE(&group, work, jobdata+elsize*i, 1, 1); \n\t} \n\tWAIT(&group, 1); \n} "}
{"label": " \nstatic int nn_(SpatialConvolution_updateOutput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n \n  THTensor *weight = luaT_getfieldcheckudata(L, 1, \"weight\", torch_Tensor); \n  THTensor *bias = luaT_getfieldcheckudata(L, 1, \"bias\", torch_Tensor); \n  THTensor *output = luaT_getfieldcheckudata(L, 1, \"output\", torch_Tensor); \n \n  int dimw = 2; \n  int dimh = 1; \n \n  luaL_argcheck(L, input->nDimension == 3 || input->nDimension == 4, 2, \"3D or 4D(batch mode) tensor expected\"); \n \n  if (input->nDimension == 4) { \n    dimw++; \n    dimh++; \n  } \n \n  { \n    long nOutputPlane = weight->size[0]; \n    long kW           = weight->size[3]; \n    long kH           = weight->size[2]; \n    long inputWidth   = input->size[dimw]; \n    long inputHeight  = input->size[dimh]; \n    long outputWidth  = (inputWidth - kW) / dW + 1; \n    long outputHeight = (inputHeight - kH) / dH + 1; \n \n    if (input->nDimension == 3) \n    { \n      long i; \n      real* bias_data; \n      real* output_data; \n \n      THTensor_(resize3d)(output, nOutputPlane, outputHeight, outputWidth); \n       \n \n      bias_data = THTensor_(data)(bias); \n      output_data = THTensor_(data)(output); \n \n      for (i=0; i<bias->size[0]; i++) \n      { \n         \n \n         \n \n        real *ptr_output = output_data + i*outputWidth*outputHeight; \n        long j; \n        for(j = 0; j < outputWidth*outputHeight; j++) \n          ptr_output[j] = bias_data[i]; \n      } \n       \n \n       \n       \n \n      THTensor_(conv2Dmv)(output, 1.0, 1.0, input, weight, dH, dW, \"V\",\"X\"); \n    } \n    else \n    { \n      real* bias_data; \n      real* output_data;  \n      long p; \n \n      THTensor_(resize4d)(output, input->size[0], nOutputPlane, outputHeight, outputWidth); \n       \n      bias_data = THTensor_(data)(bias); \n      output_data = THTensor_(data)(output); \n       \n      for (p=0; p<input->size[0]; p++) \n      { \n         \n \n        long i; \n        for (i=0; i<bias->size[0]; i++) \n        { \n          real *ptr_output = output_data + p*nOutputPlane*outputWidth*outputHeight + i*outputWidth*outputHeight; \n          long j; \n          for(j = 0; j < outputWidth*outputHeight; j++) \n            ptr_output[j] = bias_data[i]; \n        } \n      } \n       \n       \n \n      THTensor_(conv2Dmm)(output, 1.0, 1.0, input, weight, dH, dW, \"V\",\"X\"); \n    } \n  } \n  return 1; \n} ", "pred": " \nstatic int nn_(SpatialConvolution_updateOutput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n \n  THTensor *weight = luaT_getfieldcheckudata(L, 1, \"weight\", torch_Tensor); \n  THTensor *bias = luaT_getfieldcheckudata(L, 1, \"bias\", torch_Tensor); \n  THTensor *output = luaT_getfieldcheckudata(L, 1, \"output\", torch_Tensor); \n \n  int dimw = 2; \n  int dimh = 1; \n \n  luaL_argcheck(L, input->nDimension == 3 || input->nDimension == 4, 2, \"3D or 4D(batch mode) tensor expected\"); \n \n  if (input->nDimension == 4) { \n    dimw++; \n    dimh++; \n  } \n \n  { \n    long nOutputPlane = weight->size[0]; \n    long kW           = weight->size[3]; \n    long kH           = weight->size[2]; \n    long kD           = weight->size[1]; \n    long kN           = weight->size[0]; \n    long kC           = weight->size[1]; \n    long kHOut        = output->size[1]; \n    long kWOut        = output->size[3]; \n    long kDOut        = output->size[2]; \n    long kNOut        = output->size[0]; \n    long kCOut        = output->size[1]; \n    long kHIn         = input->size[1]; \n    long kWIn         = input->size[3]; \n    long kDIn         = input->size[2]; \n    long kNIn         = input->size[0]; \n    long kCIn         = input->size[1]; \n    long kHOutIn      = output->size[1]; \n    long kWOutIn      = output->size[3]; \n    long kDOutIn      = output->size[2]; \n    long kNOutIn      = output->size[0]; \n    long kCOutIn      = output->size[1]; \n    long kHIn         = input->size[2]; \n    long kWIn         = input->size[3]; \n    long kDIn         = input->size[1]; \n    long kNIn         = input->size[0]; \n    long kCIn         = input->size[2]; \n    long kHOutOut     = output->size[2]; \n    long kWOutOut     = output->size[3]; \n    long kDOutOut     = output->size[1]; \n    long kNOutOut     = output->size[0]; \n    long kCOutOut     = output->size[2]; \n    long kHIn         = input->size[3]; \n    long kWIn         = input->size[2]; \n    long kDIn         = input->size[1]; \n    long kNIn         = input->size[0]; \n    long kCIn         = input->size[2]; \n    long kHOutIn      = output->size[3]; \n    long kWOutIn      = output->size[2]; \n    long kDOutIn      = output->size[1]; \n    long kNOutIn      ="}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 16; \n  tile_size[1] = 16; \n  tile_size[2] = 16; \n  tile_size[3] = 1024; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=floord(Nt-1,2);t1++) { \n    lbp=max(ceild(t1,2),ceild(4*t1-Nt+2,4)); \n    ubp=min(floord(4*Nt+Nz-9,16),floord(8*t1+Nz+2,16)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-1,2)),ceild(16*t2-Nz-3,16));t3<=min(min(min(floord(4*Nt+Ny-9,16),floord(8*t1+Ny+7,16)),floord(16*t2+Ny+3,16)),floord(16*t1-16*t2+Nz+Ny+5,16));t3++) { \n        for (t4=max(max(max(0,ceild(t1-127,128)),ceild(16*t2-Nz-1011,1024)),ceild(16*t3-Ny-1011,1024));t4<=min(min(min(min(floord(4*Nt+Nx-9,1024),floord(8*t1+Nx+7,1024)),floord(16*t2+Nx+3,1024)),floord(16*t3+Nx+3,1024)),floord(16*t1-16*t2+Nz+Nx+5,1024));t4++) { \n          for (t5=max(max(max(max(max(0,ceild(16*t2-Nz+5,4)),ceild(16*t3-Ny+5,4)),ceild(1024*t4-Nx+5,4)),2*t1),4*t1-4*t2+1);t5<=min(min(min(min(min(floord(16*t1-16*t2+Nz+10,4),Nt-1),2*t1+3),4*t2+2),4*t3+2),256*t4+254);t5++) { \n            for (t6=max(max(16*t2,4*t5+4),-16*t1+16*t2+8*t5-15);t6<=min(min(16*t2+15,-16*t1+16*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(16*t3,4*t5+4);t7<=min(16*t3+15,4*t5+Ny-5);t7++) { \n                lbv=max(1024*t4,4*t5+4); \n                ubv=min(1024*t4+1023,4*t5+Nx-5); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((2.0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) - A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (roc2[ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] * (((((coef0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (coef1 * (((((A[ t5 % 2][ (-4*t5+t6) - 1][ (-4*t5+t7)][ (-4*t", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0; j<Ny; j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n  for(t=0; t<Nt; t++){ \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      }"}
{"label": " \nstatic void __pyx_f_6spatch_3knn_8balltree_8BallTree___query_many(struct __pyx_obj_6spatch_3knn_8balltree_BallTree *__pyx_v_self, __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_queryData, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_numQueries, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_numDimensions, __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_distances, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C *__pyx_v_idx_array) { \n  __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_query_ptr; \n  __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_dist_ptr; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C *__pyx_v_idx_ptr; \n  struct __pyx_t_6spatch_3knn_8balltree_stack *__pyx_v_node_stacks; \n  int __pyx_v_i; \n  int __pyx_t_1; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_t_2; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_t_3; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_t_4; \n \n   \n \n  { \n      #ifdef WITH_THREAD \n      PyThreadState *_save; \n      Py_UNBLOCK_THREADS \n      #endif \n       \n { \n        { \n            #if ((defined(__APPLE__) || defined(__OSX__)) && (defined(__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))))) \n                #undef likely \n                #undef unlikely \n                #define likely(x)   (x) \n                #define unlikely(x) (x) \n            #endif \n            #ifdef _OPENMP \n            #endif  \n \n            { \n                 \n \n                __pyx_v_node_stacks = ((struct __pyx_t_6spatch_3knn_8balltree_stack *)1); \n \n                 \n \n                __pyx_v_node_stacks = ((struct __pyx_t_6spatch_3knn_8balltree_stack *)malloc(((sizeof(struct __pyx_t_6spatch_3knn_8balltree_stack)) * __pyx_v_numQueries))); \n \n                 \n \n                __pyx_t_1 = ((__pyx_v_k >= 5)!= 0); \n                if (__pyx_t_1) { \n \n                   \n \n                  __pyx_t_2 = __pyx_v_numQueries; \n                  if (1 == 0) abort(); \n                  { \n                      __pyx_t_4 = (__pyx_t_2 - 0) / 1; \n                      if (__pyx_t_4 > 0) \n                      { \n                          #ifdef _OPENMP \n                          #endif  \n \n                          for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_4; __pyx_t_3++){ \n                              { \n                                  __pyx_v_i = 0 + 1 * __pyx_t_3; \n                                   \n \n                                  __pyx_v_idx_ptr = ((__pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C *)1); \n                                  __pyx_v_dist_ptr = ((__pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *)1); \n                                  __pyx_v_query_ptr = ((__pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *)1); \n \n                                   \n \n                                  __pyx_f_6spatch_3knn_8balltree_stack_create((&(__pyx_v_node_stacks[__pyx_v_i])), (__pyx_v_self->n_levels + 1)); \n \n                                   \n \n                                  __pyx_v_query_ptr = (__pyx_v_queryData + (__pyx_v_i * __pyx_v_numDimensions)); \n \n                                   \n \n                                  __pyx_v_dist_ptr = (__pyx_v_distances + (__pyx_v_i * __pyx_v_k)); \n \n                                   \n \n                                  __pyx_v_idx_ptr = (__pyx_v_idx_array + (__pyx", "pred": " \nstatic void __pyx_f_6spatch_3knn_8balltree_8BallTree___query_many(struct __pyx_obj_6spatch_3knn_8balltree_BallTree *__pyx_v_self, __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_queryData, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_numQueries, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_numDimensions, __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_distances, __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C *__pyx_v_idx_array) { \n  __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_query_ptr; \n  __pyx_t_6spatch_3knn_8balltree_DATA_TYPE_C *__pyx_v_distances_ptr; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C *__pyx_v_idx_array_ptr; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_i; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_j; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_stride; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_count; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_count; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_offset; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_count_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_count_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_offset_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_offset_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_start_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_start_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_end_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_end_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_count_start_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_count_start_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_count_end_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_count_end_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_start_start_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_start_start_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_end_start_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_end_start_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_end_end_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_end_end_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_count_start_start_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_count_start_start_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_count_end_start_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_count_end_start_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_count_end_end_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_count_end_end_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_start_start_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_start_start_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_end_start_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_end_start_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_end_end_start; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_stride_end_end_end; \n  __pyx_t_6spatch_3knn_8balltree_INDEX_TYPE_C __pyx_v_k_offset_count_"}
{"label": " \nMagickExport MagickBooleanType ProfileImage(Image *image,const char *name, \n  const void *datum,const size_t length,ExceptionInfo *exception) \n{ \n#define ProfileImageTag  \"Profile/Image\" \n#define ThrowProfileException(severity,tag,context)  {    if (source_profile!= (cmsHPROFILE) NULL)      (void) cmsCloseProfile(source_profile);    if (target_profile!= (cmsHPROFILE) NULL)      (void) cmsCloseProfile(target_profile);    ThrowBinaryException(severity,tag,context);  } \n \n  MagickBooleanType \n    status; \n \n  StringInfo \n    *profile; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(name!= (const char *) NULL); \n  if ((datum == (const void *) NULL) || (length == 0)) \n    { \n      char \n        **arguments, \n        *names; \n \n      int \n        number_arguments; \n \n      register ssize_t \n        i; \n \n       \n \n      names=ConstantString(name); \n      (void) SubstituteString(&names,\",\",\" \"); \n      arguments=StringToArgv(names,&number_arguments); \n      names=DestroyString(names); \n      if (arguments == (char **) NULL) \n        return(MagickTrue); \n      ResetImageProfileIterator(image); \n      for (name=GetNextImageProfile(image); name!= (const char *) NULL; ) \n      { \n        for (i=1; i < (ssize_t) number_arguments; i++) \n        { \n          if ((*arguments[i] == '!') && \n              (LocaleCompare(name,arguments[i]+1) == 0)) \n            break; \n          if (GlobExpression(name,arguments[i],MagickTrue)!= MagickFalse) \n            { \n              (void) DeleteImageProfile(image,name); \n              break; \n            } \n        } \n        name=GetNextImageProfile(image); \n      } \n      for (i=0; i < (ssize_t) number_arguments; i++) \n        arguments[i]=DestroyString(arguments[i]); \n      arguments=(char **) RelinquishMagickMemory(arguments); \n      return(MagickTrue); \n    } \n   \n \n  status=MagickTrue; \n  profile=AcquireStringInfo((size_t) length); \n  SetStringInfoDatum(profile,(unsigned char *) datum); \n  if ((LocaleCompare(name,\"icc\")!= 0) && (LocaleCompare(name,\"icm\")!= 0)) \n    status=SetImageProfile(image,name,profile,exception); \n  else \n    { \n      const StringInfo \n        *icc_profile; \n \n      icc_profile=GetImageProfile(image,\"icc\"); \n      if ((icc_profile!= (const StringInfo *) NULL) && \n          (CompareStringInfo(icc_profile,profile) == 0)) \n        { \n          const char \n            *value; \n \n          value=GetImageProperty(image,\"exif:ColorSpace\",exception); \n          (void) value; \n           \n \n          icc_profile=GetImageProfile(image,\"icc\"); \n        } \n      if ((icc_profile!= (const StringInfo *) NULL) && \n          (CompareStringInfo(icc_profile,profile) == 0)) \n        { \n          profile=DestroyStringInfo(profile); \n          return(MagickTrue); \n        } \n      (void) ThrowMagickException(exception,GetMagickModule(), \n        MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\", \n        \"'%s' (LCMS)\",image->filename); \n      { \n        cmsHPROFILE \n          source_profile; \n \n        CMSExceptionInfo \n          cms_exception; \n \n         \n \n        cmsSetLogErrorHandler(CMSExceptionHandler); \n        cms_exception.image=image; \n        cms_exception.exception=exception; \n        (void) cms_exception; \n        source_profile=cmsOpenProfileFromMemTHR(&cms_exception, \n          GetStringInfoDatum(profile),(cmsUInt32Number) \n          GetStringInfoLength(profile)); \n        if (source_profile == (cmsHPROFILE) NULL) \n          ThrowBinaryException(ResourceLimitError, \n            \"ColorspaceColorProfileMismatch\",name); \n        if ((cmsGetDeviceClass(source_profile)!= cmsSigLinkClass) && \n            (icc_profile == (StringInfo *) NULL)) \n          status=SetImageProfile(image,name,profile,exception); \n        else \n          { \n            CacheView \n              *image_view; \n \n            ColorspaceType \n              source_colorspace, \n              target_colorspace; \n \n            cmsColorSpaceSignature \n              signature; \n \n            cmsHPROFILE \n              target_profile; \n \n            cmsHTRANSFORM \n              *restrict transform; \n \n            cmsUInt32Number \n              flags, \n              source_type, \n              target_type; \n \n            int \n              intent; \n \n            MagickBooleanType \n              status; \n \n            MagickOffsetType \n              progress; \n \n            size_t \n              source_channels, \n              target_channels; \n \n            ssize_t \n              y; \n \n            unsigned short \n              **restrict source_pixels, \n    ", "pred": " \nMagickExport MagickBooleanType ProfileImage(Image *image,const char *name, \n  const void *datum,const size_t length,ExceptionInfo *exception) \n{ \n#define ProfileImageTag  \"Profile/Image\" \n#define ThrowProfileException(severity,tag,context)  {    if (source_profile!= (cmsHPROFILE) NULL)      (void) cmsCloseProfile(source_profile);    if (target_profile!= (cmsHPROFILE) NULL)      (void) cmsCloseProfile(target_profile);    ThrowBinaryException(severity,tag,context);  } \n \n  MagickBooleanType \n    status; \n \n  StringInfo \n    *profile; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(name!= (const char *) NULL); \n  if ((datum == (const void *) NULL) || (length == 0)) \n    { \n      char \n        **arguments, \n        *names; \n \n      arguments=GetCommandOption(MagickProfileOptions,MagickFalse,0); \n      if (arguments == (char **) NULL) \n        ThrowProfileException(ResourceLimitError,\"MemoryAllocationFailed\",\n          GetExceptionMessage(errno)); \n \n      names=GetCommandOption(MagickProfileOptions,MagickFalse,0); \n      if (names == (char **) NULL) \n        ThrowProfileException(ResourceLimitError,\"MemoryAllocationFailed\",\n          GetExceptionMessage(errno)); \n \n      (void) ConcatenateString(&arguments,arguments); \n      (void) ConcatenateString(&names,names); \n \n      if (arguments!= (char **) NULL) \n        arguments=DestroyString(arguments); \n \n      if (names!= (char **) NULL) \n        names=DestroyString(names); \n \n      if (image->debug!= MagickFalse) \n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "}
{"label": " \nvoid vec_mult(float *p, int n) \n{ \n  float *v1, *v2; \n  int i; \n \n      { \n\tif (omp_is_initial_device ()) \n\t  abort (); \n \n\tv1 = (float *) malloc (n * sizeof (float)); \n\tv2 = (float *) malloc (n * sizeof (float)); \n \n\tinit (v1, v2, n); \n      } \n \n      { \n\tif (omp_is_initial_device ()) \n\t  abort (); \n \n\t  for (i = 0; i < n; i++) \n\t    p[i] = v1[i] * v2[i]; \n \n\t  free (v1); \n\t  free (v2); \n      } \n \n} ", "pred": " \nvoid vec_mult(float *p, int n) \n{ \n  float *v1, *v2; \n  int i; \n \n      { \n\tif (omp_is_initial_device ()) \n\t  abort (); \n \n\tv1 = (float *) malloc (n * sizeof (float)); \n\tv2 = (float *) malloc (n * sizeof (float)); \n \n\tinit (v1, v2, n); \n      } \n \n      { \n\tif (omp_is_initial_device ()) \n\t  abort (); \n \n\t  for (i = 0; i < n; i++) \n\t    p[i] = v1[i] * v2[i]; \n \n\t  free (v1); \n\t  free (v2); \n      } \n \n} "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 4; \n  tile_size[3] = 1024; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,12);t1++) { \n    lbp=max(ceild(t1,2),ceild(24*t1-Nt+3,24)); \n    ubp=min(floord(Nt+Nz-4,24),floord(12*t1+Nz+9,24)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(24*t2-Nz,4)),3*t1);t3<=min(min(min(floord(Nt+Ny-4,4),floord(12*t1+Ny+21,4)),floord(24*t2+Ny+20,4)),floord(24*t1-24*t2+Nz+Ny+19,4));t3++) { \n        for (t4=max(max(max(0,ceild(3*t1-255,256)),ceild(24*t2-Nz-1020,1024)),ceild(4*t3-Ny-1020,1024));t4<=min(min(min(min(floord(4*t3+Nx,1024),floord(Nt+Nx-4,1024)),floord(12*t1+Nx+21,1024)),floord(24*t2+Nx+20,1024)),floord(24*t1-24*t2+Nz+Nx+19,1024));t4++) { \n          for (t5=max(max(max(max(max(0,12*t1),24*t1-24*t2+1),24*t2-Nz+2),4*t3-Ny+2),1024*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,12*t1+23),24*t2+22),4*t3+2),1024*t4+1022),24*t1-24*t2+Nz+21);t5++) { \n            for (t6=max(max(24*t2,t5+1),-24*t1+24*t2+2*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(4*t3,t5+1);t7<=min(4*t3+3,t5+Ny-2);t7++) { \n                lbv=max(1024*t4,t5+1); \n                ubv=min(1024*t4+1023,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = (((((((coef[0][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (coef[1][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)])) + (coef[2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    coef[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      coef[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_v[i] = (double **) malloc(sizeof(double"}
{"label": " \nint main (int argc, char **argv){ \n    int i,j,k,MatrixDim; \n    FP_NUMBER sum, *L, *U, *A; \n    FILE *fl,*fu,*fa; \n \n    if ( argc < 2) { \n        printf(\"./gen_input [Matrix_Dimension_size]\\n\"); \n        return 1; \n    } \n \n    MatrixDim = atoi(argv[1]); \n    L = (FP_NUMBER *) malloc(sizeof(FP_NUMBER*)*MatrixDim*MatrixDim); \n    U = (FP_NUMBER *) malloc(sizeof(FP_NUMBER*)*MatrixDim*MatrixDim); \n    A = (FP_NUMBER *) malloc(sizeof(FP_NUMBER*)*MatrixDim*MatrixDim); \n \n    if (!L ||!U ||!A){ \n        printf(\"Can not allocate memory\\n\"); \n        if (L) free(L); \n        if (U) free(U); \n        if (A) free(A); \n        return 1; \n    } \n \n    srand(time(NULL)); \n \n    sprintf(L_FNAME, \"l-%d.dat\", MatrixDim); \n    fl = fopen(L_FNAME, \"wb\"); \n    if (fl == NULL) { \n        printf(\"Cannot open file %s\\n\", L_FNAME); \n        return 1; \n    } \n \n    sprintf(U_FNAME, \"u-%d.dat\", MatrixDim); \n    fu = fopen(U_FNAME, \"wb\"); \n    if (fu == NULL) { \n        printf(\"Cannot open file %s\\n\", U_FNAME); \n        return 1; \n    } \n \n    sprintf(A_FNAME, \"%d.dat\", MatrixDim); \n    fa = fopen(A_FNAME, \"wb\"); \n    if (!fa) { \n        printf(\"Cannot open file %s\\n\", A_FNAME); \n        return 1; \n    } \n \n    for (i=0; i < MatrixDim; i ++){ \n        for (j=0; j < MatrixDim; j++){ \n            if ( i == j) { \n                L[i * MatrixDim + j] = 1.0; \n                U[i * MatrixDim + j] = GET_RAND_FP; \n            } else if (i < j){ \n                L[i * MatrixDim + j] = 0; \n                U[i * MatrixDim + j] = GET_RAND_FP; \n            } else {  \n \n                L[i * MatrixDim + j] = GET_RAND_FP; \n                U[i * MatrixDim + j] = 0; \n            } \n        } \n    } \n \n    for (i=0; i < MatrixDim; i++ ) { \n        for (j=0; j < MatrixDim; j++){ \n            sum = 0; \n            for(k=0; k < MatrixDim; k++) \n                sum += L[i * MatrixDim + k]*U[k * MatrixDim + j]; \n            A[i * MatrixDim + j] = sum; \n        } \n    } \n \n    for (i=0; i < MatrixDim; i ++) { \n        for (j=0; j < MatrixDim; j++) \n            fprintf(fl, \"%f \", L[i * MatrixDim + j]); \n        fprintf(fl, \"\\n\"); \n    } \n    fclose(fl); \n \n    for (i=0; i < MatrixDim; i ++) { \n        for (j=0; j < MatrixDim; j++) \n            fprintf(fu, \"%f \", U[i * MatrixDim + j]); \n        fprintf(fu, \"\\n\"); \n    } \n    fclose(fu); \n \n    fprintf(fa, \"%d\\n\", MatrixDim); \n    for (i=0; i < MatrixDim; i ++) { \n        for (j=0; j < MatrixDim; j++) \n            fprintf(fa, \"%f \", A[i * MatrixDim + j]); \n        fprintf(fa, \"\\n\"); \n    } \n    fclose(fa); \n \n    free(L); \n    free(U); \n    free(A); \n \n    return 0; \n} ", "pred": " \nint main (int argc, char **argv){ \n    int i,j,k,MatrixDim; \n    FP_NUMBER sum, *L, *U, *A; \n    FILE *fl,*fu,*fa; \n \n    if ( argc < 2) { \n        printf(\"./gen_input [Matrix_Dimension_size]\\n\"); \n        return 1; \n    } \n \n    MatrixDim = atoi(argv[1]); \n    L = (FP_NUMBER *) malloc(sizeof(FP_NUMBER*)*MatrixDim*MatrixDim); \n    U = (FP_NUMBER *) malloc(sizeof(FP_NUMBER*)*MatrixDim*MatrixDim); \n    A = (FP_NUMBER *) malloc(sizeof(FP_NUMBER*)*MatrixDim*MatrixDim); \n \n    if (!L ||!U ||!A){ \n        printf(\"Can not allocate memory\\n\"); \n        if (L) free(L); \n        if (U) free(U); \n        if (A) free(A); \n        return 1; \n    } \n \n    for (i=0; i<MatrixDim; i++){ \n        for (j=0; j<MatrixDim; j++){ \n            L[i*MatrixDim+j] = 0; \n            U[i*MatrixDim+j] = 0; \n            A[i*MatrixDim+j] = 0; \n        } \n    } \n \n    for (i=0; i<MatrixDim; i++){ \n        for (j=0; j<MatrixDim; j++){ \n            for (k=0; k<MatrixDim; k++){ \n                if (i==j) { \n                    L[i*MatrixDim+j] += A[i*MatrixDim+k]; \n                    U[i*MatrixDim+j] += A[i*MatrixDim+k]; \n                    A[i*MatrixDim+k] = 0; \n                } \n                else { \n                    L[i*MatrixDim+j] += A[i*MatrixDim+k]; \n                    U[i*MatrixDim+j] += A[i*MatrixDim+k]; \n                    A[i*MatrixDim+k] = 0; \n                } \n            } \n        } \n    } \n \n    for (i=0; i<MatrixDim; i++){ \n        for (j=0; j<MatrixDim; j++){ \n            for (k=0; k<MatrixDim; k++){ \n                if (i==j) { \n                    L[i*MatrixDim+j] += A[i*MatrixDim+k]; \n                    U[i*MatrixDim+j] += A[i*MatrixDim+k]; \n                    A[i*MatrixDim+k] = 0; \n                } \n                else { \n                    L[i*MatrixDim+j] += A[i*MatrixDim+k]; \n                    U[i*MatrixDim+j] += A[i*MatrixDim+k]; \n                    A[i*MatrixDim+k] = 0; \n                } \n            } \n        } \n    } \n \n    for (i=0; i<MatrixDim; i++){ \n        for (j=0; j<MatrixDim; j++){ \n            for (k=0; k<MatrixDim; k++){ \n                if (i==j) { \n                    L[i*MatrixDim+j] += A[i*MatrixDim+k]; \n                    U[i*MatrixDim+j] += A[i*MatrixDim+k]; \n  "}
{"label": " \nvoid _PSWITCH(D_psi)(_PTSWITCH(spinor) * const P, _PTSWITCH(spinor) * const Q){ \n  if(P==Q){ \n    printf(\"Error in D_psi (operator.c):\\n\"); \n    printf(\"Arguments must be different spinor fields\\n\"); \n    printf(\"Program aborted\\n\"); \n    exit(1); \n  } \n   \n \n  _C_TYPE ALIGN32 phase_0l = (_C_TYPE) phase_0; \n  _C_TYPE ALIGN32 phase_1l = (_C_TYPE) phase_1; \n  _C_TYPE ALIGN32 phase_2l = (_C_TYPE) phase_2; \n  _C_TYPE ALIGN32 phase_3l = (_C_TYPE) phase_3;   \n \n  if(_PSWITCH(g_update_gauge_copy)) { \n    _PSWITCH(update_backward_gauge)(_PSWITCH(g_gauge_field)); \n  } \n# if defined TM_USE_MPI \n  _PTSWITCH(xchange_lexicfield)(Q); \n# endif \n \n  { \n \n  int ix,iy; \n  _PSWITCH(su3) * restrict up,* restrict um; \n  _PTSWITCH(spinor) * restrict rr;  \n  _PTSWITCH(spinor) const * restrict s; \n  _PTSWITCH(spinor) const * restrict sp; \n  _PTSWITCH(spinor) const * restrict sm; \n  _C_TYPE rho1, rho2; \n  _PTSWITCH(spinor) tmpr; \n \n  rho1 = (_F_TYPE)1. + (_F_TYPE) g_mu * I; \n  rho2 = conj(rho1); \n \n   \n \n \n  for (ix = 0; ix < VOLUME; ix++) { \n    rr  = (_PTSWITCH(spinor) *) P +ix; \n    s  = (_PTSWITCH(spinor) *) Q +ix; \n \n    if(g_c_sw > 0) { \n      _PSWITCH(assign_mul_one_sw_pm_imu_site_lexic)(ix, &tmpr, s, (_F_TYPE) g_mu); \n    } \n    else { \n      _complex_times_vector(tmpr.s0, rho1, s->s0); \n      _complex_times_vector(tmpr.s1, rho1, s->s1); \n      _complex_times_vector(tmpr.s2, rho2, s->s2); \n      _complex_times_vector(tmpr.s3, rho2, s->s3); \n    } \n \n     \n \n    iy=g_iup[ix][0]; \n    sp = (_PTSWITCH(spinor) *) Q +iy; \n    up=&_PSWITCH(g_gauge_field)[ix][0]; \n    _PTSWITCH(p0add)(&tmpr, sp, up, phase_0l); \n \n     \n \n    iy=g_idn[ix][0]; \n    sm  = (_PTSWITCH(spinor) *) Q +iy; \n    um=&_PSWITCH(g_gauge_field)[iy][0]; \n    _PTSWITCH(m0add)(&tmpr, sm, um, phase_0l); \n \n     \n \n    iy=g_iup[ix][1]; \n    sp = (_PTSWITCH(spinor) *) Q +iy; \n    up=&_PSWITCH(g_gauge_field)[ix][1]; \n    _PTSWITCH(p1add)(&tmpr, sp, up, phase_1l); \n \n     \n \n    iy=g_idn[ix][1]; \n    sm = (_PTSWITCH(spinor) *) Q +iy; \n    um=&_PSWITCH(g_gauge_field)[iy][1]; \n    _PTSWITCH(m1add)(&tmpr, sm, um, phase_1l); \n \n     \n \n    iy=g_iup[ix][2]; \n    sp = (_PTSWITCH(spinor) *) Q +iy; \n    up=&_PSWITCH(g_gauge_field)[ix][2]; \n    _PTSWITCH(p2add)(&tmpr, sp, up, phase_2l); \n \n     \n \n    iy=g_idn[ix][2]; \n    sm = (_PTSWITCH(spinor) *) Q +iy; \n    um=&_PSWITCH(g_gauge_field)[iy][2]; \n    _PTSWITCH(m2add)(&tmpr, sm, um, phase_2l); \n \n     \n \n    iy=g_iup[ix][3]; \n    sp = (_PTSWITCH(spinor) *) Q +iy; \n    up=&_PSWITCH(g_gauge_field)[ix][3]; \n    _PTSWITCH(p3add)(&tmpr, sp, up, phase_3l); \n \n     \n \n    iy=g_idn[ix][3]; \n    sm = (_PTSWITCH(spinor) *) Q +iy; \n    um=&_PSWITCH(g_gauge_field)[iy][3]; \n    _PTSWITCH(m3addandstore)(rr, sm, um, phase_3l, &tmpr); \n  } \n  }  \n \n} ", "pred": " \nvoid _PSWITCH(D_psi)(_PTSWITCH(spinor) * const P, _PTSWITCH(spinor) * const Q){ \n  if(P==Q){ \n    printf(\"Error in D_psi (operator.c):\\n\"); \n    printf(\"Arguments must be different spinor fields\\n\"); \n    printf(\"Program aborted\\n\"); \n    exit(1); \n  } \n   \n \n  _C_TYPE ALIGN32 phase_0l = (_C_TYPE) phase_0; \n  _C_TYPE ALIGN32 phase_1l = (_C_TYPE) phase_1; \n  _C_TYPE ALIGN32 phase_2l = (_C_TYPE) phase_2; \n  _C_TYPE ALIGN32 phase_3l = (_C_TYPE) phase_3;   \n \n  if(_PSWITCH(g_update_gauge_copy)) { \n    _PSWITCH(update_backward_gauge)(_PSWITCH(g_gauge_field)); \n  } \n# if defined TM_USE_MPI \n  _PTSWITCH(xchange_lexicfield)(Q); \n# endif \n \n  { \n \n  int ix,iy; \n  _PSWITCH(su3) * restrict up,* restrict um; \n  _PTSWITCH(spinor) * restrict spinor_l; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_l; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_l_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_l; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_l_r_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_l_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_r_l; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_r_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_l_r_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_l_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_r_l; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_l_r_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_l_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_r_l; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_l_r_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_l_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_r_l; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_l_r_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_l_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_r_l; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_l_r_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_l_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_r_l; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_l_r_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_l_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_r_l; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_l_r_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_l_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_r_l; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_l_r_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_l_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_r_l; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_l_r_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_l_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_r_l; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_l_r_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_l_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_r_l; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_l_r_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_l_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_r_l; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_l_r_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_l_r; \n  _C_TYPE ALIGN32 * restrict spinor_l_ptr_r_"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 32; \n  tile_size[3] = 2048; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0765; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,4);t1++) { \n    lbp=max(ceild(t1,2),ceild(8*t1-Nt+3,8)); \n    ubp=min(floord(Nt+Nz-4,8),floord(4*t1+Nz+1,8)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-7,8)),ceild(8*t2-Nz-28,32));t3<=min(min(min(floord(Nt+Ny-4,32),floord(4*t1+Ny+5,32)),floord(8*t2+Ny+4,32)),floord(8*t1-8*t2+Nz+Ny+3,32));t3++) { \n        for (t4=max(max(max(0,ceild(t1-511,512)),ceild(8*t2-Nz-2044,2048)),ceild(32*t3-Ny-2044,2048));t4<=min(min(min(min(floord(Nt+Nx-4,2048),floord(4*t1+Nx+5,2048)),floord(8*t2+Nx+4,2048)),floord(32*t3+Nx+28,2048)),floord(8*t1-8*t2+Nz+Nx+3,2048));t4++) { \n          for (t5=max(max(max(max(max(0,4*t1),8*t1-8*t2+1),8*t2-Nz+2),32*t3-Ny+2),2048*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,4*t1+7),8*t2+6),32*t3+30),2048*t4+2046),8*t1-8*t2+Nz+5);t5++) { \n            for (t6=max(max(8*t2,t5+1),-8*t1+8*t2+2*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(32*t3,t5+1);t7<=min(32*t3+31,t5+Ny-2);t7++) { \n                lbv=max(2048*t4,t5+1); \n                ubv=min(2048*t4+2047,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = ((alpha * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (beta * (((((A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)] + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) - 1][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8) - 1]) + A[ t5 % 2][ (-t5+t6) + 1][ (-t5+t7)][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) + 1][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8) + 1])));; \n                } \n              } \n            } \n          } \n        } \n      } \n    } \n  } \n} \n \n \n      gettimeofday(&end, 0); \n      ts_return = timeval_subtract(&result, &end, &start); \n      tdiff = (double) (result.tv_sec + result.tv_usec * 1.0e-6); \n      min", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n  for(t=0; t<Nt; t++){ \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 24; \n  tile_size[3] = 256; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0765; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,12);t1++) { \n    lbp=max(ceild(t1,2),ceild(24*t1-Nt+3,24)); \n    ubp=min(floord(Nt+Nz-4,24),floord(12*t1+Nz+9,24)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-1,2)),ceild(24*t2-Nz-20,24));t3<=min(min(min(floord(Nt+Ny-4,24),floord(12*t1+Ny+21,24)),floord(24*t2+Ny+20,24)),floord(24*t1-24*t2+Nz+Ny+19,24));t3++) { \n        for (t4=max(max(max(0,ceild(3*t1-63,64)),ceild(24*t2-Nz-252,256)),ceild(24*t3-Ny-252,256));t4<=min(min(min(min(floord(Nt+Nx-4,256),floord(12*t1+Nx+21,256)),floord(24*t2+Nx+20,256)),floord(24*t3+Nx+20,256)),floord(24*t1-24*t2+Nz+Nx+19,256));t4++) { \n          for (t5=max(max(max(max(max(0,12*t1),24*t1-24*t2+1),24*t2-Nz+2),24*t3-Ny+2),256*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,12*t1+23),24*t2+22),24*t3+22),256*t4+254),24*t1-24*t2+Nz+21);t5++) { \n            for (t6=max(max(24*t2,t5+1),-24*t1+24*t2+2*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(24*t3,t5+1);t7<=min(24*t3+23,t5+Ny-2);t7++) { \n                lbv=max(256*t4,t5+1); \n                ubv=min(256*t4+255,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = ((alpha * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (beta * (((((A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)] + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) - 1][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8) - 1]) + A[ t5 % 2][ (-t5+t6) + 1][ (-t5+t7)][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) + 1][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8) + 1])));; \n                } \n              } \n            } \n          } \n        } \n      } \n    } \n  } \n} \n \n \n      gettimeofday(&end, 0); \n      ts_return = timeval_subtract(&result, &end, &start); \n      tdiff = (double) (result.tv_sec + result.tv_usec * 1.0e-6); \n      min_", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n  for(t=0; t<Nt; t++){ \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i"}
{"label": " \nvoid traj(struct s_X **J_p_X, struct s_best *p_best, double t0, double t_end, double t_transiant, struct s_par **J_p_par, struct s_data *p_data, struct s_calc **calc, plom_f_pred_t f_pred, void *sender, void *receiver, void *controller, const enum plom_print print_opt) \n{ \n    int k, j; \n    int thread_id; \n    int nt, the_nt; \n \n    FILE *p_file_X = NULL; \n    if (print_opt & PLOM_PRINT_X) { \n        p_file_X = plom_fopen(SFR_PATH, GENERAL_ID, \"X\", \"w\", header_X, p_data); \n    } \n    FILE *p_file_hat = plom_fopen(SFR_PATH, GENERAL_ID, \"hat\", \"w\", header_hat, p_data); \n \n    struct s_hat *p_hat = build_hat(p_data); \n \n \n     \n \n    if ( (p_data->implementation == PLOM_ODE) && (t_transiant > 0.0) ) { \n        replicate_J_p_X_0(J_p_X, p_data); \n    } \n \n \n     \n \n    for(j=0;j<J;j++) { \n\treset_inc(J_p_X[j], p_data); \n\tproj2obs(J_p_X[j], p_data); \n    }\t \n \n    compute_hat_nn(J_p_X, J_p_par, p_data, calc, p_hat, 0, (int) t0-1, t0); \n    print_p_hat(p_file_hat, NULL, p_hat, p_data, t0); \n \n    if ((print_opt & PLOM_PRINT_X) && FLAG_JSON==0) { \n\tprint_X(p_file_X, J_p_par, J_p_X, p_data, calc[0], 0, 0, 0, (int) t0-1, t0); \n    } \n \n \n    for (k= (int) t0 ; k< (int) t_end ; k++) { \n \n \n        if (print_opt & PLOM_PRINT_X) { \n            if(k % 10 == 0){ \n                block(); \n            } \n        } \n \n \n        for(j=0;j<J;j++) { \n\t    thread_id = omp_get_thread_num(); \n \n            reset_inc(J_p_X[j], p_data); \n            f_pred(J_p_X[j], k, k+1, J_p_par[j], p_data, calc[thread_id]); \n            proj2obs(J_p_X[j], p_data); \n        } \n \n \n\t \n \n\tfor (nt=0; nt<calc[0]->n_threads; nt++) { \n\t    zmq_send(sender, &nt, sizeof (int), ZMQ_SNDMORE); \n\t    zmq_send(sender, &k, sizeof (int), 0); \n\t} \n \n\t \n \n\tfor (nt=0; nt<calc[0]->n_threads; nt++) { \n\t    zmq_recv(receiver, &the_nt, sizeof (int), 0);\t        \n\t} \n \n \n        compute_hat_nn(J_p_X, J_p_par, p_data, calc, p_hat, 0, k, k+1); \n        print_p_hat(p_file_hat, NULL, p_hat, p_data, k+1); \n \n        if ((print_opt & PLOM_PRINT_X) && FLAG_JSON==0) { \n            print_X(p_file_X, J_p_par, J_p_X, p_data, calc[0], 0, 0, 0, k, k+1); \n        } \n    } \n \n     \n    plom_plug_hat(p_best, p_hat, p_data); \n \n \n    clean_hat(p_hat, p_data); \n    if (print_opt & PLOM_PRINT_X) { \n        plom_fclose(p_file_X); \n    } \n    plom_fclose(p_file_hat); \n} ", "pred": " \nvoid traj(struct s_X **J_p_X, struct s_best *p_best, double t0, double t_end, double t_transiant, struct s_par **J_p_par, struct s_data *p_data, struct s_calc **calc, plom_f_pred_t f_pred, void *sender, void *receiver, void *controller, const enum plom_print print_opt) \n{ \n    int k, j; \n    int thread_id; \n    int nt, the_nt; \n \n    FILE *p_file_X = NULL; \n    if (print_opt & PLOM_PRINT_X) { \n        p_file_X = plom_fopen(SFR_PATH, GENERAL_ID, \"X\", \"w\", header_X, p_data); \n    } \n    FILE *p_file_hat = plom_fopen(SFR_PATH, GENERAL_ID, \"hat\", \"w\", header_hat, p_data); \n \n    struct s_hat *p_hat = build_hat(p_data); \n \n \n     \n \n    if ( (p_data->implementation == PLOM_IMPLEMENTATION_OMP) || (p_data->implementation == PLOM_IMPLEMENTATION_OMP_DYNAMIC) ) { \n        nt = omp_get_max_threads(); \n        the_nt = omp_get_num_threads(); \n    } \n    else { \n        nt = 1; \n        the_nt = 1; \n    } \n \n    if (print_opt & PLOM_PRINT_X) { \n        fprintf(p_file_X, \"X\\n\"); \n    } \n \n    if (print_opt & PLOM_PRINT_Y) { \n        fprintf(p_file_hat, \"hat\\n\"); \n    } \n \n    if (print_opt & PLOM_PRINT_Y_X) { \n        fprintf(p_file_hat, \"X\\n\"); \n    } \n \n    if (print_opt & PLOM_PRINT_Y_X_Y) { \n        fprintf(p_file_hat, \"X\\n\"); \n    } \n \n    if (print_opt & PLOM_PRINT_Y_X_Y_Y) { \n        fprintf(p_file_hat, \"X\\n\"); \n    } \n \n    if (print_opt & PLOM_PRINT_Y_X_Y_Y_Y) { \n        fprintf(p_file_hat, \"X\\n\"); \n    } \n \n    if (print_opt & PLOM_PRINT_Y_X_Y_Y_Y_Y) { \n        fprintf(p_file_hat, \"X\\n\"); \n    } \n \n    if (print_opt & PLOM_PRINT_Y_X_Y_Y_Y_Y_Y) { \n        fprintf(p_file_hat, \"X\\n\"); \n    } \n \n    if (print_opt & PLOM_PRINT_Y_X_Y_Y_Y_Y_Y_Y) { \n        fprintf(p_file_hat, \"X\\n\"); \n    } \n \n    if (print_opt & PLOM_PRINT_Y_X_Y_Y_Y_Y_Y_Y_Y) { \n        fprintf(p_file_hat, \"X\\n\"); \n    } \n \n    if (print_opt & PLOM_PRINT_Y_X_Y_Y_Y_Y_Y_Y_Y_Y) { \n        fprintf(p_file_hat, \"X\\n\"); \n    } \n \n    if (print_opt & PLOM_PRINT_Y_X_Y_Y_Y_Y_Y_Y_Y_Y_Y) { \n        fprintf(p_file_hat, \"X\\n\"); \n    } \n \n    if (print_opt & PLOM_PRINT_Y_X_Y_Y_Y_Y_Y_Y_Y_Y_Y_Y) { \n        fprintf(p_file_hat, \"X\\n\"); \n    } \n \n    if (print_opt & PLOM_PRINT_Y_X_Y_Y_Y_Y_Y_Y_Y_Y_Y_Y_Y) { \n        fprintf(p_file_hat, \"X\\n\"); \n    } \n \n    if (print_opt & PLOM_PRINT_Y_X_Y_Y_Y_Y_Y_Y_Y_Y_Y_Y_Y_Y) { \n        fprintf"}
{"label": " \nint main( int argc, char *argv[] ) \n{ \n\tif( argc < 4 ) { \n\t\tusage(); \n\t\treturn 1; \n\t} \n\tchar\t*inB2\t= argv[1];  \n \n\tchar\t*inB3 \t= argv[2];  \n \n\tchar\t*laiF \t= argv[3];  \n \n\tfloat offset=Null, scale=Null; \n\tif(argv[4]!= NULL && argv[5]!= NULL){ \n\t\toffset \t= atof(argv[4]);  \n \n\t\tscale \t= atof(argv[5]);  \n \n\t} \n\tGDALAllRegister(); \n\tGDALDatasetH hD2 = GDALOpen(inB2,GA_ReadOnly); \n \n\tGDALDatasetH hD3 = GDALOpen(inB3,GA_ReadOnly); \n \n\tif(hD2==NULL||hD3==NULL){ \n\t\tprintf(\"One or more input files \"); \n\t\tprintf(\"could not be loaded\\n\"); \n\t\texit(1); \n\t} \n\tGDALDriverH hDr2 = GDALGetDatasetDriver(hD2); \n\tchar **options = NULL; \n\t \n \n\t \n \n\t \n \n\tGDALDatasetH hDOut = GDALCreateCopy(hDr2,laiF,hD2,FALSE,options,NULL,NULL); \n\tGDALRasterBandH hBOut = GDALGetRasterBand(hDOut,1); \n\tGDALSetRasterNoDataValue(hBOut, NODATA); \n\tGDALRasterBandH hB2 = GDALGetRasterBand(hD2,1); \n \n\tGDALRasterBandH hB3 = GDALGetRasterBand(hD3,1); \n \n \n\tint nX = GDALGetRasterBandXSize(hB2); \n\tint nY = GDALGetRasterBandYSize(hB2); \n\tint N=nX*nY; \n \n\tfloat *l2 = (float *) malloc(sizeof(float)*N); \n\tfloat *l3 = (float *) malloc(sizeof(float)*N); \n\tfloat *lOut = (float *) malloc(sizeof(float)*N); \n\tint rc, qa; \n \n\t \n \n\tint err = 0;  \n\terr=GDALRasterIO(hB2,GF_Read,0,0,nX,nY,l2,nX,nY,GDT_Float32,0,0); \n\t \n \n\terr=GDALRasterIO(hB3,GF_Read,0,0,nX,nY,l3,nX,nY,GDT_Float32,0,0); \n\tfor(rc=0;rc<N;rc++){ \n\t\tqa=mcd15A3a(l3[rc]); \n\t\tif( qa!= 0) lOut[rc] = NODATA; \n\t\tif(offset!=Null && scale!=Null){ \n\t\t\tlOut[rc] = offset + l2[rc] * scale; \n\t\t} \n\t\telse lOut[rc] = l2[rc]; \n\t} \n\terr=GDALRasterIO(hBOut,GF_Write,0,0,nX,nY,lOut,nX,nY,GDT_Float32,0,0); \n\terr=err+1; \n\tif( l2!= NULL ) free( l2 ); \n\tif( l3!= NULL ) free( l3 ); \n\tGDALClose(hD2); \n\tGDALClose(hD3); \n\tGDALClose(hDOut); \n\treturn(EXIT_SUCCESS); \n} ", "pred": " \nint main( int argc, char *argv[] ) \n{ \n\tif( argc < 4 ) { \n\t\tusage(); \n\t\treturn 1; \n\t} \n\tchar\t*inB2\t= argv[1];  \n \n\tchar\t*inB3 \t= argv[2];  \n \n\tchar\t*laiF \t= argv[3];  \n \n\tfloat offset=Null, scale=Null; \n\tif(argv[4]!= NULL && argv[5]!= NULL){ \n\t\toffset \t= atof(argv[4]);  \n \n\t\tscale \t= atof(argv[5]);  \n \n\t} \n\tGDALAllRegister(); \n\tGDALDatasetH hD2 = GDALOpen(inB2,GA_ReadOnly); \n \n\tGDALDatasetH hD3 = GDALOpen(inB3,GA_ReadOnly); \n \n\tif(hD2==NULL||hD3==NULL){ \n\t\tprintf(\"One or more input files \"); \n\t\tprintf(\"could not be loaded\\n\"); \n\t\texit(1); \n\t} \n\tGDALDriverH hDr2 = GDALGetDatasetDriver(hD2); \n\tchar **options = NULL; \n\t \n \n\t \n \n\t \n \n\tGDALDatasetH hDOut = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDS = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut2 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut3 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut4 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut5 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut6 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut7 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut8 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut9 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut10 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut11 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut12 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut13 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut14 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut15 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut16 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut17 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut18 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut19 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDSOut20 = GDALCreate(hDr2, hD3, options); \n \n\tGDALDatasetH hDS"}
{"label": " \nvoid THNN_(HardTanh_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput, \n          real min_val, \n          real max_val) \n{ \n  THTensor_(resizeAs)(gradInput, input); \n \n  if (input->nDimension == 1 || \n   !THTensor_(isContiguous)(input) || \n   !THTensor_(isContiguous)(gradOutput) || \n   !THTensor_(isContiguous)(gradInput)) \n  { \n    TH_TENSOR_APPLY3(real, gradInput, real, gradOutput, real, input, \n      if (*input_data < min_val || *input_data > max_val) \n        *gradInput_data = 0; \n      else \n        *gradInput_data = *gradOutput_data; \n    ); \n  } \n  else \n  { \n    real* ptr_gradOutput = THTensor_(data)(gradOutput); \n    real* ptr_gradInput  = THTensor_(data)(gradInput); \n    real* ptr_input      = THTensor_(data)(input); \n    long i; \n \n    for (i = 0; i < THTensor_(nElement)(input); i++) \n    { \n      if (ptr_input[i] < min_val || ptr_input[i] > max_val) \n        ptr_gradInput[i] = 0; \n      else \n        ptr_gradInput[i] = ptr_gradOutput[i]; \n    } \n  } \n} ", "pred": " \nvoid THNN_(HardTanh_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput, \n          real min_val, \n          real max_val) \n{ \n  THTensor_(resizeAs)(gradInput, input); \n \n  if (input->nDimension == 1 || \n   !THTensor_(isContiguous)(input) || \n   !THTensor_(isContiguous)(gradOutput) || \n   !THTensor_(isContiguous)(gradInput)) \n  { \n    TH_TENSOR_APPLY3(real, gradInput, real, gradOutput, real, input, \n      if (*input_data < min_val || *input_data > max_val) \n        *gradInput_data = 0; \n      else \n        *gradInput_data = *gradOutput_data; \n    ); \n  } \n  else \n  { \n    real *gradInput_data = THTensor_(data)(gradInput); \n    real *gradOutput_data = THTensor_(data)(gradOutput); \n    real *input_data = THTensor_(data)(input); \n    real *gradInput_data_end = THTensor_(data)(gradInput); \n    real *gradOutput_data_end = THTensor_(data)(gradOutput); \n    real *input_data_end = THTensor_(data)(input); \n    while (gradInput_data < gradInput_data_end) \n    { \n      real input_val = *input_data; \n      real grad_val = *gradInput_data; \n      if (input_val < min_val || input_"}
{"label": " \nvoid kappa_get_beam_properties(ParamCoLoRe *par) \n{ \n  HealpixShells *kmap=par->kmap; \n \n \n  { \n    double idx=par->n_grid/par->l_box; \n \n     \n \n    int i_r,nr; \n    double idr,dr; \n    get_radial_params(par->r_max,par->n_grid,&nr,&dr); \n    idr=1./dr; \n \n     \n \n    int *i_r_max_arr=my_malloc(kmap->nr*sizeof(int)); \n    int *i_r_min_arr=my_malloc(kmap->nr*sizeof(int)); \n    double *inv_r_max=my_malloc(kmap->nr*sizeof(double)); \n    for(i_r=0;i_r<kmap->nr;i_r++) { \n      int i_r_here=(int)(kmap->rf[i_r]*idr+0.5); \n      inv_r_max[i_r]=1./(i_r_here*dr); \n      i_r_max_arr[i_r]=MIN(i_r_here,nr-1); \n    } \n    i_r_min_arr[0]=0; \n    for(i_r=1;i_r<kmap->nr;i_r++) \n      i_r_min_arr[i_r]=i_r_max_arr[i_r-1]+1; \n \n     \n \n    double *fac_r_1=my_malloc(nr*sizeof(double)); \n    double *fac_r_2=my_malloc(nr*sizeof(double)); \n    for(i_r=0;i_r<nr;i_r++) { \n      double rm=(i_r+0.5)*dr; \n      double pg=get_bg(par,rm,BG_D1,0)*(1+get_bg(par,rm,BG_Z,0)); \n      fac_r_1[i_r]=rm*pg*dr; \n      fac_r_2[i_r]=rm*rm*pg*dr; \n    } \n \n    long ip; \n \n    for(ip=0;ip<kmap->num_pix;ip++) { \n      int ax,added; \n      flouble t[6]; \n      double rot[6],xn[3]; \n      double kappa_1=0,kappa_2=0; \n      double *u=&(kmap->pos[3*ip]); \n      double prefac=idx*idx; \n      double cth_h=1,sth_h=0,cph_h=1,sph_h=0; \n \n      cth_h=u[2]; \n      if(cth_h>=1) cth_h=1; \n      if(cth_h<=-1) cth_h=-1; \n      sth_h=sqrt((1-cth_h)*(1+cth_h)); \n      if(sth_h!=0) { \n\tcph_h=u[0]/sth_h; \n\tsph_h=u[1]/sth_h; \n      } \n \n      rot[0]=(cth_h*cth_h*cph_h*cph_h+sph_h*sph_h)*prefac; \n      rot[1]=(2*cph_h*sph_h*(cth_h*cth_h-1))*prefac; \n      rot[2]=(-2*cth_h*sth_h*cph_h)*prefac; \n      rot[3]=(cth_h*cth_h*sph_h*sph_h+cph_h*cph_h)*prefac; \n      rot[4]=(-2*cth_h*sth_h*sph_h)*prefac; \n      rot[5]=(sth_h*sth_h)*prefac; \n      for(i_r=0;i_r<kmap->nr;i_r++) { \n\tint irr; \n\tint irmin=i_r_min_arr[i_r]; \n\tint irmax=i_r_max_arr[i_r]; \n\tfor(irr=irmin;irr<=irmax;irr++) { \n\t  double rm=(irr+0.5)*dr; \n\t  for(ax=0;ax<3;ax++) \n\t    xn[ax]=(rm*u[ax]+par->pos_obs[ax])*idx; \n\t  added=interpolate_from_grid(par,xn,NULL,NULL,t,NULL,NULL,RETURN_TID,INTERP_TYPE_LENSING); \n\t  if(added) { \n\t    double dotp=0; \n\t    for(ax=0;ax<6;ax++) \n\t      dotp+=rot[ax]*t[ax]; \n\t    kappa_1+=dotp*fac_r_1[irr]; \n\t    kappa_2+=dotp*fac_r_2[irr]; \n\t  } \n\t} \n\tkmap->data[i_r*kmap->num_pix+ip]+=(kappa_1-inv_r_max[i_r]*kappa_2); \n      } \n    }  \n \n \n    free(fac_r_1); \n    free(fac_r_2); \n    free(i_r_max_arr); \n    free(i_r_min_arr); \n    free(inv_r_max); \n  }  \n \n \n  return; \n} ", "pred": " \nvoid kappa_get_beam_properties(ParamCoLoRe *par) \n{ \n  HealpixShells *kmap=par->kmap; \n \n \n  { \n    double idx=par->n_grid/par->l_box; \n \n     \n \n    int i_r,nr; \n    double idr,dr; \n    get_radial_params(par->r_max,par->n_grid,&nr,&dr); \n    idr=1./dr; \n \n     \n \n    int *i_r_max_arr=my_malloc(kmap->nr*sizeof(int)); \n    int *i_r_min_arr=my_malloc(kmap->nr*sizeof(int)); \n    double *inv_r_max=my_malloc(kmap->nr*sizeof(double)); \n    for(i_r=0;i_r<kmap->nr;i_r++) { \n      int i_r_here=(int)(kmap->rf[i_r]*idr+0.5); \n      inv_r_max[i_r]=1./(i_r_here*dr); \n      i_r_max_arr[i_r]=i_r_here; \n      i_r_min_arr[i_r]=i_r_here; \n    } \n \n    \n    \n    int i_r_max=0; \n    int i_r_min=0; \n    double r_max=0.; \n    double r_min=0.; \n    double r_max_max=0.; \n    double r_min_max=0.; \n    double r_max_min=0.; \n    double r_min_min=0.; \n    double r_max_max_max=0.; \n    double r_min_max_max=0.; \n    double r_max_min_max=0.; \n    double r_min_min_max=0.; \n    double r_max_max_min=0.; \n    double r_min_max_min=0.; \n    double r_max_min_min=0.; \n    double r_max_max_max_max=0.; \n    double r_min_max_max_max=0.; \n    double r_max_min_max_max=0.; \n    double r_min_min_max_max=0.; \n    double r_max_max_min_max=0.; \n    double r_min_max_min_max=0.; \n    double r_max_min_min_max=0.; \n    double r_max_max_max_min=0.; \n    double r_min_max_max_min=0.; \n    double r_max_min_min_min=0.; \n    double r_max_max_min_min=0.; \n    double r_min_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_max_max_min=0.; \n    double r_max_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_max_max_min=0.; \n    double r_max_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_max_max_min=0.; \n    double r_max_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_max_max_min=0.; \n    double r_max_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_max_max_min=0.; \n    double r_max_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_max_max_min=0.; \n    double r_max_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_max_max_min=0.; \n    double r_max_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_max_max_min=0.; \n    double r_max_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min_min_min_min=0.; \n    double r_max_max_max_min=0.; \n    double r_min"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 24; \n  tile_size[3] = 2048; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,12);t1++) { \n    lbp=max(ceild(t1,2),ceild(24*t1-Nt+3,24)); \n    ubp=min(floord(Nt+Nz-4,24),floord(12*t1+Nz+9,24)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-1,2)),ceild(24*t2-Nz-20,24));t3<=min(min(min(floord(Nt+Ny-4,24),floord(12*t1+Ny+21,24)),floord(24*t2+Ny+20,24)),floord(24*t1-24*t2+Nz+Ny+19,24));t3++) { \n        for (t4=max(max(max(0,ceild(3*t1-511,512)),ceild(24*t2-Nz-2044,2048)),ceild(24*t3-Ny-2044,2048));t4<=min(min(min(min(floord(Nt+Nx-4,2048),floord(12*t1+Nx+21,2048)),floord(24*t2+Nx+20,2048)),floord(24*t3+Nx+20,2048)),floord(24*t1-24*t2+Nz+Nx+19,2048));t4++) { \n          for (t5=max(max(max(max(max(0,12*t1),24*t1-24*t2+1),24*t2-Nz+2),24*t3-Ny+2),2048*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,12*t1+23),24*t2+22),24*t3+22),2048*t4+2046),24*t1-24*t2+Nz+21);t5++) { \n            for (t6=max(max(24*t2,t5+1),-24*t1+24*t2+2*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(24*t3,t5+1);t7<=min(24*t3+23,t5+Ny-2);t7++) { \n                lbv=max(2048*t4,t5+1); \n                ubv=min(2048*t4+2047,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = (((((((coef[0][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (coef[1][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)])) + (coef[2][ (-t5+t6)][ (-t", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    coef[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      coef[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_v[i] = (double **) malloc(sizeof(double"}
{"label": " \nvoid fastsum_trafo(fastsum_plan *ths) \n{ \n  int j, k, t; \n  ticks t0, t1; \n \n  ths->MEASURE_TIME_t[4] = K(0.0); \n  ths->MEASURE_TIME_t[5] = K(0.0); \n  ths->MEASURE_TIME_t[6] = K(0.0); \n  ths->MEASURE_TIME_t[7] = K(0.0); \n \n  t0 = getticks(); \n   \n \n  NFFT(adjoint)(&(ths->mv1)); \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[4] += NFFT(elapsed_seconds)(t1,t0); \n \n  t0 = getticks(); \n   \n \n  for (k = 0; k < ths->mv2.N_total; k++) \n    ths->mv2.f_hat[k] = ths->b[k] * ths->mv1.f_hat[k]; \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[5] += nfft_elapsed_seconds(t1,t0); \n \n  t0 = getticks(); \n   \n \n  NFFT(trafo)(&(ths->mv2)); \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[6] += nfft_elapsed_seconds(t1,t0); \n \n  t0 = getticks(); \n \n   \n \n  for (j = 0; j < ths->M_total; j++) \n    ths->f[j] = ths->mv2.f[j]; \n \n  if (ths->eps_I > 0.0) \n  { \n     \n \n  #ifdef _OPENMP \n  #endif \n    for (j = 0; j < ths->M_total; j++) \n    { \n      R ymin[ths->d], ymax[ths->d];  \n \n \n      if (ths->flags & NEARFIELD_BOXES) \n        ths->f[j] += SearchBox(ths->y + ths->d * j, ths); \n      else \n      { \n        for (t = 0; t < ths->d; t++) \n        { \n          ymin[t] = ths->y[ths->d * j + t] - ths->eps_I; \n          ymax[t] = ths->y[ths->d * j + t] + ths->eps_I; \n        } \n        ths->f[j] \n         += SearchTree(ths->d, 0, ths->x, ths->alpha, ymin, ymax, ths->N_total, \n             ths->k, ths->kernel_param, ths->Ad, ths->Add, ths->p, ths->flags); \n      } \n    } \n  } \n \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[7] += NFFT(elapsed_seconds)(t1,t0); \n} ", "pred": " \nvoid fastsum_trafo(fastsum_plan *ths) \n{ \n  int j, k, t; \n  ticks t0, t1; \n \n  ths->MEASURE_TIME_t[4] = K(0.0); \n  ths->MEASURE_TIME_t[5] = K(0.0); \n  ths->MEASURE_TIME_t[6] = K(0.0); \n  ths->MEASURE_TIME_t[7] = K(0.0); \n \n  t0 = getticks(); \n   \n \n  NFFT(adjoint)(&(ths->mv1)); \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[4] += NFFT(elapsed_seconds)(t1,t0); \n \n  t0 = getticks(); \n   \n \n  for (k = 0; k < ths->mv2.N_total; k++) \n    ths->mv2.f_hat[k] = ths->b[k] * ths->mv1.f_hat[k]; \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[5] += nfft_elapsed_seconds(t1,t0); \n \n  t0 = getticks(); \n   \n \n  for (j = 0; j < ths->mv2.N_total; j++) \n    for (k = 0; k < ths->mv2.N_total; k++) \n      ths->mv2.f_hat[j*ths->mv2.N_total+k] = ths->mv1.f_hat[j*ths->mv1.N_total+k] * ths->mv2.f_hat[k*ths->mv2.N_total+j]; \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[6] += nfft_elapsed_seconds(t1,t0); \n \n  t0 = getticks(); \n   \n \n  for (j = 0; j < ths->mv2.N_total; j++) \n    for (k = 0; k < ths->mv2.N_total; k++) \n      ths->mv2.f_hat[j*ths->mv2.N_total+k] = ths->mv1.f_hat[j*ths->mv1.N_total+k] * ths->mv2.f_hat[k*ths->mv2.N_total+j]; \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[7] += nfft_elapsed_seconds(t1,t0); \n \n  ths->MEASURE_TIME_t[4] += NFFT(elapsed_seconds)(t1,t0); \n  ths->MEASURE_TIME_t[5] += NFFT(elapsed_seconds)(t1,t0); \n  ths->MEASURE_TIME_t[6] += NFFT(elapsed_seconds)(t1,t0); \n  ths->MEASURE_TIME_t[7] += NFFT(elapsed_seconds)(t1,t0); \n \n  return; \n} \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n"}
{"label": " \nstatic void nn_(SpatialMaxPooling_updateOutput_frame)(real *input_p, real *output_p, \n                                                      real *ind_p, \n                                                      long nslices, \n                                                      long iwidth, long iheight, \n                                                      long owidth, long oheight, \n                                                      int kW, int kH, int dW, int dH, \n                                                      int padW, int padH) \n{ \n  long k; \n  for (k = 0; k < nslices; k++) \n  { \n     \n \n    long i, j; \n    real *ip = input_p   + k*iwidth*iheight; \n    for(i = 0; i < oheight; i++) \n    { \n      for(j = 0; j < owidth; j++) \n      { \n        long hstart = i * dH - padH; \n        long wstart = j * dW - padW; \n        long hend = fminf(hstart + kH, iheight); \n        long wend = fminf(wstart + kW, iwidth); \n        hstart = fmaxf(hstart, 0); \n        wstart = fmaxf(wstart, 0); \n \n         \n \n        real *op = output_p  + k*owidth*oheight + i*owidth + j; \n        real *indp = ind_p   + k*owidth*oheight + i*owidth + j; \n \n         \n \n        long maxindex = -1; \n        real maxval = -THInf; \n        long tcntr = 0; \n        long x,y; \n        for(y = hstart; y < hend; y++) \n        { \n          for(x = wstart; x < wend; x++) \n          { \n            tcntr = y*iwidth + x; \n            real val = *(ip + tcntr); \n            if (val > maxval) \n            { \n              maxval = val; \n              maxindex = tcntr; \n            } \n          } \n        } \n \n         \n \n        *op = maxval; \n \n         \n \n        *indp = maxindex + 1; \n      } \n    } \n  } \n} ", "pred": " \nstatic void nn_(SpatialMaxPooling_updateOutput_frame)(real *input_p, real *output_p, \n                                                      real *ind_p, \n                                                      long nslices, \n                                                      long iwidth, long iheight, \n                                                      long owidth, long oheight, \n                                                      long ostride, \n                                                      long ostride_width, \n                                                      long ostride_height, \n                                                      long ostride_width_height, \n                                                      long ostride_width_height_width, \n                                                      long ostride_width_height_width_height, \n                                                      long ostride_width_height_width_height_width, \n                                                      long ostride_width_height_width_height_width_height, \n                                                      long ostride_width_height_width_height_width_height_width, \n                                                      long ostride_width_height_width_height_width_height_width_height, \n                                                      long ostride_width_height_width_height_width_height_width_height_width, \n                                                      long ostride_width_height_width_height_width_height_width_"}
{"label": "uct perturbs * ppt, \n    struct transfers * ptr, \n    struct primordial * ppm, \n    struct spectra * psp \n) { \n \n     \n \n \n     \n \n \n    int index_md; \n    int index_ic1,index_ic2,index_ic1_ic2; \n    int index_l; \n    int index_ct; \n    int cl_integrand_num_columns; \n \n    double * cl_integrand;  \n \n    double * transfer_ic1;  \n \n    double * transfer_ic2;  \n \n    double * primordial_pk;   \n \n \n     \n \n    int abort; \n \n     \n \n    double tstart, tstop; \n \n     \n \n \n    class_alloc(psp->l_size,sizeof(int)*psp->md_size,psp->error_message); \n    class_alloc(psp->cl,sizeof(double *)*psp->md_size,psp->error_message); \n    class_alloc(psp->ddcl,sizeof(double *)*psp->md_size,psp->error_message); \n \n    psp->l_size_max = ptr->l_size_max; \n    class_alloc(psp->l,sizeof(double)*psp->l_size_max,psp->error_message); \n \n     \n \n    for (index_l=0; index_l < psp->l_size_max; index_l++) { \n        psp->l[index_l] = (double)ptr->l[index_l]; \n    } \n \n     \n \n \n    for (index_md = 0; index_md < psp->md_size; index_md++) { \n \n         \n \n \n        psp->l_size[index_md] = ptr->l_size[index_md]; \n \n         \n \n \n        class_alloc(psp->cl[index_md],sizeof(double)*psp->l_size[index_md]*psp->ct_size*psp->ic_ic_size[index_md],psp->error_message); \n        class_alloc(psp->ddcl[index_md],sizeof(double)*psp->l_size[index_md]*psp->ct_size*psp->ic_ic_size[index_md],psp->error_message); \n        cl_integrand_num_columns = 1+psp->ct_size*2;  \n \n \n         \n \n \n        for (index_ic1 = 0; index_ic1 < psp->ic_size[index_md]; index_ic1++) { \n            for (index_ic2 = index_ic1; index_ic2 < psp->ic_size[index_md]; index_ic2++) { \n                index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,psp->ic_size[index_md]); \n \n                 \n \n                if (psp->is_non_zero[index_md][index_ic1_ic2] == _TRUE_) { \n \n                     \n \n                    abort = _FALSE_; \n \n                     \n \n \n \n                    { \n \n                        tstart = omp_get_wtime(); \n \n                        class_alloc_parallel(cl_integrand, \n                                             ptr->q_size*cl_integrand_num_columns*sizeof(double), \n                                             psp->error_message); \n \n                        class_alloc_parallel(primordial_pk, \n                                             psp->ic_ic_size[index_md]*sizeof(double), \n                                             psp->error_message); \n \n                        class_alloc_parallel(transfer_ic1, \n                                             ptr->tt_size[index_md]*sizeof(double), \n                                             psp->error_message); \n \n                        class_alloc_parallel(transfer_ic2, \n                                             ptr->tt_size[index_md]*sizeof(double), \n                                             psp->error_message); \n \n \n                         \n \n \n                        for (index_l=0; index_l < ptr->l_size[index_md]; index_l++) { \n \n \n                            class_call_parallel(spectra_compute_cl(pba, \n                                                                   ppt, \n                                                                   ptr, \n                                                                   ppm, \n                                                                   psp, \n                                                       ", "pred": "uct perturbs * ppt, \n    struct transfers * ptr, \n    struct primordial * ppm, \n    struct spectra * psp \n) { \n \n     \n \n \n     \n \n \n    int index_md; \n    int index_ic1,index_ic2,index_ic1_ic2; \n    int index_l; \n    int index_ct; \n    int cl_integrand_num_columns; \n \n    double * cl_integrand;  \n \n    double * transfer_ic1;  \n \n    double * transfer_ic2;  \n \n    double * primordial_pk;   \n \n \n     \n \n    int abort; \n \n     \n \n    double tstart, tstop; \n \n     \n \n \n    class_alloc(psp->l_size,sizeof(int)*psp->md_size,psp->error_message); \n    class_alloc(psp->cl,sizeof(double *)*psp->md_size,psp->error_message); \n    class_alloc(psp->ddcl,sizeof(double *)*psp->md_size,psp->error_message); \n    class_alloc(psp->ddcl_ic1,sizeof(double *)*psp->md_size,psp->error_message); \n    class_alloc(psp->ddcl_ic2,sizeof(double *)*psp->md_size,psp->error_message); \n    class_alloc(psp->ddcl_ic1_ic2,sizeof(double *)*psp->md_size,psp->error_message); \n    class_alloc(psp->ddcl_ic2_ic1,sizeof(double *)*psp->md_size,psp->error_message); \n \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n   "}
{"label": " \nstatic void fastsum_precompute_kernel(fastsum_plan *ths) \n{ \n  int j, k, t; \n  INT N[ths->d]; \n  int n_total; \n  ticks t0, t1; \n \n  ths->MEASURE_TIME_t[0] = K(0.0); \n \n  t0 = getticks(); \n   \n \n  if (ths->eps_I > 0.0 &&!(ths->flags & EXACT_NEARFIELD)) \n  { \n    if (ths->d == 1) \n      for (k = -ths->Ad / 2 - 2; k <= ths->Ad / 2 + 2; k++) \n        ths->Add[k + ths->Ad / 2 + 2] = regkern1(ths->k, \n            ths->eps_I * (R) k / (R)(ths->Ad) * K(2.0), ths->p, ths->kernel_param, \n            ths->eps_I, ths->eps_B); \n    else \n      for (k = 0; k <= ths->Ad + 2; k++) \n        ths->Add[k] = regkern3(ths->k, ths->eps_I * (R) k / (R)(ths->Ad), ths->p, \n            ths->kernel_param, ths->eps_I, ths->eps_B); \n  } \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[0] += NFFT(elapsed_seconds)(t1,t0); \n \n  t0 = getticks(); \n   \n \n  n_total = 1; \n  for (t = 0; t < ths->d; t++) \n    n_total *= ths->n; \n \n  for (j = 0; j < n_total; j++) \n  { \n    if (ths->d == 1) \n      ths->b[j] = regkern1(ths->k, (R) - (j / (R)(ths->n) - K(0.5)), ths->p, \n          ths->kernel_param, ths->eps_I, ths->eps_B) / (R)(n_total); \n    else \n    { \n      k = j; \n      ths->b[j] = K(0.0); \n      for (t = 0; t < ths->d; t++) \n      { \n        ths->b[j] += ((R) (k % (ths->n)) / (R)(ths->n) - K(0.5)) \n            * ((R) (k % (ths->n)) / (R)(ths->n) - K(0.5)); \n        k = k / (ths->n); \n      } \n      ths->b[j] = regkern3(ths->k, SQRT(CREAL(ths->b[j])), ths->p, ths->kernel_param, \n          ths->eps_I, ths->eps_B) / (R)(n_total); \n    } \n  } \n \n  for (t = 0; t < ths->d; t++) \n    N[t] = ths->n; \n \n  NFFT(fftshift_complex)(ths->b, (int)(ths->d), N); \n  FFTW(execute)(ths->fft_plan); \n  NFFT(fftshift_complex)(ths->b, (int)(ths->d), N); \n  t1 = getticks(); \n  ths->MEASURE_TIME_t[0] += nfft_elapsed_seconds(t1,t0); \n} ", "pred": " \nstatic void fastsum_precompute_kernel(fastsum_plan *ths) \n{ \n  int j, k, t; \n  INT N[ths->d]; \n  int n_total; \n  ticks t0, t1; \n \n  ths->MEASURE_TIME_t[0] = K(0.0); \n \n  t0 = getticks(); \n   \n \n  if (ths->eps_I > 0.0 &&!(ths->flags & EXACT_NEARFIELD)) \n  { \n    if (ths->d == 1) \n      for (k = -ths->Ad / 2 - 2; k <= ths->Ad / 2 + 2; k++) \n        ths->Add[k + ths->Ad / 2 + 2] = regkern1(ths->k, \n            ths->eps_I * (R) k / (R)(ths->Ad) * K(2.0), ths->p, ths->kernel_param, \n            ths->eps_I, ths->eps_B); \n    else \n      for (k = 0; k <= ths->Ad + 2; k++) \n        ths->Add[k] = regkern1(ths->k, \n            ths->eps_I * (R) k / (R)(ths->Ad) * K(2.0), ths->p, ths->kernel_param, \n            ths->eps_I, ths->eps_B); \n  } \n \n  if (ths->flags & EXACT_NEARFIELD) \n  { \n    for (k = -ths->Ad / 2 - 2; k <= ths->Ad / 2 + 2; k++) \n      ths->Add[k + ths->Ad / 2 + 2] = regkern1(ths->k, \n          ths->eps_I * (R) k / (R)(ths->Ad) * K(2.0), ths->p, ths->kernel_param, \n          ths->eps_I, ths->eps_B); \n  } \n \n  if (ths->flags & EXACT_NEARFIELD) \n  { \n    for (k = 0; k <= ths->Ad + 2; k++) \n      ths->Add[k] = regkern1(ths->k, \n          ths->eps_I * (R) k / (R)(ths->Ad) * K(2.0), ths->p, ths->kernel_param, \n          ths->eps_I, ths->eps_B); \n  } \n \n  if (ths->flags & EXACT_NEARFIELD) \n  { \n    for (k = -ths->Ad / 2 - 2; k <= ths->Ad / 2 + 2; k++) \n      ths->Add[k + ths->Ad / 2 + 2] = regkern1(ths->k, \n          ths->eps_I * (R) k / (R)(ths->Ad) * K(2.0), ths->p, ths->kernel_param, \n          ths->eps_I, ths->eps_B); \n  } \n \n  if (ths->flags & EXACT_NEARFIELD) \n  { \n    for (k = 0; k <= ths->Ad + 2; k++) \n      ths->Add[k] = regkern1(ths->k, \n          ths->eps_I * (R) k / (R)(ths->Ad) * K(2.0), ths->p, ths->kernel_param, \n          ths->eps_I, ths->eps_B"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 4; \n  tile_size[1] = 4; \n  tile_size[2] = 8; \n  tile_size[3] = 256; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0765; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,2);t1++) { \n    lbp=max(ceild(t1,2),ceild(4*t1-Nt+3,4)); \n    ubp=min(floord(Nt+Nz-4,4),floord(2*t1+Nz-1,4)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-3,4)),ceild(4*t2-Nz-4,8));t3<=min(min(min(floord(4*t2+Ny,8),floord(Nt+Ny-4,8)),floord(2*t1+Ny+1,8)),floord(4*t1-4*t2+Nz+Ny-1,8));t3++) { \n        for (t4=max(max(max(0,ceild(t1-127,128)),ceild(4*t2-Nz-252,256)),ceild(8*t3-Ny-252,256));t4<=min(min(min(min(floord(4*t2+Nx,256),floord(Nt+Nx-4,256)),floord(2*t1+Nx+1,256)),floord(8*t3+Nx+4,256)),floord(4*t1-4*t2+Nz+Nx-1,256));t4++) { \n          for (t5=max(max(max(max(max(0,2*t1),4*t1-4*t2+1),4*t2-Nz+2),8*t3-Ny+2),256*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,2*t1+3),4*t2+2),8*t3+6),256*t4+254),4*t1-4*t2+Nz+1);t5++) { \n            for (t6=max(max(4*t2,t5+1),-4*t1+4*t2+2*t5-3);t6<=min(min(4*t2+3,-4*t1+4*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(8*t3,t5+1);t7<=min(8*t3+7,t5+Ny-2);t7++) { \n                lbv=max(256*t4,t5+1); \n                ubv=min(256*t4+255,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = ((alpha * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (beta * (((((A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)] + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) - 1][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8) - 1]) + A[ t5 % 2][ (-t5+t6) + 1][ (-t5+t7)][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) + 1][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8) + 1])));; \n                } \n              } \n            } \n          } \n        } \n      } \n    } \n  } \n} \n \n \n      gettimeofday(&end, 0); \n      ts_return = timeval_subtract(&result, &end, &start); \n      tdiff = (double) (result.tv_sec + result.tv_usec * 1.0e-6); \n      min_tdiff = min(min", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n  for(t=0; t<Nt; t++){ \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i"}
{"label": " \nvoid kappa_beams_preproc(ParamCoLoRe *par) \n{ \n   \n \n  int ir; \n  flouble *r0_i=my_malloc(par->kmap->nr*sizeof(flouble)); \n  flouble *rf_i=my_malloc(par->kmap->nr*sizeof(flouble)); \n \n  memcpy(r0_i,par->kmap->r0,par->kmap->nr*sizeof(flouble)); \n  memcpy(rf_i,par->kmap->rf,par->kmap->nr*sizeof(flouble)); \n \n  int *i_sorted=ind_sort(par->kmap->nr,par->kmap->r0); \n  for(ir=0;ir<par->kmap->nr;ir++) { \n    par->kmap->r0[ir]=r0_i[i_sorted[ir]]; \n    par->kmap->rf[ir]=rf_i[i_sorted[ir]]; \n  } \n  free(r0_i); \n  free(rf_i); \n  free(i_sorted); \n \n   \n \n \n  { \n    long ipp; \n \n \n    for(ipp=0;ipp<par->kmap->num_pix*par->kmap->nr;ipp++) { \n      par->kmap->data[ipp]=0; \n      par->kmap->nadd[ipp]=1; \n    }  \n \n  }  \n \n \n  return; \n} ", "pred": " \nvoid kappa_beams_preproc(ParamCoLoRe *par) \n{ \n   \n \n  int ir; \n  flouble *r0_i=my_malloc(par->kmap->nr*sizeof(flouble)); \n  flouble *rf_i=my_malloc(par->kmap->nr*sizeof(flouble)); \n \n  memcpy(r0_i,par->kmap->r0,par->kmap->nr*sizeof(flouble)); \n  memcpy(rf_i,par->kmap->rf,par->kmap->nr*sizeof(flouble)); \n \n  int *i_sorted=ind_sort(par->kmap->nr,par->kmap->r0); \n  for(ir=0;ir<par->kmap->nr;ir++) { \n    par->kmap->r0[ir]=r0_i[i_sorted[ir]]; \n    par->kmap->rf[ir]=rf_i[i_sorted[ir]]; \n  } \n  free(r0_i); \n  free(rf_i); \n  free(i_sorted); \n \n   \n \n \n  { \n    long ipp; \n \n \n    for(ipp=0;ipp<par->kmap->num_pix*par->kmap->nr;ipp++) { \n      par->kmap->r0[ipp]=par->r0[ipp]; \n      par->kmap->rf[ipp]=par->rf[ipp]; \n    } \n  } \n   \n"}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n  const dt_iop_temperature_data_t *const d = (dt_iop_temperature_data_t *)piece->data; \n \n  const float *const in = (const float *const)ivoid; \n  float *const out = (float *const)ovoid; \n \n  if(filters == 9u) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t p = (size_t)j * roi_out->width + i; \n        out[p] = in[p] * d->coeffs[FCxtrans(j, i, roi_out, xtrans)]; \n      } \n    } \n  } \n  else if(filters) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t p = (size_t)j * roi_out->width + i; \n        out[p] = in[p] * d->coeffs[FC(j + roi_out->y, i + roi_out->x, filters)]; \n      } \n    } \n  } \n  else \n  {  \n \n    const int ch = piece->colors; \n \n    for(size_t k = 0; k < (size_t)ch * roi_out->width * roi_out->height; k += ch) \n    { \n      for(int c = 0; c < 3; c++) \n      { \n        const size_t p = (size_t)k + c; \n        out[p] = in[p] * d->coeffs[c]; \n      } \n    } \n \n    if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out->width, roi_out->height); \n  } \n \n  piece->pipe->dsc.temperature.enabled = 1; \n  for(int k = 0; k < 4; k++) \n  { \n    piece->pipe->dsc.temperature.coeffs[k] = d->coeffs[k]; \n    piece->pipe->dsc.processed_maximum[k] = d->coeffs[k] * piece->pipe->dsc.processed_maximum[k]; \n  } \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n  const dt_iop_temperature_data_t *const d = (dt_iop_temperature_data_t *)piece->data; \n \n  const float *const in = (const float *const)ivoid; \n  float *const out = (float *const)ovoid; \n \n  if(filters == 9u) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const size_t p = (size_t)j * roi_out->width + i; \n        const float *const in_p = in + p * 6; \n        float *const out_p = out + p * 6; \n        const float *const in_p_ = in_p; \n        const float *const in_p_1 = in_p + 1; \n        const float *const in_p_2 = in_p + 2; \n        const float *const in_p_3 = in_p + 3; \n        const float *const in_p_4 = in_p + 4; \n        const float *const in_p_5 = in_p + 5; \n        const float *const in_p_6 = in_p + 6; \n        const float *const in_p_7 = in_p + 7; \n        const float *const in_p_8 = in_p + 8; \n        const float *const in_p_9 = in_p + 9; \n        const float *const in_p_10 = in_p + 10; \n        const float *const in_p_11 = in_p + 11; \n        const float *const in_p_12 = in_p + 12; \n        const float *const in_p_13 = in_p + 13; \n        const float *const in_p_14 = in_p + 14; \n        const float *const in_p_15 = in_p + 15; \n        const float *const in_p_16 = in_p + 16; \n        const float *const in_p_17 = in_p + 17; \n        const float *const in_p_18 = in_p + 18; \n        const float *const in"}
{"label": " \nvoid fastsum_exact(fastsum_plan *ths) \n{ \n  int j, k; \n  int t; \n  R r; \n \n  for (j = 0; j < ths->M_total; j++) \n  { \n    ths->f[j] = K(0.0); \n    for (k = 0; k < ths->N_total; k++) \n    { \n      if (ths->d == 1) \n        r = ths->y[j] - ths->x[k]; \n      else \n      { \n        r = K(0.0); \n        for (t = 0; t < ths->d; t++) \n          r += (ths->y[j * ths->d + t] - ths->x[k * ths->d + t]) \n              * (ths->y[j * ths->d + t] - ths->x[k * ths->d + t]); \n        r = SQRT(r); \n      } \n      ths->f[j] += ths->alpha[k] * ths->k(r, 0, ths->kernel_param); \n    } \n  } \n} ", "pred": " \nvoid fastsum_exact(fastsum_plan *ths) \n{ \n  int j, k; \n  int t; \n  R r; \n \n  for (j = 0; j < ths->M_total; j++) \n  { \n    ths->f[j] = K(0.0); \n    for (k = 0; k < ths->N_total; k++) \n    { \n      if (ths->d == 1) \n        r = ths->y[j] - ths->x[k]; \n      else \n      { \n        r = K(0.0); \n        for (t = 0; t < ths->d; t++) \n          r += (ths->y[j * ths->d + t] - ths->x[k * ths->d + t]) \n              * (ths->y[j * ths->d + t] - ths->x[k * ths->d + t]); \n        r = SQRT(r); \n      } \n      ths->f[j] += r; \n    } \n  } \n  return; \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"label": " \nvoid TrainBatch(LeNet5 *lenet, image *inputs, uint8 *labels, int batchSize) \n{ \n\tdouble buffer[GETCOUNT(LeNet5)] = { 0 }; \n\tint i = 0; \n\tfor (i = 0; i < batchSize; ++i) \n\t{ \n\t\tFeature features = { 0 }; \n\t\tFeature errors = { 0 }; \n\t\tLeNet5\tdeltas = { 0 }; \n\t\tload_input(&features, inputs[i]); \n\t\tforward(lenet, &features, relu); \n\t\tload_target(&features, &errors, labels[i]); \n\t\tbackward(lenet, &deltas, &errors, &features, relugrad); \n\t\t{ \n\t\t\tFOREACH(j, GETCOUNT(LeNet5)) \n\t\t\t\tbuffer[j] += ((double *)&deltas)[j]; \n\t\t} \n\t} \n\tdouble k = ALPHA / batchSize; \n\tFOREACH(i, GETCOUNT(LeNet5)) \n\t\t((double *)lenet)[i] += k * buffer[i]; \n} ", "pred": " \nvoid TrainBatch(LeNet5 *lenet, image *inputs, uint8 *labels, int batchSize) \n{ \n\tdouble buffer[GETCOUNT(LeNet5)] = { 0 }; \n\tint i = 0; \n\tfor (i = 0; i < batchSize; ++i) \n\t{ \n\t\tFeature features = { 0 }; \n\t\tFeature errors = { 0 }; \n\t\tLeNet5\tdeltas = { 0 }; \n\t\tload_input(&features, inputs[i]); \n\t\tforward(lenet, &features, relu); \n\t\tload_target(&features, &errors, labels[i]); \n\t\tbackward(lenet, &deltas, &errors, &features, relugrad); \n\t\t{ \n\t\t\tFOREACH(j, GETCOUNT(LeNet5)) \n\t\t\t\tbuffer[j] += ((double *)&deltas)[j]; \n\t\t} \n\t} \n\tdouble k = ALPHA / batchSize; \n\tFOREACH(i, GETCOUNT(LeNet5)) \n\t\t((double *)lenet)[i] += k * buffer[i]; \n} "}
{"label": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n  dt_iop_temperature_data_t *d = (dt_iop_temperature_data_t *)piece->data; \n  if(filters == 9u) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)j * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)j * roi_out->width; \n \n      int i = 0; \n      const int alignment = ((4 - (j * roi_out->width & (4 - 1))) & (4 - 1)); \n \n       \n \n      for(; i < alignment && i < roi_out->width; i++, out++, in++) \n        *out = *in * d->coeffs[FCxtrans(j, i, roi_out, xtrans)]; \n \n      const __m128 coeffs[3] = { \n        _mm_set_ps(d->coeffs[FCxtrans(j, i + 3, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 2, roi_out, xtrans)], \n                   d->coeffs[FCxtrans(j, i + 1, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 0, roi_out, xtrans)]), \n        _mm_set_ps(d->coeffs[FCxtrans(j, i + 7, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 6, roi_out, xtrans)], \n                   d->coeffs[FCxtrans(j, i + 5, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 4, roi_out, xtrans)]), \n        _mm_set_ps(d->coeffs[FCxtrans(j, i + 11, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 10, roi_out, xtrans)], \n                   d->coeffs[FCxtrans(j, i + 9, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 8, roi_out, xtrans)]) \n      }; \n \n       \n \n      for(int c = 0; c < 3 && i < roi_out->width - (4 - 1); c++, i += 4, in += 4, out += 4) \n      { \n        __m128 v; \n \n        v = _mm_load_ps(in); \n        v = _mm_mul_ps(v, coeffs[c]); \n        _mm_stream_ps(out, v); \n      } \n \n       \n \n      for(; i < roi_out->width; i++, out++, in++) *out = *in * d->coeffs[FCxtrans(j, i, roi_out, xtrans)]; \n    } \n    _mm_sfence(); \n  } \n  else if(filters) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)j * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)j * roi_out->width; \n \n      int i = 0; \n      const int alignment = ((4 - (j * roi_out->width & (4 - 1))) & (4 - 1)); \n \n       \n \n      for(; i < alignment && i < roi_out->width; i++, out++, in++) \n        *out = *in * d->coeffs[FC(j + roi_out->y, i + roi_out->x, filters)]; \n \n      const __m128 coeffs = _mm_set_ps(d->coeffs[FC(j + roi_out->y, roi_out->x + i + 3, filters)], \n                                       d->coeffs[FC(j + roi_out->y, roi_out->x + i + 2, filters)], \n                                       d->coeffs[FC(j + roi_out->y, roi_out->x + i + 1, filters)], \n                                       d->coeffs[FC(j + roi_out->y, roi_out->x + i, filters)]); \n \n       \n \n      for(; i < roi_out->width - (4 - 1); i += 4, in += 4, out += 4) \n      { \n        const __m128 input = _mm_load_ps(in); \n \n        const __m128 multiplied = _mm_mul_ps(input, coeffs); \n \n        _mm_stream_ps(out, multiplied); \n      } \n \n       \n \n      for(; i < roi_out->width; i++, out++, in++) \n        *out = *in * d->coeffs[FC(j + roi_out->y, i + roi_out->x, filters)]; \n    } \n    _mm_sfence(); \n  } \n  else \n  {  \n \n    const int ch = piece->colors; \n \n    const __m128 coeffs = _mm_set_ps(1.0f, d->coeffs[2], d->coeffs[1], d->coeffs[0]); \n \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)ch * k * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++, in += ch, out += ch) \n      { \n        const __m128 input = _mm_load_ps(in); \n        const __m128 multiplied = _mm_mul_ps(input, coeffs); \n        _mm_stream_ps(out, multiplied); \n      } \n    } \n    _mm_sfence(); \n \n    if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out->width, roi_out->height); \n  } \n \n  piece->pipe->dsc.temperature.enabled = 1; \n  for(int k = 0; k < 4; k++) \n  { \n    piece->pipe->dsc.temperature.coeffs[k] = d->coeffs[k]; \n    piece->", "pred": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n  dt_iop_temperature_data_t *d = (dt_iop_temperature_data_t *)piece->data; \n  if(filters == 9u) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)j * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)j * roi_out->width; \n \n      int i = 0; \n      const int alignment = ((4 - ((size_t)j & 0x3)) & 0x3); \n      for(i = 0; i < roi_out->width; i += 4) \n      { \n        const float x = in[i]; \n        const float y = in[i + 1]; \n        const float z = in[i + 2]; \n        const float w = in[i + 3]; \n        const float x_ = xtrans[0][0] * x + xtrans[0][1] * y + xtrans[0][2] * z + xtrans[0][3]; \n        const float y_ = xtrans[1][0] * x + xtrans[1][1] * y + xtrans[1][2] * z + xtrans[1][3]; \n        const float z_ = xtrans[2][0] * x + xtrans[2][1] * y + xtrans[2][2] * z + xtrans[2][3]; \n        const float w_ = xtrans[3][0] * x + xtrans[3][1] * y + xtrans[3][2] * z + xtrans[3][3]; \n        out[i] = x_ * w_ + y_ * z_ + z_ * w; \n        out[i + 1] = x_ * y_ + z_ * w; \n        out[i + 2] = x_ * z_ + w_ * y; \n        out[i + 3] = x_ * w_ + y_ * z; \n      } \n    } \n  } \n  else if(filters == 16u) \n  {  \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)j * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)j * roi_out->width; \n \n      int i = 0; \n      const int alignment = ((4 - ((size_t)j & 0x3)) & 0x3); \n      for(i = 0; i < roi_out->width; i += 4) \n      { \n        const float x = in[i]; \n        const float y = in[i + 1]; \n        const float z = in[i + 2]; \n        const float w = in[i + 3]; \n        const float x_ = xtrans[0][0] * x + xtrans[0][1] * y + xtrans[0][2] * z + xtrans[0][3]; \n        const float y_ = xtrans[1][0] * x + xtrans[1][1] * y + xtrans[1][2] * z + xtrans[1][3]; \n        const float z_ = xtrans[2][0] * x + xtrans[2][1] * y + xtrans[2][2] * z + xtrans[2][3]; \n        const float w_ = xtrans[3][0] * x + xtrans[3][1] * y + xtrans[3][2] * z + xtrans[3][3]; \n        out[i] = x_ * w_ + y_ * z_ + z_ * w; \n        out[i + 1] = x_ * y_ + z_ * w; \n        out[i + 2] = x_ * z_ + w_ * y; \n        out[i + 3] = x_ * w_ + y_ * z; \n      } \n    } \n  } \n  else if(filters == 32u) \n  {  \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)j * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)j * roi_out->width; \n \n      int i = 0; \n      const int alignment = ((4 - ((size_t)j & 0x3)) & 0x3); \n      for(i = 0; i < roi_out->width; i += 4) \n      { \n        const float x = in[i]; \n        const float y = in[i + 1]; \n        const float z = in[i + 2]; \n        const float w = in[i + 3]; \n        const float x_ = xtrans[0][0] * x + xtrans[0][1] * y + xtrans[0][2] * z + xtrans[0][3]; \n        const float y_ = xtrans[1][0] * x + xtrans[1][1] * y + xtrans[1][2] * z + xtrans[1][3]; \n        const float z_ = xtrans[2][0] * x + xtrans[2][1] * y + xtrans[2][2] * z + xtrans[2][3]; \n        const float w_ = xtrans[3][0] * x + xtrans[3][1] * y + xtrans[3][2] * z + xtrans[3][3]; \n        out[i] = x_ * w_ + y_ * z_ + z_ * w; \n        out[i + 1] = x_ * y_ + z_ * w; \n        out[i + 2] = x_ * z_ + w_ * y; \n        out[i + 3] = x_ * w_ + y_ * z; \n      } \n    } \n  } \n  else if(filters == 64u) \n  {  \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)j * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)j * roi_out->width; \n \n      int i = 0; \n      const int alignment = ((4 - ((size_t)j & 0x3)) & 0x3); \n      for(i = 0; i < roi_out->width; i += 4) \n      { \n "}
{"label": "nt loadAncAll_mp(struct ind_map *matmap, long int col, FILE *i_a, int nt) \n{ \n \n \n \n \nchar *buf; \nchar *buf_split, *spf; \nlong int line=0,tot=0; \nlong int i; \nlong int size_buf=200; \n \nchar tmp[200]; \nchar al; \nchar rs[200]; \n \nint iCPU = omp_get_num_procs(); \n \nif (nt>iCPU){nt=iCPU;} \nomp_set_num_threads(nt); \n \n \nbuf=malloc(size_buf*sizeof(char)); \nprintf(\"\\nStart reading ancestral allele state file...\\n\"); \nwhile (fgets(buf,size_buf,i_a)!=NULL){ \n\tline++; \n\tprintf(\"\\nAnc all line %ld\",line); \n\tif (strchr(buf,' ')==NULL & strchr(buf,'\\t')==NULL ){printf(\"ERROR: loadAncAll: wrong separator character in line %ld. Please use only TAB or SPACE.\\n\",line);return 1;} \n\tchoppy(buf); \n\tbuf_split=strtok_r(buf,\" \\t\",&spf); \n\tstrcpy(rs,buf_split); \n\tbuf_split=strtok_r(NULL,\" \\t\",&spf); \n\tal=*buf_split; \n\tfor (i=0;i<col;i++){ \n\t\t \n \n\t\tstrncpy(tmp,\"rs\",3); \n\t\tstrcat(tmp, rs); \n\t\tif (strcmp(matmap[i].rs,tmp)==0){ \n\t\t\t \n \n\t\t\tmatmap[i].anc=al; \n\t\t\ttot++; \n\t\t\tprintf(\"\\nLine %ld - Found match! rs:%s Tot match1\",line,rs); \n\t\t\t \n \n\t\t} \n\t\t \n \n\t\t \n \n\t\t \n \n\t\t \n \n\t} \n\t \n \nif (line==10000){ \nprintf(\"\\ntot %ld\",tot); \nbreak;} \n} \nif (tot!=col){printf(\"WARNING: loadAncAll: some SNPs have no ancestral allele information. (%ld SNPs with allele information - %ld SNPs in total).\\n\",tot,col);} \nelse{printf(\"\\nAncestral state loaded for %ld/%ld SNPs\",tot,col);} \nreturn 0; \nprintf(\"\\nStart reading ancestral allele state file...done!\"); \nfree(buf); \n} \n \n ", "pred": "nt loadAncAll_mp(struct ind_map *matmap, long int col, FILE *i_a, int nt) \n{ \n \n \n \n \nchar *buf; \nchar *buf_split, *spf; \nlong int line=0,tot=0; \nlong int i; \nlong int size_buf=200; \n \nchar tmp[200]; \nchar al; \nchar rs[200]; \n \nint iCPU = omp_get_num_procs(); \n \nif (nt>iCPU){nt=iCPU;} \nomp_set_num_threads(nt); \n \n \nbuf=malloc(size_buf*sizeof(char)); \nprintf(\"\\nStart reading ancestral allele state file...\\n\"); \nwhile (fgets(buf,size_buf,i_a)!=NULL){ \n\tline++; \n\tprintf(\"\\nAnc all line %ld\",line); \n\tif (strchr(buf,' ')==NULL & strchr(buf,'\\t')==NULL ){printf(\"ERROR: loadAncAll: wrong separator character in line %ld. Please use only TAB or SPACE.\\n\",line);return 1;} \n\tchoppy(buf); \n\tbuf_split=strtok_r(buf,\" \\t\",&spf); \n\tstrcpy(rs,buf_split); \n\tfor (i=0;i<nt;i++){ \n\t\tif (strcmp(rs,matmap[i].name)==0){ \n\t\t\ttot++; \n\t\t\tif (tot>1){ \n\t\t\t\tprintf(\"\\nAnc all line %ld\",line); \n\t\t\t\tprintf(\"Anc all %ld\",i); \n\t\t\t\tprintf(\"Anc all %ld\",tot); \n\t\t\t\tprintf(\"Anc all %ld\",matmap[i].nt); \n\t\t\t\tprintf(\"Anc all %ld\",matmap[i].nt); \n\t\t\t\tprintf(\"Anc all %ld\",matmap[i].nt); \n\t\t\t\tprintf(\"Anc all %ld\",matmap[i].nt); \n\t\t\t\tprintf(\"Anc all %ld\",matmap[i].nt); \n\t\t\t\tprintf(\"Anc all %ld\",matmap[i].nt); \n\t\t\t\tprintf(\"Anc all %ld\",matmap[i].nt); \n\t\t\t\tprintf(\"Anc all %ld\",matmap[i].nt); \n\t\t\t\tprintf(\"Anc all %ld\",matmap[i].nt); \n\t\t\t\tprintf(\"Anc all %ld\",matmap[i].nt); \n\t\t\t\tprintf(\"Anc all %ld\",matmap[i].nt); \n\t\t\t\tprintf(\""}
{"label": " \nstatic void nn_(SpatialMaxPooling_updateGradInput_frame)(real *gradInput_p, real *gradOutput_p, \n                                                         real *ind_p, \n                                                         long nslices, \n                                                         long iwidth, long iheight, \n                                                         long owidth, long oheight, \n                                                         int dW, int dH) \n{ \n  long k; \n  for (k = 0; k < nslices; k++) \n  { \n    real *gradInput_p_k = gradInput_p + k*iwidth*iheight; \n    real *gradOutput_p_k = gradOutput_p + k*owidth*oheight; \n    real *ind_p_k = ind_p + k*owidth*oheight; \n \n     \n \n    long i, j; \n    for(i = 0; i < oheight; i++) \n    { \n      for(j = 0; j < owidth; j++) \n      { \n         \n \n        long maxp = ind_p_k[i*owidth + j] - 1; \n         \n \n        gradInput_p_k[maxp] += gradOutput_p_k[i*owidth + j]; \n      } \n    } \n  } \n} ", "pred": " \nstatic void nn_(SpatialMaxPooling_updateGradInput_frame)(real *gradInput_p, real *gradOutput_p, \n                                                         real *ind_p, \n                                                         long nslices, \n                                                         long iwidth, long iheight, \n                                                         long owidth, long oheight, \n                                                         long owidthStride, long oheightStride, \n                                                         long owidthStep, long oheightStep, \n                                                         long owidthPad, long oheightPad, \n                                                         long owidthStridePad, long oheightStridePad, \n                                                         long owidthStep"}
{"label": " \nvoid \nfoo (int a, int b, int c) \n{ \n  int i; \n  for (i = a; i < b; i += c) \n    { \n      j++; \n      bar (&j); \n    } \n} ", "pred": " \nvoid \nfoo (int a, int b, int c) \n{ \n  int i; \n  for (i = a; i < b; i += c) \n    { \n      j++; \n      bar (&j); \n    } \n} "}
{"label": " \nstatic int nn_(SpatialMaxPooling_updateOutput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  int kW = luaT_getfieldcheckint(L, 1, \"kW\"); \n  int kH = luaT_getfieldcheckint(L, 1, \"kH\"); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n  int padW = luaT_getfieldcheckint(L, 1, \"padW\"); \n  int padH = luaT_getfieldcheckint(L, 1, \"padH\"); \n  int ceil_mode = luaT_getfieldcheckboolean(L,1,\"ceil_mode\"); \n  THTensor *indices = luaT_getfieldcheckudata(L, 1, \"indices\", torch_Tensor); \n  THTensor *output = luaT_getfieldcheckudata(L, 1, \"output\", torch_Tensor); \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  long nslices; \n  long iheight; \n  long iwidth; \n  long oheight; \n  long owidth; \n  real *input_data; \n  real *output_data; \n  real *indices_data; \n \n \n  luaL_argcheck(L, input->nDimension == 3 || input->nDimension == 4, 2, \"3D or 4D (batch mode) tensor expected\"); \n \n  if (input->nDimension == 4)  \n  { \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n  luaL_argcheck(L, input->size[dimw] >= kW - padW && input->size[dimh] >= kH - padH, 2, \"input image smaller than kernel size\"); \n \n  luaL_argcheck(L, kW/2 >= padW && kH/2 >= padH, 2, \"pad should be smaller than half of kernel size\"); \n \n   \n \n  nslices = input->size[dimh-1]; \n  iheight = input->size[dimh]; \n  iwidth = input->size[dimw]; \n  if (ceil_mode) \n  { \n    oheight = (long)(ceil((float)(iheight - kH + 2*padH) / dH)) + 1; \n    owidth  = (long)(ceil((float)(iwidth  - kW + 2*padW) / dW)) + 1; \n  } \n  else \n  { \n    oheight = (long)(floor((float)(iheight - kH + 2*padH) / dH)) + 1; \n    owidth  = (long)(floor((float)(iwidth  - kW + 2*padW) / dW)) + 1; \n  } \n \n  if (padW || padH) \n  { \n     \n \n    if ((oheight - 1)*dH >= iheight + padH) \n      --oheight; \n    if ((owidth  - 1)*dW >= iwidth  + padW) \n      --owidth; \n  } \n \n   \n \n  input = THTensor_(newContiguous)(input); \n \n   \n \n  if (input->nDimension == 3) \n  { \n    THTensor_(resize3d)(output, nslices, oheight, owidth); \n     \n \n    THTensor_(resize3d)(indices,  nslices, oheight, owidth); \n \n    input_data = THTensor_(data)(input); \n    output_data = THTensor_(data)(output); \n    indices_data = THTensor_(data)(indices); \n \n    nn_(SpatialMaxPooling_updateOutput_frame)(input_data, output_data, \n                                              indices_data, \n                                              nslices, \n                                              iwidth, iheight, \n                                              owidth, oheight, \n                                              kW, kH, dW, dH, \n                                              padW, padH); \n  } \n  else \n  { \n    long p; \n \n    THTensor_(resize4d)(output, nbatch, nslices, oheight, owidth); \n     \n \n    THTensor_(resize4d)(indices, nbatch, nslices, oheight, owidth); \n \n    input_data = THTensor_(data)(input); \n    output_data = THTensor_(data)(output); \n    indices_data = THTensor_(data)(indices); \n \n    for (p = 0; p < nbatch; p++) \n    { \n      nn_(SpatialMaxPooling_updateOutput_frame)(input_data+p*nslices*iwidth*iheight, output_data+p*nslices*owidth*oheight, \n                                                indices_data+p*nslices*owidth*oheight, \n                                                nslices, \n                                                iwidth, iheight, \n                                                owidth, oheight, \n                                                kW, kH, dW, dH, \n                                                padW, padH); \n    } \n  } \n \n   \n \n  THTensor_(free)(input); \n  return 1; \n} ", "pred": " \nstatic int nn_(SpatialMaxPooling_updateOutput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  int kW = luaT_getfieldcheckint(L, 1, \"kW\"); \n  int kH = luaT_getfieldcheckint(L, 1, \"kH\"); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n  int padW = luaT_getfieldcheckint(L, 1, \"padW\"); \n  int padH = luaT_getfieldcheckint(L, 1, \"padH\"); \n  int ceil_mode = luaT_getfieldcheckboolean(L,1,\"ceil_mode\"); \n  THTensor *indices = luaT_getfieldcheckudata(L, 1, \"indices\", torch_Tensor); \n  THTensor *output = luaT_getfieldcheckudata(L, 1, \"output\", torch_Tensor); \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  long nslices; \n  long iheight; \n  long iwidth; \n  long oheight; \n  long owidth; \n  long ostride; \n  long osize; \n  long ostride2; \n  long osize2; \n  long ostride3; \n  long osize3; \n  long ostride4; \n  long osize4; \n  long ostride5; \n  long osize5; \n  long ostride6; \n  long osize6; \n  long ostride7; \n  long osize7; \n  long ostride8; \n  long osize8; \n  long ostride9; \n  long osize9; \n  long ostride10; \n  long osize10; \n  long ostride11; \n  long osize11; \n  long ostride12; \n  long osize12; \n  long ostride13; \n  long osize13; \n  long ostride14; \n  long osize14; \n  long ostride15; \n  long osize15; \n  long ostride16; \n  long osize16; \n  long ostride17; \n  long osize17; \n  long ostride18; \n  long osize18; \n  long ostride19; \n  long osize19; \n  long ostride20; \n  long osize20; \n  long ostride21; \n  long osize21; \n  long ostride22; \n  long osize22; \n  long ostride23; \n  long osize23; \n  long ostride24; \n  long osize24; \n  long ostride25; \n  long osize25; \n  long ostride26; \n  long osize26; \n  long ostride27; \n  long osize27; \n  long ostride28; \n  long osize28; \n  long ostride29; \n  long osize29; \n  long ostride30; \n  long osize30; \n  long ostride31; \n  long osize31; \n  long ostride32; \n  long osize32; \n  long ostride33; \n  long osize33; \n  long ostride34; \n  long osize34; \n  long ostride35; \n  long osize35; \n  long ostride36; \n  long osize36; \n  long ostride37; \n  long osize37; \n  long ostride38; \n  long osize38; \n  long ostride39; \n  long osize39; \n  long ostride40; \n  long osize40; \n  long ostride41; \n  long osize41; \n  long ostride42; \n  long osize42; \n  long ostride43; \n  long osize43; \n  long ostride44; \n  long osize44; \n  long ostride45; \n  long osize45; \n  long ostride46; \n  long osize46; \n  long ostride47; \n  long osize47; \n  long ostride48; \n  long osize48; \n  long ostride49; \n  long osize49; \n  long ostride50; \n  long osize50; \n  long ostride51; \n  long osize51; \n  long ostride52; \n  long osize52; \n  long ostride53; \n  long osize53; \n  long ostride54; \n  long osize54; \n  long ostride55; \n  long osize55; \n  long ostride56; \n  long osize56; \n  long ostride57; \n  long osize57; \n  long ostride58; \n  long osize58; \n  long ostride59; \n  long osize59; \n  long ostride60; \n  long osize60; \n  long ostride61; \n  long osize61; \n  long ostride62; \n  long osize62; \n  long ostride63; \n  long osize63; \n  long ostride64; \n  long osize64; \n  long ostride65; \n  long osize65; \n  long ostride66; \n  long osize66; \n  long ostride67; \n  long osize67; \n  long ostride68; \n  long osize68; \n  long ostride69; \n  long osize69; \n  long ostride70; \n  long osize70; \n  long ostride71; \n  long osize71; \n  long ostride72; \n  long osize72; \n  long ostride73; \n  long osize73; \n  long ostride74; \n  long osize74; \n  long ostride75; \n  long osize75; \n  long ostride76; \n  long osize76; \n  long ostride77; \n  long osize77; \n  long ostride78; \n  long osize78; \n  long ostride79; \n  long osize79; \n  long ostride80; \n  long osize80; \n  long ostride81; \n  long osize81; \n  long ostride82; \n  long osize82; \n  long ostride83; \n  long osize83; \n  long ostride84; \n  long osize84; \n  long ostride85; \n  long osize85; \n  long ostride86; \n  long osize86; \n  long ostride87; \n  long osize87; \n  long ostride88; \n  long osize88; \n  long ostride89; \n  long osize89; \n  long ostride90; \n  long osize90; \n  long ostride91; \n  long osize91; \n  long ostride92; \n  long osize92; \n  long ostride93; \n  long osize93; \n  long ostride94; \n  long osize94; \n  long ostride95; \n  long osize95; \n  long ostride96; \n  long osize96; \n  long ostride97; \n  long osize97; \n  long ostride98; \n  long osize98; \n  long ostride99; \n  long osize99; \n  long ostride100; \n  long osize100; \n  long ostride101; \n  long osize101; \n  long ostride102; \n  long osize102; \n  long ostride103; \n  long osize103; \n  long ostride104; \n  long osize104; \n  long ostride105; \n  long osize105; \n  long ostride106; \n  long osize106; \n  long ostride107; \n  long osize107; \n  long ostride108; \n  long osize108; \n  long ostride109; \n "}
{"label": " \nstatic int nn_(SpatialMaxPooling_updateGradInput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor *gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n  THTensor *indices = luaT_getfieldcheckudata(L, 1, \"indices\", torch_Tensor); \n  THTensor *gradInput = luaT_getfieldcheckudata(L, 1, \"gradInput\", torch_Tensor); \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  int nslices; \n  int iheight; \n  int iwidth; \n  int oheight; \n  int owidth; \n  real *gradInput_data; \n  real *gradOutput_data; \n  real *indices_data; \n \n   \n \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n \n   \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(zero)(gradInput); \n \n  if (input->nDimension == 4) { \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n   \n \n  nslices = input->size[dimh-1]; \n  iheight = input->size[dimh]; \n  iwidth = input->size[dimw]; \n  oheight = gradOutput->size[dimh]; \n  owidth = gradOutput->size[dimw]; \n \n   \n \n  gradInput_data = THTensor_(data)(gradInput); \n  gradOutput_data = THTensor_(data)(gradOutput); \n  indices_data = THTensor_(data)(indices); \n \n   \n \n  if (input->nDimension == 3) \n  { \n    nn_(SpatialMaxPooling_updateGradInput_frame)(gradInput_data, gradOutput_data, \n                                                 indices_data, \n                                                 nslices, \n                                                 iwidth, iheight, \n                                                 owidth, oheight, \n                                                 dW, dH); \n  } \n  else \n  { \n    long p; \n    for (p = 0; p < nbatch; p++) \n    { \n      nn_(SpatialMaxPooling_updateGradInput_frame)(gradInput_data+p*nslices*iwidth*iheight, gradOutput_data+p*nslices*owidth*oheight, \n                                                   indices_data+p*nslices*owidth*oheight, \n                                                   nslices, \n                                                   iwidth, iheight, \n                                                   owidth, oheight, \n                                                   dW, dH); \n    } \n  } \n \n   \n \n  THTensor_(free)(gradOutput); \n \n  return 1; \n} ", "pred": " \nstatic int nn_(SpatialMaxPooling_updateGradInput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor *gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  int dW = luaT_getfieldcheckint(L, 1, \"dW\"); \n  int dH = luaT_getfieldcheckint(L, 1, \"dH\"); \n  THTensor *indices = luaT_getfieldcheckudata(L, 1, \"indices\", torch_Tensor); \n  THTensor *gradInput = luaT_getfieldcheckudata(L, 1, \"gradInput\", torch_Tensor); \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  int nslices; \n  int iheight; \n  int iwidth; \n  int oheight; \n  int owidth; \n  real *gradInput_data; \n  real *gradOutput_data; \n  real *indices_data; \n \n   \n \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n \n   \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(zero)(gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradInput); \n  THTensor_(zero)(gradOutput); \n \n  THTensor_(resizeAs)(indices, indices); \n  THTensor_(zero)(indices); \n \n  THTensor_(resizeAs)(gradInput_data, gradInput); \n  THTensor_(zero)(gradInput_data); \n \n  THTensor_(resizeAs)(gradOutput_data, gradOutput); \n  THTensor_(zero)(gradOutput_data); \n \n  THTensor_(resizeAs)(indices_data, indices); \n  THTensor_(zero)(indices_data); \n \n  THTensor_(resizeAs)(gradInput_data, gradInput); \n  THTensor_(zero)(gradInput_data); \n \n  THTensor_(resizeAs)(gradOutput_data, gradOutput); \n  THTensor_(zero)(gradOutput_data); \n \n  THTensor_(resizeAs)(indices_data, indices); \n  THTensor_(zero)(indices_data); \n \n  THTensor_(resizeAs)(gradInput_data, gradInput); \n  THTensor_(zero)(gradInput_data); \n \n  THTensor_(resizeAs)(gradOutput_data, gradOutput); \n  THTensor_(zero)(gradOutput_data); \n \n  THTensor_(resizeAs)(indices_data, indices); \n  THTensor_(zero)(indices_data); \n \n  THTensor_(resizeAs)(gradInput_data, gradInput); \n  THTensor_(zero)(gradInput_data); \n \n  THTensor_(resizeAs)(gradOutput_data, gradOutput); \n  THTensor_(zero)(gradOutput_data); \n \n  THTensor_(resizeAs)(indices_data, indices); \n  THTensor_(zero)(indices_data); \n \n  THTensor_(resizeAs)(gradInput_data, gradInput); \n  THTensor_(zero)(gradInput_data); \n \n  THTensor_(resizeAs)(gradOutput_data, gradOutput); \n  THTensor_(zero)(gradOutput_data); \n \n  THTensor_(resizeAs)(indices_data, indices); \n  THTensor_(zero)(indices_data); \n \n  THTensor_(resizeAs)(gradInput_data, gradInput); \n  THTensor_(zero)(gradInput_data); \n \n  THTensor_(resizeAs)(gradOutput_data, gradOutput); \n  THTensor_(zero)(gradOutput_data); \n \n  THTensor_(resizeAs)(indices_data, indices); \n  THTensor_(zero)(indices_data); \n \n  THTensor_(resizeAs)(gradInput_data, gradInput); \n  THTensor_(zero)(gradInput_data); \n \n  THTensor_(resizeAs)(gradOutput_data, gradOutput); \n  THTensor_(zero)(gradOutput_data); \n \n  THTensor_(resizeAs)(indices_data, indices); \n  THTensor_(zero)(indices_data); \n \n  THTensor_(resizeAs)(gradInput_data, gradInput); \n  THTensor_(zero)(gradInput_data); \n \n  THTensor_(resizeAs)(gradOutput_data, gradOutput); \n  THTensor_(zero)(gradOutput_data); \n \n  THTensor_(resizeAs)(indices_data, indices); \n  THTensor_(zero)(indices_data); \n \n  THTensor_(resizeAs)(gradInput_data, gradInput); \n  THTensor_(zero)(gradInput_data); \n \n  THTensor_(resizeAs)(gradOutput_data, gradOutput); \n  THTensor_(zero)(gradOutput_data); \n \n  THTensor_(resizeAs)(indices_data, indices); \n  THTensor_(zero)(indices_data); \n \n  THTensor_(resizeAs)(gradInput_data, gradInput); \n  THTensor_(zero)(gradInput_data); \n"}
{"label": " \nvoid THNN_(HardTanh_updateOutput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *output, \n          real min_val, \n          real max_val) \n{ \n  THTensor_(resizeAs)(output, input); \n   \n  if (input->nDimension == 1 ||!THTensor_(isContiguous)(input) ||!THTensor_(isContiguous)(output)) \n  { \n    TH_TENSOR_APPLY2(real, output, real, input, \n      if (*input_data < min_val) \n        *output_data = min_val; \n      else if (*input_data <= max_val) \n        *output_data = *input_data; \n      else \n        *output_data = max_val; \n    ); \n  } \n  else \n  { \n    real* ptr_output = THTensor_(data)(output); \n    real* ptr_input  = THTensor_(data)(input); \n    long i; \n \n    for (i = 0; i < THTensor_(nElement)(input); i++) \n    { \n      if (ptr_input[i] < min_val) \n        ptr_output[i] = min_val; \n      else if (ptr_input[i] <= max_val) \n        ptr_output[i] = ptr_input[i]; \n      else \n        ptr_output[i] = max_val; \n    } \n  } \n} ", "pred": " \nvoid THNN_(HardTanh_updateOutput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *output, \n          real min_val, \n          real max_val) \n{ \n  THTensor_(resizeAs)(output, input); \n   \n  if (input->nDimension == 1 ||!THTensor_(isContiguous)(input) ||!THTensor_(isContiguous)(output)) \n  { \n    TH_TENSOR_APPLY2(real, output, real, input, \n      if (*input_data < min_val) \n        *output_data = min_val; \n      else if (*input_data <= max_val) \n        *output_data = *input_data; \n      else \n        *output_data = max_val; \n    ); \n  } \n  else \n  { \n    real* ptr_output = THTensor_(data)(output); \n    real* ptr_input  = THTensor_(data)(input); \n    for (int i = 0; i < input->nDimension; i++) \n    { \n      *ptr_output = *ptr_input; \n      ptr_output++; \n      ptr_input++; \n    } \n  } \n  \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 16; \n  tile_size[3] = 512; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n  const double alpha = 0.0876; \n  const double beta = 0.0765; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,4);t1++) { \n    lbp=max(ceild(t1,2),ceild(8*t1-Nt+3,8)); \n    ubp=min(floord(Nt+Nz-4,8),floord(4*t1+Nz+1,8)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-3,4)),ceild(8*t2-Nz-12,16));t3<=min(min(min(floord(Nt+Ny-4,16),floord(4*t1+Ny+5,16)),floord(8*t2+Ny+4,16)),floord(8*t1-8*t2+Nz+Ny+3,16));t3++) { \n        for (t4=max(max(max(0,ceild(t1-127,128)),ceild(8*t2-Nz-508,512)),ceild(16*t3-Ny-508,512));t4<=min(min(min(min(floord(Nt+Nx-4,512),floord(4*t1+Nx+5,512)),floord(8*t2+Nx+4,512)),floord(16*t3+Nx+12,512)),floord(8*t1-8*t2+Nz+Nx+3,512));t4++) { \n          for (t5=max(max(max(max(max(0,4*t1),8*t1-8*t2+1),8*t2-Nz+2),16*t3-Ny+2),512*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,4*t1+7),8*t2+6),16*t3+14),512*t4+510),8*t1-8*t2+Nz+5);t5++) { \n            for (t6=max(max(8*t2,t5+1),-8*t1+8*t2+2*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(16*t3,t5+1);t7<=min(16*t3+15,t5+Ny-2);t7++) { \n                lbv=max(512*t4,t5+1); \n                ubv=min(512*t4+511,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = ((alpha * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (beta * (((((A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)] + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) - 1][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8) - 1]) + A[ t5 % 2][ (-t5+t6) + 1][ (-t5+t7)][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7) + 1][ (-t5+t8)]) + A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8) + 1])));; \n                } \n              } \n            } \n          } \n        } \n      } \n    } \n  } \n} \n \n \n      gettimeofday(&end, 0); \n      ts_return = timeval_subtract(&result, &end, &start); \n      tdiff = (double) (result.tv_sec + result.tv_usec * 1.0e-6); \n      min_tdiff", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n  for(t=0; t<Nt; t++){ \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Ny; j++){ \n\tfor(k=0; k<Nx; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i"}
{"label": " \nstatic void process_nlmeans(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                            const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in, \n                            const dt_iop_roi_t *const roi_out) \n{ \n   \n \n   \n \n  const dt_iop_denoiseprofile_params_t *const d = (const dt_iop_denoiseprofile_params_t *const)piece->data; \n \n  const int ch = piece->colors; \n \n   \n \n   \n \n  const float scale = fmin(roi_in->scale, 2.0f) / fmax(piece->iscale, 1.0f); \n  const int P = ceilf(d->radius * scale);  \n \n  const int K = ceilf(7 * scale);          \n \n \n   \n \n \n  float *Sa = dt_alloc_align(64, (size_t)sizeof(float) * roi_out->width * dt_get_num_threads()); \n   \n \n  memset(ovoid, 0x0, (size_t)sizeof(float) * roi_out->width * roi_out->height * 4); \n  float *in = dt_alloc_align(64, (size_t)4 * sizeof(float) * roi_in->width * roi_in->height); \n \n  const float wb[3] = { piece->pipe->dsc.processed_maximum[0] * d->strength * (scale * scale), \n                        piece->pipe->dsc.processed_maximum[1] * d->strength * (scale * scale), \n                        piece->pipe->dsc.processed_maximum[2] * d->strength * (scale * scale) }; \n  const float aa[3] = { d->a[1] * wb[0], d->a[1] * wb[1], d->a[1] * wb[2] }; \n  const float bb[3] = { d->b[1] * wb[0], d->b[1] * wb[1], d->b[1] * wb[2] }; \n  precondition((float *)ivoid, in, roi_in->width, roi_in->height, aa, bb); \n \n   \n \n  for(int kj = -K; kj <= K; kj++) \n  { \n    for(int ki = -K; ki <= K; ki++) \n    { \n       \n \n       \n \n \n      int inited_slide = 0; \n \n \n \n \n \n \n \n \n      for(int j = 0; j < roi_out->height; j++) \n      { \n        if(j + kj < 0 || j + kj >= roi_out->height) continue; \n        float *S = Sa + dt_get_thread_num() * roi_out->width; \n        const float *ins = in + 4l * ((size_t)roi_in->width * (j + kj) + ki); \n        float *out = ((float *)ovoid) + (size_t)4 * roi_out->width * j; \n \n        const int Pm = MIN(MIN(P, j + kj), j); \n        const int PM = MIN(MIN(P, roi_out->height - 1 - j - kj), roi_out->height - 1 - j); \n         \n \n         \n \n        if(!inited_slide) \n        { \n           \n \n          memset(S, 0x0, sizeof(float) * roi_out->width); \n          for(int jj = -Pm; jj <= PM; jj++) \n          { \n            int i = MAX(0, -ki); \n            float *s = S + i; \n            const float *inp = in + 4 * i + (size_t)4 * roi_in->width * (j + jj); \n            const float *inps = in + 4 * i + 4l * ((size_t)roi_in->width * (j + jj + kj) + ki); \n            const int last = roi_out->width + MIN(0, -ki); \n            for(; i < last; i++, inp += 4, inps += 4, s++) \n            { \n              for(int k = 0; k < 3; k++) s[0] += (inp[k] - inps[k]) * (inp[k] - inps[k]); \n            } \n          } \n           \n \n          if(Pm == P && PM == P) inited_slide = 1; \n        } \n \n         \n \n        float *s = S; \n        float slide = 0.0f; \n         \n \n        for(int i = 0; i < 2 * P + 1; i++) slide += s[i]; \n        for(int i = 0; i < roi_out->width; i++, s++, ins += 4, out += 4) \n        { \n           \n \n           \n \n          if(i - P > 0 && i + P < roi_out->width) slide += s[P] - s[-P - 1]; \n          if(i + ki >= 0 && i + ki < roi_out->width) \n          { \n             \n \n             \n \n            const float norm =.015f / (2 * P + 1); \n            const float iv[4] = { ins[0], ins[1], ins[2], 1.0f }; \n            for(size_t c = 0; c < 4; c++) \n            { \n              out[c] += iv[c] * fast_mexp2f(fmaxf(0.0f, slide * norm - 2.0f)); \n            } \n          } \n        } \n        if(inited_slide && j + P + 1 + MAX(0, kj) < roi_out->height) \n        { \n           \n \n          int i = MAX(0, -ki); \n          s = S + i; \n          const float *inp = in + 4 * i + 4l * (size_t)roi_in->width * (j + P + 1); \n          const float *inps = in + 4 * i + 4l * ((size_t)roi_in->width * (j + P + 1 + kj) + ki); \n          const float *inm = in +", "pred": " \nstatic void process_nlmeans(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                            const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in, \n                            const dt_iop_roi_t *const roi_out) \n{ \n   \n \n   \n \n  const dt_iop_denoiseprofile_params_t *const d = (const dt_iop_denoiseprofile_params_t *const)piece->data; \n \n  const int ch = piece->colors; \n \n   \n \n   \n \n  const float scale = fmin(roi_in->scale, 2.0f) / fmax(piece->iscale, 1.0f); \n  const int P = ceilf(d->radius * scale);  \n \n  const int K = ceilf(7 * scale);          \n \n \n   \n \n \n  float *Sa = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = dt_alloc_align(64, (size_t)sizeof(float) * P); \n  float *Sa_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv"}
{"label": "nt Data_plot_print_data  \n( Data_plot_t *D, int (*F) (const gsl_vector *x, gsl_vector *fx ),  \n  const char *fmt ) \n{ \n    const size_t Nvar = D->Nvar ;  \n    const size_t Nfunc = D->Nfunc ; \n   \n    if ( D->b_parallel_print_data &&  \n         D->b_print_data_stop_if_too_much_nan ) \n    { \n        WARNING ( stdout, \"%s\", \"le fait d'arreter la routine lorsque\" \n                  \" la fonction renvoie trop de failure n'est pas \\n\" \n                  \"compatible avec le multithreading je pense. \" \n                  \"A faire. En attendant, on ne parall\u00e9lise pas. \" );  \n \n        D->b_parallel_print_data = false ;  \n    } \n \n \n    if ( D->b_parallel_print_data ) \n    { \n       \n        WARNING ( stdout, \"%s\", \"A cause des changements faits, la\" \n                  \" routine de parall\u00e9lisation ne peut pas marcher : \" \n                  \"d'une part, chaque thread partage la meme fonction\" \n                  \" partageant a priori des variables communes. Donc \" \n                  \"c'est la merde. Ensuite, la routine source pour \" \n                  \"printer les data a besoin d'un objet data_plot, et\" \n                  \" qu'un seul est cr\u00e9e pour tous les threads : donc \" \n                  \"c'est la merde aussi. -> pas de parall\u00e9lisation \" \n                  \"possible pour le moement\" );  \n \n        return GSL_FAILURE ;  \n \n         \n \n       \n        const size_t nthread = 4 ;  \n        const size_t idecomp = 0 ; \n \n        TVector ** B  \n                = Data_plot_src_print_data_para_bounds (D, idecomp, nthread );  \n \n        gsl_vector_uint ** N \n                = Data_plot_src_print_data_para_npts ( D, B, idecomp, nthread );  \n       \n        TFlux * T = TFlux_alloc ( nthread );  \n       \n        for ( size_t i = 0 ; i < nthread ; i++ ) \n\t{ \n            TFlux_set_mode ( T, i, \"w\" );  \n            TFlux_set_path ( T, i, \"%s\", D->Fdata->path->s );  \n            TFlux_set_basename ( T, i, \"%s_omp_data%zu.dat\",  \n                                 D->basename->s, i );  \n            TFlux_open ( T, i );  \n\t} \n       \n         \n \n \n        for ( size_t i = 0 ; i < nthread ; i++ ) \n\t{ \n            Data_plot_src_print_data \n                    ( D, T->files[i]->file, F, B[i], N[i],  \n                      fmt, Nfunc, D->b_print_failure );  \n\t} \n         \n \n \n         \n \n \n        __DEBUG ( true, \"%s\", \"Il reste encore \u00e0 merger les fichiers\" \n                  \" cr\u00e9e en un seul qui a le meme nom que celui \" \n                  \"cr\u00e9e si on n'avait pas parall\u00e9lis\u00e9.\" );  \n \n         \n \n \n        for ( size_t i= 0 ; i < nthread ; i++ ) \n\t{ \n            gsl_vector_uint_free ( N[i] );  \n            TVector_free ( B[i] );  \n\t} \n        free ( B ) ;  \n        free ( N );  \n \n \n        WARNING ( stdout, \"%s\", \"A faire : merger les fichiers du \" \n                  \"tableau de flux\" );  \n \n \n        TFlux_free ( T );  \n \n    }  \n \n    else \n    {     \n        FILE * file = D->Fdata->file ;  \n        gsl_vector_uint * npts = gsl_vector_uint_alloc ( Nvar );  \n   \n        for ( size_t i = 0 ; i < Nvar ; i++ ) \n            gsl_vector_uint_set  \n                    ( npts, i, Vector_uint_get ( D->npts_var, i ) ) ;  \n \n \n        int status = Data_plot_src_print_data \n                ( D, file, F, D->bounds_var, npts, fmt, Nfunc,  \n                  D->b_print_failure);    \n \n        if ( status )  \n\t{ \n            WARNING ( stdout, \"%s\", \"Probleme print data\" );  \n\t} \n \n        gsl_vector_uint_free ( npts );  \n \n        return status ;  \n    }  \n \n} \n \n \n \n/********* ", "pred": "nt Data_plot_print_data  \n( Data_plot_t *D, int (*F) (const gsl_vector *x, gsl_vector *fx ),  \n  const char *fmt ) \n{ \n    const size_t Nvar = D->Nvar ;  \n    const size_t Nfunc = D->Nfunc ; \n   \n    if ( D->b_parallel_print_data &&  \n         D->b_print_data_stop_if_too_much_nan ) \n    { \n        WARNING ( stdout, \"%s\", \"le fait d'arreter la routine lorsque\" \n                  \" la fonction renvoie trop de failure n'est pas \\n\" \n                  \"compatible avec le multithreading je pense. \" \n                  \"A faire. En attendant, on ne parall\u00e9lise pas. \" );  \n \n        D->b_parallel_print_data = false ;  \n    } \n    else if ( D->b_parallel_print_data &&  \n              D->b_print_data_stop_if_too_much_nan ) \n    { \n        WARNING ( stdout, \"%s\", \"le fait d'arreter la routine lorsque\" \n                  \" la fonction renvoie trop de failure n'est pas \\n\" \n                  \"compatible avec le multithreading je pense. \" \n                  \"A faire. En attendant, on ne parall\u00e9lise pas. \" );  \n \n        D->b_parallel_print_data = false ;  \n    } \n    else if ( D->b_parallel_print_data &&  \n              D->b_print_data_stop_if_too_much_nan ) \n    { \n        WARNING ( stdout, \"%s\", \"le fait d'arreter la routine lorsque\" \n                  \" la fonction renvoie trop de failure n'est pas \\n\" \n                  \"compatible avec le multithreading je pense. \" \n                  \"A faire. En attendant, on ne parall\u00e9lise pas. \" );  \n \n        D->b_parallel_print_data = false ;  \n    } \n    else if ( D->b_parallel_print_data &&  \n              D->b_print_data_stop_if_too_much_nan ) \n    { \n        WARNING ( stdout, \"%s\", \"le fait d'arreter la routine lorsque\" \n                  \" la fonction renvoie trop de failure n'est pas \\n\" \n                  \"compatible avec le multithreading je pense. \" \n                  \"A faire. En attendant, on ne parall\u00e9lise pas. \" );  \n \n        D->b_parallel_print_data = false ;  \n    } \n    else if ( D->b_parallel_print_data &&  \n              D->b_print_data_stop_if_too_much_nan ) \n    { \n        WARNING ( stdout, \"%s\", \"le fait d'arreter la routine lorsque\" \n                  \" la fonction renvoie trop de failure n'est pas \\n\" \n                  \"compatible avec le multithreading je pense. \" \n                  \"A faire. En attendant, on ne parall\u00e9lise pas. \" );  \n \n        D->b_parallel_print_data = false ;  \n    } \n    else if ( D->b_parallel_print_data &&  \n              D->b_print_data_stop_if_too_much_nan ) \n    { \n        WARNING ( stdout, \"%s\", \"le fait d'arreter la routine lorsque\" \n                  \" la fonction renvoie trop de failure n'est pas \\n\" \n                  \"compatible avec le multithreading je pense. \" \n                  \"A faire. En attendant, on ne parall\u00e9lise pas. \" );  \n \n        D->b_parallel_print_data = false ;  \n    } \n    else if ( D->b_parallel_print_data &&  \n              D->b_print_data_stop_if_too_much_nan ) \n    { \n        WARNING ( stdout, \"%s\", \"le fait d'arreter la routine lorsque\" \n                  \" la fonction renvoie trop de failure n'est pas \\n\" \n                  \"compatible avec le multithreading je pense. \" \n                  \"A faire. En attendant, on ne parall\u00e9lise pas. \" );  \n \n        D->b_parallel_print_data = false ;  \n    } \n    else if ( D->b_parallel_print_data &&  \n              D->b_print_data_stop_if_too_much_nan ) \n    { \n        WARNING ( stdout, \"%s\", \"le fait d'arreter la routine lorsque\" \n                  \" la fonction renvoie trop de failure n'est pas \\n\" \n                  \"compatible avec le multithreading je pense. \" \n                  \"A faire. En attendant, on ne parall\u00e9lise pas. \" );  \n \n        D->b_parallel_print_data = false ;  \n    } \n    else if ( D->b_parallel_print_data &&  \n           "}
{"label": " \nstatic void process_nlmeans_sse(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in, \n                                const dt_iop_roi_t *const roi_out) \n{ \n   \n \n   \n \n  dt_iop_denoiseprofile_params_t *d = (dt_iop_denoiseprofile_params_t *)piece->data; \n \n   \n \n   \n \n  const float scale = fmin(roi_in->scale, 2.0f) / fmax(piece->iscale, 1.0f); \n  const int P = ceilf(d->radius * scale);  \n \n  const int K = ceilf(7 * scale);          \n \n \n   \n \n \n  float *Sa = dt_alloc_align(64, (size_t)sizeof(float) * roi_out->width * dt_get_num_threads()); \n   \n \n  memset(ovoid, 0x0, (size_t)sizeof(float) * roi_out->width * roi_out->height * 4); \n  float *in = dt_alloc_align(64, (size_t)4 * sizeof(float) * roi_in->width * roi_in->height); \n \n  const float wb[3] = { piece->pipe->dsc.processed_maximum[0] * d->strength * (scale * scale), \n                        piece->pipe->dsc.processed_maximum[1] * d->strength * (scale * scale), \n                        piece->pipe->dsc.processed_maximum[2] * d->strength * (scale * scale) }; \n  const float aa[3] = { d->a[1] * wb[0], d->a[1] * wb[1], d->a[1] * wb[2] }; \n  const float bb[3] = { d->b[1] * wb[0], d->b[1] * wb[1], d->b[1] * wb[2] }; \n  precondition((float *)ivoid, in, roi_in->width, roi_in->height, aa, bb); \n \n   \n \n  for(int kj = -K; kj <= K; kj++) \n  { \n    for(int ki = -K; ki <= K; ki++) \n    { \n       \n \n       \n \n \n      int inited_slide = 0; \n \n \n \n \n \n \n \n \n      for(int j = 0; j < roi_out->height; j++) \n      { \n        if(j + kj < 0 || j + kj >= roi_out->height) continue; \n        float *S = Sa + dt_get_thread_num() * roi_out->width; \n        const float *ins = in + 4l * ((size_t)roi_in->width * (j + kj) + ki); \n        float *out = ((float *)ovoid) + (size_t)4 * roi_out->width * j; \n \n        const int Pm = MIN(MIN(P, j + kj), j); \n        const int PM = MIN(MIN(P, roi_out->height - 1 - j - kj), roi_out->height - 1 - j); \n         \n \n         \n \n        if(!inited_slide) \n        { \n           \n \n          memset(S, 0x0, sizeof(float) * roi_out->width); \n          for(int jj = -Pm; jj <= PM; jj++) \n          { \n            int i = MAX(0, -ki); \n            float *s = S + i; \n            const float *inp = in + 4 * i + (size_t)4 * roi_in->width * (j + jj); \n            const float *inps = in + 4 * i + 4l * ((size_t)roi_in->width * (j + jj + kj) + ki); \n            const int last = roi_out->width + MIN(0, -ki); \n            for(; i < last; i++, inp += 4, inps += 4, s++) \n            { \n              for(int k = 0; k < 3; k++) s[0] += (inp[k] - inps[k]) * (inp[k] - inps[k]); \n            } \n          } \n           \n \n          if(Pm == P && PM == P) inited_slide = 1; \n        } \n \n         \n \n        float *s = S; \n        float slide = 0.0f; \n         \n \n        for(int i = 0; i < 2 * P + 1; i++) slide += s[i]; \n        for(int i = 0; i < roi_out->width; i++) \n        { \n           \n \n           \n \n          if(i - P > 0 && i + P < roi_out->width) slide += s[P] - s[-P - 1]; \n          if(i + ki >= 0 && i + ki < roi_out->width) \n          { \n             \n \n             \n \n            const float norm =.015f / (2 * P + 1); \n            const __m128 iv = { ins[0], ins[1], ins[2], 1.0f }; \n            _mm_store_ps(out, \n                         _mm_load_ps(out) + iv * _mm_set1_ps(fast_mexp2f(fmaxf(0.0f, slide * norm - 2.0f)))); \n             \n \n          } \n          s++; \n          ins += 4; \n          out += 4; \n        } \n        if(inited_slide && j + P + 1 + MAX(0, kj) < roi_out->height) \n        { \n           \n \n          int i = MAX(0, -ki); \n          s = S + i; \n          const float *inp = in + 4 * i + 4l * (size_t)roi_in->width * (j + P + 1); \n          const float *inps = in + 4 * i + 4l * ((size_t)roi_in->width * (j + P +", "pred": " \nstatic void process_nlmeans_sse(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in, \n                                const dt_iop_roi_t *const roi_out) \n{ \n   \n \n   \n \n  dt_iop_denoiseprofile_params_t *d = (dt_iop_denoiseprofile_params_t *)piece->data; \n \n   \n \n   \n \n  const float scale = fmin(roi_in->scale, 2.0f) / fmax(piece->iscale, 1.0f); \n  const int P = ceilf(d->radius * scale);  \n \n  const int K = ceilf(7 * scale);          \n \n \n   \n \n \n  float *Sa = dt_alloc_align(64, (size_t)sizeof(float) * roi_out->width * roi_out->height);\n  float *Sa_c = Sa;\n  float *Sa_c_c = Sa;\n  float *Sa_c_c_c = Sa;\n  float *Sa_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c_c_c_c_c_c_c_c_c_c_c_c_c = Sa;\n  float *Sa_c_c_c"}
{"label": " \nvoid THNN_(SpatialConvolutionLocal_updateGradInput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *gradOutput, \n    THTensor *gradInput, \n    THTensor *weight, \n    THTensor *finput, \n    THTensor *fgradInput, \n    int kW, int kH, \n    int dW, int dH, \n    int padW, int padH, \n    int64_t inputWidth, int64_t inputHeight, \n    int64_t outputWidth, int64_t outputHeight) \n{ \n  weight = THNN_(view_weight_local)(weight); \n \n  THNN_(SpatialConvolutionLocal_shapeCheck) \n    (input, gradOutput, weight, NULL, kH, kW, dH, dW, padH, padW, \n     inputHeight, inputWidth, outputHeight, outputWidth); \n \n  input = THTensor_(newContiguous)(input); \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n  int64_t nInputPlane = THTensor_(size)(weight,2)/(kW*kH); \n  int64_t nOutputPlane = THTensor_(size)(weight,1); \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(resizeAs)(fgradInput, finput); \n \n  THTensor *tweight = THTensor_(new)(); \n  THTensor_(transpose)(tweight, weight, 1, 2); \n \n  if(input->nDimension == 3) \n  { \n    THNN_(SpatialConvolutionLocal_updateGradInput_frame) \n      (gradInput, gradOutput, tweight, \n       fgradInput, kW, kH, dW, dH, padW, padH, \n       nInputPlane, inputWidth, inputHeight, \n       nOutputPlane, outputWidth, outputHeight); \n  } \n  else \n  { \n    int64_t T = input->size[0]; \n    int64_t t; \n \n    for(t = 0; t < T; t++) \n    { \n      THTensor *gradInput_t = THTensor_(newSelect)(gradInput, 0, t); \n      THTensor *gradOutput_t = THTensor_(newSelect)(gradOutput, 0, t); \n      THTensor *fgradInput_t = THTensor_(newSelect)(fgradInput, 0, t); \n \n      THNN_(SpatialConvolutionLocal_updateGradInput_frame) \n    (gradInput_t, gradOutput_t, tweight, fgradInput_t, \n     kW, kH, dW, dH, padW, padH, \n     nInputPlane, inputWidth, inputHeight, \n     nOutputPlane, outputWidth, outputHeight); \n \n      THTensor_(free)(gradInput_t); \n      THTensor_(free)(gradOutput_t); \n      THTensor_(free)(fgradInput_t); \n    } \n  } \n \n  THTensor_(free)(tweight); \n  THTensor_(free)(input); \n  THTensor_(free)(gradOutput); \n  THTensor_(free)(weight); \n} ", "pred": " \nvoid THNN_(SpatialConvolutionLocal_updateGradInput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *gradOutput, \n    THTensor *gradInput, \n    THTensor *weight, \n    THTensor *finput, \n    THTensor *fgradInput, \n    int kW, int kH, \n    int dW, int dH, \n    int padW, int padH, \n    int64_t inputWidth, int64_t inputHeight, \n    int64_t outputWidth, int64_t outputHeight) \n{ \n  weight = THNN_(view_weight_local)(weight); \n \n  THNN_(SpatialConvolutionLocal_shapeCheck) \n    (input, gradOutput, weight, NULL, kH, kW, dH, dW, padH, padW, \n     inputHeight, inputWidth, outputHeight, outputWidth); \n \n  input = THTensor_(newContiguous)(input); \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n  int64_t nInputPlane = THTensor_(size)(weight,2)/(kW*kH); \n  int64_t nOutputPlane = THTensor_(size)(weight,3)/(kH*kW); \n  int64_t nInputPlaneGrad = THTensor_(size)(gradInput,2)/(kH*kW); \n  int64_t nOutputPlaneGrad = THTensor_(size)(gradInput,3)/(kH*kW); \n  int64_t nInputPlaneWeight = THTensor_(size)(weight,2)/(kW*kH); \n  int64_t nOutputPlaneWeight = THTensor_(size)(weight,3)/(kH*kW); \n  int64_t nInputPlaneWeightGrad = THTensor_(size)(gradInput,2)/(kH*kW); \n  int64_t nOutputPlaneWeightGrad = THTensor_(size)(gradInput,3)/(kH*kW); \n  int64_t nInputPlaneWeightGradGrad = THTensor_(size)(gradInput,2)/(kH*kW); \n  int64_t nOutputPlaneWeightGradGrad = THTensor_(size)(gradInput,3)/(kH*kW); \n  int64_t nInputPlaneWeightGradWeight = THTensor_(size)(weight,2)/(kW*kH); \n  int64_t nOutputPlaneWeightGradWeight = THTensor_(size)(weight,3)/(kH*kW); \n  int64_t nInputPlaneWeightGradWeightGrad = THTensor_(size)(gradInput,2)/(kH*kW); \n  int64_t nOutputPlaneWeightGradWeightGrad = THTensor_(size)(gradInput,3)/(kH*kW); \n  int64_t nInputPlaneWeightGradWeightGradGrad = THTensor_(size)(gradInput,2)/(kH*kW); \n  int64_t nOutputPlaneWeightGradWeightGradGrad = THTensor_(size)(gradInput,3)/(kH*kW); \n  int64_t nInputPlaneWeightGradWeightGradWeight = THTensor_(size)(weight,2)/(kW*kH); \n  int64_t nOutputPlaneWeightGradWeightGradWeight = THTensor_(size)(weight,3)/(kH*kW); \n  int64_t nInputPlaneWeightGradWeightGradWeightGrad = THTensor_(size)(gradInput,2)/(kH*kW); \n  int64_t nOutputPlaneWeightGradWeightGrad"}
{"label": " \nvoid reb_integrator_leapfrog_part2(struct reb_simulation* r){ \n\tconst int N = r->N; \n\tstruct reb_particle* restrict const particles = r->particles; \n\tconst double dt = r->dt; \n\tfor (int i=0;i<N;i++){ \n\t\tparticles[i].vx += dt * particles[i].ax; \n\t\tparticles[i].vy += dt * particles[i].ay; \n\t\tparticles[i].vz += dt * particles[i].az; \n\t\tparticles[i].x  += 0.5* dt * particles[i].vx; \n\t\tparticles[i].y  += 0.5* dt * particles[i].vy; \n\t\tparticles[i].z  += 0.5* dt * particles[i].vz; \n\t} \n\tr->t+=dt/2.; \n} ", "pred": " \nvoid reb_integrator_leapfrog_part2(struct reb_simulation* r){ \n\tconst int N = r->N; \n\tstruct reb_particle* restrict const particles = r->particles; \n\tconst double dt = r->dt; \n\tfor (int i=0;i<N;i++){ \n\t\tparticles[i].vx += dt * particles[i].ax; \n\t\tparticles[i].vy += dt * particles[i].ay; \n\t\tparticles[i].vz += dt * particles[i].az; \n\t\tparticles[i].x  += 0.5* dt * particles[i].vx; \n\t\tparticles[i].y  += 0.5* dt * particles[i].vy; \n\t\tparticles[i].z  += 0.5* dt * particles[i].vz; \n\t} \n\tr->t+=dt/2.; \n} "}
{"label": " \nvoid VMatrixECM(gsl_matrix_float *X,float *ev,int type,int maxiter,VImage map) \n{ \n  size_t i,j; \n  size_t nvox = X->size1; \n  size_t nt = X->size2; \n \n   \n   \n \n  size_t m = (nvox*(nvox+1))/2; \n  float *A = (float *) calloc(m,sizeof(float)); \n  if (!A) VError(\" err allocating correlation matrix (too big)\"); \n  memset(A,0,m*sizeof(float)); \n  size_t progress=0; \n   \n \n  for (i=0; i<nvox; i++) { \n    if (i%1000 == 0) fprintf(stderr,\" %d000  of  %lu\\r\",(int)(++progress),nvox); \n \n    const float *arr1 = gsl_matrix_float_const_ptr(X,i,0); \n    for (j=0; j<=i; j++) { \n      if (i == j) continue; \n      const float *arr2 = gsl_matrix_float_const_ptr(X,j,0); \n       \n      const double v = ECMcorrelation(arr1,arr2,nt,type); \n      const size_t k=j+i*(i+1)/2; \n      A[k] = v; \n    } \n  } \n  fprintf(stderr,\"\\n\"); \n \n   \n   \n \n   \n \n     \n   \n \n  MatrixPowerIteration(A,ev,nvox,maxiter); \n  VFree(A); \n} ", "pred": " \nvoid VMatrixECM(gsl_matrix_float *X,float *ev,int type,int maxiter,VImage map) \n{ \n  size_t i,j; \n  size_t nvox = X->size1; \n  size_t nt = X->size2; \n \n   \n   \n \n  size_t m = (nvox*(nvox+1))/2; \n  float *A = (float *) calloc(m,sizeof(float)); \n  if (!A) VError(\" err allocating correlation matrix (too big)\"); \n  memset(A,0,m*sizeof(float)); \n  size_t progress=0; \n   \n \n  for (i=0; i<nvox; i++) { \n    if (i%1000 == 0) fprintf(stderr,\" %d000  of  %lu\\r\",(int)(++progress),nvox); \n \n    const float *arr1 = gsl_matrix_float_const_ptr(X,i,0); \n    for (j=0; j<=i; j++) { \n      if (i == j) continue; \n      const float *arr2 = gsl_matrix_float_const_ptr(X,j,0); \n       \n      float *ev1 = A+i*nt; \n      float *ev2 = A+j*nt; \n       \n       \n       \n       \n       \n       \n       \n       \n       \n       \n       \n       \n    "}
{"label": " \nvoid assign_mul_add_mul_add_mul_r(spinor * const R, spinor * const S, spinor * const U, \n\t\t\t\t  const double c1,const double c2,const double c3, \n\t\t\t\t  const int N) \n{ \n  { \n \n  spinor *r,*s,*u; \n \n  for (int ix = 0; ix < N; ++ix) \n  { \n    r=(spinor *) R + ix; \n    s=(spinor *) S + ix; \n    u=(spinor *) U + ix; \n     \n    r->s0.c0 = c1 * r->s0.c0 + c2 * s->s0.c0 + c3 * u->s0.c0; \n    r->s0.c1 = c1 * r->s0.c1 + c2 * s->s0.c1 + c3 * u->s0.c1; \n    r->s0.c2 = c1 * r->s0.c2 + c2 * s->s0.c2 + c3 * u->s0.c2; \n     \n    r->s1.c0 = c1 * r->s1.c0 + c2 * s->s1.c0 + c3 * u->s1.c0; \n    r->s1.c1 = c1 * r->s1.c1 + c2 * s->s1.c1 + c3 * u->s1.c1; \n    r->s1.c2 = c1 * r->s1.c2 + c2 * s->s1.c2 + c3 * u->s1.c2; \n \n    r->s2.c0 = c1 * r->s2.c0 + c2 * s->s2.c0 + c3 * u->s2.c0; \n    r->s2.c1 = c1 * r->s2.c1 + c2 * s->s2.c1 + c3 * u->s2.c1; \n    r->s2.c2 = c1 * r->s2.c2 + c2 * s->s2.c2 + c3 * u->s2.c2; \n     \n    r->s3.c0 = c1 * r->s3.c0 + c2 * s->s3.c0 + c3 * u->s3.c0; \n    r->s3.c1 = c1 * r->s3.c1 + c2 * s->s3.c1 + c3 * u->s3.c1; \n    r->s3.c2 = c1 * r->s3.c2 + c2 * s->s3.c2 + c3 * u->s3.c2; \n  } \n \n  }  \n \n} ", "pred": " \nvoid assign_mul_add_mul_add_mul_r(spinor * const R, spinor * const S, spinor * const U, \n\t\t\t\t  const double c1,const double c2,const double c3, \n\t\t\t\t  const int N) \n{ \n  { \n \n  spinor *r,*s,*u; \n \n  for (int ix = 0; ix < N; ++ix) \n  { \n    r=(spinor *) R + ix; \n    s=(spinor *) S + ix; \n    u=(spinor *) U + ix; \n     \n    r->s0.c0 = c1 * r->s0.c0 + c2 * s->s0.c0 + c3 * u->s0.c0; \n    r->s0.c1 = c1 * r->s0.c1 + c2 * s->s0.c1 + c3 * u->s0.c1; \n    r->s0.c2 = c1 * r->s0.c2 + c2 * s->s0.c2 + c3 * u->s0.c2; \n     \n    r->s1.c0 = c1 * r->s1.c0 + c2 * s->s1.c0 + c3 * u->s1.c0; \n    r->s1.c1 = c1 * r->s1.c1 + c2 * s->s1.c1 + c3 * u->s1.c1; \n    r->s1.c2 = c1 * r->s1.c2 + c2 * s->s1.c2 + c3 * u->s1.c2; \n     \n    r->s2.c0 = c1 * r->s2.c0 + c2 * s->s2.c0 + c3 * u->s2.c0; \n    r->s2.c1 = c1 * r->s2.c1 + c2 * s->s2.c1 + c3 * u->s2.c1; \n    r->s2.c2 = c1 * r->s2.c2 + c2 * s->s2.c2 + c3 * u->s2.c2; \n     \n    r->s3.c0 = c1 * r->s3.c0 + c2 * s->s3.c0 + c3 * u->s3.c0; \n    r->s3.c1 = c1 * r->s3.c1 + c2 * s->s3.c1 + c3 * u->s3.c1; \n    r->s3.c2 = c1 * r->s3.c2 + c2 * s->s3.c2 + c3 * u->s3.c2; \n     \n   "}
{"label": " \nvoid \ntest16 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest16 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ngrad_imp_LCU( struct halfspinor *der, \n\t      const struct halfspinor *S, \n\t      const struct field *Fmunu, \n\t      const double U_0, \n\t      const size_t t, \n\t      const size_t mu ) \n{ \n  size_t i ; \n  for( i = 0 ; i < LCU ; i++ ) { \n \n     \n \n    double complex A[ NCNC ] __attribute__((aligned(ALIGNMENT))) ; \n    double complex B[ NCNC ] __attribute__((aligned(ALIGNMENT))) ; \n     \n    const size_t Uidx = i + t*LCU ;     \n    const size_t Ubck = lat[ Uidx ].back[mu] ; \n     \n    const size_t Sfwd = lat[ i ].neighbor[mu] ; \n    const size_t Sfwd2 = lat[ Sfwd ].neighbor[mu] ; \n     \n    const size_t Sbck = lat[ i ].back[mu] ; \n    const size_t Sbck2 = lat[ Sbck ].back[mu] ; \n     \n    size_t d ; \n    for( d = 0 ; d < NS ; d++ ) { \n       \n \n      multab( (void*)der[ i ].D[d], \n\t      (void*)lat[ Uidx ].O[mu], \n\t      (void*)S[ Sfwd ].D[d] ) ; \n       \n \n      multabdag( (void*)A, \n\t\t (void*)lat[ Ubck ].O[mu], \n\t\t (void*)S[ Sbck ].D[d] ) ; \n       \n \n      #ifdef LEGACY_NRQCD_COMPARE \n      colormatrix_Sa_xmy( der[i].D[d], A, (7+1/(U_0*U_0))/12. ) ; \n      #else \n      colormatrix_Sa_xmy( der[i].D[d], A, 2./3. ) ; \n      #endif \n       \n       \n \n      multab( (void*)A, \n\t      (void*)Fmunu[i].O[6+2*mu], \n\t      (void*)S[ Sfwd2 ].D[d] ) ; \n       \n \n      multabdag( (void*)B, \n\t\t (void*)Fmunu[i].O[7+2*mu], \n\t\t (void*)S[ Sbck2 ].D[d] ) ; \n      colormatrix_Sa_xmy( A, B, -1./12. ) ; \n \n      add_mat( (void*)der[i].D[d], (void*)A ) ; \n    } \n  } \n  return ; \n} ", "pred": " \nvoid \ngrad_imp_LCU( struct halfspinor *der, \n\t      const struct halfspinor *S, \n\t      const struct field *Fmunu, \n\t      const double U_0, \n\t      const size_t t, \n\t      const size_t mu ) \n{ \n  size_t i ; \n  for( i = 0 ; i < LCU ; i++ ) { \n \n     \n \n    double complex A[ NCNC ] __attribute__((aligned(ALIGNMENT))) ; \n    double complex B[ NCNC ] __attribute__((aligned(ALIGNMENT))) ; \n     \n    const size_t Uidx = i + t*LCU ;     \n    const size_t Ubck = lat[ Uidx ].back[mu] ; \n     \n    const size_t Sfwd = lat[ i ].neighbor[mu] ; \n    const size_t Sfwd2 = lat[ Sfwd ].neighbor[mu] ; \n     \n    const size_t Sbck = lat[ i ].back[mu] ; \n    const size_t Sbck2 = lat[ Sbck ].back[mu] ; \n     \n    const size_t Sidx = Sfwd2 + Sbck2 ; \n    const size_t Sidx2 = Sidx + Sbck ; \n     \n    const size_t Sidx3 = Sidx2 + Sbck ; \n    const size_t Sidx4 = Sidx3 + Sbck ; \n     \n    const size_t Sidx5 = Sidx4 + Sbck ; \n    const size_t Sidx6 = Sidx5 + Sbck ; \n     \n    const size_t Sidx7 = Sidx6 + Sbck ; \n    const size_t Sidx8 = Sidx7 + Sbck ; \n     \n    const size_t Sidx9 = Sidx8 + Sbck ; \n    const size_t Sidx10 = Sidx9 + Sbck ; \n     \n    const size_t Sidx11 = Sidx10 + Sbck ; \n    const size_t Sidx12 = Sidx11 + Sbck ; \n     \n    const size_t Sidx13 = Sidx12 + Sbck ; \n    const size_t Sidx14 = Sidx13 + Sbck ; \n     \n    const size_t Sidx15 = Sidx14 + Sbck ; \n    const size_t Sidx16 = Sidx15 + Sbck ; \n     \n    const size_t Sidx17 = Sidx16 + Sbck ; \n    const size_t Sidx18 = Sidx17 + Sbck ; \n     \n    const size_t Sidx19 = Sidx18 + Sbck ; \n    const size_t Sidx20 = Sidx19 + Sbck ; \n     \n    const size_t Sidx21 = Sidx20 + Sbck ; \n  "}
{"label": " \nvoid reb_integrator_leapfrog_part1(struct reb_simulation* r){ \n\tconst int N = r->N; \n\tstruct reb_particle* restrict const particles = r->particles; \n\tconst double dt = r->dt; \n\tfor (int i=0;i<N;i++){ \n\t\tparticles[i].x  += 0.5* dt * particles[i].vx; \n\t\tparticles[i].y  += 0.5* dt * particles[i].vy; \n\t\tparticles[i].z  += 0.5* dt * particles[i].vz; \n\t} \n\tr->t+=dt/2.; \n} ", "pred": " \nvoid reb_integrator_leapfrog_part1(struct reb_simulation* r){ \n\tconst int N = r->N; \n\tstruct reb_particle* restrict const particles = r->particles; \n\tconst double dt = r->dt; \n\tfor (int i=0;i<N;i++){ \n\t\tparticles[i].x  += 0.5* dt * particles[i].vx; \n\t\tparticles[i].y  += 0.5* dt * particles[i].vy; \n\t\tparticles[i].z  += 0.5* dt * particles[i].vz; \n\t} \n\tr->t+=dt/2.; \n} "}
{"label": " \nvoid \ntest15 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest15 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ntest3 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest3 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 16; \n  tile_size[3] = 512; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,4);t1++) { \n    lbp=max(ceild(t1,2),ceild(8*t1-Nt+3,8)); \n    ubp=min(floord(Nt+Nz-4,8),floord(4*t1+Nz+1,8)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-3,4)),ceild(8*t2-Nz-12,16));t3<=min(min(min(floord(Nt+Ny-4,16),floord(4*t1+Ny+5,16)),floord(8*t2+Ny+4,16)),floord(8*t1-8*t2+Nz+Ny+3,16));t3++) { \n        for (t4=max(max(max(0,ceild(t1-127,128)),ceild(8*t2-Nz-508,512)),ceild(16*t3-Ny-508,512));t4<=min(min(min(min(floord(Nt+Nx-4,512),floord(4*t1+Nx+5,512)),floord(8*t2+Nx+4,512)),floord(16*t3+Nx+12,512)),floord(8*t1-8*t2+Nz+Nx+3,512));t4++) { \n          for (t5=max(max(max(max(max(0,4*t1),8*t1-8*t2+1),8*t2-Nz+2),16*t3-Ny+2),512*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,4*t1+7),8*t2+6),16*t3+14),512*t4+510),8*t1-8*t2+Nz+5);t5++) { \n            for (t6=max(max(8*t2,t5+1),-8*t1+8*t2+2*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(16*t3,t5+1);t7<=min(16*t3+15,t5+Ny-2);t7++) { \n                lbv=max(512*t4,t5+1); \n                ubv=min(512*t4+511,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = (((((((coef[0][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (coef[1][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)])) + (coef[2][ (-t5+t6)][ (-t5+t7)][", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    coef[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      coef[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_v[i] = (double **) malloc(sizeof(double"}
{"label": " \nvoid ctrsm(CBlasSide side, CBlasUplo uplo, CBlasTranspose transA, CBlasDiag diag, \n           size_t m, size_t n, \n           float complex alpha, const float complex * restrict A, size_t lda, \n           float complex * restrict B, size_t ldb) { \n  const size_t nRowA = (side == CBlasLeft)? m : n; \n \n  int info = 0; \n  if (lda < nRowA) \n    info = 9; \n  else if (ldb < m) \n    info = 11; \n  if (info!= 0) { \n    XERBLA(info); \n    return; \n  } \n \n  if (m == 0 || n == 0) \n    return; \n \n  if (alpha == zero) { \n    for (size_t j = 0; j < n; j++) { \n      for (size_t i = 0; i < m; i++) \n        B[j * ldb + i] = zero; \n    } \n    return; \n  } \n \n  if (side == CBlasLeft) { \n    if (transA == CBlasNoTrans) { \n      if (uplo == CBlasUpper) { \n        for (size_t j = 0; j < n; j++) { \n          if (alpha!= one) { \n            for (size_t i = 0; i < m; i++) \n              B[j * ldb + i] *= alpha; \n          } \n          size_t k = m - 1; \n          do { \n            if (B[j * ldb + k]!= zero) { \n              if (diag == CBlasNonUnit) B[j * ldb + k] /= A[k * lda + k]; \n              register float complex temp = B[j * ldb + k]; \n              for (size_t i = 0; i < k; i++) \n                B[j * ldb + i] -= temp * A[k * lda + i]; \n            } \n          } while (k-- > 0); \n        } \n      } \n      else { \n        for (size_t j = 0; j < n; j++) { \n          if (alpha!= one) { \n            for (size_t i = 0; i < m; i++) \n              B[j * ldb + i] *= alpha; \n          } \n          for (size_t k = 0; k < m; k++) { \n            if (B[j * ldb + k]!= zero) { \n              if (diag == CBlasNonUnit) B[j * ldb + k] /= A[k * lda + k]; \n              register float complex temp = B[j * ldb + k]; \n              for (size_t i = k + 1; i < m; i++) \n                B[j * ldb + i] -= temp * A[k * lda + i]; \n            } \n          } \n        } \n      } \n    } \n    else { \n      if (uplo == CBlasUpper) { \n        for (size_t j = 0; j < n; j++) { \n          for (size_t i = 0; i < m; i++) { \n            register float complex temp = alpha * B[j * ldb + i]; \n            if (transA == CBlasTrans) { \n              for (size_t k = 0; k < i; k++) \n                temp -= A[i * lda + k] * B[j * ldb + k]; \n              if (diag == CBlasNonUnit) temp /= A[i * lda + i]; \n            } \n            else { \n              for (size_t k = 0; k < i; k++) \n                temp -= conjf(A[i * lda + k]) * B[j * ldb + k]; \n              if (diag == CBlasNonUnit) temp /= conjf(A[i * lda + i]); \n            } \n            B[j * ldb + i] = temp; \n          } \n        } \n      } \n      else { \n        for (size_t j = 0; j < n; j++) { \n          size_t i = m - 1; \n          do { \n            register float complex temp = alpha * B[j * ldb + i]; \n            if (transA == CBlasTrans) { \n              for (size_t k = i + 1; k < m; k++) \n                temp -= A[i * lda + k] * B[j * ldb + k]; \n              if (diag == CBlasNonUnit) temp /= A[i * lda + i]; \n            } \n            else { \n              for (size_t k = i + 1; k < m; k++) \n                temp -= conjf(A[i * lda + k]) * B[j * ldb + k]; \n              if (diag == CBlasNonUnit) temp /= conjf(A[i * lda + i]); \n            } \n            B[j * ldb + i] = temp; \n          } while (i-- > 0); \n        } \n      } \n    } \n  } \n  else { \n    if (transA == CBlasNoTrans) { \n      if (uplo == CBlasUpper) { \n        for (size_t j = 0; j < n; j++) { \n          if (alpha!= one) { \n            for (size_t i = 0; i < m; i++) \n              B[j * ldb + i] *= alpha; \n          } \n          for (size_t k = 0; k < j; k++) { \n            if (A[j * lda + k]!= zero) { \n        ", "pred": " \nvoid ctrsm(CBlasSide side, CBlasUplo uplo, CBlasTranspose transA, CBlasDiag diag, \n           size_t m, size_t n, \n           float complex alpha, const float complex * restrict A, size_t lda, \n           float complex * restrict B, size_t ldb) { \n  const size_t nRowA = (side == CBlasLeft)? m : n; \n \n  int info = 0; \n  if (lda < nRowA) \n    info = 9; \n  else if (ldb < m) \n    info = 11; \n  if (info!= 0) { \n    XERBLA(info); \n    return; \n  } \n \n  if (m == 0 || n == 0) \n    return; \n \n  if (alpha == zero) { \n    for (size_t j = 0; j < n; j++) { \n      for (size_t i = 0; i < m; i++) \n        B[j * ldb + i] = zero; \n    } \n    return; \n  } \n \n  if (transA == CblasNoTrans) { \n    if (uplo == CblasUpper) { \n      for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < m; i++) \n          B[j * ldb + i] = alpha * A[i * lda + j]; \n      } \n    } \n    else { \n      for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < m; i++) \n          B[j * ldb + i] = alpha * A[i * lda + j]; \n      } \n    } \n  } \n  else if (transA == CblasTrans) { \n    if (uplo == CblasUpper) { \n      for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < m; i++) \n          B[j * ldb + i] = alpha * A[i * lda + j]; \n      } \n    } \n    else { \n      for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < m; i++) \n          B[j * ldb + i] = alpha * A[i * lda + j]; \n      } \n    } \n  } \n  else if (transA == CblasConjTrans) { \n    if (uplo == CblasUpper) { \n      for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < m; i++) \n          B[j * ldb + i] = alpha * A[i * lda + j]; \n      } \n    } \n    else { \n      for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < m; i++) \n          B[j * ldb + i] = alpha * A[i * lda + j]; \n      } \n    } \n  } \n  else { \n    BLAS_ERROR(\"unrecognized operation\"); \n  } \n \n}\n\n\nvoid ctrsm(CBlasSide side, CBlasUplo uplo, CBlasTranspose transA, CBlasDiag diag, \n           size_t m, size_t n, \n           double complex alpha, const double complex * restrict A, size_t lda, \n           double complex * restrict B, size_t ldb) { \n  const size_t nRowA = (side == CblasLeft)? m : n; \n \n  int info = 0; \n  if (lda < nRowA) \n    info = 9; \n  else if (ldb < m) \n    info = 11; \n  if (info!= 0) { \n    XERBLA(info); \n    return; \n  } \n \n  if (m == 0 || n == 0) \n    return; \n \n  if (alpha == zero) { \n    for (size_t j = 0; j < n; j++) { \n      for (size_t i = 0; i < m; i++) \n        B[j * ldb + i] = zero; \n    } \n    return; \n  } \n \n  if (transA == CblasNoTrans) { \n    if (uplo == CblasUpper) { \n      for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < m; i++) \n          B[j * ldb + i] = alpha * A[i * lda + j]; \n      } \n    } \n    else { \n      for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < m; i++) \n          B[j * ldb + i] = alpha * A[i * lda + j]; \n      } \n    } \n  } \n  else if (transA == CblasTrans) { \n    if (uplo == CblasUpper) { \n      for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < m; i++) \n          B[j * ldb + i] = alpha * A[i * lda + j]; \n      } \n    } \n    else { \n      for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < m; i++) \n          B[j * ldb + i] = alpha * A[i * lda + j]; \n      } \n    } \n  } \n  else if (transA == CblasConjTrans) { \n    if (uplo == CblasUpper) { \n      for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < m; i++) \n          B[j * ldb + i] = alpha * A[i * lda + j]; \n      } \n    } \n    else { \n      for (size_t j = 0; j < n; j++) { \n        for (size_t i = 0; i < m; i++) \n          B[j * ldb + i] = alpha * A[i * lda + j]; \n      } \n    } \n  } \n  else { \n    BLAS_ERROR(\"unrecognized operation\"); \n  } \n \n}\n\n\nvoid ctrsm(CBlasSide side, CBlasUplo uplo, CBlasTranspose transA, CBlasDiag diag, \n           size_t m, size_t n, \n           std::complex<float> alpha, const std::complex<float> * A, size_t lda, \n           std::complex<float> * B, size_t ldb) { \n  const size_t nRowA = (side == CblasLeft)? m : n; \n \n  int info = 0; \n  if (lda < nRowA) \n    info = 9; \n  else if (ldb <"}
{"label": " \nvoid \ntest13 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest13 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ntest12 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest12 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ntest7 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest7 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ntest10 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest10 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid direct_conv(float * D0, float * F, float * O, const int N, const int K, const int P, const int Q, const int C, const int R, const int S) { \n    const int P_pad = P + 2;  \n    const int Q_pad = Q + 2;  \n    int n, k, p, q, c, r, s;  \n    float sum;  \n    for (n = 0; n < N; n++) { \n        for (k = 0; k < K; k++) { \n            for (p = 1; p < P_pad-1; p++) { \n                for (q = 1; q < P_pad-1; q++) { \n                    sum = 0;  \n                    for (c = 0; c < C; c++) { \n                        for (r = 0; r < R; r++) { \n                            for (s = 0; s < S; s++) { \n                                sum += F[k*C*R*S + c*R*S + r*S + s]*D0[n*C*P_pad*Q_pad + c*P_pad*Q_pad + (p+r-1)*Q_pad + (q+s-1)];  \n                            } \n                        } \n                    } \n                    O[n*K*P*Q+ k*P*Q+ (p-1)*Q+ (q-1)] = sum;  \n                } \n            } \n        } \n    } \n} ", "pred": " \nvoid direct_conv(float * D0, float * F, float * O, const int N, const int K, const int P, const int Q, const int C, const int R, const int S) { \n    const int P_pad = P + 2;  \n    const int Q_pad = Q + 2;  \n    int n, k, p, q, c, r, s;  \n    float sum;  \n    for (n = 0; n < N; n++) { \n        for (k = 0; k < K; k++) { \n            for (p = 1; p < P_pad-1; p++) { \n                for (q = 1; q < P_pad-1; q++) { \n                    sum = 0;  \n                    for (c = 0; c < C; c++) { \n                        for (r = 0; r < R; r++) { \n                            for (s = 0; s < S; s++) { \n                                sum += F[n*K*P + k*P + p*P + q*P + c*P + r*P + s] * O[n*K*Q + k*Q + q*Q + c*Q + r*Q + s]; \n                            }  \n                        }  \n                    }  \n                    O[n*K*Q + k*Q + q*Q + c*Q + r*Q + s] = sum;  \n                }  \n            }  \n        }  \n    }  \n    for (n ="}
{"label": "void process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n  dt_iop_temperature_data_t *d = (dt_iop_temperature_data_t *)piece->data; \n  if(filters == 9u) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)j * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)j * roi_out->width; \n \n      int i = 0; \n      const int alignment = ((4 - (j * roi_out->width & (4 - 1))) & (4 - 1)); \n \n       \n \n      for(; i < alignment && i < roi_out->width; i++, out++, in++) \n        *out = *in * d->coeffs[FCxtrans(j, i, roi_out, xtrans)]; \n \n      const __m128 coeffs[3] = { \n        _mm_set_ps(d->coeffs[FCxtrans(j, i + 3, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 2, roi_out, xtrans)], \n                   d->coeffs[FCxtrans(j, i + 1, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 0, roi_out, xtrans)]), \n        _mm_set_ps(d->coeffs[FCxtrans(j, i + 7, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 6, roi_out, xtrans)], \n                   d->coeffs[FCxtrans(j, i + 5, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 4, roi_out, xtrans)]), \n        _mm_set_ps(d->coeffs[FCxtrans(j, i + 11, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 10, roi_out, xtrans)], \n                   d->coeffs[FCxtrans(j, i + 9, roi_out, xtrans)], d->coeffs[FCxtrans(j, i + 8, roi_out, xtrans)]) \n      }; \n \n       \n \n      for(int c = 0; c < 3 && i < roi_out->width - (4 - 1); c++, i += 4, in += 4, out += 4) \n      { \n        __m128 v; \n \n        v = _mm_load_ps(in); \n        v = _mm_mul_ps(v, coeffs[c]); \n        _mm_stream_ps(out, v); \n      } \n \n       \n \n      for(; i < roi_out->width; i++, out++, in++) *out = *in * d->coeffs[FCxtrans(j, i, roi_out, xtrans)]; \n    } \n    _mm_sfence(); \n  } \n  else if(filters) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)j * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)j * roi_out->width; \n \n      int i = 0; \n      const int alignment = ((4 - (j * roi_out->width & (4 - 1))) & (4 - 1)); \n \n       \n \n      for(; i < alignment && i < roi_out->width; i++, out++, in++) \n        *out = *in * d->coeffs[FC(j + roi_out->y, i + roi_out->x, filters)]; \n \n      const __m128 coeffs = _mm_set_ps(d->coeffs[FC(j + roi_out->y, roi_out->x + i + 3, filters)], \n                                       d->coeffs[FC(j + roi_out->y, roi_out->x + i + 2, filters)], \n                                       d->coeffs[FC(j + roi_out->y, roi_out->x + i + 1, filters)], \n                                       d->coeffs[FC(j + roi_out->y, roi_out->x + i, filters)]); \n \n       \n \n      for(; i < roi_out->width - (4 - 1); i += 4, in += 4, out += 4) \n      { \n        const __m128 input = _mm_load_ps(in); \n \n        const __m128 multiplied = _mm_mul_ps(input, coeffs); \n \n        _mm_stream_ps(out, multiplied); \n      } \n \n       \n \n      for(; i < roi_out->width; i++, out++, in++) \n        *out = *in * d->coeffs[FC(j + roi_out->y, i + roi_out->x, filters)]; \n    } \n    _mm_sfence(); \n  } \n  else \n  {  \n \n    const int ch = piece->colors; \n \n    const __m128 coeffs = _mm_set_ps(1.0f, d->coeffs[2], d->coeffs[1], d->coeffs[0]); \n \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)ch * k * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++, in += ch, out += ch) \n      { \n        const __m128 input = _mm_load_ps(in); \n        const __m128 multiplied = _mm_mul_ps(input, coeffs); \n        _mm_stream_ps(out, multiplied); \n      } \n    } \n    _mm_sfence(); \n \n    if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out->width, roi_out->height); \n  } \n \n  piece->pipe->dsc.temperature.enabled = 1; \n  for(int k = 0; k < 4; k++) \n  { \n    piece->pipe->dsc.temperature.coeffs[k] = d->coeffs[k]; \n    piece->pipe->", "pred": "void process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n  dt_iop_temperature_data_t *d = (dt_iop_temperature_data_t *)piece->data; \n  if(filters == 9u) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)j * roi_out->width; \n      float *out = ((float *)ovoid) + (size_t)j * roi_out->width; \n \n      int i = 0; \n      const int alignment = ((4 - (int)sizeof(float)) & 3); \n      for(i = 0; i < roi_out->width; i += 4) \n      { \n        const float *in_p = in + i; \n        float *out_p = out + i; \n        const float *xtrans_p = xtrans[i]; \n        const float *xtrans_p2 = xtrans[i + 1]; \n        const float *xtrans_p3 = xtrans[i + 2]; \n        const float *xtrans_p4 = xtrans[i + 3]; \n        const float *xtrans_p5 = xtrans[i + 4]; \n        const float *xtrans_p6 = xtrans[i + 5]; \n        const float *xtrans_p7 = xtrans[i + 6]; \n        const float *xtrans_p8 = xtrans[i + 7]; \n        const float *xtrans_p9 = xtrans[i + 8]; \n        const float *xtrans_p10 = xtrans[i + 9]; \n        const float *xtrans_p11 = xtrans[i + 10]; \n        const float *xtrans_p12 = xtrans[i + 11]; \n        const float *xtrans_p13 = xtrans[i + 12]; \n        const float *xtrans_p14 = xtrans[i + 13]; \n        const float *xtrans_p15 = xtrans[i + 14]; \n        const float *xtrans_p16 = xtrans[i + 15]; \n        const float *xtrans_p17 = xtrans[i + 16]; \n        const float *xtrans_p18 = xtrans[i + 17]; \n        const float *xtrans_p19 = xtrans[i + 18]; \n        const float *xtrans_p20 = xtrans[i + 19]; \n        const float *xtrans_p21 = xtrans[i + 20]; \n        const float *xtrans_p22 = xtrans[i + 21]; \n        const float *xtrans_p23 = xtrans[i + 22]; \n        const float *xtrans_p24 = xtrans[i + 23]; \n        const float *xtrans_p25 = xtrans[i + 24]; \n        const float *xtrans_p26 = xtrans[i + 25]; \n        const float *xtrans_p27 = xtrans[i + 26]; \n        const float *xtrans_p28 = xtrans[i + 27]; \n        const float *xtrans_p29 = xtrans[i + 28]; \n        const float *xtrans_p30 = xtrans[i + 29]; \n        const float *xtrans_p31 = xtrans[i + 30]; \n        const float *xtrans_p32 = xtrans[i + 31]; \n        const float *xtrans_p33 = xtrans[i + 32]; \n        const float *xtrans_p34 = xtrans[i + 33]; \n        const float *xtrans_p35 = xtrans[i + 34]; \n        const float *xtrans_p36 = xtrans[i + 35]; \n        const float *xtrans_p37 = xtrans[i + 36]; \n        const float *xtrans_p38 = xtrans[i + 37]; \n        const float *xtrans_p39 = xtrans[i + 38]; \n        const float *xtrans_p40 = xtrans[i + 39]; \n        const float *xtrans_p41 = xtrans[i + 40]; \n        const float *xtrans_p42 = xtrans[i + 41]; \n        const float *xtrans_p43 = xtrans[i + 42]; \n        const float *xtrans_p44 = xtrans[i + 43]; \n        const float *xtrans_p45 = xtrans[i + 44]; \n        const float *xtrans_p46 = xtrans[i + 45]; \n        const float *xtrans_p47 = xtrans[i + 46]; \n        const float *xtrans_p48 = xtrans[i + 47]; \n        const float *xtrans_p49 = xtrans[i + 48]; \n        const float *xtrans_p50 = xtrans[i + 49]; \n        const float *xtrans_p51 = xtrans[i + 50]; \n        const float *xtrans_p52 = xtrans[i + 51]; \n        const float *xtrans_p53 = xtrans[i + 52]; \n        const float *xtrans_p54 = xtrans[i + 53]; \n        const float *xtrans_p55 = xtrans[i + 54]; \n        const float *xtrans_p56 = xtrans[i + 55]; \n        const float *xtrans_p57 = xtrans[i + 56]; \n        const float *xtrans_p58 = xtrans[i + 57]; \n        const float *xtrans_p59 = xtrans[i + 58]; \n        const float *xtrans_p60 = xtrans[i + 59]; \n        const float *xtrans_p61 = xtrans[i + 60]; \n        const float *xtrans_p62 = xtrans[i + 61]; \n        const float *xtrans_p63 = xtrans[i + 62]; \n        const float *xtrans_p64 = xtrans[i + 63]; \n        const float *xtrans_p65 = xtrans[i + 64]; \n        const float *xtrans_p66 = xtrans[i + 65]; \n        const float *xtrans_p67 = xtrans[i + 66]; \n        const float *xtrans_p68 = xtrans[i + 67]; \n        const float *xtrans_p69 = xtrans[i + 68]; \n        const float *xtrans_p70 = x"}
{"label": " \nstatic void compute_centroids(void) \n{ \n\tint i, j;        \n \n\tint population;  \n \n \n\tstart = timer_get(); \n\t \n\tmemcpy(lcentroids, CENTROID(rank*(ncentroids/nprocs)), lncentroids[rank]*dimension*sizeof(float)); \n\tmemset(&has_changed[rank*NUM_THREADS], 0, NUM_THREADS*sizeof(int)); \n\tmemset(centroids, 0, (ncentroids + DELTA*nprocs)*dimension*sizeof(float)); \n\tmemset(ppopulation, 0, (ncentroids + nprocs*DELTA)*sizeof(int)); \n \n\t \n \n\tfor (i = 0; i < lnpoints; i++) \n\t{ \n\t\tj = map[i]%NUM_THREADS; \n\t\t \n\t\tomp_set_lock(&lock[j]); \n\t\t \n\t\tvector_add(CENTROID(map[i]), POINT(i)); \n\t\t\t \n\t\tppopulation[map[i]]++; \n\t\t \n\t\tomp_unset_lock(&lock[j]); \n\t} \n\t \n\tend = timer_get(); \n\ttotal += timer_diff(start, end); \n\t \n\tsync_pcentroids(); \n \n\tsync_ppopulation(); \n\t \n\tstart = timer_get(); \n \n\t \n \n\tfor (j = 0; j < lncentroids[rank]; j++) \n\t{ \n\t\tpopulation = 0; \n\t\t \n\t\tfor (i = 0; i < nprocs; i++) \n\t\t{ \n\t\t\tif (*POPULATION(i, j) == 0) \n\t\t\t\tcontinue; \n\t\t\t \n\t\t\tpopulation += *POPULATION(i, j); \n\t\t\t \n\t\t\tif (i == rank) \n\t\t\t\tcontinue; \n\t\t\t \n\t\t\tvector_add(PCENTROID(rank, j), PCENTROID(i, j)); \n\t\t} \n\t\t \n\t\tif (population > 1) \n\t\t\tvector_mult(PCENTROID(rank, j), 1.0/population); \n\t\t \n\t\t \n \n\t\tif (!vector_equal(PCENTROID(rank, j), LCENTROID(j))) \n\t\t{ \n\t\t\thas_changed[rank*NUM_THREADS + omp_get_thread_num()] = 1; \n\t\t\tvector_assign(LCENTROID(j), PCENTROID(rank, j)); \n\t\t} \n\t} \n\t \n\tend = timer_get(); \n\ttotal += timer_diff(start, end); \n\t\t \n\tsync_centroids(); \n\t\t \n\tsync_status(); \n} ", "pred": " \nstatic void compute_centroids(void) \n{ \n\tint i, j;        \n \n\tint population;  \n \n \n\tstart = timer_get(); \n\t \n\tmemcpy(lcentroids, CENTROID(rank*(ncentroids/nprocs)), lncentroids[rank]*dimension*sizeof(float)); \n\tmemset(&has_changed[rank*NUM_THREADS], 0, NUM_THREADS*sizeof(int)); \n\tmemset(centroids, 0, (ncentroids + DELTA*nprocs)*dimension*sizeof(float)); \n\tmemset(ppopulation, 0, (ncentroids + nprocs*DELTA)*sizeof(int)); \n \n\t \n \n\tfor (i = 0; i < lnpoints; i++) \n\t{ \n\t\tj = map[i]%NUM_THREADS; \n\t\t \n\t\tomp_set_lock(&lock[j]); \n\t\t \n\t\tvector_add(CENTROID(map[i]), POINT(i)); \n\t\t\t \n\t\tppopulation[map[i]]++; \n\t\t \n\t\tomp_unset_lock(&lock[j]); \n\t} \n\t \n\tend = timer_get(); \n\ttotal += timer_diff(start, end); \n\t \n\tsync_pcentroids(); \n \n\tfor (i = 0; i < NUM_THREADS; i++) \n\t{ \n\t\tif (ppopulation[i]!= 0) \n\t\t{ \n\t\t\thas_changed[i] = 1; \n\t\t\tlcentroids[i] = ppopulation[i]; \n\t\t} \n\t} \n \n\t\n} \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n"}
{"label": " \nvoid \ntest9 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest9 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ntest11 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest11 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = j1; i <= k1; ++i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nint findNodeDepths(double dt) \n{ \n    int i; \n    int converged;       \n \n    double yOld;         \n \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++ ) link_setOutfallDepth(i); \n \n     \n \n     \n \n    converged = TRUE; \n \n{ \n \n    for ( i = 0; i < Nobjects[NODE]; i++ ) \n    { \n        if ( Node[i].type == OUTFALL ) continue; \n        yOld = Node[i].newDepth; \n        setNodeDepth(i, dt); \n        Xnode[i].converged = TRUE; \n        if ( fabs(yOld - Node[i].newDepth) > HeadTol ) \n        { \n            converged = FALSE; \n            Xnode[i].converged = FALSE; \n        } \n    } \n}                                                                               \n \n    return converged; \n} ", "pred": " \nint findNodeDepths(double dt) \n{ \n    int i; \n    int converged;       \n \n    double yOld;         \n \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++ ) link_setOutfallDepth(i); \n \n     \n \n     \n \n    converged = TRUE; \n \n{ \n \n    for ( i = 0; i < Nobjects[NODE]; i++ ) \n    { \n        if ( Node[i].type == OUTFALL ) continue; \n        yOld = Node[i].newDepth; \n        setNodeDepth(i, dt); \n        Xnode[i].converged = TRUE; \n        if ( fabs(yOld - Node[i].newDepth) > HeadTol ) \n        { \n            converged = FALSE; \n            Xnode[i].converged = FALSE; \n        } \n    } \n \n} \n \nreturn( converged ); \n} \n \nint findNodeDepths(double dt) \n{ \n    int i; \n    int converged;       \n \n    double yOld;         \n \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i"}
{"label": " \nvoid findLinkFlows(double dt) \n{ \n    int i; \n \n     \n \n \n{ \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n        if ( isTrueConduit(i) &&!Link[i].bypassed ) \n            dwflow_findConduitFlow(i, Steps, Omega, dt); \n    } \n} \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n\t    if ( isTrueConduit(i) ) updateNodeFlows(i); \n    } \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n        if (!isTrueConduit(i) ) \n        {\t \n            if (!Link[i].bypassed ) findNonConduitFlow(i, dt); \n            updateNodeFlows(i); \n        } \n    } \n} ", "pred": " \nvoid findLinkFlows(double dt) \n{ \n    int i; \n \n     \n \n \n{ \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n        if ( isTrueConduit(i) &&!Link[i].bypassed ) \n            dwflow_findConduitFlow(i, Steps, Omega, dt); \n    } \n} \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n\t    if ( isTrueConduit(i) ) updateNodeFlows(i); \n    } \n \n     \n \n    for ( i = 0; i < Nobjects[LINK]; i++) \n    { \n        if (!isTrueConduit(i) ) \n        {\t \n            if (!Link[i].bypassed ) findNonConduitFlow(i, dt); \n            updateNodeFlows(i); \n        } \n    } \n \n}"}
{"label": " \nstatic void populate(void) \n{ \n\tint i, j;         \n \n\tfloat tmp;       \n \n\tfloat distance;  \n \n \n\tstart = timer_get(); \n\tmemset(&too_far[rank*NUM_THREADS], 0, NUM_THREADS*sizeof(int));  \n\t \n\t \n \n\tfor (i = 0; i < lnpoints; i++) \n\t{ \n\t\tdistance = vector_distance(CENTROID(map[i]), POINT(i)); \n\t\t \n\t\t \n \n\t\tfor (j = 0; j < ncentroids; j++) \n\t\t{ \n\t\t\t \n \n\t\t\tif (j == map[i]) \n\t\t\t\tcontinue; \n\t\t\t\t \n\t\t\ttmp = vector_distance(CENTROID(j), POINT(i)); \n\t\t\t \n\t\t\t \n \n\t\t\tif (tmp < distance) \n\t\t\t{ \n\t\t\t\tmap[i] = j; \n\t\t\t\tdistance = tmp; \n\t\t\t} \n\t\t} \n\t\t \n\t\t \n \n\t\tif (distance > mindistance) \n\t\t\ttoo_far[rank*NUM_THREADS + omp_get_thread_num()] = 1; \n\t} \n\tend = timer_get(); \n\ttotal += timer_diff(start, end); \n\t \n} ", "pred": " \nstatic void populate(void) \n{ \n\tint i, j;         \n \n\tfloat tmp;       \n \n\tfloat distance;  \n \n \n\tstart = timer_get(); \n\tmemset(&too_far[rank*NUM_THREADS], 0, NUM_THREADS*sizeof(int));  \n\t \n\t \n \n\tfor (i = 0; i < lnpoints; i++) \n\t{ \n\t\tdistance = vector_distance(CENTROID(map[i]), POINT(i)); \n\t\t \n\t\t \n \n\t\tfor (j = 0; j < ncentroids; j++) \n\t\t{ \n\t\t\t \n \n\t\t\tif (j == map[i]) \n\t\t\t\tcontinue; \n\t\t\t\t \n\t\t\ttmp = vector_distance(CENTROID(j), POINT(i)); \n\t\t\t \n\t\t\t \n \n\t\t\tif (tmp < distance) \n\t\t\t{ \n\t\t\t\tmap[i] = j; \n\t\t\t\tdistance = tmp; \n\t\t\t} \n\t\t} \n\t\t \n\t\t \n \n\t\tif (distance > mindistance) \n\t\t\ttoo_far[rank*NUM_THREADS + omp_get_thread_num()] = 1; \n\t} \n\tend = timer_get(); \n\ttotal += timer_diff(start, end); \n\t \n} \n"}
{"label": " \nvoid \ntest14 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest14 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  for (i = k1; i >= j1; --i) \n    { \n      if (i < j2 || i > k2) \n\t++e; \n      ++c; \n    } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nstatic int crypt_all(int *pcount, struct db_salt *salt) \n{ \n\tint count = *pcount; \n\tint i; \n \n\tfor (i = 0; i < count; i++) { \n\t\tSHA512_CTX ctx; \n \n\t\tmemcpy(&ctx, &ctx_salt, sizeof(ctx)); \n\t\tSHA512_Init(&ctx); \n\t\tSHA512_Update(&ctx, &saved_salt, SALT_SIZE); \n \n\t\tSHA512_Update(&ctx, saved_key[i], saved_key_length[i]); \n\t\tSHA512_Final((unsigned char *)(crypt_out[i]), &ctx); \n\t} \n\treturn count; \n} ", "pred": " \nstatic int crypt_all(int *pcount, struct db_salt *salt) \n{ \n\tint count = *pcount; \n\tint i; \n \n\tfor (i = 0; i < count; i++) { \n\t\tSHA512_CTX ctx; \n \n\t\tmemcpy(&ctx, &ctx_salt, sizeof(ctx)); \n\t\tSHA512_Init(&ctx); \n\t\tSHA512_Update(&ctx, &saved_salt, SALT_SIZE); \n \n\t\tSHA512_Update(&ctx, saved_key[i], saved_key_length[i]); \n\t\tSHA512_Final((unsigned char *)(crypt_out[i]), &ctx); \n\t} \n\treturn count; \n} "}
{"label": " \nvoid \ntest6 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest6 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ntest1 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest1 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 16; \n  tile_size[3] = 32; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,12);t1++) { \n    lbp=max(ceild(t1,2),ceild(24*t1-Nt+3,24)); \n    ubp=min(floord(Nt+Nz-4,24),floord(12*t1+Nz+9,24)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(3*t1-3,4)),ceild(24*t2-Nz-12,16));t3<=min(min(min(floord(Nt+Ny-4,16),floord(12*t1+Ny+21,16)),floord(24*t2+Ny+20,16)),floord(24*t1-24*t2+Nz+Ny+19,16));t3++) { \n        for (t4=max(max(max(0,ceild(3*t1-7,8)),ceild(24*t2-Nz-28,32)),ceild(16*t3-Ny-28,32));t4<=min(min(min(min(floord(Nt+Nx-4,32),floord(12*t1+Nx+21,32)),floord(24*t2+Nx+20,32)),floord(16*t3+Nx+12,32)),floord(24*t1-24*t2+Nz+Nx+19,32));t4++) { \n          for (t5=max(max(max(max(max(0,12*t1),24*t1-24*t2+1),24*t2-Nz+2),16*t3-Ny+2),32*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,12*t1+23),24*t2+22),16*t3+14),32*t4+30),24*t1-24*t2+Nz+21);t5++) { \n            for (t6=max(max(24*t2,t5+1),-24*t1+24*t2+2*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(16*t3,t5+1);t7<=min(16*t3+15,t5+Ny-2);t7++) { \n                lbv=max(32*t4,t5+1); \n                ubv=min(32*t4+31,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = (((((((coef[0][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (coef[1][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)])) + (coef[2][ (-t5+t6)][ (-t5", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    coef[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      coef[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_v[i] = (double **) malloc(sizeof(double"}
{"label": " \nvoid mul_add_mul_r(spinor * const R, spinor * const S, spinor * const U, \n\t\t   const double c1,const double c2, const int N) { \n  { \n \n  int ix; \n  spinor *r,*s,*u; \n   \n  for (ix=0; ix < N; ix++){ \n    r=(spinor *) R + ix; \n    s=(spinor *) S + ix; \n    u=(spinor *) U + ix; \n     \n    r->s0.c0 = c1 * s->s0.c0 + c2 * u->s0.c0; \n    r->s0.c1 = c1 * s->s0.c1 + c2 * u->s0.c1; \n    r->s0.c2 = c1 * s->s0.c2 + c2 * u->s0.c2; \n     \n    r->s1.c0 = c1 * s->s1.c0 + c2 * u->s1.c0; \n    r->s1.c1 = c1 * s->s1.c1 + c2 * u->s1.c1; \n    r->s1.c2 = c1 * s->s1.c2 + c2 * u->s1.c2; \n \n    r->s2.c0 = c1 * s->s2.c0 + c2 * u->s2.c0; \n    r->s2.c1 = c1 * s->s2.c1 + c2 * u->s2.c1; \n    r->s2.c2 = c1 * s->s2.c2 + c2 * u->s2.c2; \n \n    r->s3.c0 = c1 * s->s3.c0 + c2 * u->s3.c0; \n    r->s3.c1 = c1 * s->s3.c1 + c2 * u->s3.c1; \n    r->s3.c2 = c1 * s->s3.c2 + c2 * u->s3.c2; \n  } \n  }  \n \n} ", "pred": " \nvoid mul_add_mul_r(spinor * const R, spinor * const S, spinor * const U, \n\t\t   const double c1,const double c2, const int N) { \n  { \n \n  int ix; \n  spinor *r,*s,*u; \n   \n  for (ix=0; ix < N; ix++){ \n    r=(spinor *) R + ix; \n    s=(spinor *) S + ix; \n    u=(spinor *) U + ix; \n     \n    r->s0.c0 = c1 * s->s0.c0 + c2 * u->s0.c0; \n    r->s0.c1 = c1 * s->s0.c1 + c2 * u->s0.c1; \n    r->s0.c2 = c1 * s->s0.c2 + c2 * u->s0.c2; \n     \n    r->s1.c0 = c1 * s->s1.c0 + c2 * u->s1.c0; \n    r->s1.c1 = c1 * s->s1.c1 + c2 * u->s1.c1; \n    r->s1.c2 = c1 * s->s1.c2 + c2 * u->s1.c2; \n     \n    r->s2.c0 = c1 * s->s2.c0 + c2 * u->s2.c0; \n    r->s2.c1 = c1 * s->s2.c1 + c2 * u->s2.c1; \n    r->s2.c2 = c1 * s->s2.c2 + c2 * u->s2.c2; \n     \n    r->s3.c0 = c1 * s->s3.c0 + c2 * u->s3.c0; \n    r->s3.c1 = c1 * s->s3.c1 + c2 * u->s3.c1; \n    r->s3.c2 = c1 * s->s3.c2 + c2 * u->s3.c2; \n   "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 4; \n  tile_size[3] = 64; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,4);t1++) { \n    lbp=max(ceild(t1,2),ceild(8*t1-Nt+3,8)); \n    ubp=min(floord(Nt+Nz-4,8),floord(4*t1+Nz+1,8)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(8*t2-Nz,4)),t1);t3<=min(min(min(floord(Nt+Ny-4,4),floord(4*t1+Ny+5,4)),floord(8*t2+Ny+4,4)),floord(8*t1-8*t2+Nz+Ny+3,4));t3++) { \n        for (t4=max(max(max(0,ceild(t1-15,16)),ceild(8*t2-Nz-60,64)),ceild(4*t3-Ny-60,64));t4<=min(min(min(min(floord(4*t3+Nx,64),floord(Nt+Nx-4,64)),floord(4*t1+Nx+5,64)),floord(8*t2+Nx+4,64)),floord(8*t1-8*t2+Nz+Nx+3,64));t4++) { \n          for (t5=max(max(max(max(max(0,4*t1),8*t1-8*t2+1),8*t2-Nz+2),4*t3-Ny+2),64*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,4*t1+7),8*t2+6),4*t3+2),64*t4+62),8*t1-8*t2+Nz+5);t5++) { \n            for (t6=max(max(8*t2,t5+1),-8*t1+8*t2+2*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(4*t3,t5+1);t7<=min(4*t3+3,t5+Ny-2);t7++) { \n                lbv=max(64*t4,t5+1); \n                ubv=min(64*t4+63,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = (((((((coef[0][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (coef[1][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)])) + (coef[2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    coef[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      coef[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_v[i] = (double **) malloc(sizeof(double"}
{"label": " \nvoid winograd_conv(const int M, int irows, int C, int K, const int batch, long* total_flops, double* total_time, const int mod, const int verify){ \n    \n    long i, j, n;  \n    const int outHeight = irows-2;  \n    const int outWidth = irows-2;  \n    const int sizeI = irows*irows;  \n    const int sizeF = 3*3;  \n    const int sizeO = outHeight*outWidth;  \n    const int tiles = (outHeight)*0.5*(outWidth)*0.5;  \n \n    int ret;  \n \n    float* image;  \n     \n \n    ret = hbw_posix_memalign((void*)&image, 64, batch*C*sizeI*sizeof(float));  \n    assert(image!= NULL);  \n \n    float* filter;  \n     \n \n    ret = hbw_posix_memalign((void*)&filter, 64, K*C*sizeF*sizeof(float));  \n    assert(filter!= NULL);  \n \n \n    float* out;  \n     \n \n    ret = hbw_posix_memalign((void*)&out, 64, batch*K*sizeO*sizeof(float));  \n    assert(out!= NULL);  \n     \n     \n \n    for(i = 0; i < batch*C*sizeI; i++) \n        image[i] = (float)(i%mod);  \n     \n     \n \n    for(i = 0; i < K*C*sizeF; i++) \n        filter[i] = (float)(i%mod);  \n     \n \n    double timer;  \n    double timer_acc = 0.0f;  \n \n     \n \n    for(i = 0; i < 5; i++){ \n         \n \n        if (i>0) timer= omp_get_wtime();  \n        fal_conv(M, image, irows, C, filter, K, batch, out);  \n        if(i>0) timer_acc += omp_get_wtime()-timer;  \n    } \n \n    timer = timer_acc/4.0f;  \n    long nflops = batch*K*C*(irows-2)*(irows-2)*3*3*2;  \n    double gflops = (double) nflops*1.0e-9/timer;  \n    *total_flops += nflops;  \n    *total_time += timer;  \n \n    if(verify){ \n        printf(\"Verifying WINOGRAD CONV I = %d Batch = %d C = %d K = %d \\n\", irows, batch, C, K);  \n \n        float* vout;  \n         \n \n        ret = hbw_posix_memalign((void*)&vout, 64, batch*K*sizeO*sizeof(float));  \n        assert(vout!= NULL);  \n        direct_conv(image, filter, vout, batch, K, outHeight, outWidth, C, 3, 3);  \n        for(n = 0; n < batch*sizeO*K; n++){ \n            if(out[n]!= vout[n]){ \n                printf(\"Output Error: out[%d] = %f and vout[%d] = %f \\n\", n, out[n], n, vout[n]);  \n                break;  \n            } \n        } \n        hbw_free(vout);  \n    }else  \n        printf(\"WINOGRAD CONV:\\tEFFECTIVE GFLOPS is %.2f \\tGFlops \\tand timing is \\t%f  seconds \\n\", gflops, timer);  \n \n    hbw_free(image);  \n    hbw_free(filter);  \n    hbw_free(out);  \n \n} ", "pred": " \nvoid winograd_conv(const int M, int irows, int C, int K, const int batch, long* total_flops, double* total_time, const int mod, const int verify){ \n    \n    long i, j, n;  \n    const int outHeight = irows-2;  \n    const int outWidth = irows-2;  \n    const int sizeI = irows*irows;  \n    const int sizeF = 3*3;  \n    const int sizeO = outHeight*outWidth;  \n    const int tiles = (outHeight)*0.5*(outWidth)*0.5;  \n \n    int ret;  \n \n    float* image;  \n     \n \n    ret = hbw_posix_memalign((void*)&image, 64, batch*C*sizeI*sizeof(float));  \n    assert(image!= NULL);  \n \n    float* filter;  \n     \n \n    ret = hbw_posix_memalign((void*)&filter, 64, K*C*sizeF*sizeof(float));  \n    assert(filter!= NULL);  \n \n \n    float* out;  \n     \n    for(i=0; i<K; i++){  \n        for(j=0; j<C; j++){  \n            for(n=0; n<batch; n++){  \n                image[n*C*i+j*C+i] = 0.0;  \n            }  \n        }  \n    }  \n \n    for(i=0; i<outHeight; i++){  \n        for(j=0; j<outWidth; j++){  \n            for(n=0; n<batch; n++){  \n                filter[n*C*i+j*C+i] = 0.0;  \n            }  \n        }  \n    }  \n \n    for(i=0; i<K; i++){  \n        for(j=0; j<C; j++){  \n            for(n=0; n<batch; n++){  \n                out[n*C*i+j*C+i] = 0.0;  \n            }  \n        }  \n    }  \n \n    for(i=0; i<outHeight; i++){  \n        for(j=0; j<outWidth; j++){  \n            for(n=0; n<batch; n++){  \n                out[n*C*i+j*C+i] = 0.0;  \n            }  \n        }  \n    }  \n \n    for(i=0; i<K; i++){  \n        for(j=0; j<C; j++){  \n            for(n=0; n<batch; n++){  \n                image[n*C*i+j*C+i] = 0.0;  \n            }  \n        }  \n    }  \n \n    for(i=0; i<outHeight; i++){  \n        for(j=0; j<outWidth; j++){  \n            for(n=0; n<batch; n++){  \n                filter[n*C*i+j*C+i] = 0.0;  \n            }  \n        }  \n    }  \n \n    for(i=0; i<K; i++){  \n        for(j=0; j<C; j++){  \n     "}
{"label": " \nvoid \ntest5 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest5 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = j1; i <= k1; ++i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid THNN_(SpatialConvolutionLocal_updateOutput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *output, \n    THTensor *weight, \n    THTensor *bias, \n    THTensor *finput, \n    THTensor *fgradInput, \n    int kW, int kH, \n    int dW, int dH, \n    int padW, int padH, \n    int64_t inputWidth, int64_t inputHeight, \n    int64_t outputWidth, int64_t outputHeight) \n{ \n  weight = THNN_(view_weight_local)(weight); \n \n  THNN_(SpatialConvolutionLocal_shapeCheck) \n    (input, NULL, weight, bias, kH, kW, dH, dW, padH, padW, \n     inputHeight, inputWidth, outputHeight, outputWidth); \n \n  input = THTensor_(newContiguous)(input); \n \n  int64_t nInputPlane = THTensor_(size)(weight, 2)/ (kW * kH); \n  int64_t nOutputPlane = THTensor_(size)(weight, 1); \n \n  if(input->nDimension == 3) \n  { \n    THTensor_(resize2d)(finput, kW*kH*nInputPlane, outputHeight*outputWidth); \n    THTensor_(resize3d)(output, nOutputPlane, outputHeight, outputWidth); \n \n    THNN_(SpatialConvolutionLocal_updateOutput_frame) \n      (input, output, weight, bias, finput, \n       kW, kH, dW, dH, padW, padH, \n       nInputPlane, inputWidth, inputHeight, \n       nOutputPlane, outputWidth, outputHeight); \n  } \n  else \n  { \n    int64_t T = input->size[0]; \n    int64_t t; \n \n    THTensor_(resize3d)(finput, T, kW*kH*nInputPlane, outputHeight*outputWidth); \n    THTensor_(resize4d)(output, T, nOutputPlane, outputHeight, outputWidth); \n \n    for(t = 0; t < T; t++) \n    { \n      THTensor *input_t = THTensor_(newSelect)(input, 0, t); \n      THTensor *output_t = THTensor_(newSelect)(output, 0, t); \n      THTensor *finput_t = THTensor_(newSelect)(finput, 0, t); \n \n      THNN_(SpatialConvolutionLocal_updateOutput_frame) \n    (input_t, output_t, weight, bias, finput_t, \n     kW, kH, dW, dH, padW, padH, \n     nInputPlane, inputWidth, inputHeight, \n     nOutputPlane, outputWidth, outputHeight); \n \n      THTensor_(free)(input_t); \n      THTensor_(free)(output_t); \n      THTensor_(free)(finput_t); \n    } \n  } \n \n  THTensor_(free)(input); \n  THTensor_(free)(weight); \n} ", "pred": " \nvoid THNN_(SpatialConvolutionLocal_updateOutput)( \n    THNNState *state, \n    THTensor *input, \n    THTensor *output, \n    THTensor *weight, \n    THTensor *bias, \n    THTensor *finput, \n    THTensor *fgradInput, \n    int kW, int kH, \n    int dW, int dH, \n    int padW, int padH, \n    int64_t inputWidth, int64_t inputHeight, \n    int64_t outputWidth, int64_t outputHeight) \n{ \n  weight = THNN_(view_weight_local)(weight); \n \n  THNN_(SpatialConvolutionLocal_shapeCheck) \n    (input, NULL, weight, bias, kH, kW, dH, dW, padH, padW, \n     inputHeight, inputWidth, outputHeight, outputWidth); \n \n  input = THTensor_(newContiguous)(input); \n \n  int64_t nInputPlane = THTensor_(size)(weight, 2)/ (kW * kH); \n  int64_t nOutputPlane = THTensor_(size)(weight, 1); \n  int64_t nInputPlane2 = nInputPlane * nInputPlane; \n  int64_t nOutputPlane2 = nOutputPlane * nOutputPlane; \n \n  int64_t nInputPlane3 = nInputPlane * nInputPlane; \n  int64_t nOutputPlane3 = nOutputPlane * nOutputPlane; \n \n  int64_t nInputPlane4 = nInputPlane * nInputPlane; \n  int64_t nOutputPlane4 = nOutputPlane * nOutputPlane; \n \n  int64_t nInputPlane5 = nInputPlane * nInputPlane; \n  int64_t nOutputPlane5 = nOutputPlane * nOutputPlane; \n \n  int64_t nInputPlane6 = nInputPlane * nInputPlane; \n  int64_t nOutputPlane6 = nOutputPlane * nOutputPlane; \n \n  int64_t nInputPlane7 = nInputPlane * nInputPlane; \n  int64_t nOutputPlane7 = nOutputPlane * nOutputPlane; \n \n  int64_t nInputPlane8 = nInputPlane * nInputPlane; \n  int64_t nOutputPlane8 = nOutputPlane * nOutputPlane; \n \n  int64_t nInputPlane9 = nInputPlane * nInputPlane; \n  int64_t nOutputPlane9 = nOutputPlane * nOutputPlane; \n \n  int64_t nInputPlane10 = nInputPlane * nInputPlane; \n  int64_t nOutputPlane10 = nOutputPlane * nOutputPlane; \n \n  int64_t nInputPlane11 = nInputPlane * nInputPlane; \n  int64_t nOutputPlane11 = nOutputPlane * nOutputPlane; \n \n  int64_t nInputPlane12 = nInputPlane * nInputPlane; \n  int64_t nOutputPlane12 = nOutputPlane * nOutputPlane; \n \n  int64_t nInputPlane13 = nInputPlane * nInputPlane; \n  int64_t nOutputPlane13 = nOutputPlane * nOutputPlane; \n \n  int64_t nInputPlane14 = nInputPlane * nInputPlane; \n  int64_t nOutputPlane14 = nOutputPlane * nOutputPlane; \n \n  int64_t nInputPlane15 = nInputPlane * nInputPlane; \n  int64_t nOutputPlane15 = nOutputPlane *"}
{"label": " \nvoid \ntest8 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest8 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \nmontecarlo_main_loop(storage_model_t * storage, int64_t virtual_packet_flag, int nthreads, unsigned long seed) \n{ \n  int64_t packet_index; \n  storage->virt_packet_nus = (double *)malloc(sizeof(double) * storage->no_of_packets); \n  storage->virt_packet_energies = (double *)malloc(sizeof(double) * storage->no_of_packets); \n  storage->virt_packet_count = 0; \n  storage->virt_array_size = storage->no_of_packets; \n  fprintf(stderr, \"Running with OpenMP - %d threads\", nthreads); \n  omp_set_dynamic(0); \n  omp_set_num_threads(nthreads); \n  { \n    initialize_random_kit(seed + omp_get_thread_num()); \n  fprintf(stderr, \"Running without OpenMP\"); \n  initialize_random_kit(seed); \n  for (packet_index = 0; packet_index < storage->no_of_packets; packet_index++) \n    { \n      int reabsorbed = 0; \n      rpacket_t packet; \n      rpacket_set_id(&packet, packet_index); \n      rpacket_init(&packet, storage, packet_index, virtual_packet_flag); \n      if (virtual_packet_flag > 0) \n\t{ \n\t  reabsorbed = montecarlo_one_packet(storage, &packet, -1); \n\t} \n      reabsorbed = montecarlo_one_packet(storage, &packet, 0); \n      storage->output_nus[packet_index] = rpacket_get_nu(&packet); \n      if (reabsorbed == 1) \n\t{ \n\t  storage->output_energies[packet_index] = -rpacket_get_energy(&packet); \n\t} \n      else \n\t{ \n\t  storage->output_energies[packet_index] = rpacket_get_energy(&packet); \n\t} \n    } \n  } \n} ", "pred": " \nvoid \nmontecarlo_main_loop(storage_model_t * storage, int64_t virtual_packet_flag, int nthreads, unsigned long seed) \n{ \n  int64_t packet_index; \n  storage->virt_packet_nus = (double *)malloc(sizeof(double) * storage->no_of_packets); \n  storage->virt_packet_energies = (double *)malloc(sizeof(double) * storage->no_of_packets); \n  storage->virt_packet_count = 0; \n  storage->virt_array_size = storage->no_of_packets; \n  fprintf(stderr, \"Running with OpenMP - %d threads\", nthreads); \n  omp_set_dynamic(0); \n  omp_set_num_threads(nthreads); \n  { \n    initialize_random_kit(seed + omp_get_thread_num()); \n  fprintf(stderr, \"Running without OpenMP\"); \n  initialize_random_kit(seed); \n  for (packet_index = 0; packet_index < storage->no_of_packets; packet_index++) \n    { \n      int reabsorbed = 0; \n      rpacket_t packet; \n      rpacket_set_id(&packet, packet_index); \n      rpacket_set_virtual_packet_flag(&packet, virtual_packet_flag); \n      rpacket_set_virtual_packet_size(&packet, storage->virt_packet_size); \n      rpacket_set_virtual_packet_nus(&packet, storage->virt_packet_nus); \n      rpacket_set_virtual_packet_energies(&packet, storage->virt_packet_energies); \n      rpacket_set_virtual_packet_count(&packet, storage->virt_packet_count); \n      rpacket_set_virtual_packet_index(&packet, packet_index); \n      rpacket_set_virtual_packet_timestamp(&packet, storage->virt_packet_timestamp); \n      rpacket_set_virtual_packet_timestamp_ns(&packet, storage->virt_packet_timestamp_ns);"}
{"label": " \nvoid \ntest2 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest2 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid \ntest4 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} ", "pred": " \nvoid \ntest4 (long j1, long k1, long j2, long k2) \n{ \n  long i, e = 0, c = 0; \n  { \n    for (i = k1; i >= j1; --i) \n      { \n\tif (i < j2 || i > k2) \n\t  ++e; \n\t++c; \n      } \n    ++cnt; \n  } \n  if (e || (c!= j2 > k2? 0 : k2 - j2 + 1)) \n    abort (); \n} "}
{"label": " \nvoid  \nupdate_rho(double *rho,  \n           double *t) \n{ \n     \n \n \n    int i, j; \n \n    double ref_rho = 100.; \n    double ref_temp = 500.; \n    double thermal_expansivity = 0.001; \n \n    for ( j = 0; j < NY; j++ ){ \n       for ( i = 0; i < NX; i++ ){ \n           rho[NX*j + i] = ref_rho * (1. - (thermal_expansivity * (t[NX*j + i] - ref_temp))); \n       } \n    } \n} ", "pred": " \nvoid  \nupdate_rho(double *rho,  \n           double *t) \n{ \n     \n \n \n    int i, j; \n \n    double ref_rho = 100.; \n    double ref_temp = 500.; \n    double thermal_expansivity = 0.001; \n \n    for ( j = 0; j < NY; j++ ){ \n       for ( i = 0; i < NX; i++ ){ \n           rho[NX*j + i] = ref_rho * (1. - (thermal_expansivity * (t[NX*j + i] - ref_temp))); \n       } \n    } \n} "}
{"label": "lar_t k_arborescence_genf2(index_t         n, \n                              index_t         m, \n                              index_t         k, \n                              index_t         g, \n                              index_t         *d_pos, \n                              index_t         *d_adj,  \n                              ffprng_scalar_t y_seed, \n                              line_array_t    *d_x)  \n{ \n \n    assert(g == SCALARS_IN_LINE);    \n    assert(k >= 1); \n \n    line_array_t *d_s0  = (line_array_t *) MALLOC(LINE_ARRAY_SIZE(n*g)); \n    line_array_t *d_s1  = (line_array_t *) MALLOC(LINE_ARRAY_SIZE(n*g)); \n \n    scalar_t sum; \n    SCALAR_SET_ZERO(sum); \n \n     \n \n     \n \n     \n \n     \n \n    index_t deg = 1UL << (k-1); \n    for(index_t d = 0; d <= deg; d++) { \n        scalar_t zd = d+1;  \n         \n         \n \n        for(index_t u = 0; u < n; u++) { \n            line_t xu; \n            LINE_LOAD(xu, d_x, u);        \n \n            line_t xuzd; \n            LINE_MUL_SCALAR(xuzd, xu, zd);   \n \n            LINE_STORE(d_s0, u, xuzd);    \n \n        } \n \n         \n \n        srand(y_seed); \n        for(index_t l = 2; l <= k; l++) { \n            ffprng_scalar_t yl_seed = irand();  \n                 \n \n                 \n \n            k_arborescence_genf2_round(n,m,k,g,l,d_pos,d_adj,yl_seed,d_s0,d_s1); \n            line_array_t *tmp = d_s0; \n            d_s0 = d_s1; \n            d_s1 = tmp; \n        } \n         \n \n \n         \n \n        scalar_t zdsum = line_sum(n, g, d_s0); \n        scalar_t ldk = lagrange_coeff(deg, d, k); \n        scalar_t pk; \n        SCALAR_MUL(pk, ldk, zdsum); \n        SCALAR_ADD(sum, sum, pk);  \n    } \n \n    FREE(d_s0); \n    FREE(d_s1); \n \n    trans_bytes += (deg+1)*2*n*g*sizeof(scalar_t); \n    num_muls    += (deg+1)*n*g; \n \n    return sum; \n} \n \n \n \n ", "pred": "lar_t k_arborescence_genf2(index_t         n, \n                              index_t         m, \n                              index_t         k, \n                              index_t         g, \n                              index_t         *d_pos, \n                              index_t         *d_adj,  \n                              ffprng_scalar_t y_seed, \n                              index_t         *d_pos_gen, \n                              index_t         *d_adj_gen, \n                              index_t         *d_pos_gen_2, \n                              index_t         *d_adj_gen_2, \n                              index_t         *d_pos_gen_3, \n                              index_t         *d_adj_gen_3, \n                              index_t         *d_pos_gen_4, \n                              index_t         *d_adj_gen_4, \n                              index_t         *d_pos_gen_5, \n                              index_t         *d_adj_gen_5, \n                              index_t         *d_pos_gen_6, \n                              index_t         *d_adj_gen_6, \n                              index_t         *d_pos_gen_7, \n                              index_t         *d_adj_gen_7, \n                              index_t         *d_pos_gen_8, \n                              index_t         *d_adj_gen_8, \n                              index_t         *d_pos_gen_9, \n                              index_t         *d_adj"}
{"label": " \nvoid  \napply_thermal_boundary_conditions(double *t) \n{ \n    int i, j; \n    \n    for ( j = 0; j < NY; j++ ){ \n         \n \n        t[NX*j + 0] = t[NX*j + 1]; \n         \n         \n \n        t[NX*j + (NX-1)] = t[NX*j + (NX-2)]; \n    } \n     \n \n    for ( i = 0; i < NX; i++ ){ \n         \n \n        t[0 + i] = 1000.; \n \n         \n \n        t[NX*(NY-1) + i] = 0.; \n    } \n} ", "pred": " \nvoid  \napply_thermal_boundary_conditions(double *t) \n{ \n    int i, j; \n    \n    for ( j = 0; j < NY; j++ ){ \n         \n \n        t[NX*j + 0] = t[NX*j + 1]; \n         \n         \n \n        t[NX*j + (NX-1)] = t[NX*j + (NX-2)]; \n    } \n     \n \n    for ( i = 0; i < NX; i++ ){ \n         \n \n        t[0 + i] = 1000.; \n \n         \n \n        t[NX*(NY-1) + i] = 0.; \n    } \n} "}
{"label": " \nstatic IDnum *computeReadToNodeCounts(Coordinate *totalCount) \n{ \n\tIDnum nodeIndex; \n\tIDnum maxNodeIndex = 2 * nodeCount(graph) + 1; \n\tIDnum maxReadIndex = sequenceCount(graph) + 1; \n\tIDnum *readNodeCounts = callocOrExit(maxReadIndex, IDnum); \n\tunsigned char *readMarker = callocOrExit(1 + maxReadIndex / 8, unsigned char); \n\tCoordinate total = 0; \n \n\tvelvetLog(\"Computing read to node mapping array sizes\\n\"); \n \n\tfor (nodeIndex = 0; nodeIndex < maxNodeIndex; nodeIndex++) { \n\t\tNode *node; \n\t\tShortReadMarker *nodeArray; \n\t\tIDnum nodeReadCount; \n\t\tIDnum readIndex; \n \n\t\tnode = getNodeInGraph(graph, nodeIndex - nodeCount(graph)); \n\t\tif (node == NULL) \n\t\t\tcontinue; \n\t\tnodeArray = getNodeReads(node, graph); \n\t\tnodeReadCount = getNodeReadCount(node, graph); \n \n\t\t \n \n\t\tfor (readIndex = 0; readIndex < nodeReadCount; readIndex++) { \n\t\t\tShortReadMarker *shortMarker; \n\t\t\tIDnum readID; \n \n\t\t\tshortMarker = getShortReadMarkerAtIndex(nodeArray, \n\t\t\t\t\t\t\t\treadIndex); \n\t\t\treadID = getShortReadMarkerID(shortMarker); \n\t\t\treadNodeCounts[readID]++; \n\t\t\ttotal++; \n\t\t} \n\t} \n \n\tfor (nodeIndex = 0; nodeIndex < maxNodeIndex; nodeIndex++) { \n\t\tNode *node; \n\t\tPassageMarkerI marker; \n \n\t\tnode = getNodeInGraph(graph, nodeIndex - nodeCount(graph)); \n\t\tif (node == NULL) \n\t\t\tcontinue; \n\t\t \n \n\t\tfor (marker = getMarker(node); marker!= NULL_IDX; \n\t\t     marker = getNextInNode(marker)) { \n\t\t\tIDnum readIndex = getPassageMarkerSequenceID(marker);; \n \n\t\t\tif (readIndex < 0) \n\t\t\t\tcontinue; \n \n\t\t\tconst unsigned int idx = readIndex / 8; \n\t\t\tconst unsigned int mask = 1 << (readIndex & 7); \n\t\t\tif (readMarker[idx] & mask) \n\t\t\t\tcontinue; \n \n\t\t\treadNodeCounts[readIndex]++; \n\t\t\ttotal++; \n\t\t\treadMarker[idx] |= mask; \n\t\t} \n \n\t\t \n \n\t\tfor (marker = getMarker(node); marker!= NULL_IDX; \n\t\t     marker = getNextInNode(marker)) { \n\t\t\tIDnum readIndex = getPassageMarkerSequenceID(marker); \n\t\t\tif (readIndex > 0) \n\t\t\t\t \n \n\t\t\t\treadMarker[readIndex / 8] = 0; \n\t\t} \n\t} \n \n\t*totalCount = total; \n\tfree(readMarker); \n\treturn readNodeCounts; \n} ", "pred": " \nstatic IDnum *computeReadToNodeCounts(Coordinate *totalCount) \n{ \n\tIDnum nodeIndex; \n\tIDnum maxNodeIndex = 2 * nodeCount(graph) + 1; \n\tIDnum maxReadIndex = sequenceCount(graph) + 1; \n\tIDnum *readNodeCounts = callocOrExit(maxReadIndex, IDnum); \n\tunsigned char *readMarker = callocOrExit(1 + maxReadIndex / 8, unsigned char); \n\tCoordinate total = 0; \n \n\tvelvetLog(\"Computing read to node mapping array sizes\\n\"); \n \n\tfor (nodeIndex = 0; nodeIndex < maxNodeIndex; nodeIndex++) { \n\t\tNode *node; \n\t\tShortReadMarker *nodeArray; \n\t\tIDnum nodeReadCount; \n\t\tIDnum readIndex; \n \n\t\tnode = getNodeInGraph(graph, nodeIndex - nodeCount(graph)); \n\t\tif (node == NULL) \n\t\t\tcontinue; \n\t\tnodeArray = getNodeReads(node, graph); \n\t\tnodeReadCount = getNodeReadCount(node, graph); \n \n\t\t \n \n\t\tfor (readIndex = 0; readIndex < nodeReadCount; readIndex++) { \n\t\t\tShortReadMarker *shortMarker; \n\t\t\tIDnum readID; \n \n\t\t\tshortMarker = getShortReadMarkerAtIndex(nodeArray, \n\t\t\t\treadIndex, graph); \n\t\t\treadID = shortMarker->readID; \n\t\t\tif (readID > maxReadIndex) \n\t\t\t\tmaxReadIndex = readID; \n\t\t} \n \n\t\treadNodeCounts[nodeIndex] = maxReadIndex; \n\t\treadMarker[nodeIndex] = maxReadIndex; \n\t} \n \n\tfor (nodeIndex = 0; nodeIndex < maxNodeIndex; nodeIndex++) { \n\t\treadNodeCounts[nodeIndex] = 0; \n\t\treadMarker[nodeIndex] = 0; \n\t} \n \n\tfor (nodeIndex = 0; nodeIndex < maxNodeIndex; nodeIndex++) { \n\t\tif (readNodeCounts[nodeIndex] > 0) { \n\t\t\treadNodeCounts[nodeIndex]--; \n\t\t\treadMarker[nodeIndex] = readNodeCounts[nodeIndex]; \n\t\t} \n\t} \n \n\tfor (nodeIndex = 0; nodeIndex < maxNodeIndex; nodeIndex++) { \n\t\tif (readNodeCounts[nodeIndex] > 0) { \n\t\t\treadNodeCounts[nodeIndex]--; \n\t\t\treadMarker[nodeIndex] = readNodeCounts[nodeIndex]; \n\t\t} \n\t} \n \n\tfor (nodeIndex = 0; nodeIndex < maxNodeIndex; nodeIndex++) { \n\t\tif (readNodeCounts[nodeIndex] > 0) { \n\t\t\treadNodeCounts[nodeIndex]--; \n\t\t\treadMarker[nodeIndex] = readNodeCounts[nodeIndex]; \n\t\t} \n\t} \n \n\tfor (nodeIndex = 0; nodeIndex < maxNodeIndex; nodeIndex++) { \n\t\tif (readNodeCounts[nodeIndex] > 0) { \n\t\t\treadNodeCounts"}
{"label": "d randinits_scalar(scalar_t *a, index_t s, ffprng_scalar_t seed)  \n{ \n    ffprng_t base; \n    FFPRNG_INIT(base, seed); \n    index_t nt = num_threads(); \n    index_t block_size = s/nt; \n    for(index_t t = 0; t < nt; t++) { \n        ffprng_t gen; \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? s-1 : (start+block_size-1); \n        FFPRNG_FWD(gen, start, base); \n        for(index_t i = start; i <= stop; i++) { \n            ffprng_scalar_t rnd; \n            FFPRNG_RAND(rnd, gen); \n            scalar_t rs = (scalar_t) rnd;            \n            a[i] = rs; \n        } \n    } \n} \n \n/* ", "pred": "d randinits_scalar(scalar_t *a, index_t s, ffprng_scalar_t seed)  \n{ \n    ffprng_t base; \n    FFPRNG_INIT(base, seed); \n    index_t nt = num_threads(); \n    index_t block_size = s/nt; \n    for(index_t t = 0; t < nt; t++) { \n        ffprng_t gen; \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? s-1 : (start+block_size-1); \n        FFPRNG_FWD(gen, start, base); \n        for(index_t i = start; i <= stop; i++) { \n            ffprng_scalar_t rnd; \n            FFPRNG_RAND(rnd, gen); \n            scalar_t rs = (scalar_t) rnd;            \n            if(rs < a[i]) a[i] = rs; \n        } \n    }"}
{"label": " \nvoid  \nsolve_advection_diffusion(double *t,  \n                          double *u,  \n                          double *v, \n                          double dx,  \n                          double dy, \n                          double *rho,  \n                          double dt, \n                          double cp,  \n                          double *k, \n                          double H) \n{ \n    int i,j;  \n    double tn[NY*NX]; \n    double kx; \n    double ky; \n \n     \n \n    double dx2 = dx * dx; \n    double dy2 = dy * dy; \n    double twodx = 2. * dx; \n    double twody = 2. * dy; \n \n    for ( j = 0; j < NY; j++ ){ \n       for ( i = 0; i < NX; i++ ){ \n           tn[NX*j + i] = t[NX*j + i]; \n       } \n    } \n    \n  \n    unsigned int n = 0; \n    unsigned int s = 0; \n    unsigned int m = 0; \n    unsigned int e = 0; \n    unsigned int w = 0; \n \n    for ( j = 1; j < NY-1; j++ ){ \n        for ( i = 1; i < NX-1; i++){ \n            m = NX*j + i; \n            n = NX*(j-1) + i; \n            s = NX*(j+1) + i; \n            e = NX*j + (i+1); \n            w = NX*j + (i-1); \n \n            kx = k[m] * (tn[e] - 2.*tn[m] + tn[w]) / dx2; \n            ky = k[m] * (tn[s] - 2.*tn[m] + tn[n]) / dy2; \n \n            t[m] = tn[m] + dt * ((H + kx + ky)/(rho[m] * cp)                       - (u[m] * ( (tn[e] - tn[w]) / twodx ))                       - (v[m] * ( (tn[s] - tn[n]) / twody )) ); \n       } \n    } \n \n    apply_thermal_boundary_conditions(t); \n} ", "pred": " \nvoid  \nsolve_advection_diffusion(double *t,  \n                          double *u,  \n                          double *v, \n                          double dx,  \n                          double dy, \n                          double *rho,  \n                          double dt, \n                          double cp,  \n                          double *k, \n                          double H) \n{ \n    int i,j,k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21,k22,k23,k24,k25,k26,k27,k28,k29,k30,k31,k32,k33,k34,k35,k36,k37,k38,k39,k40,k41,k42,k43,k44,k45,k46,k47,k48,k49,k50,k51,k52,k53,k54,k55,k56,k57,k58,k59,k60,k61,k62,k63,k64,k65,k66,k67,k68,k69,k70,k71,k72,k73,k74,k75,k76,k77,k78,k79,k80,k81,k82,k83,k84,k85,k86,k87,k88,k89,k90,k91,k92,k93,k94,k95,k96,k97,k98,k99,k100,k101,k102,k103,k104,k105,k106,k107,k108,k109,k110,k111,k112,k113,k114,k115,k116,k117,k118,k119,k120,k121,k122,k123,k124,k125,k126,k127,k128,k129,k130,k131,k132,k133,k134,k135,k136,k137,k138,k139,k140,k141,k142,k143,k144,k145,k146,k147,k148,k149,k150,k151,k152,k153,k154,k155,k156,k157,k158,k159,k160,k161,k162,k163,k164,k165,k166,k167,k168,k169,k170,k171,k172,k173,k174,k175,k176,k177,k178,k179,k180,k181,k182,k183,k184,k185,k186,k187,k188,k189,k190,k191,k192,k193,k194,k195,k196,k197,k198,k199,k200,k201,k202,k203,k204,k205,k206,k207"}
{"label": " \nvoid scale(double *A, int rows, int cols, double alpha) { \n\tint N,i; \n\t \n  \n\t  \n\tN = rows * cols; \n\t \n\tfor (i = 0; i < N;++i) { \n\t\tA[i] = alpha * A[i]; \n\t} \n} ", "pred": " \nvoid scale(double *A, int rows, int cols, double alpha) { \n\tint N,i; \n\t \n  \n\t  \n\tN = rows * cols; \n\t \n\tfor (i = 0; i < N;++i) { \n\t\tA[i] = alpha * A[i]; \n\t} \n} "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 4; \n  tile_size[1] = 4; \n  tile_size[2] = 8; \n  tile_size[3] = 1024; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=2*Nt-2;t1++) { \n    lbp=ceild(t1+2,2); \n    ubp=min(floord(4*Nt+Nz-9,4),floord(2*t1+Nz-4,4)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(ceild(t1,4),ceild(4*t2-Nz+5,8));t3<=min(min(floord(4*Nt+Ny-9,8),floord(2*t1+Ny-3,8)),floord(4*t2+Ny-9,8));t3++) { \n        for (t4=max(max(ceild(t1-508,512),ceild(4*t2-Nz-1011,1024)),ceild(8*t3-Ny-1011,1024));t4<=min(min(min(floord(4*Nt+Nx-9,1024),floord(2*t1+Nx-3,1024)),floord(4*t2+Nx-9,1024)),floord(8*t3+Nx-5,1024));t4++) { \n          for (t5=max(max(max(ceild(t1,2),ceild(4*t2-Nz+5,4)),ceild(8*t3-Ny+5,4)),ceild(1024*t4-Nx+5,4));t5<=floord(t1+1,2);t5++) { \n            for (t6=max(4*t2,-4*t1+4*t2+8*t5-3);t6<=min(min(4*t2+3,-4*t1+4*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(8*t3,4*t5+4);t7<=min(8*t3+7,4*t5+Ny-5);t7++) { \n                lbv=max(1024*t4,4*t5+4); \n                ubv=min(1024*t4+1023,4*t5+Nx-5); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((2.0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) - A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (roc2[ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] * (((((coef0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (coef1 * (((((A[ t5 % 2][ (-4*t5+t6) - 1][ (-4*t5+t7)][ (-4*t5+t8)] + A[ t5 % 2][ (-4*t5+t6) + 1][ (-4*t5+t7)][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) - 1][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) + 1][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0; j<Ny; j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n  for(t=0; t<Nt; t++){ \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      }"}
{"label": "d k_arborescence_genf2_round(index_t         n, \n                                index_t         m, \n                                index_t         k, \n                                index_t         g, \n                                index_t         l, \n                                index_t         *d_pos, \n                                index_t         *d_adj, \n                                ffprng_scalar_t yl_seed, \n                                line_array_t    *d_in, \n                                line_array_t    *d_out) \n{ \n    assert(g == SCALARS_IN_LINE);    \n \n    index_t nt = num_threads(); \n    index_t length = n; \n    index_t block_size = length/nt; \n \n    ffprng_t y_base; \n    FFPRNG_INIT(y_base, yl_seed); \n \n \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? length-1 : (start+block_size-1); \n        ffprng_t y_gen; \n        index_t y_pos = d_pos[start]-start; \n        FFPRNG_FWD(y_gen, y_pos, y_base); \n        for(index_t u = start; u <= stop; u++) { \n            index_t pu  = d_pos[u];                 \n \n            index_t deg = d_adj[pu];                \n \n            index_t poff = 4; \n            index_t vvp = d_adj[pu+0+poff];       \n \n            LINE_PREFETCH(d_in, vvp);             \n \n            line_t pyvsum; \n            LINE_SET_ONE(pyvsum); \n            for(index_t j = 1; j <= deg; j++) { \n                index_t v = d_adj[pu+j];            \n \n                line_t pvin; \n                LINE_LOAD(pvin, d_in, v);      \n \n                index_t vp = d_adj[pu+j+poff];    \n \n                LINE_PREFETCH(d_in, vp);          \n \n                ffprng_scalar_t rnd;                \n                FFPRNG_RAND(rnd, y_gen); \n                scalar_t y_luv = (scalar_t) rnd; \n                line_t yuvpvin; \n                LINE_MUL_SCALAR(yuvpvin, pvin, y_luv);    \n \n                LINE_ADD(pyvsum, pyvsum, yuvpvin); \n            } \n            line_t puin; \n            LINE_LOAD(puin, d_in, u);               \n \n            line_t puout; \n            LINE_MUL(puout, puin, pyvsum);                \n \n            LINE_STORE(d_out, u, puout);            \n \n        } \n    } \n \n    trans_bytes += (2*n+m)*sizeof(index_t) + (m+2*n)*g*sizeof(scalar_t); \n    num_muls    += (m+n)*g; \n} \n \nsc ", "pred": "d k_arborescence_genf2_round(index_t         n, \n                                index_t         m, \n                                index_t         k, \n                                index_t         g, \n                                index_t         l, \n                                index_t         *d_pos, \n                                index_t         *d_ind, \n                                index_t         *d_val, \n                                index_t         *d_ind_t, \n                                index_t         *d_val_t, \n                                index_t         *d_ind_r, \n                                index_t         *d_val_r, \n                                index_t         *d_ind_c, \n                                index_t         *d_val_c, \n                                index_t         *d_ind_c_t, \n                                index_t         *d_val_c_t, \n                                index_t         *d_ind_c_r, \n                                index_t         *d_val_c_r, \n                                index_t         *d_ind_c_c, \n                                index_t         *d_val_c_c, \n                                index_t         *d_ind_r_t, \n                                index_t         *d_val_r_t, \n                                index_t         *d_ind_r_r, \n                                index_t         *d_val_r_r, \n                                index_t         *d_ind_c_t_t, \n                                index_t         *d_val_c_t_t, \n                                index_t         *d_ind_c_r_t, \n                                index_t         *d_val_c_r_t, \n                                index_t         *d_ind_c_c_t, \n                                index_t         *d_val_c_c_t, \n                                index_t         *d_ind_r"}
{"label": "atic pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose) \n{ \n    png_structp  png_ptr = NULL; \n    png_infop    info_ptr = NULL; \n    png_size_t   rowbytes; \n    int          color_type, bit_depth; \n \n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr, \n      rwpng_error_handler, verbose? rwpng_warning_stderr_handler : rwpng_warning_silent_handler); \n    if (!png_ptr) { \n        return PNG_OUT_OF_MEMORY_ERROR;    \n \n    } \n \n    info_ptr = png_create_info_struct(png_ptr); \n    if (!info_ptr) { \n        png_destroy_read_struct(&png_ptr, NULL, NULL); \n        return PNG_OUT_OF_MEMORY_ERROR;    \n \n    } \n \n     \n \n \n    if (setjmp(mainprog_ptr->jmpbuf)) { \n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL); \n        return LIBPNG_FATAL_ERROR;    \n \n    } \n \n     \n \n    png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_const_bytep)\"pHYs\\0iTXt\\0tEXt\\0zTXt\", 4); \n    png_set_read_user_chunk_fn(png_ptr, &mainprog_ptr->chunks, read_chunk_callback); \n \n    struct rwpng_read_data read_data = {infile, 0}; \n    png_set_read_fn(png_ptr, &read_data, user_read_data); \n \n    png_read_info(png_ptr, info_ptr);   \n \n \n     \n \n \n    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height, \n                 &bit_depth, &color_type, NULL, NULL, NULL); \n \n     \n \n    if (mainprog_ptr->width > INT_MAX/mainprog_ptr->height) { \n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL); \n        return PNG_OUT_OF_MEMORY_ERROR;   \n \n    } \n \n     \n \n \n     \n \n \n    if (!(color_type & PNG_COLOR_MASK_ALPHA)) { \n        png_set_expand(png_ptr); \n        png_set_filler(png_ptr, 65535L, PNG_FILLER_AFTER); \n        fprintf(stderr, \"pngquant readpng:  image is neither RGBA nor GA\\n\"); \n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL); \n        mainprog_ptr->retval = WRONG_INPUT_COLOR_TYPE; \n        return mainprog_ptr->retval; \n    } \n \n    if (bit_depth == 16) { \n        png_set_strip_16(png_ptr); \n    } \n \n    if (!(color_type & PNG_COLOR_MASK_COLOR)) { \n        png_set_gray_to_rgb(png_ptr); \n    } \n \n \n     \n \n    double gamma = 0.45455; \n    if (!png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB)) { \n        png_get_gAMA(png_ptr, info_ptr, &gamma); \n        if (gamma < 0 || gamma > 1.0) { \n            fprintf(stderr, \"pngquant readpng:  ignored out-of-range gamma %f\\n\", gamma); \n            gamma = 0.45455; \n        } \n    } \n    mainprog_ptr->gamma = gamma; \n \n    png_set_interlace_handling(png_ptr); \n \n     \n \n \n    png_read_update_info(png_ptr, info_ptr); \n \n    rowbytes = png_get_rowbytes(png_ptr, info_ptr); \n \n    if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) { \n        fprintf(stderr, \"pngquant readpng:  unable to allocate image data\\n\"); \n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL); \n        return PNG_OUT_OF_MEMORY_ERROR; \n    } \n \n    png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0); \n \n     \n \n \n    png_read_image(png_ptr, row_pointers); \n \n     \n \n \n    png_read_end(png_ptr, NULL); \n \n    png_charp ProfileData; \n    png_bytep ProfileData; \n    png_uint_32 ProfileLen; \n \n    cmsHPROFILE hInProfile = NULL; \n \n     \n \n    int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR; \n \n    mainprog_ptr->lcms_status = NONE; \n \n     \n \n    if (png_get_iCCP(png_ptr, info_ptr, &(png_charp){0}, &(int){0}, &ProfileData, &ProfileLen)) { \n \n        hInProfile = cmsOpenProfileFromMem(ProfileData, ProfileLen); \n        cmsColorSpaceSignature colorspace = cmsGetColorSpace(hInProfile); \n \n         \n \n        if (colorspace == cmsSigRgbData && COLOR_PNG) { \n            mainprog_ptr->lcms_status = ICCP; \n        } else { \n            if (colorspace == cmsSigGrayData &&!COLOR_PNG) { \n                mainprog_ptr->lcms_status = ICCP_WARN_GRAY; \n            } \n            cmsCloseProfile(hInProfile); \n            hInProfile = NULL; \n        } \n    } \n \n     \n \n    if (hInProfile == NULL && COLOR_PNG && \n       !png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB) && \n        png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA) && \n        png_get_valid(png_ptr, info_ptr, PNG_INFO_cHRM)) { \n \n        cmsCIExyY WhitePoint; \n        cmsCIExyYTRIPLE Primaries; \n \n        png_get_cHRM(png_ptr, info_ptr, &WhitePoint.x, &WhitePoint.y, \n                     &Primaries.Red.x, &Primaries.Red.y, \n                     &Primaries.Green.x", "pred": "atic pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose) \n{ \n    png_structp  png_ptr = NULL; \n    png_infop    info_ptr = NULL; \n    png_size_t   rowbytes; \n    int          color_type, bit_depth; \n \n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr, \n      rwpng_error_handler, verbose? rwpng_warning_stderr_handler : rwpng_warning_silent_handler); \n    if (!png_ptr) { \n        return PNG_OUT_OF_MEMORY_ERROR;    \n \n    } \n \n    info_ptr = png_create_info_struct(png_ptr); \n    if (!info_ptr) { \n        png_destroy_read_struct(&png_ptr, NULL, NULL); \n        return PNG_OUT_OF_MEMORY_ERROR;    \n \n    } \n \n     \n \n \n    if (setjmp(png_jmpbuf(png_ptr))) { \n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL); \n        return PNG_READ_ERROR; \n \n    } \n \n    png_init_io(png_ptr, infile); \n \n    png_read_info(png_ptr, info_ptr); \n    png_get_IHDR(png_ptr, info_ptr, &png_ptr->width, &png_ptr->height, &png_ptr->bit_depth, &png_ptr->color_type, &png_ptr->interlace_type, NULL, NULL); \n \n    if (verbose) { \n        png_get_rowbytes(png_ptr, info_ptr, &rowbytes); \n        png_set_rowbytes(png_ptr, info_ptr, rowbytes); \n    } \n \n    png_read_image(png_ptr, mainprog_ptr); \n \n    png_read_end(png_ptr, info_ptr); \n    png_destroy_read_struct(&png_ptr, &info_ptr, NULL); \n \n    return PNG_OK; \n} \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n    \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n    \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n    \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n    \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n"}
{"label": "d k_arborescence_genf1_round(index_t         n, \n                                index_t         m, \n                                index_t         k, \n                                index_t         g, \n                                index_t         l, \n                                index_t         *d_pos, \n                                index_t         *d_adj, \n                                ffprng_scalar_t yl_seed, \n                                line_array_t    *d_s)  \n{ \n    assert(g == SCALARS_IN_LINE);    \n \n    index_t nt = num_threads(); \n    index_t length = n; \n    index_t block_size = length/nt; \n \n    ffprng_t y_base; \n    FFPRNG_INIT(y_base, yl_seed); \n \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? length-1 : (start+block_size-1); \n        ffprng_t y_gen; \n        index_t y_pos = d_pos[start]-start; \n        FFPRNG_FWD(y_gen, y_pos, y_base); \n        for(index_t u = start; u <= stop; u++) { \n            index_t pu  = d_pos[u];                 \n \n            index_t deg = d_adj[pu];                \n \n            line_t pul; \n            LINE_SET_ZERO(pul); \n            for(index_t j = 1; j <= deg; j++) { \n                index_t v = d_adj[pu+j];            \n \n                index_t nv = d_adj[pu+j+(j < deg? 1 : 2)]; \n                     \n \n                line_t s; \n                LINE_SET_ZERO(s); \n                for(index_t l1 = 1; l1 < l; l1++) { \n                    line_t pul1, pvl2; \n                    index_t l2 = l-l1;  \n \n                    index_t i_v_l2 = ARB_LINE_IDX(b, k, l2, v);  \n \n                    LINE_LOAD(pvl2, d_s, i_v_l2);   \n                                               \n \n                    index_t i_u_l1 = ARB_LINE_IDX(b, k, l1, u);  \n \n                    LINE_LOAD(pul1, d_s, i_u_l1);   \n                                               \n \n                    index_t i_nv_l2 = ARB_LINE_IDX(b, k, l2, nv); \n                    LINE_PREFETCH(d_s, i_nv_l2);   \n \n                    line_t p; \n                    LINE_MUL(p, pul1, pvl2);        \n \n                    LINE_ADD(s, s, p); \n                } \n                ffprng_scalar_t rnd;                \n                FFPRNG_RAND(rnd, y_gen); \n                scalar_t y_luv = (scalar_t) rnd; \n                line_t sy; \n                LINE_MUL_SCALAR(sy, s, y_luv);      \n \n                LINE_ADD(pul, pul, sy); \n            } \n            index_t i_u_l = ARB_LINE_IDX(b, k, l, u); \n            LINE_STORE(d_s, i_u_l, pul);       \n \n        } \n    } \n \n    trans_bytes += (2*n+m)*sizeof(index_t) + (2*(l-1)*m+n)*g*sizeof(scalar_t); \n    num_muls    += ((l-1)*m+n)*g; \n} \n \nsc ", "pred": "d k_arborescence_genf1_round(index_t         n, \n                                index_t         m, \n                                index_t         k, \n                                index_t         g, \n                                index_t         l, \n                                index_t         *d_pos, \n                                index_t         *d_ind, \n                                index_t         *d_val, \n                                index_t         *d_ind_t, \n                                index_t         *d_val_t, \n                                index_t         *d_ind_r, \n                                index_t         *d_val_r, \n                                index_t         *d_ind_c, \n                                index_t         *d_val_c, \n                                index_t         *d_ind_c_t, \n                                index_t         *d_val_c_t, \n                                index_t         *d_ind_c_r, \n                                index_t         *d_val_c_r, \n                                index_t         *d_ind_c_c, \n                                index_t         *d_val_c_c, \n                                index_t         *d_ind_r_t, \n                                index_t         *d_val_r_t, \n                                index_t         *d_ind_r_r, \n                                index_t         *d_val_r_r, \n                                index_t         *d_ind_c_t_t, \n                                index_t         *d_val_c_t_t, \n                                index_t         *d_ind_c_r_t, \n                                index_t         *d_val_c_r_t, \n                                index_t         *d_ind_c_c_t, \n                                index_t         *d_val_c_c_t, \n                                index_t         *d_ind_r_t_r, \n                                index_t         *d_val_r_t_r, \n                                index_t         *d_ind_r_r_t, \n                                index_t         *d_val_r_r_t, \n                                index_t         *d_ind_c_t_r, \n                                index_t         *d_val_c_t_r, \n                                index_t     "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 4; \n  tile_size[1] = 4; \n  tile_size[2] = 4; \n  tile_size[3] = 2048; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=2*Nt-2;t1++) { \n    lbp=ceild(t1+2,2); \n    ubp=min(floord(4*Nt+Nz-9,4),floord(2*t1+Nz-4,4)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(ceild(t1+2,2),ceild(4*t2-Nz+9,4));t3<=min(min(floord(4*Nt+Ny-9,4),floord(2*t1+Ny-3,4)),floord(4*t2+Ny-9,4));t3++) { \n        for (t4=max(max(ceild(t1-1020,1024),ceild(4*t2-Nz-2035,2048)),ceild(4*t3-Ny-2035,2048));t4<=min(min(min(floord(4*Nt+Nx-9,2048),floord(2*t1+Nx-3,2048)),floord(4*t2+Nx-9,2048)),floord(4*t3+Nx-9,2048));t4++) { \n          for (t5=max(max(max(ceild(t1,2),ceild(4*t2-Nz+5,4)),ceild(4*t3-Ny+5,4)),ceild(2048*t4-Nx+5,4));t5<=floord(t1+1,2);t5++) { \n            for (t6=max(4*t2,-4*t1+4*t2+8*t5-3);t6<=min(min(4*t2+3,-4*t1+4*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=4*t3;t7<=min(4*t3+3,4*t5+Ny-5);t7++) { \n                lbv=max(2048*t4,4*t5+4); \n                ubv=min(2048*t4+2047,4*t5+Nx-5); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((2.0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) - A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (roc2[ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] * (((((coef0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (coef1 * (((((A[ t5 % 2][ (-4*t5+t6) - 1][ (-4*t5+t7)][ (-4*t5+t8)] + A[ t5 % 2][ (-4*t5+t6) + 1][ (-4*t5+t7)][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) - 1][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) + 1][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0; j<Ny; j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n  for(t=0; t<Nt; t++){ \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      }"}
{"label": "lar_t k_arborescence_genf1(index_t         n, \n                              index_t         m, \n                              index_t         k, \n                              index_t         g, \n                              index_t         *d_pos, \n                              index_t         *d_adj,  \n                              ffprng_scalar_t y_seed, \n                              line_array_t    *d_x)  \n{ \n \n    assert(g == SCALARS_IN_LINE);    \n    assert(k >= 1); \n \n    line_array_t *d_s  = (line_array_t *) MALLOC(LINE_ARRAY_SIZE(k*n*g)); \n \n     \n \n \n    for(index_t u = 0; u < n; u++) { \n        line_t xu; \n        LINE_LOAD(xu, d_x, u);               \n \n        index_t i_u_1 = ARB_LINE_IDX(b, k, 1, u); \n        LINE_STORE(d_s, i_u_1, xu);          \n \n    } \n \n     \n \n    srand(y_seed); \n    for(index_t l = 2; l <= k; l++) { \n        ffprng_scalar_t yl_seed = irand();  \n \n        k_arborescence_genf1_round(n,m,k,g,l,d_pos,d_adj,yl_seed,d_s); \n    } \n \n     \n \n \n    scalar_t sum = line_sum_stride(n, g, k,  \n                                          ((line_array_t *)(((line_t *) d_s) + k - 1))); \n \n    FREE(d_s); \n \n    trans_bytes += 2*n*g*sizeof(scalar_t); \n    num_muls    += 0; \n \n    return sum; \n} \n \n \n \n ", "pred": "lar_t k_arborescence_genf1(index_t         n, \n                              index_t         m, \n                              index_t         k, \n                              index_t         g, \n                              index_t         *d_pos, \n                              index_t         *d_adj,  \n                              ffprng_scalar_t y_seed, \n                              index_t         *d_pos_gen, \n                              index_t         *d_adj_gen, \n                              index_t         *d_pos_gen_2, \n                              index_t         *d_adj_gen_2, \n                              index_t         *d_pos_gen_3, \n                              index_t         *d_adj_gen_3, \n                              index_t         *d_pos_gen_4, \n                              index_t         *d_adj_gen_4, \n                              index_t         *d_pos_gen_5, \n                              index_t         *d_adj_gen_5, \n                              index_t  "}
{"label": " \nvoid  \nupdate_nu(double *nu,  \n          double *t) \n{ \n     \n \n \n    int i, j; \n \n    double ref_nu = 1.; \n    double ref_temp = 500.; \n    double theta = 1.5; \n \n    for ( j = 0; j < NY; j++ ){ \n       for ( i = 0; i < NX; i++ ){ \n           nu[NX*j + i] = ref_nu * exp(-theta * ((t[NX*j + i] - ref_temp)/ref_temp)); \n       } \n    } \n} ", "pred": " \nvoid  \nupdate_nu(double *nu,  \n          double *t) \n{ \n     \n \n \n    int i, j; \n \n    double ref_nu = 1.; \n    double ref_temp = 500.; \n    double theta = 1.5; \n \n    for ( j = 0; j < NY; j++ ){ \n       for ( i = 0; i < NX; i++ ){ \n           nu[NX*j + i] = ref_nu * exp(-theta * ((t[NX*j + i] - ref_temp)/ref_temp)); \n       } \n    } \n} "}
{"label": "eduction (int loop) \n{ \n  int\ti; \n \n  for (i=1; i<loop; i++) { \n    rdct_and  = rdct_and && i; \n    rdct_and2 = i && rdct_and2; \n    rdct_and3 = rdct_and3 && false; \n    rdct_and4 = false && rdct_and4; \n  } \n} \n \n \nvoid \nchec ", "pred": "eduction (int loop) \n{ \n  int\ti; \n \n  for (i=1; i<loop; i++) { \n    rdct_and  = rdct_and && i; \n    rdct_and2 = i && rdct_and2; \n    rdct_and3 = rdct_and3 && false; \n    rdct_and4 = false && rdct_and4; \n  } \n} \n \n \nvoid \nchec "}
{"label": " \nvoid msub(double* A, double* B, double* C,int rows,int cols) { \n\tint N,i; \n\t \n  \n\t  \n\tN = rows * cols; \n\t \n\tfor (i = 0; i < N; ++i) { \n\t\tC[i] = A[i] - B[i]; \n\t} \n} ", "pred": " \nvoid msub(double* A, double* B, double* C,int rows,int cols) { \n\tint N,i; \n\t \n  \n\t  \n\tN = rows * cols; \n\t \n\tfor (i = 0; i < N; ++i) { \n\t\tC[i] = A[i] - B[i]; \n\t} \n} "}
{"label": "ifq_t *motifq_project(motifq_t *q,  \n                         index_t nproj, index_t *proj, index_t *embed, \n                         index_t nl, index_t *l) \n{ \n    index_t n = q->n; \n    index_t *pos = q->pos; \n    index_t *adj = q->adj;     \n  \n    index_t *posproj = alloc_idxtab(nproj); \n    index_t bproj = get_posproj(n, pos, adj, nproj, proj, embed, posproj); \n    index_t *adjproj = alloc_idxtab(bproj); \n \n    for(index_t v = 0; v < nproj; v++) { \n        index_t pv = posproj[v]; \n        index_t u = embed[v]; \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        index_t degproj = 0; \n        for(index_t i = 0; i < deg; i++) { \n            index_t w = proj[adj[pu + 1 + i]]; \n            if(w!= PROJ_UNDEF) \n                adjproj[pv + 1 + degproj++] = w; \n        } \n        adjproj[pv] = degproj; \n    } \n \n    motifq_t *qq = (motifq_t *) MALLOC(sizeof(motifq_t)); \n    qq->is_stub = 0; \n    qq->n = nproj; \n    qq->k = q->k; \n    qq->pos = posproj; \n    qq->adj = adjproj; \n \n     \n \n \n    assert(q->nl == 0);  \n \n    qq->nl = nl; \n    qq->l = (index_t *) MALLOC(sizeof(index_t)*nl); \n    for(index_t i = 0; i < nl; i++) { \n        index_t u = proj[l[i]]; \n        assert(u!= PROJ_UNDEF);  \n \n        qq->l[i] = u; \n    } \n \n     \n \n \n    qq->ns = q->ns; \n    qq->shade = (shade_map_t *) MALLOC(sizeof(shade_map_t)*nproj); \n \n    for(index_t u = 0; u < n; u++) { \n        index_t v = proj[u]; \n        if(v!= PROJ_UNDEF) \n            qq->shade[v] = q->shade[u]; \n    } \n \n     \n \n     \n \n \n     \n \n    index_t *l_shade = (index_t *) MALLOC(sizeof(index_t)*nl); \n    shade_map_t reserved_shades = 0; \n    for(index_t i = 0; i < nl; i++) { \n        index_t v = qq->l[i]; \n        index_t j = 0; \n        for(; j < qq->ns; j++) \n            if(((qq->shade[v] >> j)&1) == 1 &&  \n               ((reserved_shades >> j)&1) == 0) \n                break; \n        assert(j < qq->ns); \n        reserved_shades |= 1UL << j; \n        l_shade[i] = j; \n    } \n     \n \n \n    for(index_t v = 0; v < nproj; v++) \n        qq->shade[v] &= ~reserved_shades; \n \n     \n \n    for(index_t i = 0; i < nl; i++) { \n        index_t v = qq->l[i]; \n        qq->shade[v] = 1UL << l_shade[i]; \n    } \n    FREE(l_shade); \n \n    return qq; \n} \n \n/* ", "pred": "ifq_t *motifq_project(motifq_t *q,  \n                         index_t nproj, index_t *proj, index_t *embed, \n                         index_t nl, index_t *l) \n{ \n    index_t n = q->n; \n    index_t *pos = q->pos; \n    index_t *adj = q->adj;     \n  \n    index_t *posproj = alloc_idxtab(nproj); \n    index_t bproj = get_posproj(n, pos, adj, nproj, proj, embed, posproj); \n    index_t *adjproj = alloc_idxtab(bproj); \n \n    for(index_t v = 0; v < nproj; v++) { \n        index_t pv = posproj[v]; \n        index_t u = embed[v]; \n        index_t pu = pos[u]; \n        index_t p = adj[u]; \n        index_t v = embed[p]; \n        index_t pv2 = embed[v]; \n        index_t p2 = pos[pv2]; \n        index_t v2 = adj[p2]; \n        index_t pv3 = embed[v2]; \n        index_t p3 = pos[pv3]; \n        index_t v3 = adj[p3]; \n        index_t pv4 = embed[v3]; \n        index_t p4 = pos[pv4]; \n        index_t v4 = adj[p4]; \n        index_t pv5 = embed[v4]; \n        index_t p5 = pos[pv5]; \n        index_t v5 = adj[p5]; \n        index_t pv6 = embed[v5]; \n        index_t p6 = pos[pv6]; \n        index_t v6 = adj[p6]; \n        index_t pv7 = embed[v6]; \n        index_t p7 = pos[pv7]; \n        index_t v7 = adj[p7]; \n        index_t pv8 = embed[v7]; \n        index_t p8 = pos[pv8]; \n        index_t v8 = adj[p8]; \n        index_t pv9 = embed[v8]; \n        index_t p9 = pos[pv9]; \n        index_t v9 = adj[p9]; \n        index_t pv10 = embed[v9]; \n        index_t p10 = pos[pv10]; \n        index_t v10 = adj[p10]; \n        index_t pv11 = embed[v10]; \n        index_t p11 = pos[pv11]; \n        index_t v11 = adj[p11]; \n        index_t pv12 = embed[v11]; \n        index_t p12 = pos[pv12]; \n        index_t v12 = adj[p12]; \n        index_t pv13 = embed[v12]; \n        index_t p13 = pos[pv13]; \n        index_t v13 = adj[p13]; \n        index_t pv14 = embed[v13]; \n        index_t p14 = pos[pv14]; \n        index_t v14 = adj[p14]; \n        index_t pv15 = embed[v14]; \n        index_t p15 = pos[pv15]; \n        index_t v15 = adj[p15]; \n        index_t pv16 = embed[v15]; \n        index_t p16 = pos[pv16]; \n        index_t v16 = adj[p16]; \n        index_t pv17 = embed[v16]; \n        index_t p17 = pos[pv17]; \n        index_t v17 = adj[p17]; \n        index_t pv18 = embed[v17]; \n  "}
{"label": "ex_t prefixsum(index_t n, index_t *a, index_t k) \n{ \n \n    index_t s[MAX_THREADS]; \n    index_t nt = num_threads(); \n    assert(nt < MAX_THREADS); \n \n    index_t length = n; \n    index_t block_size = length/nt; \n \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? length-1 : (start+block_size-1); \n        index_t tsum = (stop-start+1)*k; \n        for(index_t u = start; u <= stop; u++) \n            tsum += a[u]; \n        s[t] = tsum; \n    } \n \n    index_t run = 0; \n    for(index_t t = 1; t <= nt; t++) { \n        index_t v = s[t-1]; \n        s[t-1] = run; \n        run += v; \n    } \n    s[nt] = run; \n \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? length-1 : (start+block_size-1); \n        index_t trun = s[t]; \n        for(index_t u = start; u <= stop; u++) { \n            index_t tv = a[u]; \n            a[u] = trun; \n            trun += tv + k; \n        } \n        assert(trun == s[t+1]);     \n    } \n \n \n    index_t run = 0; \n    for(index_t u = 0; u < n; u++) { \n        index_t tv = a[u]; \n        a[u] = run; \n        run += tv + k; \n    } \n \n \n    return run;  \n} \n \n \n/ ", "pred": "ex_t prefixsum(index_t n, index_t *a, index_t k) \n{ \n \n    index_t s[MAX_THREADS]; \n    index_t nt = num_threads(); \n    assert(nt < MAX_THREADS); \n \n    index_t length = n; \n    index_t block_size = length/nt; \n \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? length-1 : (start+block_size-1); \n        index_t tsum = (stop-start+1)*k; \n        for(index_t u = start; u <= stop; u++) \n            tsum += a[u]; \n        s[t] = tsum; \n    } \n \n    index_t run = 0; \n    for(index_t t = 1; t <= nt; t++) { \n        index_t v = s[t-1]; \n        index_t u = s[t]; \n        s[t] = v + u; \n        run = t; \n    } \n \n    return s[run]; \n} \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n"}
{"label": " \nvoid madd(double* A, double* B, double* C,int rows,int cols) { \n\tint N,i; \n\t \n  \n\t  \n\tN = rows * cols; \n\t \n\tfor (i = 0; i < N; ++i) { \n\t\tC[i] = A[i] + B[i]; \n\t} \n} ", "pred": " \nvoid madd(double* A, double* B, double* C,int rows,int cols) { \n\tint N,i; \n\t \n  \n\t  \n\tN = rows * cols; \n\t \n\tfor (i = 0; i < N; ++i) { \n\t\tC[i] = A[i] + B[i]; \n\t} \n} "}
{"label": " \nint main(int argc, char** argv) { \n    struct pb_TimerSet timers; \n    struct pb_Parameters *parameters; \n \n \n \n \n \n    printf(\"CPU-based sparse matrix vector multiplication****\\n\"); \n    printf(\"Original version by Li-Wen Chang <lchang20@illinois.edu> and Shengzhao Wu<wu14@illinois.edu>\\n\"); \n    printf(\"This version maintained by Chris Rodrigues  ***********\\n\"); \n    parameters = pb_ReadParameters(&argc, argv); \n    if ((parameters->inpFiles[0] == NULL) || (parameters->inpFiles[1] == NULL)) \n    { \n        fprintf(stderr, \"Expecting two input filenames\\n\"); \n        exit(-1); \n    } \n \n    pb_InitializeTimerSet(&timers); \n    pb_SwitchToTimer(&timers, pb_TimerID_COMPUTE); \n \n     \n \n    int len; \n    int depth; \n    int dim; \n    int pad=1; \n    int nzcnt_len; \n \n     \n \n     \n \n    float *h_data; \n    int *h_indices; \n    int *h_ptr; \n    int *h_perm; \n    int *h_nzcnt; \n     \n \n    float *h_Ax_vector; \n    float *h_x_vector; \n \n \n     \n \n    pb_SwitchToTimer(&timers, pb_TimerID_IO); \n     \n \n     \n \n     \n \n    int col_count; \n    coo_to_jds( \n            parameters->inpFiles[0],  \n \n            1,  \n \n            pad,  \n \n            1,  \n \n            1,  \n \n            0,  \n \n            1,  \n \n            &h_data, &h_ptr, &h_nzcnt, &h_indices, &h_perm, \n            &col_count, &dim, &len, &nzcnt_len, &depth \n            );\t\t \n \n \n    h_Ax_vector=(float*)malloc(sizeof(float)*dim); \n    h_x_vector=(float*)malloc(sizeof(float)*dim); \n    input_vec( parameters->inpFiles[1], h_x_vector,dim); \n \n    pb_SwitchToTimer(&timers, pb_TimerID_COMPUTE); \n \n \n \n    int p, i, k; \n     \n \n    for(p=0;p<50;p++) \n    { \n        for (i = 0; i < dim; i++) { \n            float sum = 0.0f; \n             \n \n            int  bound = h_nzcnt[i]; \n            for(k=0;k<bound;k++ ) { \n                int j = h_ptr[k] + i; \n                int in = h_indices[j]; \n \n                float d = h_data[j]; \n                float t = h_x_vector[in]; \n \n                sum += d*t; \n            } \n            h_Ax_vector[h_perm[i]] = sum; \n        } \n    }\t \n \n    if (parameters->outFile) { \n        pb_SwitchToTimer(&timers, pb_TimerID_IO); \n        outputData(parameters->outFile,h_Ax_vector,dim); \n \n    } \n    pb_SwitchToTimer(&timers, pb_TimerID_COMPUTE); \n \n    free (h_data); \n    free (h_indices); \n    free (h_ptr); \n    free (h_perm); \n    free (h_nzcnt); \n    free (h_Ax_vector); \n    free (h_x_vector); \n    pb_SwitchToTimer(&timers, pb_TimerID_NONE); \n \n    pb_PrintTimerSet(&timers); \n    pb_FreeParameters(parameters); \n \n    return 0; \n \n} ", "pred": " \nint main(int argc, char** argv) { \n    struct pb_TimerSet timers; \n    struct pb_Parameters *parameters; \n \n \n \n \n \n    printf(\"CPU-based sparse matrix vector multiplication****\\n\"); \n    printf(\"Original version by Li-Wen Chang <lchang20@illinois.edu> and Shengzhao Wu<wu14@illinois.edu>\\n\"); \n    printf(\"This version maintained by Chris Rodrigues  ***********\\n\"); \n    parameters = pb_ReadParameters(&argc, argv); \n    if ((parameters->inpFiles[0] == NULL) || (parameters->inpFiles[1] == NULL)) \n    { \n        fprintf(stderr, \"Expecting two input filenames\\n\"); \n        exit(-1); \n    } \n \n    pb_InitializeTimerSet(&timers); \n    pb_SwitchToTimer(&timers, pb_TimerID_COMPUTE); \n \n     \n \n    int len; \n    int depth; \n    int dim; \n    int pad=1; \n    int nzcnt_len; \n \n     \n \n     \n \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n  "}
{"label": "d adjsort(index_t n, index_t *pos, index_t *adj) \n{ \n    for(index_t u = 0; u < n; u++) { \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        heapsort_indext(deg, adj + pu + 1); \n    } \n} \n \nvo ", "pred": "d adjsort(index_t n, index_t *pos, index_t *adj) \n{ \n    for(index_t u = 0; u < n; u++) { \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        heapsort_indext(deg, adj + pu + 1); \n    } \n} \n \nvo "}
{"label": " \nvoid stranspose(double *sig, int rows, int cols,double *col) { \n\tint t,u; \n\tregister int i,j; \n\tfor (i=0; i < rows; i++) { \n\t\tt = i * cols; \n\t\tu = 0; \n\t\tfor (j=0; j < cols; j++) { \n\t\t\tcol[u+i] = sig[j+t]; \n\t\t\tu+=rows; \n\t\t} \n\t} \n\t \n} ", "pred": " \nvoid stranspose(double *sig, int rows, int cols,double *col) { \n\tint t,u; \n\tregister int i,j; \n\tfor (i=0; i < rows; i++) { \n\t\tt = i * cols; \n\t\tu = 0; \n\t\tfor (j=0; j < cols; j++) { \n\t\t\tcol[u+i] = sig[j+t]; \n\t\t\tu+=rows; \n\t\t} \n\t} \n\t \n} "}
{"label": "ex_t get_poscut(index_t n, index_t *pos, index_t *adj,  \n                   index_t lo_v, index_t hi_v, \n                   index_t *poscut) \n{ \n     \n \n    assert(lo_v <= hi_v); \n \n    for(index_t u = 0; u < lo_v; u++) { \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        index_t cs, ce; \n        index_t l = get_interval(deg, adj + pu + 1, \n                                 lo_v, hi_v, \n                                 &cs, &ce); \n        poscut[u] = deg - l; \n    } \n \n    for(index_t u = hi_v+1; u < n; u++) { \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        index_t cs, ce; \n        index_t l = get_interval(deg, adj + pu + 1, \n                                 lo_v, hi_v, \n                                 &cs, &ce); \n        poscut[u-hi_v-1+lo_v] = deg - l; \n    } \n \n    index_t ncut = n - (hi_v-lo_v+1); \n    index_t run = prefixsum(ncut, poscut, 1); \n    return run; \n} \n \nmo ", "pred": "ex_t get_poscut(index_t n, index_t *pos, index_t *adj,  \n                   index_t lo_v, index_t hi_v, \n                   index_t *poscut) \n{ \n     \n \n    assert(lo_v <= hi_v); \n \n    for(index_t u = 0; u < lo_v; u++) { \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        index_t cs, ce; \n        index_t l = get_interval(deg, adj + pu + 1, \n                                 lo_v, hi_v, \n                                 &cs, &ce); \n        poscut[u] = l; \n    } \n    return l; \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"label": "lar_t line_sum_stride(index_t      l,  \n                         index_t      g, \n                         index_t      stride, \n                         line_array_t *d_s) \n{ \n \n    index_t nt = num_threads(); \n    index_t block_size = l/nt; \n    assert(nt < MAX_THREADS); \n    scalar_t ts[MAX_THREADS]; \n     \n    for(index_t t = 0; t < nt; t++) { \n        SCALAR_SET_ZERO(ts[t]); \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? l-1 : (start+block_size-1); \n        line_t ln; \n        line_t acc; \n        LINE_SET_ZERO(acc); \n        for(index_t i = start; i <= stop; i++) {     \n            index_t ii = i*stride; \n            LINE_LOAD(ln, d_s, ii);     \n \n            LINE_ADD(acc, acc, ln); \n        } \n        scalar_t lsum; \n        LINE_SUM(lsum, acc); \n        ts[t] = lsum; \n    } \n    scalar_t sum; \n    SCALAR_SET_ZERO(sum); \n    for(index_t t = 0; t < nt; t++) { \n        SCALAR_ADD(sum, sum, ts[t]); \n    } \n \n    trans_bytes += sizeof(scalar_t)*l*g; \n \n    return sum; \n} \n \n \n/ ", "pred": "lar_t line_sum_stride(index_t      l,  \n                         index_t      g, \n                         index_t      stride, \n                         line_array_t *d_s) \n{ \n \n    index_t nt = num_threads(); \n    index_t block_size = l/nt; \n    assert(nt < MAX_THREADS); \n    scalar_t ts[MAX_THREADS]; \n     \n    for(index_t t = 0; t < nt; t++) { \n        SCALAR_SET_ZERO(ts[t]); \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? l-1 : (start+block_size-1); \n        line_t ln; \n        line_init(ln, start, stop, stride); \n        line_sum_stride(ln, g, stride, d_s); \n        line_destroy(ln); \n    } \n    return ts; \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"label": " \nstatic Connection **computeNodeToNodeMappings(ReadOccurence ** readNodes, \n\t\t\t\t\t      IDnum * readNodeCounts, \n\t\t\t\t\t      IDnum * readPairs, \n\t\t\t\t\t      Category * cats, \n\t\t\t\t\t      boolean * dubious, \n\t\t\t\t\t      boolean * shadows, \n\t\t\t\t\t      ShortLength * lengths) \n{ \n\tIDnum nodeID; \n\tIDnum nodes = nodeCount(graph); \n\tstruct timeval start, end, diff; \n\tCategory cat; \n\tboolean hasShadow; \n \n\tscaffold = callocOrExit(2 * nodes + 1, Connection *); \n \n\tvelvetLog(\"Computing direct node to node mappings\\n\"); \n \n\tgettimeofday(&start, NULL); \n\tcreateNodeLocks(graph); \n \n\tint threads = omp_get_max_threads(); \n\tif (threads > 32) \n\t\tthreads = 32; \n \n\tfor (nodeID = -nodes; nodeID <= nodes; nodeID++) \n\t{ \n\t\tif (nodeID % 10000 == 0) \n\t\t\tvelvetLog(\"Scaffolding node %li\\n\", (long) nodeID); \n \n\t\tprojectFromNode(nodeID, readNodes, readNodeCounts, \n\t\t\t\treadPairs, cats, dubious, lengths, shadows, false, 0); \n\t} \n \n\tinitConnectionStackMemory(); \n \n\thasShadow = false; \n\tfor (cat = 0; cat < CATEGORIES; cat++) \n\t\tif (shadows[cat]) \n\t\t{ \n\t\t\thasShadow = true; \n\t\t\tbreak; \n\t\t} \n \n\tif (hasShadow) \n\t{ \n\t\tfor (cat = 0; cat < CATEGORIES; cat++) \n\t\t{ \n\t\t\tsetAllConnectionsClean(); \n\t\t\tif (!shadows[cat]) \n\t\t\t\tcontinue; \n\t\t\tvelvetLog(\"Scaffolding MP library %i\\n\", cat); \n\t\t\tfor (nodeID = -nodes; nodeID <= nodes; nodeID++) \n\t\t\t\tprojectFromNode(nodeID, readNodes, readNodeCounts, \n\t\t\t\t\t\treadPairs, cats, dubious, lengths, \n\t\t\t\t\t\tshadows, true, cat); \n\t\t} \n\t} \n\tfor (nodeID = 2 * nodes; nodeID >= 0; nodeID--) \n\t\tsplayToList(scaffold + nodeID); \n \n\tdestroyConnectionStackMemory(); \n \n\tfree(nodeLocks); \n\tnodeLocks = NULL; \n\tgettimeofday(&end, NULL); \n\ttimersub(&end, &start, &diff); \n\tvelvetLog(\" === Nodes Scaffolded in %ld.%06ld s\\n\", (long) diff.tv_sec, (long) diff.tv_usec); \n \n\tPEBBLE_ROUND_NUM++; \n \n\treturn scaffold; \n} ", "pred": " \nstatic Connection **computeNodeToNodeMappings(ReadOccurence ** readNodes, \n\t\t\t\t\t      IDnum * readNodeCounts, \n\t\t\t\t\t      IDnum * readPairs, \n\t\t\t\t\t      Category * cats, \n\t\t\t\t\t      boolean * dubious, \n\t\t\t\t\t      boolean * shadows, \n\t\t\t\t\t      ShortLength * lengths) \n{ \n\tIDnum nodeID; \n\tIDnum nodes = nodeCount(graph); \n\tstruct timeval start, end, diff; \n\tCategory cat; \n\tboolean hasShadow; \n \n\tscaffold = callocOrExit(2 * nodes + 1, Connection *); \n \n\tvelvetLog(\"Computing direct node to node mappings\\n\"); \n \n\tgettimeofday(&start, NULL); \n\tcreateNodeLocks(graph); \n \n\tint threads = omp_get_max_threads(); \n\tif (threads > 32) \n\t\tthreads = 32; \n \n\tfor (nodeID = -nodes; nodeID <= nodes; nodeID++) \n\t{ \n\t\tif (nodeID % 10000 == 0) \n\t\t\tvelvetLog(\"Scaffolding node %li\\n\", (long) nodeID); \n \n\t\tprojectFromNode(nodeID, readNodes, readNodeCounts, \n\t\t\t\treadPairs, cats, dubious, shadows, lengths); \n \n\t\tif (shadows[nodeID]) \n\t\t{ \n\t\t\thasShadow = TRUE; \n\t\t\tif (shadows[nodeID] == 1) \n\t\t\t{ \n\t\t\t\tif (nodeID == 0) \n\t\t\t\t\tcat = cats[0]; \n\t\t\t\telse \n\t\t\t\t\tcat = cats[1]; \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\tif (nodeID == 0) \n\t\t\t\t\tcat = cats[1]; \n\t\t\t\telse \n\t\t\t\t\tcat = cats[0]; \n\t\t\t} \n\t\t} \n\t\telse \n\t\t{ \n\t\t\tif (nodeID == 0) \n\t\t\t\tcat = cats[0]; \n\t\t\telse \n\t\t\t\tcat = cats[1]; \n\t\t} \n \n\t\tif (cat == cats[0]) \n\t\t{ \n\t\t\tif (nodeID == 0) \n\t\t\t\tcreateNodeLocks(graph); \n\t\t\telse \n\t\t\t\tcreateNodeLocks(graph); \n \n\t\t\tcreateConnection(nodeID, readNodes, readNodeCounts, \n\t\t\t\t\treadPairs, cats, dubious, shadows, lengths); \n\t\t} \n\t\telse \n\t\t{ \n\t\t\tif (nodeID == 0) \n\t\t\t\tcreateNodeLocks(graph); \n\t\t\telse \n\t\t\t\tcreateNodeLocks(graph); \n \n\t\t\tcreateConnection(nodeID, readNodes, readNodeCounts, \n\t\t\t\t\treadPairs, cats, dubious, shadows, lengths); \n\t\t} \n \n\t\tif (shadows[nodeID])"}
{"label": " \nvoid nmult(double* A, double* B, double* C,int ra,int ca, int cb) { \n\tregister int i,j,k; \n\tint u,v,t,rb; \n\t \n\t \n  \n\t  \n\trb = ca; \n\tfor (i = 0; i < ra; ++i) { \n\t\tfor (j = 0; j < cb; ++j) { \n\t\t\tv = i * rb; \n\t\t\tu = i *cb; \n\t\t\tt = j + u; \n\t\t\tC[t] = 0.; \n\t\t\tfor (k = 0; k < rb;++k) { \n\t\t\t\tC[t] += A[k + v] * B[j + k * cb]; \n\t\t\t} \n\t\t} \n\t} \n \n \n} ", "pred": " \nvoid nmult(double* A, double* B, double* C,int ra,int ca, int cb) { \n\tregister int i,j,k; \n\tint u,v,t,rb; \n\t \n\t \n  \n\t  \n\trb = ca; \n\tfor (i = 0; i < ra; ++i) { \n\t\tfor (j = 0; j < cb; ++j) { \n\t\t\tv = i * rb; \n\t\t\tu = i *cb; \n\t\t\tt = j + u; \n\t\t\tC[t] = 0.; \n\t\t\tfor (k = 0; k < rb;++k) { \n\t\t\t\tC[t] += A[k + v] * B[j + k * cb]; \n\t\t\t} \n\t\t} \n\t} \n \n \n} "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 16; \n  tile_size[1] = 16; \n  tile_size[2] = 16; \n  tile_size[3] = 64; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,8);t1++) { \n    lbp=max(ceild(t1,2),ceild(16*t1-Nt+3,16)); \n    ubp=min(floord(Nt+Nz-4,16),floord(8*t1+Nz+5,16)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-1,2)),ceild(16*t2-Nz-12,16));t3<=min(min(min(floord(Nt+Ny-4,16),floord(8*t1+Ny+13,16)),floord(16*t2+Ny+12,16)),floord(16*t1-16*t2+Nz+Ny+11,16));t3++) { \n        for (t4=max(max(max(0,ceild(t1-7,8)),ceild(16*t2-Nz-60,64)),ceild(16*t3-Ny-60,64));t4<=min(min(min(min(floord(Nt+Nx-4,64),floord(8*t1+Nx+13,64)),floord(16*t2+Nx+12,64)),floord(16*t3+Nx+12,64)),floord(16*t1-16*t2+Nz+Nx+11,64));t4++) { \n          for (t5=max(max(max(max(max(0,8*t1),16*t1-16*t2+1),16*t2-Nz+2),16*t3-Ny+2),64*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,8*t1+15),16*t2+14),16*t3+14),64*t4+62),16*t1-16*t2+Nz+13);t5++) { \n            for (t6=max(max(16*t2,t5+1),-16*t1+16*t2+2*t5-15);t6<=min(min(16*t2+15,-16*t1+16*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(16*t3,t5+1);t7<=min(16*t3+15,t5+Ny-2);t7++) { \n                lbv=max(64*t4,t5+1); \n                ubv=min(64*t4+63,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = (((((((coef[0][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (coef[1][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)])) + (coef[2][ (-t5+t6)][ (-t5+t7)][", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    coef[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      coef[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_v[i] = (double **) malloc(sizeof(double"}
{"label": "d constrained_sieve_pre(index_t         n, \n                           index_t         k, \n                           index_t         g, \n                           index_t         pfx, \n                           index_t         num_shades, \n                           shade_map_t     *d_s, \n                           ffprng_scalar_t seed, \n                           line_array_t    *d_x) \n{ \n    assert(g == SCALARS_IN_LINE);    \n    assert(num_shades <= MAX_SHADES); \n \n    line_t   wdj[SHADE_LINES*MAX_K]; \n \n    ffprng_t base; \n    FFPRNG_INIT(base, seed); \n    for(index_t j = 0; j < k; j++) { \n        for(index_t dl = 0; dl < SHADE_LINES; dl++) { \n            index_t jsdl = j*SHADE_LINES+dl; \n            LINE_SET_ZERO(wdj[jsdl]); \n            for(index_t a = 0; a < SCALARS_IN_LINE; a++) { \n                ffprng_scalar_t rnd; \n                FFPRNG_RAND(rnd, base); \n                scalar_t rs = (scalar_t) rnd; \n                LINE_STORE_SCALAR(wdj[jsdl], a, rs);    \n \n            } \n        } \n    } \n \n    index_t nt = num_threads(); \n    index_t length = n; \n    index_t block_size = length/nt; \n    for(index_t t = 0; t < nt; t++) { \n        ffprng_t gen; \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? length-1 : (start+block_size-1); \n        FFPRNG_FWD(gen, SHADE_LINES*SCALARS_IN_LINE*start, base); \n        line_t vd[SHADE_LINES]; \n        for(index_t j = 0; j < SHADE_LINES; j++) { \n            LINE_SET_ZERO(vd[j]);  \n \n        }        \n        for(index_t u = start; u <= stop; u++) { \n            scalar_t uu[MAX_K]; \n            shade_map_t shades_u = d_s[u];             \n \n            for(index_t dl = 0; dl < SHADE_LINES; dl++) { \n                for(index_t a = 0; a < SCALARS_IN_LINE; a++) { \n                    index_t d = dl*SCALARS_IN_LINE + a; \n                    ffprng_scalar_t rnd; \n                    FFPRNG_RAND(rnd, gen); \n                    scalar_t rs = (scalar_t) rnd; \n                    rs = rs & (-((scalar_t)((shades_u >> d)&(d < num_shades))));   \n                    LINE_STORE_SCALAR(vd[dl], a, rs);  \n \n                } \n            } \n            for(index_t j = 0; j < k; j++) { \n                scalar_t uj; \n                SCALAR_SET_ZERO(uj); \n                for(index_t dl = 0; dl < SHADE_LINES; dl++) { \n                    index_t jsdl = j*SHADE_LINES+dl; \n                    line_t ln; \n                    LINE_MUL(ln, wdj[jsdl], vd[dl]);   \n \n                                                       \n \n                    scalar_t lns; \n                    LINE_SUM(lns, ln); \n                    SCALAR_ADD(uj, uj, lns); \n                } \n                uu[j] = uj; \n            } \n            line_t ln; \n            LINE_SET_ZERO(ln); \n            for(index_t a = 0; a < SCALARS_IN_LINE; a++) { \n                index_t ap = a < (1L << k)? pfx+a : 0; \n                scalar_t xua; \n                SCALAR_SET_ZERO(xua); \n                for(index_t j = 0; j < k; j++) { \n                    scalar_t z_uj = uu[j];             \n \n                    z_uj = z_uj & (-((scalar_t)(((ap) >> j)&1))); \n                    SCALAR_ADD(xua, xua, z_uj); \n                } \n                LINE_STORE_SCALAR(ln,", "pred": "d constrained_sieve_pre(index_t         n, \n                           index_t         k, \n                           index_t         g, \n                           index_t         pfx, \n                           index_t         num_shades, \n                           shade_map_t     *d_s, \n                           ffprng_scalar_t seed, \n                           line_array_t    *d_x, \n                           line_array_t    *d_y, \n                           line_array_t    *d_z, \n                           line_array_t    *d_w, \n                           line_array_t    *d_u, \n                           line_array_t    *d_v, \n                           line_array_t    *d_w_prime, \n                           line_array_t    *d_u_prime, \n                           line_array_t    *d_v_prime, \n                           line_array_t    *d_w_prime_prime, \n                           line_array_t    *d_u_prime_prime, \n                           line_array_t    *d_v_prime_prime, \n                           line_array_t    *d_w_prime_prime_prime, \n                           line_array_t    *d_u_prime_prime_prime, \n                           line_array_t    *d_v_prime_prime_prime, \n                           line_array_t    *d_w_prime_prime_prime_prime, \n                           line_array_t    *d_u_prime_prime_prime_prime, \n                           line_array_t    *d_v_prime_prime_prime_prime, \n                           line_array_t    *d_w_prime_prime_prime_prime_prime, \n                           line_array_t    *d_u_prime_prime_prime_prime_prime, \n                           line_array_t    *d_v_prime_prime_prime_prime_prime, \n                           line_array_t    *d_w_prime_prime_prime_prime_prime_prime, \n                           line_array_t    *d_u_prime_prime_prime_prime_prime_prime, \n                           line_array_t    *d_v_prime_prime_prime_prime_prime_prime, \n                           line_array_t    *d_w_prime_prime_prime_prime_prime_prime_prime, \n                           line_array_t    *d_u_prime_prime_prime_prime_prime_prime_prime, \n                           line_array_t    *d_v_prime_prime_prime_prime_prime_prime_prime, \n                           line_array_t    *d_w_prime_prime_prime_prime_prime_prime_prime_prime, \n                           line_array_t    *d_u_prime_prime_prime_prime_prime_prime_prime_prime, \n                           line_array_t    *d_v_prime_prime_prime_prime_prime_prime_prime_prime, \n                           line_array_t    *d_w_prime_prime_prime_prime_prime_prime_prime_prime_prime, \n                           line_array_t    *d_u_prime_prime_prime_prime_prime_prime_prime_prime_prime, \n                           line_array_t    *d_v_prime_prime_prime_prime_prime_prime_prime_prime_prime, \n                           line_array_t    *d_w_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime, \n                           line_array_t    *d_u_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime, \n                           line_array_t    *d_v_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime, \n                "}
{"label": " \nuint64_t grid_wtowers(double complex *uvgrid, int grid_size, \n                      double theta, \n                      struct vis_data *vis, struct w_kernel_data *wkern, \n                      int subgrid_size, int fsample_size, \n                      int subgrid_margin, double wincrement) { \n \n     \n \n    if(subgrid_margin < wkern->size_x) { \n        fprintf(stderr, \"Error: The margin is too small for this w-kernel size!\\n\"); \n        exit(1); \n    } \n    assert(wkern->size_x == wkern->size_y); \n    if(wkern->w_min > -wincrement / 2 || wkern->w_max < wincrement / 2) { \n        fprintf(stderr, \"Error: The w-kernel does not cover a whole w-increment!\\n\"); \n        exit(1); \n    } \n    assert(subgrid_size % 2 == 0 && subgrid_margin % 2 == 0);  \n \n \n     \n \n    uint64_t flops = 0; \n    double complex *wtransfer = make_wtransfer(theta, wincrement, subgrid_size, fsample_size, &flops); \n \n     \n \n    double vis_w_min = 0, vis_w_max = 0; \n    int bl; \n    for (bl = 0; bl < vis->bl_count; bl++) { \n        double w_min = lambda_min(&vis->bl[bl], vis->bl[bl].w_min); \n        double w_max = lambda_max(&vis->bl[bl], vis->bl[bl].w_max); \n        if (w_min < vis_w_min) { vis_w_min = w_min; } \n        if (w_max > vis_w_max) { vis_w_max = w_max; } \n    } \n    int wp_min = (int) floor(vis_w_min / wincrement + 0.5); \n    int wp_max = (int) floor(vis_w_max / wincrement + 0.5); \n \n     \n \n    int chunk_size = subgrid_size - subgrid_margin; \n    int chunk_count = grid_size / chunk_size + 1; \n    int bins_size = sizeof(void *) * chunk_count * chunk_count; \n    struct bl_data ***bins = (struct bl_data ***)malloc(bins_size); \n    memset(bins, 0, bins_size); \n    int bins_count_size = sizeof(int) * chunk_count * chunk_count; \n    int *bins_count = (int *)malloc(bins_count_size); \n    memset(bins_count, 0, bins_count_size); \n    for (bl = 0; bl < vis->bl_count; bl++) { \n \n         \n \n        struct bl_data *bl_data = &vis->bl[bl]; \n        double u_min = lambda_min(bl_data, bl_data->u_min); \n        double u_max = lambda_max(bl_data, bl_data->u_max); \n        double v_min = lambda_min(bl_data, bl_data->v_min); \n        double v_max = lambda_max(bl_data, bl_data->v_max); \n \n         \n \n        int cx0 = (floor(u_min * theta + 0.5) + grid_size/2) / chunk_size; \n        int cx1 = (floor(u_max * theta + 0.5) + grid_size/2) / chunk_size; \n        int cy0 = (floor(v_min * theta + 0.5) + grid_size/2) / chunk_size; \n        int cy1 = (floor(v_max * theta + 0.5) + grid_size/2) / chunk_size; \n \n        int cy, cx; \n        for (cy = cy0; cy <= cy1; cy++) { \n            for (cx = cx0; cx <= cx1; cx++) { \n \n                 \n \n                int bcount = ++bins_count[cy*chunk_count + cx]; \n                bins[cy*chunk_count + cx] = \n                    (struct bl_data **)realloc(bins[cy*chunk_count + cx], sizeof(void *) * bcount); \n                bins[cy*chunk_count + cx][bcount-1] = bl_data; \n \n            } \n        } \n \n    } \n \n     \n \n     \n \n    int subgrid_cells = subgrid_size * subgrid_size; \n    uint64_t subgrid_fft_flops = (int) ceil(5 * subgrid_cells * log(subgrid_cells) / log(2) ); \n \n    { \n \n     \n \n    int subgrid_mem_size = sizeof(double complex) * subgrid_size * subgrid_size; \n    double complex *subgrid = (double complex *)malloc(subgrid_mem_size); \n    double complex *subimg = (double complex *)malloc(subgrid_mem_size); \n    fftw_plan fft_plan, ifft_plan; \n    { \n        fft_plan = fftw_plan_dft_2d(subgrid_size, subgrid_size, subimg, subimg, -1, FFTW_MEASURE); \n        ifft_plan = fftw_plan_dft_2d(subgrid_size, subgrid_size, subgrid, subgrid, +1, FFTW_MEASURE); \n    } \n \n     \n \n    int cc; \n    for (cc = 0; cc < chunk_count * chunk_count; cc++) { \n        int cx = cc % chunk_count, cy = cc / chunk_count; \n \n         \n \n        struct bl_data **bl_bin = bins[cy*chunk_count + cx]; \n        int bl_count = bins_count[cy*chunk_count + cx]; \n        if (bl_count == 0) { continue; } \n         \n \n \n         \n \n        int x_min = chunk_size*cx - grid_size/2; \n        int y_min = chunk_size*cy - grid_size/2; \n        double u_min = ((double)x_min - 0.5) / theta; \n        double v_min = ((double)y_min - 0.5) / theta; \n        double u_max = u_min + chunk_size / theta; \n        double v_max = v_min + chunk_size / theta; \n \n         \n \n         \n \n         \n \n        double u_mid = (", "pred": " \nuint64_t grid_wtowers(double complex *uvgrid, int grid_size, \n                      double theta, \n                      struct vis_data *vis, struct w_kernel_data *wkern, \n                      int subgrid_size, int fsample_size, \n                      int subgrid_margin, double wincrement) { \n \n     \n \n    if(subgrid_margin < wkern->size_x) { \n        fprintf(stderr, \"Error: The margin is too small for this w-kernel size!\\n\"); \n        exit(1); \n    } \n    assert(wkern->size_x == wkern->size_y); \n    if(wkern->w_min > -wincrement / 2 || wkern->w_max < wincrement / 2) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->w_min < 0 || wkern->w_max > 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x < 1 || wkern->size_y < 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x > grid_size - 1 || wkern->size_y > grid_size - 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x < 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_y < 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x > grid_size - 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_y > grid_size - 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == 1 && wkern->size_y == 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == grid_size - 1 && wkern->size_y == grid_size - 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == grid_size - 1 && wkern->size_y == 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == grid_size - 1 && wkern->size_y == grid_size - 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == grid_size - 1 && wkern->size_y == 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == grid_size - 1 && wkern->size_y == grid_size - 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == 1 && wkern->size_y == 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == 1 && wkern->size_y == 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == 1 && wkern->size_y == 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == 1 && wkern->size_y == 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == 1 && wkern->size_y == 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == 1 && wkern->size_y == 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == 1 && wkern->size_y == 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == 1 && wkern->size_y == 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == 1 && wkern->size_y == 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == 1 && wkern->size_y == 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == 1 && wkern->size_y == 1) { \n        fprintf(stderr, \"Error: The w-kernel does not cover the whole grid!\\n\"); \n        exit(1); \n    } \n    if(wkern->size_x == 1 && wkern->size_y == 1) { \n       "}
{"label": " R_StudioDrawPoints( void ) \n{ \n\tint\t\ti, j, m_skinnum; \n\tbyte\t\t*pvertbone; \n\tbyte\t\t*pnormbone; \n\tvec3_t\t\t*pstudioverts; \n\tvec3_t\t\t*pstudionorms; \n\tmstudiotexture_t\t*ptexture; \n\tmstudiomesh_t\t*pmesh; \n\tshort\t\t*pskinref; \n\tfloat\t\t*lv, scale = 0.0f; \n \n\tif(!r_studio_drawelements->integer ) \n\t{ \n\t\tR_StudioDrawPoints_legacy(); \n\t\treturn; \n\t} \n \n\tR_StudioSetupTextureHeader (); \n \n\tg_nNumArrayVerts = g_nNumArrayElems = 0; \n \n\tif(!m_pTextureHeader ) return; \n\tif( RI.currententity->curstate.renderfx == kRenderFxGlowShell ) \n\t\tg_nStudioCount++; \n \n\t \n \n\tm_skinnum = bound( 0, RI.currententity->curstate.skin, ( m_pTextureHeader->numskinfamilies - 1 )); \n\tpvertbone = ((byte *)m_pStudioHeader + m_pSubModel->vertinfoindex); \n\tpnormbone = ((byte *)m_pStudioHeader + m_pSubModel->norminfoindex); \n \n\t \n \n\tif( m_fDoRemap ) ptexture = CL_GetRemapInfoForEntity( RI.currententity )->ptexture; \n\telse ptexture = (mstudiotexture_t *)((byte *)m_pTextureHeader + m_pTextureHeader->textureindex); \n \n\tASSERT( ptexture!= NULL ); \n \n\tpmesh = (mstudiomesh_t *)((byte *)m_pStudioHeader + m_pSubModel->meshindex); \n\tpstudioverts = (vec3_t *)((byte *)m_pStudioHeader + m_pSubModel->vertindex); \n\tpstudionorms = (vec3_t *)((byte *)m_pStudioHeader + m_pSubModel->normindex); \n \n\tpskinref = (short *)((byte *)m_pTextureHeader + m_pTextureHeader->skinindex); \n\tif( m_skinnum!= 0 && m_skinnum < m_pTextureHeader->numskinfamilies ) \n\t\tpskinref += (m_skinnum * m_pTextureHeader->numskinref); \n \n\tif( m_pSubModel->numverts > MAXSTUDIOVERTS ) \n\t\tm_pSubModel->numverts = MAXSTUDIOVERTS; \n \n\tfor( i = 0; i < m_pSubModel->numverts; i++ ) \n\t\tMatrix3x4_VectorTransform( g_bonestransform[pvertbone[i]], pstudioverts[i], g_xformverts[i] ); \n \n\tif( g_nForceFaceFlags & STUDIO_NF_CHROME ) \n\t{ \n\t\tscale = RI.currententity->curstate.renderamt * (1.0f / 255.0f); \n \n\t\tfor( i = 0; i < m_pSubModel->numnorms; i++ ) \n\t\t\tMatrix3x4_VectorRotate( g_bonestransform[pnormbone[i]], pstudionorms[i], g_xformnorms[i] ); \n\t} \n \n\tlv = (float *)g_lightvalues; \n \n\tfor( j = 0; j < m_pSubModel->nummesh; j++ ) \n\t{ \n\t\tg_nFaceFlags = ptexture[pskinref[pmesh[j].skinref]].flags; \n \n\t\t \n \n\t\tg_sortedMeshes[j].mesh = &pmesh[j]; \n\t\tg_sortedMeshes[j].flags = g_nFaceFlags; \n \n\t\tfor( i = 0; i < pmesh[j].numnorms; i++, lv += 3, pstudionorms++, pnormbone++ ) \n\t\t{ \n\t\t\tR_StudioLighting( lv, *pnormbone, g_nFaceFlags, (float *)pstudionorms ); \n \n\t\t\tif(( g_nFaceFlags & STUDIO_NF_CHROME ) || ( g_nForceFaceFlags & STUDIO_NF_CHROME )) \n\t\t\t{ \n\t\t\t\tR_StudioSetupChrome( g_chrome[(float (*)[3])lv - g_lightvalues], *pnormbone, (float *)pstudionorms ); \n\t\t\t} \n\t\t} \n\t} \n \n\tif( r_studio_sort_textures->integer ) \n\t{ \n\t\t \n \n\t\tqsort( g_sortedMeshes, m_pSubModel->nummesh, sizeof( sortedmesh_t ), (void *)R_StudioMeshCompare ); \n\t} \n \n\tR_StudioDrawMeshes( ptexture, pskinref, scale ); \n \n\t \n \n\tif( g_iRenderMode!= kRenderTransAdd ) \n\t\tpglDepthMask( GL_TRUE ); \n} ", "pred": " R_StudioDrawPoints( void ) \n{ \n\tint\t\ti, j, m_skinnum; \n\tbyte\t\t*pvertbone; \n\tbyte\t\t*pnormbone; \n\tvec3_t\t\t*pstudioverts; \n\tvec3_t\t\t*pstudionorms; \n\tmstudiotexture_t\t*ptexture; \n\tmstudiomesh_t\t*pmesh; \n\tshort\t\t*pskinref; \n\tfloat\t\t*lv, scale = 0.0f; \n \n\tif(!r_studio_drawelements->integer ) \n\t{ \n\t\tR_StudioDrawPoints_legacy(); \n\t\treturn; \n\t} \n \n\tR_StudioSetupTextureHeader (); \n \n\tg_nNumArrayVerts = g_nNumArrayElems = 0; \n \n\tif(!m_pTextureHeader ) return; \n\tif( RI.currententity->curstate.renderfx == kRenderFxGlowShell ) \n\t\tg_nStudioCount++; \n \n\t \n \n\tm_skinnum = bound( 0, RI.currententity->curstate.skin, ( m_pTextureHeader->numskinfamilies - 1 )); \n\tpvertbone = ((byte *)m_pStudioHeader + m_pSubModel->vertinfoindex) + m_pSubModel->vertindex; \n\tpnormbone = ((byte *)m_pStudioHeader + m_pSubModel->norminfoindex) + m_pSubModel->normindex; \n\tpstudioverts = ((byte *)m_pStudioHeader + m_pSubModel->studiotextureindex) + m_pSubModel->studiotextureindex; \n\tpstudionorms = ((byte *)m_pStudioHeader + m_pSubModel->studiotexturenormalindex) + m_pSubModel->studiotexturenormalindex; \n\tpskinref = ((byte *)m_pStudioHeader + m_pSubModel->skinrefindex) + m_pSubModel->skinrefindex; \n\tlv = ((byte *)m_pStudioHeader + m_pSubModel->vertexlightindex) + m_pSubModel->vertexlightindex; \n\tscale = ((byte *)m_pStudioHeader + m_pSubModel->scaleindex) + m_pSubModel->scaleindex; \n \n\tfor( i = 0; i < m_pSubModel->numvertices; i++ ) \n\t{ \n\t\tpvertbone[i*4+0] = pstudioverts[i].x; \n\t\tpvertbone[i*4+1] = pstudioverts[i].y; \n\t\tpvertbone[i*4+2] = pstudioverts[i].z; \n\t\tpvertbone[i*4+3] = 255; \n\t} \n \n\tfor( i = 0; i < m_pSubModel->numstudiomodels; i++ ) \n\t{ \n\t\tpstudioverts[i*4+0] = pstudiostudiotextures[i].x; \n\t\tpstudioverts[i*4+1] = pstudiostudiotextures[i].y; \n\t\tpstudioverts[i*4+2] = pstudiostudiotextures[i].z; \n\t\tpstudioverts[i*4+3] = 255; \n\t} \n \n\tfor( i = 0; i < m_pSubModel->numbones; i++ ) \n\t{ \n\t\tpnormbone[i*4+0] = pstudiobones[i].x; \n\t\tpnormbone[i*4+1] = pstudiobones[i].y; \n\t\tpnormbone[i*4+2] = pstudiobones[i].z; \n\t\tpnormbone[i*4+3] = 255; \n\t} \n \n\tfor( i = 0; i < m_pSubModel->numnorms; i++ ) \n\t{ \n\t\tpstudionorms[i*4+0] = pstudionorms[i].x; \n\t\tpstudionorms[i*4+1] = pstudionorms[i].y; \n\t\tpstudionorms[i*4+2] = pstudionorms[i].z; \n\t\tpstudionorms[i*4+3] = 255; \n\t} \n \n\tfor( i = 0; i < m_pSubModel->numskinref; i++ ) \n\t{ \n\t\tpskinref[i*4+0] = pstudioskinref[i].x; \n\t\tpskinref[i*4+1] = pstudioskinref[i].y; \n\t\tpskinref[i*4+2] = pstudioskinref[i].z; \n\t\tpskinref[i*4+3] = 255; \n\t} \n \n\tfor( i = 0; i < m_pSubModel->numvertexes; i++ ) \n\t{ \n\t\tlv[i*4+0] = pstudiovertexes[i]."}
{"label": " \nvoid tmult(double* A, double* B, double* C,int ra,int ca, int cb) { \n\tregister int i,j,k; \n\tint u,v,t,rb; \n\tdouble *BT; \n\tBT = (double*) malloc(sizeof(double) * ca * cb); \n\t \n  \n\t  \n\tmtranspose(B,ca,cb,BT); \n\trb = ca; \n\tfor (i = 0; i < ra; ++i) { \n\t\tfor (j = 0; j < cb; ++j) { \n\t\t\tv = i * rb; \n\t\t\tu = i *cb; \n\t\t\tt = j + u; \n\t\t\tC[t] = 0.; \n\t\t\tfor (k = 0; k < rb;++k) { \n\t\t\t\tC[t] += A[k + v] * BT[k + j * rb]; \n\t\t\t} \n\t\t} \n\t} \n\t \n\tfree(BT); \n \n} ", "pred": " \nvoid tmult(double* A, double* B, double* C,int ra,int ca, int cb) { \n\tregister int i,j,k; \n\tint u,v,t,rb; \n\tdouble *BT; \n\tBT = (double*) malloc(sizeof(double) * ca * cb); \n\t \n  \n\t  \n\tmtranspose(B,ca,cb,BT); \n\trb = ca; \n\tfor (i = 0; i < ra; ++i) { \n\t\tfor (j = 0; j < cb; ++j) { \n\t\t\tv = i * rb; \n\t\t\tu = i *cb; \n\t\t\tt = j + u; \n\t\t\tC[t] = 0.; \n\t\t\tfor (k = 0; k < rb;++k) { \n\t\t\t\tC[t] += A[k + v] * BT[k + j * rb]; \n\t\t\t} \n\t\t} \n\t} \n\t \n\tfree(BT); \n \n} "}
{"label": "ex_t get_posproj(index_t n, index_t *pos, index_t *adj,  \n                    index_t nproj, index_t *proj, index_t *embed, \n                    index_t *posproj) \n{ \n \n    for(index_t v = 0; v < nproj; v++) { \n        index_t u = embed[v]; \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        index_t degproj = 0; \n        for(index_t i = 0; i < deg; i++) { \n            index_t w = proj[adj[pu + 1 + i]]; \n            if(w!= PROJ_UNDEF) \n                degproj++; \n        } \n        posproj[v] = degproj; \n    } \n \n    index_t run = prefixsum(nproj, posproj, 1); \n    return run; \n} \n \nmo ", "pred": "ex_t get_posproj(index_t n, index_t *pos, index_t *adj,  \n                    index_t nproj, index_t *proj, index_t *embed, \n                    index_t *posproj) \n{ \n \n    for(index_t v = 0; v < nproj; v++) { \n        index_t u = embed[v]; \n        index_t pu = pos[u]; \n        index_t deg = adj[pu]; \n        index_t degproj = 0; \n        for(index_t i = 0; i < deg; i++) { \n            index_t w = proj[adj[pu + 1 + i]]; \n            if(w!= PROJ_UNDEF) \n                degproj++; \n        } \n        posproj[v] = degproj; \n    } \n    return nproj; \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"label": "ifq_t *root_build(graph_t *g, index_t k, index_t *kk) \n{ \n    push_memtrack(); \n \n    index_t n = g->num_vertices; \n    index_t m = 2*g->num_edges; \n    index_t *pos = alloc_idxtab(n); \n    index_t *adj = alloc_idxtab(n+m); \n    index_t ns = k; \n    shade_map_t *shade = (shade_map_t *) MALLOC(sizeof(shade_map_t)*n); \n \n    motifq_t *root = (motifq_t *) MALLOC(sizeof(motifq_t)); \n    root->is_stub = 0; \n    root->n       = g->num_vertices; \n    root->k       = k; \n    root->pos     = pos; \n    root->adj     = adj; \n    root->nl      = 0; \n    root->l       = (index_t *) MALLOC(sizeof(index_t)*root->nl); \n    root->ns      = ns; \n    root->shade   = shade; \n \n    push_time(); \n    fprintf(stdout, \"root build... \"); \n    fflush(stdout); \n \n    push_time(); \n    for(index_t u = 0; u < n; u++) \n        pos[u] = 0; \n    double time = pop_time(); \n    fprintf(stdout, \"[zero: %.2lf ms] \", time); \n    fflush(stdout); \n     \n    push_time(); \n    index_t *e = g->edges; \n    \n \n    \n \n    \n \n    index_t nt = num_threads(); \n    index_t block_size = n/nt; \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? n-1 : (start+block_size-1); \n        for(index_t j = 0; j < m; j++) { \n            index_t u = e[j]; \n            if(start <= u && u <= stop)                 \n                pos[u]++;  \n \n        } \n    } \n    for(index_t j = 0; j < m; j++) \n        pos[e[j]]++; \n \n    index_t run = prefixsum(n, pos, 1); \n    assert(run == n+m); \n    time = pop_time(); \n    fprintf(stdout, \"[pos: %.2lf ms] \", time); \n    fflush(stdout); \n \n    push_time(); \n    for(index_t u = 0; u < n; u++) \n        adj[pos[u]] = 0; \n \n    e = g->edges; \n     \n \n     \n \n     \n \n    nt = num_threads(); \n    block_size = n/nt; \n    for(index_t t = 0; t < nt; t++) { \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? n-1 : (start+block_size-1); \n        for(index_t j = 0; j < m; j+=2) { \n            index_t u0 = e[j+0]; \n            index_t u1 = e[j+1]; \n            if(start <= u0 && u0 <= stop) { \n                 \n \n                index_t pu0 = pos[u0]; \n                adj[pu0 + 1 + adj[pu0]++] = u1; \n            } \n            if(start <= u1 && u1 <= stop) { \n                 \n \n                index_t pu1 = pos[u1]; \n                adj[pu1 + 1 + adj[pu1]++] = u0; \n            } \n        } \n    } \n    for(index_t j = 0; j < m; j+=2) { \n        index_t u0 = e[j+0]; \n        index_t u1 = e[j+1]; \n        index_t p0 = pos[u0]; \n        index_t p1 = pos[u1];        \n        adj[p1 + 1 + adj[p1]++] = u0; \n        adj[p0 + 1 + adj[p0]++] = u1; \n    } \n    time = pop_time(); \n    fprintf(stdout, \"[adj: %.2lf ms] \", time); \n    fflush(stdout); \n \n    push_time(); \n    adjsort(n, pos, adj); \n    time = pop_time(); \n    fprintf(stdout, \"[adjsort: %.2lf ms] \", time); \n    fflush(stdout); \n \n    push_time(); \n    for(index_t u = 0; u < n; u++) { \n        shade_map_t s = 0; \n        for(index_t j = 0; j < k; j++) \n            if(g->colors[u] == kk[j]) \n                s |= 1UL << j; \n        shade[u] = s; \n \n \n    } \n    time = pop_time(); \n    fprintf(stdout, \"[shade: %.2lf ms] \", time); \n    fflush(stdout); \n \n    time = pop_time(); \n    fprintf(stdout, \"done. [%.2lf ms] \", time); \n    print_pop_memtrack(); \n    fprintf(stdout, \" \"); \n    print_current_mem(); \n    fprintf(stdout, \"\\n\"); \n    fflush(stdout); \n \n    return root; \n} \n \n/* ", "pred": "ifq_t *root_build(graph_t *g, index_t k, index_t *kk) \n{ \n    push_memtrack(); \n \n    index_t n = g->num_vertices; \n    index_t m = 2*g->num_edges; \n    index_t *pos = alloc_idxtab(n); \n    index_t *adj = alloc_idxtab(n+m); \n    index_t ns = k; \n    shade_map_t *shade = (shade_map_t *) MALLOC(sizeof(shade_map_t)*n); \n \n    motifq_t *root = (motifq_t *) MALLOC(sizeof(motifq_t)); \n    root->is_stub = 0; \n    root->n       = g->num_vertices; \n    root->k       = k; \n    root->pos     = pos; \n    root->adj     = adj; \n    root->nl      = 0; \n    root->l       = (index_t *) MALLOC(sizeof(index_t)*n); \n    root->r       = (index_t *) MALLOC(sizeof(index_t)*n); \n    root->ns      = ns; \n    root->shade   = shade; \n    root->root    = root_build_internal(g, k, kk); \n    root->root->l  = root->root->r = root->root->ns = root->root->shade = NULL; \n    root->root->pos = root->root->adj = NULL; \n    root->root->is_stub = 1; \n    root->root->n                   = n; \n    root->root->k                   = k; \n    root->root->pos                 = pos; \n    root->root->adj                 = adj; \n    root->root->nl                  = 0; \n    root->root->l                   = (index_t *) MALLOC(sizeof(index_t)*n); \n    root->root->r                   = (index_t *) MALLOC(sizeof(index_t)*n); \n    root->root->ns                  = ns; \n    root->root->shade               = shade; \n    root->root->root                = root; \n    root->root->pos                 = pos; \n    root->root->adj                 = adj; \n    root->root->nl                  = 0; \n    root->root->l                   = (index_t *) MALLOC(sizeof(index_t)*n); \n    root->root->r                   = (index_t *) MALLOC(sizeof(index_t)*n); \n    root->root->ns                  = ns; \n    root->root->shade               = shade; \n    root->root->root                = root; \n    root->root->pos                 = pos; \n    root->root->adj                 = adj; \n    root->root->nl                  = 0; \n    root->root->l                   = (index_t *) MALLOC(sizeof(index_t)*n); \n    root->root->r                   = (index_t *) MALLOC(sizeof(index_t)*n); \n    root->root->ns                  = ns; \n    root->root->shade               = shade; \n    root->root->root                = root; \n    root->root->pos                 = pos; \n    root->root->adj                 = adj; \n    root->root->nl                  = 0; \n    root->root->l                   = (index_t *) MALLOC(sizeof(index_t)*n); \n    root->root->r                   = (index_t *) MALLOC(sizeof(index_t)*n); \n    root->root->ns                  = ns; \n    root->root->shade               = shade; \n    root->root->root                = root; \n    root->root->pos                 = pos; \n    root->root->adj                 = adj; \n    root->root->nl                  = 0; \n    root->root->l                   = (index_t *) MALLOC(sizeof(index_t)*n); \n    root->root->r                   = (index_t *) MALLOC(sizeof(index_t)*n); \n    root->root->ns                  = ns; \n    root->root->shade               = shade; \n    root->root->root                = root; \n    root->root->pos                 = pos; \n    root->root->adj               "}
{"label": " \nvoid  \nupdate_k(double *k,  \n         double *t) \n{ \n     \n \n \n    int i, j; \n \n    double ref_k = 100.; \n    double ref_temp = 500.; \n    double thermal_factor = 0.001; \n \n    for ( j = 0; j < NY; j++ ){ \n       for ( i = 0; i < NX; i++ ){ \n           k[NX*j + i] = ref_k * (1. - (thermal_factor * (t[NX*j + i] - ref_temp))); \n       } \n    } \n} ", "pred": " \nvoid  \nupdate_k(double *k,  \n         double *t) \n{ \n     \n \n \n    int i, j; \n \n    double ref_k = 100.; \n    double ref_temp = 500.; \n    double thermal_factor = 0.001; \n \n    for ( j = 0; j < NY; j++ ){ \n       for ( i = 0; i < NX; i++ ){ \n           k[NX*j + i] = ref_k * (1. - (thermal_factor * (t[NX*j + i] - ref_temp))); \n       } \n    } \n} "}
{"label": " \nvoid _PSWITCH(little_D)(_C_TYPE * v, _C_TYPE *w) { \n  int sq = g_N_s*g_N_s; \n  _PSWITCH(CONE) = 1.0; \n  _PSWITCH(CMONE) = -1.0; \n  _PSWITCH(CZERO) = 0.0; \n \n  if(dfl_subspace_updated) { \n    compute_little_D(0); \n    dfl_subspace_updated = 0; \n  } \n   \n  _PSWITCH(little_field_gather)(w); \n   \n  for(int i = 0; i < nb_blocks; i++) { \n    for(int j = 0; j < 9; j++) { \n      _MV(zgemv)(\"N\", &g_N_s, &g_N_s, &_PSWITCH(CONE), _PSWITCH(block_list[i].little_dirac_operator) + j * sq, \n                 &g_N_s, w + (nb_blocks * j + i) * g_N_s, &ONE, &_PSWITCH(CONE), v + i * g_N_s, &ONE, 1); \n    } \n  } \n  return; \n} ", "pred": " \nvoid _PSWITCH(little_D)(_C_TYPE * v, _C_TYPE *w) { \n  int sq = g_N_s*g_N_s; \n  _PSWITCH(CONE) = 1.0; \n  _PSWITCH(CMONE) = -1.0; \n  _PSWITCH(CZERO) = 0.0; \n \n  if(dfl_subspace_updated) { \n    compute_little_D(0); \n    dfl_subspace_updated = 0; \n  } \n   \n  _PSWITCH(little_field_gather)(w); \n   \n  for(int i = 0; i < nb_blocks; i++) { \n    for(int j = 0; j < 9; j++) { \n      _MV(zgemv)(\"N\", &g_N_s, &g_N_s, &_PSWITCH(CONE), _PSWITCH(block_list[i].little_dirac_operator) + j * sq, \n                 &g_N_s, w + (nb_blocks * j + i) * g_N_s, &ONE, &_PSWITCH(CONE), v + i * g_N_s, &ONE, &_PSWITCH(CMONE), v + (nb_blocks * j + i)"}
{"label": "ifq_t *motifq_cut(motifq_t *q, index_t lo_v, index_t hi_v) \n{ \n     \n \n \n    index_t n = q->n; \n    index_t *pos = q->pos; \n    index_t *adj = q->adj;     \n    assert(0 <= lo_v && lo_v <= hi_v && hi_v < n); \n \n     \n \n     \n \n    for(index_t i = 0; i < q->nl; i++) { \n        if(q->l[i] >= lo_v && q->l[i] <= hi_v) { \n            motifq_t *qs = (motifq_t *) MALLOC(sizeof(motifq_t)); \n            qs->is_stub = 1; \n            return qs; \n        } \n    } \n \n    index_t ncut = n - (hi_v-lo_v+1); \n    index_t *poscut = alloc_idxtab(ncut); \n    index_t bcut = get_poscut(n, pos, adj, lo_v, hi_v, poscut); \n    index_t *adjcut = alloc_idxtab(bcut); \n    index_t gap = hi_v-lo_v+1; \n \n    for(index_t v = 0; v < ncut; v++) { \n        index_t u = v; \n        if(u >= lo_v) \n            u += gap; \n        index_t pu = pos[u]; \n        index_t degu = adj[pu]; \n        index_t cs, ce; \n        index_t l = get_interval(degu, adj + pu + 1, \n                                 lo_v, hi_v, \n                                 &cs, &ce); \n        index_t pv = poscut[v]; \n        index_t degv = degu - l; \n        adjcut[pv] = degv; \n         \n \n        for(index_t i = 0; i < cs; i++) \n            adjcut[pv + 1 + i] = adj[pu + 1 + i]; \n         \n \n        for(index_t i = cs; i < degv; i++) \n            adjcut[pv + 1 + i] = adj[pu + 1 + i + l] - gap; \n    } \n \n    motifq_t *qq = (motifq_t *) MALLOC(sizeof(motifq_t)); \n    qq->is_stub = 0; \n    qq->n = ncut; \n    qq->k = q->k; \n    qq->pos = poscut; \n    qq->adj = adjcut; \n    qq->nl = q->nl; \n    qq->l = (index_t *) MALLOC(sizeof(index_t)*qq->nl); \n    for(index_t i = 0; i < qq->nl; i++) { \n        index_t u = q->l[i]; \n        assert(u < lo_v || u > hi_v); \n        if(u > hi_v) \n            u -= gap; \n        qq->l[i] = u; \n    } \n    qq->ns = q->ns; \n    qq->shade = (shade_map_t *) MALLOC(sizeof(shade_map_t)*ncut); \n    for(index_t v = 0; v < ncut; v++) { \n        index_t u = v; \n        if(u >= lo_v) \n            u += gap; \n        qq->shade[v] = q->shade[u]; \n    } \n \n    return qq; \n} \n \n/* ", "pred": "ifq_t *motifq_cut(motifq_t *q, index_t lo_v, index_t hi_v) \n{ \n     \n \n \n    index_t n = q->n; \n    index_t *pos = q->pos; \n    index_t *adj = q->adj;     \n    assert(0 <= lo_v && lo_v <= hi_v && hi_v < n); \n \n     \n \n     \n \n    for(index_t i = 0; i < q->nl; i++) { \n        if(q->l[i] >= lo_v && q->l[i] <= hi_v) { \n            motifq_t *qs = (motifq_t *) MALLOC(sizeof(motifq_t)); \n            qs->is_stub = 1; \n            return qs; \n        } \n    } \n \n    index_t ncut = n - (hi_v-lo_v+1); \n    index_t *cut = (index_t *) MALLOC(sizeof(index_t)*ncut); \n    index_t *cut_pos = cut; \n    index_t *cut_adj = cut+ncut; \n    index_t *cut_l = cut_pos+ncut; \n    index_t *cut_r = cut_adj+ncut; \n \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n  "}
{"label": "lar_t line_sum(index_t      l,  \n                  index_t      g, \n                  line_array_t *d_s) \n{ \n \n    index_t nt = num_threads(); \n    index_t block_size = l/nt; \n    assert(nt < MAX_THREADS); \n    scalar_t ts[MAX_THREADS]; \n     \n    for(index_t t = 0; t < nt; t++) { \n        SCALAR_SET_ZERO(ts[t]); \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? l-1 : (start+block_size-1); \n        line_t ln; \n        line_t acc; \n        LINE_SET_ZERO(acc); \n        for(index_t i = start; i <= stop; i++) {     \n            LINE_LOAD(ln, d_s, i);     \n \n            LINE_ADD(acc, acc, ln); \n        } \n        scalar_t lsum; \n        LINE_SUM(lsum, acc); \n        ts[t] = lsum; \n    } \n    scalar_t sum; \n    SCALAR_SET_ZERO(sum); \n    for(index_t t = 0; t < nt; t++) { \n        SCALAR_ADD(sum, sum, ts[t]); \n    } \n \n    trans_bytes += sizeof(scalar_t)*l*g; \n \n    return sum; \n} \n \n \ns ", "pred": "lar_t line_sum(index_t      l,  \n                  index_t      g, \n                  line_array_t *d_s) \n{ \n \n    index_t nt = num_threads(); \n    index_t block_size = l/nt; \n    assert(nt < MAX_THREADS); \n    scalar_t ts[MAX_THREADS]; \n     \n    for(index_t t = 0; t < nt; t++) { \n        SCALAR_SET_ZERO(ts[t]); \n        index_t start = t*block_size; \n        index_t stop = (t == nt-1)? l-1 : (start+block_size-1); \n        line_t ln; \n        line_t acc; \n        LINE_SET_ZERO(acc); \n        for(index_t i = start; i <= stop; i++) {     \n            ln = d_s[i]; \n            LINE_SET_ADD(acc, ln); \n        } \n        LINE_SUM(acc, ts[t]); \n    } \n    return ts[0]; \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"label": " \nvoid bar() { \n  int **a; \n   \n \nfor (int i = 0; i < 10; ++i) \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n++i; \n} ", "pred": " \nvoid bar() { \n  int **a; \n   \n \nfor (int i = 0; i < 10; ++i) \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n   \n \n \n   \n \n \n   \n \n \n   \n \n \n   \n \n \n   \n \n \n   \n \n \n   \n \n \n   \n \n \n   \n \n \n   \n \n \n   \n"}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_grain_data_t *data = (dt_iop_grain_data_t *)piece->data; \n \n  unsigned int hash = _hash_string(piece->pipe->image.filename) % (int)fmax(roi_out->width * 0.3, 1.0); \n \n  const int ch = piece->colors; \n   \n \n  const double strength = (data->strength / 100.0); \n  const double octaves = 3; \n   \n \n  const double wd = fminf(piece->buf_in.width, piece->buf_in.height); \n  const double zoom = (1.0 + 8 * data->scale / 100) / 800.0; \n  const int filter = fabsf(roi_out->scale - 1.0f) > 0.01; \n   \n \n   \n \n  const double filtermul = piece->iscale / (roi_out->scale * wd); \n  const float fib1 = 34.0, fib2 = 21.0; \n  const float fib1div2 = fib1 / fib2; \n \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    float *in = ((float *)ivoid) + (size_t)roi_out->width * j * ch; \n    float *out = ((float *)ovoid) + (size_t)roi_out->width * j * ch; \n    const double wy = (roi_out->y + j) / roi_out->scale; \n    const double y = wy / wd; \n     \n \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n       \n \n       \n \n      const double wx = (roi_out->x + i) / roi_out->scale; \n       \n \n      const double x = wx / wd; \n       \n \n      double noise = 0.0; \n      if(filter) \n      { \n         \n \n        for(int l = 0; l < fib2; l++) \n        { \n          float px = l / fib2, py = l * fib1div2; \n          py -= (int)py; \n          float dx = px * filtermul, dy = py * filtermul; \n          noise += (1.0 / fib2) * _simplex_2d_noise(x + dx + hash, y + dy, octaves, 1.0, zoom); \n        } \n      } \n      else \n      { \n        noise = _simplex_2d_noise(x + hash, y, octaves, 1.0, zoom); \n      } \n \n      out[0] = in[0] + dt_lut_lookup_2d_1c(data->grain_lut, (noise * strength) * GRAIN_LIGHTNESS_STRENGTH_SCALE, in[0] / 100.0f); \n      out[1] = in[1]; \n      out[2] = in[2]; \n      out[3] = in[3]; \n \n      out += ch; \n      in += ch; \n    } \n  } \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_grain_data_t *data = (dt_iop_grain_data_t *)piece->data; \n \n  unsigned int hash = _hash_string(piece->pipe->image.filename) % (int)fmax(roi_out->width * 0.3, 1.0); \n \n  const int ch = piece->colors; \n   \n \n  const double strength = (data->strength / 100.0); \n  const double octaves = 3; \n   \n \n  const double wd = fminf(piece->buf_in.width, piece->buf_in.height); \n  const double zoom = (1.0 + 8 * data->scale / 100) / 800.0; \n  const int filter = fabsf(roi_out->scale - 1.0f) > 0.01; \n   \n \n   \n \n  const double filtermul = piece->iscale / (roi_out->width * roi_out->height); \n  const double filteradd = filtermul * (1.0 - powf(filter, 2.0)); \n  const double filtermul2 = filtermul * (1.0 - powf(filter, 2.0)); \n  const double filteradd2 = filtermul2 * (1.0 - powf(filter, 2.0)); \n  const double filtermul3 = filtermul * (1.0 - powf(filter, 3.0)); \n  const double filteradd3 = filtermul3 * (1.0 - powf(filter, 3.0)); \n  const double filtermul4 = filtermul * (1.0 - powf(filter, 4.0)); \n  const double filteradd4 = filtermul4 * (1.0 - powf(filter, 4.0)); \n  const double filtermul5 = filtermul * (1.0 - powf(filter, 5.0)); \n  const double filteradd5 = filtermul5 * (1.0 - powf(filter, 5.0)); \n  const double filtermul6 = filtermul * (1.0 - powf(filter, 6.0)); \n  const double filteradd6 = filtermul6 * (1.0 - powf(filter, 6.0)); \n  const double filtermul7 = filtermul * (1.0 - powf(filter, 7.0)); \n  const double filteradd7 = filtermul7 * (1.0 - powf(filter, 7.0)); \n  const double filtermul8 = filtermul * (1.0 - powf(filter, 8.0)); \n  const double filteradd8 = filtermul8 * (1.0 - powf(filter, 8.0)); \n  const double filtermul9 = filtermul * (1.0 - powf(filter, 9.0)); \n  const double filteradd9 = filtermul9 * (1.0 - powf(filter, 9.0)); \n  const double filtermul10 = filtermul * (1.0 - powf(filter, 10.0)); \n  const double filteradd10 = filtermul10 * (1.0 - powf(filter, 10.0)); \n  const double filtermul11 = filtermul * (1.0 - powf(filter, 11.0)); \n  const double filteradd11 = filtermul11 * (1.0 - powf(filter, 11.0)); \n  const double filtermul12 = filtermul * (1.0 - powf(filter, 12.0)); \n  const double filteradd12 = filtermul12 * (1.0 - powf(filter, 12.0)); \n  const double filtermul13 = filtermul * (1.0 - powf(filter, 13.0)); \n  const double filteradd13 = filtermul13 * (1.0 - powf(filter, 13.0)); \n  const double filtermul14 = filtermul * (1.0 - powf"}
{"label": " \nint main(int argc, char **argv) \n{ \n  if (argc!= 5) { \n    fprintf(stderr, \"usage:./life <cores> <infile name> <# of iterations> <print frequency> \\n\"); \n    exit(EXIT_FAILURE); \n  } \n \n  double time_start, time_end; \n  time_start = omp_get_wtime(); \n \n  cell *lifeGrid, *tempGrid, *swapPtr;       \n \n  int rows = 0, cols = 0, neighborCount = 0, i = 0, j = 0, k = 0; \n  const int cores = atoi(argv[ARG_CORES]); \n \n  getRowsAndCols(argv[ARG_FILE_NAME], &rows, &cols); \n \n  const int num_steps = atoi(argv[ARG_NUM_ITERATIONS]); \n  const int print_frequency = atoi(argv[ARG_PRINT_FREQ]); \n \n  char *outfile_name = calloc(100, sizeof(char)); \n  snprintf(outfile_name, 100, \"%s_%s_%s_%s.out\", argv[ARG_CORES], argv[ARG_FILE_NAME], argv[ARG_NUM_ITERATIONS], argv[ARG_PRINT_FREQ]); \n \n  lifeGrid = calloc(rows * cols, sizeof(cell));    \n \n  tempGrid = calloc(rows * cols, sizeof(cell));    \n \n  initializeGrid(lifeGrid, argv[ARG_FILE_NAME]); \n \n \n  for ( ; i < num_steps; i++) \n  { \n    if (i % print_frequency == 0) { \n      printGrid(lifeGrid, rows, cols, i, stdout); \n    } \n \n     \n \n    for (j=0; j<rows; j++ ) { \n       \n \n      for (k=0; k<cols; k++) { \n        neighborCount = getNeighborCount( lifeGrid, rows, cols, j, k ); \n \n        if(neighborCount == 2) tempGrid[j*cols+k] = lifeGrid[j*cols+k]; \n        if(neighborCount == 3) tempGrid[j*cols+k] = ALIVE; \n        if(neighborCount < 2) tempGrid[j*cols+k] = DEAD; \n        if(neighborCount > 3) tempGrid[j*cols+k] = DEAD; \n      } \n    } \n \n     \n \n    swapPtr = lifeGrid; \n    lifeGrid = tempGrid; \n    tempGrid = swapPtr; \n  } \n \n \n  FILE *outfile = fopen(outfile_name, \"w\"); \n  printGrid(lifeGrid, rows, cols, i, outfile); \n \n   \n \n  fclose(outfile); \n  free(outfile_name); \n  free(tempGrid); \n  free(lifeGrid); \n \n  time_end = omp_get_wtime(); \n  printf(\"Execution Time (s): %f\\n\", time_end-time_start ); \n \n  return (EXIT_SUCCESS); \n} ", "pred": " \nint main(int argc, char **argv) \n{ \n  if (argc!= 5) { \n    fprintf(stderr, \"usage:./life <cores> <infile name> <# of iterations> <print frequency> \\n\"); \n    exit(EXIT_FAILURE); \n  } \n \n  double time_start, time_end; \n  time_start = omp_get_wtime(); \n \n  cell *lifeGrid, *tempGrid, *swapPtr;       \n \n  int rows = 0, cols = 0, neighborCount = 0, i = 0, j = 0, k = 0; \n  const int cores = atoi(argv[ARG_CORES]); \n \n  getRowsAndCols(argv[ARG_FILE_NAME], &rows, &cols); \n \n  const int num_steps = atoi(argv[ARG_NUM_ITERATIONS]); \n  const int print_frequency = atoi(argv[ARG_PRINT_FREQ]); \n \n  char *outfile_name = calloc(100, sizeof(char)); \n  snprintf(outfile_name, 100, \"%s_%s_%s_%s.out\", argv[ARG_CORES], argv[ARG_FILE_NAME], argv[ARG_NUM_ITERATIONS], argv[ARG_PRINT_FREQ]); \n \n  lifeGrid = calloc(rows * cols, sizeof(cell)); \n  tempGrid = calloc(rows * cols, sizeof(cell)); \n  swapPtr = calloc(rows * cols, sizeof(cell)); \n \n  for (i = 0; i < rows; i++) { \n    for (j = 0; j < cols; j++) { \n      if (i == 0 || j == 0) { \n        lifeGrid[i * cols + j] = 1; \n        tempGrid[i * cols + j] = 1; \n        swapPtr[i * cols + j] = 1; \n      } \n      else { \n        lifeGrid[i * cols + j] = 0; \n        tempGrid[i * cols + j] = 0; \n        swapPtr[i * cols + j] = 0; \n      } \n    } \n  } \n \n  for (i = 0; i < cores; i++) { \n    for (j = 0; j < cols; j++) { \n      if (i == 0 || j == 0) { \n        lifeGrid[i * cols + j] = 1; \n        tempGrid[i * cols + j] = 1; \n        swapPtr[i * cols + j] = 1; \n      } \n      else { \n        lifeGrid[i * cols + j] = 0; \n        tempGrid[i * cols + j] = 0; \n        swapPtr[i * cols + j] = 0; \n      } \n    } \n  } \n \n  for (i = 0; i < cores; i++) { \n    for (j = 0; j < cols; j"}
{"label": " \nint transfer_init( \n                  struct precision * ppr, \n                  struct background * pba, \n                  struct thermo * pth, \n                  struct perturbs * ppt, \n                  struct nonlinear * pnl, \n                  struct transfers * ptr \n                  ) { \n \n   \n \n \n   \n \n \n   \n \n  int index_q; \n \n   \n \n  double tau0; \n   \n \n  double tau_rec; \n   \n \n  double q_period; \n \n   \n \n  int tau_size_max; \n \n   \n \n  double *** sources; \n \n   \n \n  double *** sources_spline; \n \n   \n \n  struct transfer_workspace * ptw; \n \n   \n \n  int ** tp_of_tt; \n \n   \n \n \n  HyperInterpStruct BIS; \n  double xmax; \n \n   \n \n  FILE * input_file; \n  int row,status; \n  double tmp1,tmp2; \n \n   \n \n  int abort; \n \n \n   \n \n  double tstart, tstop, tspent; \n \n \n   \n \n \n  if (ppt->has_cls == _FALSE_) { \n    ptr->has_cls = _FALSE_; \n    if (ptr->transfer_verbose > 0) \n      printf(\"No harmonic space transfer functions to compute. Transfer module skipped.\\n\"); \n    return _SUCCESS_; \n  } \n  else \n    ptr->has_cls = _TRUE_; \n \n  if (ptr->transfer_verbose > 0) \n    fprintf(stdout,\"Computing transfers\\n\"); \n \n   \n \n \n  ptr->md_size = ppt->md_size; \n \n   \n \n \n  tau0 = pba->conformal_age; \n  tau_rec = pth->tau_rec; \n \n   \n \n \n  ptr->angular_rescaling = pth->angular_rescaling; \n \n   \n \n \n  q_period = 2.*_PI_/(tau0-tau_rec)*ptr->angular_rescaling; \n \n   \n \n \n  class_call(transfer_indices_of_transfers(ppr,ppt,ptr,q_period,pba->K,pba->sgnK), \n             ptr->error_message, \n             ptr->error_message); \n \n   \n \n \n  class_alloc(sources, \n              ptr->md_size*sizeof(double**), \n              ptr->error_message); \n \n  class_call(transfer_perturbation_copy_sources_and_nl_corrections(ppt,pnl,ptr,sources), \n             ptr->error_message, \n             ptr->error_message); \n \n   \n \n \n  class_alloc(sources_spline, \n              ptr->md_size*sizeof(double**), \n              ptr->error_message); \n \n  class_call(transfer_perturbation_source_spline(ppt,ptr,sources,sources_spline), \n             ptr->error_message, \n             ptr->error_message); \n \n   \n \n \n  class_alloc(tp_of_tt, \n              ptr->md_size*sizeof(int*), \n              ptr->error_message); \n \n  class_call(transfer_get_source_correspondence(ppt,ptr,tp_of_tt), \n             ptr->error_message, \n             ptr->error_message); \n \n   \n \n \n  class_call(transfer_source_tau_size_max(ppr,pba,ppt,ptr,tau_rec,tau0,&tau_size_max), \n             ptr->error_message, \n             ptr->error_message); \n \n   \n \n \n  xmax = ptr->q[ptr->q_size-1]*tau0; \n  if (pba->sgnK == -1) \n    xmax *= (ptr->l[ptr->l_size_max-1]/ppr->hyper_flat_approximation_nu)/asinh(ptr->l[ptr->l_size_max-1]/ppr->hyper_flat_approximation_nu)*1.01; \n \n  class_call(hyperspherical_HIS_create(0, \n                                       1., \n                                       ptr->l_size_max, \n                                       ptr->l, \n                                       ppr->hyper_x_min, \n                                       xmax, \n                                       ppr->hyper_sampling_flat, \n                                       ptr->l[ptr->l_size_max-1]+1, \n                                       ppr->hyper_phi_min_abs, \n                                       &BIS, \n                                       ptr->error_message), \n             ptr->error_message, \n             ptr->error_message); \n \n   \n \n \n   \n \n \n  ptr->nz_size = 0; \n \n  if (ptr->has_nz_file == _TRUE_) { \n \n    input_file = fopen(ptr->nz_file_name,\"r\"); \n    class_test(input_file == NULL, \n               ptr->error_message, \n               \"Could not open file %s!\",ptr->nz_file_name); \n \n     \n \n    for (row=0,status=2; status==2; row++){ \n      status = fscanf(input_file,\"%lf %lf\",&tmp1,&tmp2); \n    } \n    rewind(input_file); \n    ptr->nz_size = row-1; \n \n     \n \n    class_alloc(ptr->nz_z,sizeof(double)*ptr->nz_size,ptr->error_message); \n    class_alloc(ptr->nz_nz,sizeof(double)*ptr->nz_size,ptr", "pred": " \nint transfer_init( \n                  struct precision * ppr, \n                  struct background * pba, \n                  struct thermo * pth, \n                  struct perturbs * ppt, \n                  struct nonlinear * pnl, \n                  struct transfers * ptr \n                  ) { \n \n   \n \n \n   \n \n \n   \n \n  int index_q; \n \n   \n \n  double tau0; \n   \n \n  double tau_rec; \n   \n \n  double q_period; \n \n   \n \n  int tau_size_max; \n \n   \n \n  double *** sources; \n \n   \n \n  double *** sources_spline; \n \n   \n \n  struct transfer_workspace * ptw; \n \n   \n \n  int ** tp_of_tt; \n \n   \n \n  int ** tp_of_tt_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline_spline; \n \n   \n \n  int ** tp_of_tt_spline_spline_"}
{"label": " \nMAT * dilate_f(MAT * img_in, MAT * strel) { \n\tMAT * dilated = m_get(img_in->m, img_in->n); \n\t \n\t \n \n\tint el_center_i = strel->m / 2, el_center_j = strel->n / 2, i; \n\t \n\t \n \n { const unsigned long long parallel_for_start = current_time_ns(); \nfor (i = 0; i < img_in->m; i++) { \n\t\tint j, el_i, el_j, x, y; \n\t\tfor (j = 0; j < img_in->n; j++) { \n\t\t\tdouble max = 0.0, temp; \n\t\t\t \n \n\t\t\tfor (el_i = 0; el_i < strel->m; el_i++) { \n\t\t\t\tfor (el_j = 0; el_j < strel->n; el_j++) { \n\t\t\t\t\ty = i - el_center_i + el_i; \n\t\t\t\t\tx = j - el_center_j + el_j; \n\t\t\t\t\t \n \n\t\t\t\t\tif (y >=0 && x >= 0 && y < img_in->m && x < img_in->n && m_get_val(strel, el_i, el_j)!= 0) { \n\t\t\t\t\t\t \n \n\t\t\t\t\t\ttemp = m_get_val(img_in, y, x); \n\t\t\t\t\t\tif (temp > max)\tmax = temp; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t\t \n \n\t\t\tm_set_val(dilated, i, j, max); \n\t\t} \n\t} ;  \nconst unsigned long long parallel_for_end = current_time_ns(); \nprintf(\"pragma186_omp_parallel %llu ns\\n\", parallel_for_end - parallel_for_start); }  \n \n \n\treturn dilated; \n} ", "pred": " \nMAT * dilate_f(MAT * img_in, MAT * strel) { \n\tMAT * dilated = m_get(img_in->m, img_in->n); \n\t \n\t \n \n\tint el_center_i = strel->m / 2, el_center_j = strel->n / 2, i; \n\t \n\t \n \n { const unsigned long long parallel_for_start = current_time_ns(); \nfor (i = 0; i < img_in->m; i++) { \n\t\tint j, el_i, el_j, x, y; \n\t\tfor (j = 0; j < img_in->n; j++) { \n\t\t\tdouble max = 0.0, temp; \n\t\t\t \n \n\t\t\tfor (el_i = 0; el_i < strel->m; el_i++) { \n\t\t\t\tfor (el_j = 0; el_j < strel->n; el_j++) { \n\t\t\t\t\ty = i - el_center_i + el_i; \n\t\t\t\t\tx = j - el_center_j + el_j; \n\t\t\t\t\t \n \n\t\t\t\t\tif (y >=0 && x >= 0 && y < img_in->m && x < img_in->n && m_get_val(strel, el_i, el_j, x, y) > max) { \n\t\t\t\t\t\tmax = m_get_val(strel, el_i, el_j, x, y); \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t\ttemp = max; \n\t\t\tmax = max * max; \n\t\t\tif (max > 0.0) { \n\t\t\t\tm_set_val(dilated, i, j, max); \n\t\t\t} \n\t\t} \n\t} \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t"}
{"label": "void CLASS cfa_impulse_gauss(float lclean, float cclean) \n{   \n\tdouble dt; \n\tclock_t t1, t2; \n\tint winx=0, winy=0,winw=width, winh=height; \n \n\tint compt=0, compt10=0,compt50=0,compt250=0,compt500=0,comptmax=0; \n\tstatic const int border=8; \n\tint rayo=1,i,d; \n\tint compte1=0; \n\tstatic const float eps1=1e-10; \n\t \n\tif (verbose) fprintf (stderr,_(\"CFA impulse-hot and gaussian denoise [E.Martinec +JD] g:%1.4f  br:%1.4f\\n\"), lclean,cclean); \n\tt1 = clock(); \n\tborder_interpolate(16); \n\tfloat noisevar=SQRF(lclean);  \n\tfloat noisevarbr=SQRF(cclean); \n \n{\t \n\tint top,left; \n\tchar\t\t*buffer;\t\t\t\t \n \n\tfloat         (*rgb)[3];\t\t \n \n\tfloat         (*lpf);\t\t\t \n \n\tfloat         (*hpf);\t\t\t \n \n \n\t \n \n\tbuffer = (char *) calloc((4*sizeof(float)+sizeof(int))*TS*TS,1); \n\t \n\t \n \n\trgb         = (float (*)[3])\t\tbuffer;  \n \n \tlpf\t\t\t= (float (*))\t\t\t(buffer +  3*sizeof(float)*TS*TS); \n\thpf\t\t\t= (float (*))\t\t\t(buffer +  4*sizeof(float)*TS*TS); \n\t \n\t \n \n\t \n\t \n \n \n \n\t \n \n\t \n \n \n\tfor (top=0; top < winh-16; top += TS-32) \n\t\tfor (left=0; left < winw-16; left += TS-32) { \n \n\t\t\tint bottom = MIN( top+TS,winh); \n\t\t\tint right  = MIN(left+TS, winw); \n\t\t\tint rr1 = bottom - top; \n\t\t\tint cc1 = right - left; \n\t\t\t \n\t\t\tint rr,cc; \n\t\t\tint c; \n\t\t\tint row, col; \n\t\t\tint indx; \n\t\t\tfloat  hfvar[3]; \n\t\t\tfloat gin, g[8]; \n\t\t\tfloat norm; \n\t\t\tfloat wtdsum; \n\t\t\tint dir,dirwt; \n\t\t\tfloat rbin,rb[8],hfnbrave; \n\t\t\tfloat v1; \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\tfor (rr=0; rr < rr1; rr++) \n\t\t\t\tfor (row=rr+top, cc=0; cc < cc1; cc++) { \n\t\t\t\t\tcol = cc+left; \n\t\t\t\t\tc = FC(rr,cc); \n\t\t\t\t\t \n \n\t\t\t\t\trgb[rr*TS+cc][c] = image[row*width+col][c]/65535.0f;  \n\t\t\t\t} \n\t\t\tfor (c=0; c<3; c++){hfvar[c]=0.0f;} \n\t\t\t \n\t\t\t \n \n\t\t\t \n\t\t\tfor (rr=2; rr < rr1-1; rr++) \n\t\t\t\tfor (cc=2; cc < cc1-1; cc++) { \n\t\t\t\t\tc = FC(rr,cc); \n\t\t\t\t\tif (c==1) {  \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tgin=rgb[(rr)*TS+cc][c]; \n\t\t\t\t\t\tg[0]=rgb[(rr-2)*TS+cc][c]; \n\t\t\t\t\t\tg[1]=rgb[(rr-1)*TS+cc-1][c]; \n\t\t\t\t\t\tg[2]=rgb[(rr-1)*TS+cc+1][c]; \n\t\t\t\t\t\tg[3]=rgb[(rr)*TS+cc-2][c]; \n\t\t\t\t\t\tg[4]=rgb[(rr)*TS+cc+2][c]; \n\t\t\t\t\t\tg[5]=rgb[(rr+1)*TS+cc-1][c]; \n\t\t\t\t\t\tg[6]=rgb[(rr+1)*TS+cc+1][c]; \n\t\t\t\t\t\tg[7]=rgb[(rr+2)*TS+cc][c]; \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tnorm=0.0f; \n\t\t\t\t\t\twtdsum=0.0f; \n\t\t\t\t\t\tfor (dir=0; dir<8; dir++){ \n\t\t\t\t\t\t\tdirwt=1/(SQRF(gin-g[dir])+noisevar+eps1); \n \n\t\t\t\t\t\t\tnorm+=dirwt; \n\t\t\t\t\t\t\twtdsum+=g[dir]*dirwt; \n\t\t\t\t\t\t} \n\t\t\t\t\t\twtdsum=wtdsum/norm; \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tlpf[(rr)*TS+cc]=(gin+wtdsum)/2; \n\t\t\t\t\t\thpf[(rr)*TS+cc]=(gin-wtdsum)/2; \n\t\t\t\t\t\thfvar[c]=hfvar[c]+SQRF(hpf[(rr)*TS+cc]); \n \n\t\t\t\t\t} \n\t\t\t\t\telse { \n\t\t\t\t \n\t\t\t\t\t\t \n \n\t\t\t\t\t\trbin=rgb[(rr)*TS+cc][c]; \n\t\t\t\t\t\trb[0]=rgb[(rr-2)*TS+cc-2][c]; \n\t\t\t\t\t\trb[1]=rgb[(rr-2)*TS+cc][c]; \n\t\t\t\t\t\trb[2]=rgb[(rr-2)*TS+cc+2][c]; \n\t\t\t\t\t\trb[3]=rgb[(rr)*TS+cc-2][c]; \n\t\t\t\t\t\trb[4]=rgb[(rr)*TS+cc+2][c]; \n\t\t\t\t\t\trb[5]=rgb[(rr+2)*TS+cc-2][c]; \n\t\t\t\t\t\trb[6]=rgb[(rr+2)*TS+cc][c]; \n\t\t\t\t\t\trb[7]=rgb[(rr+2)*TS+cc+2][c]; \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tnorm=0.0f; \n\t\t\t\t\t\twtdsum=0.0f; \n\t\t\t\t\t\tfor (dir=0; dir<8; dir++) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tdirwt=1/(SQRF(rbin-rb[dir])+noisevarbr+eps1); \n \n\t\t\t\t\t\t\tnorm+=dirwt; \n\t\t\t\t\t\t\twtdsum+=rb[dir]*dirwt; \n\t\t\t\t\t\t} \n\t\t\t\t\t\twtdsum=wtdsum/norm; \n\t\t\t\t\t\t \n \n\t\t\t\t\t\tlpf[(rr)*TS+cc]=(rbin+wtdsum)/2; \n\t\t\t\t\t\thpf[(rr)*TS+cc]=(rbin-wtdsum)/2; \n\t\t\t\t\t\thfvar[c]=hfvar[c]+SQRF(hpf[(rr)*TS+cc]); \n \n\t\t\t\t\t} \n\t\t\t\t\t \n \n\t\t\t\t} \n\t\t\t \n \n\t\t\thfvar[1]=hfvar[1]/(0.5f*(rr1-4)*(cc1-4)); \n\t\t\thfvar[0]=hfvar[0]/(0.25f*(rr1-4)*(cc1-4)); \n\t\t\thfvar[2]=hfvar[2]/(0.25f*(rr1-4)*(cc1-4)); \n\t\t\t \n \n\t\t\tfor (rr=4; rr < rr1-3; rr++) \n\t\t\t\tfor (cc=4; cc < cc1-3; cc++) { \n\t\t\t\t\tc = FC(rr,cc); \n\t\t\t \n\t\t\t\t\tif (c==1) {  \n\t\t\t\t\t\t \n \n\t\t\t\t\t\thfnbrave=0.125f*(hpf[(rr-2)*TS+cc]+hpf[(rr-1)*TS+cc-1]+hpf[(rr-1)*TS+cc+1]+hpf[(rr)*TS+cc-2]+  \t\t\t\t\t\t\t\t\t\thpf[(rr)*TS+cc+2]+hpf[(rr+1)*TS+cc-1]+hpf[(rr+1)*TS+cc+1]+hpf[(rr+2)*TS+cc]); \n\t\t\t\t\t} \n\t\t\t\t\telse { \n\t\t\t\t\t\t \n \n\t\t\t\t\t\t \n\t\t\t\t\t\thfnbrave=0.125f*(hpf[(rr-2)*TS+cc-2]+hpf[(rr-2)*TS+cc]+hpf[(rr-2)*TS+cc+2]+hpf[(rr)*TS+cc-2]+  \t\t\t\t\t\t\t\t\t\thpf[(rr)*TS+cc+2]+hpf[(rr+2)*TS+cc-2]+hpf[(rr+2)*TS+cc]+hpf[(rr+2)*TS+cc+2]); \n\t\t\t\t\t} \n\t\t\t\t\t \n \n\t\t\t\t\thpf[(rr)*TS+cc]=hpf[(rr)*TS+cc]*hfvar[c]/(SQRF(hpf[(rr)*TS+cc]-hfnbrave)+hfvar[c]); \n\t\t\t\t\t \n \n\t\t\t\t\trgb[(rr)*TS+cc][c]=lpf[(rr)*TS+cc]+h", "pred": "void CLASS cfa_impulse_gauss(float lclean, float cclean) \n{   \n\tdouble dt; \n\tclock_t t1, t2; \n\tint winx=0, winy=0,winw=width, winh=height; \n \n\tint compt=0, compt10=0,compt50=0,compt250=0,compt500=0,comptmax=0; \n\tstatic const int border=8; \n\tint rayo=1,i,d; \n\tint compte1=0; \n\tstatic const float eps1=1e-10; \n\t \n\tif (verbose) fprintf (stderr,_(\"CFA impulse-hot and gaussian denoise [E.Martinec +JD] g:%1.4f  br:%1.4f\\n\"), lclean,cclean); \n\tt1 = clock(); \n\tborder_interpolate(16); \n\tfloat noisevar=SQRF(lclean);  \n\tfloat noisevarbr=SQRF(cclean); \n \n{\t \n\tint top,left; \n\tchar\t\t*buffer;\t\t\t\t \n \n\tfloat         (*rgb)[3];\t\t \n \n\tfloat         (*lpf);\t\t\t \n \n\tfloat         (*lpf_orig);\t\t \n\tfloat         (*lpf_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig);\t\t \n\tfloat         (*lpf_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig"}
{"label": " \nint \nyescrypt_kdf(const yescrypt_shared_t * shared, yescrypt_local_t * local, \n    const uint8_t * passwd, size_t passwdlen, \n    const uint8_t * salt, size_t saltlen, \n    uint64_t N, uint32_t r, uint32_t p, uint32_t t, yescrypt_flags_t flags, \n    uint8_t * buf, size_t buflen) \n{ \n\tyescrypt_region_t tmp; \n\tuint64_t NROM; \n\tsize_t B_size, V_size, XY_size, need; \n\tuint8_t * B, * S; \n\tsalsa20_blk_t * V, * XY; \n\tuint8_t sha256[32]; \n \n\t \n \n\tif (p == 1) \n\t\tflags &= ~YESCRYPT_PARALLEL_SMIX; \n \n\t \n \n\tif (flags & ~YESCRYPT_KNOWN_FLAGS) { \n\t\terrno = EINVAL; \n\t\treturn -1; \n\t} \n\tif (buflen > (((uint64_t)(1) << 32) - 1) * 32) { \n\t\terrno = EFBIG; \n\t\treturn -1; \n\t} \n\tif ((uint64_t)(r) * (uint64_t)(p) >= (1 << 30)) { \n\t\terrno = EFBIG; \n\t\treturn -1; \n\t} \n\tif (N > UINT32_MAX) { \n\t\terrno = EFBIG; \n\t\treturn -1; \n\t} \n\tif (((N & (N - 1))!= 0) || (N <= 7) || (r < 1) || (p < 1)) { \n\t\terrno = EINVAL; \n\t\treturn -1; \n\t} \n\tif ((flags & YESCRYPT_PARALLEL_SMIX) && (N / p <= 7)) { \n\t\terrno = EINVAL; \n\t\treturn -1; \n\t} \n\tif ((r > SIZE_MAX / 256 / p) || \n\t    (N > SIZE_MAX / 128 / r)) { \n\t\terrno = ENOMEM; \n\t\treturn -1; \n\t} \n\tif (!(flags & YESCRYPT_PARALLEL_SMIX) && \n\t    (N > SIZE_MAX / 128 / (r * p))) { \n\t\terrno = ENOMEM; \n\t\treturn -1; \n\t} \n\tif ((flags & YESCRYPT_PWXFORM) && \n\t    (flags & YESCRYPT_PARALLEL_SMIX) && \n\t    p > SIZE_MAX / S_SIZE_ALL) { \n\t\terrno = ENOMEM; \n\t\treturn -1; \n\t} \n \n\tNROM = 0; \n\tif (shared->shared1.aligned) { \n\t\tNROM = shared->shared1.aligned_size / ((size_t)128 * r); \n\t\tif (NROM > UINT32_MAX) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (((NROM & (NROM - 1))!= 0) || (NROM <= 7) || \n\t\t   !(flags & YESCRYPT_RW)) { \n\t\t\terrno = EINVAL; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n\t \n \n\tV = NULL; \n\tV_size = (size_t)128 * r * N; \n\tif (!(flags & YESCRYPT_PARALLEL_SMIX)) \n\t\tV_size *= p; \n\tneed = V_size; \n\tif (flags & __YESCRYPT_INIT_SHARED) { \n\t\tif (local->aligned_size < need) { \n\t\t\tif (local->base || local->aligned || \n\t\t\t    local->base_size || local->aligned_size) { \n\t\t\t\terrno = EINVAL; \n\t\t\t\treturn -1; \n\t\t\t} \n\t\t\tif (!alloc_region(local, need)) \n\t\t\t\treturn -1; \n\t\t} \n\t\tV = (salsa20_blk_t *)local->aligned; \n\t\tneed = 0; \n\t} \n\tB_size = (size_t)128 * r * p; \n\tneed += B_size; \n\tif (need < B_size) { \n\t\terrno = ENOMEM; \n\t\treturn -1; \n\t} \n\tXY_size = (size_t)256 * r; \n\tXY_size *= p; \n\tneed += XY_size; \n\tif (need < XY_size) { \n\t\terrno = ENOMEM; \n\t\treturn -1; \n\t} \n\tif (flags & YESCRYPT_PWXFORM) { \n\t\tsize_t S_size = S_SIZE_ALL; \n\t\tS_size *= p; \n\t\tif (flags & YESCRYPT_PARALLEL_SMIX) \n\t\t\tS_size *= p; \n\t\tneed += S_size; \n\t\tif (need < S_size) { \n\t\t\terrno = ENOMEM; \n\t\t\treturn -1; \n\t\t} \n\t} \n\tif (flags & __YESCRYPT_INIT_SHARED) { \n\t\tif (!alloc_region(&tmp, need)) \n\t\t\treturn -1; \n\t\tB = (uint8_t *)tmp.aligned; \n\t\tXY = (salsa20_blk_t *)((uint8_t *)B + B_size); \n\t} else { \n\t\tinit_region(&tmp); \n\t\tif (local->aligned_size < need) { \n\t\t\tif (free_region(local)) \n\t\t\t\treturn -1; \n\t\t\tif (!alloc_region(local, need)) \n\t\t\t\treturn -1; \n\t\t} \n\t\tB = (uint8_t *)local->aligned; \n\t\tV = (salsa20_blk_t *)((uint8_t *)B + B_size); \n\t\tXY = (salsa20_blk_t *)((uint8_t *)V + V_size); \n\t} \n\tS = NULL; \n\tif (flags & YESCRYPT_PWXFORM) \n\t\tS = (uint8_t *)XY + XY_size; \n \n\tif (t || flags) { \n\t\tSHA256_CTX_Y ctx; \n\t\tSHA256_Init_Y(&ctx); \n\t\tSHA256_Update_Y(&ctx, passwd, passwdlen); \n\t\tSHA256_Final_Y(sha256, &ctx); \n\t\tpasswd = sha256; \n\t\tpasswdlen = sizeof(sha256); \n\t} \n \n\t \n \n\tPBKDF2_SHA256(passwd, passwdlen, salt, saltlen, 1, B, B_size); \n \n\tif (t || flags) \n\t\tmemcpy(sha256, B, sizeof(sha256)); \n \n\tif (p == 1 || (flags & YESCRYPT_PARALLEL_SMIX)) { \n\t\tsmix(B, r, N, p, t, flags, V, NROM, shared, XY, S); \n\t} else { \n\t\tuint32_t i; \n \n\t\t \n \n\t\tfor (i = 0; i < p; i++) { \n\t\t\t \n \n\t\t\tsmix(&B[(size_t)128 * r * i], r, N, 1, t, flags, \n\t\t\t    &V[(size_t)2 * r * i * N], \n\t\t\t    NROM, shared, \n\t\t\t    &XY[(size_t)4 * r * i], \n\t\t\t    S? &S[S_SIZE_ALL * i] : S); \n\t\t\tsmix(&B[(size_t)128 * r * i], r, N, 1, t, flags, V, \n\t\t\t    NROM, shared, XY, S); \n\t\t} \n\t} \n \n\t \n \n\tPBKDF2_SHA256(passwd, passwdlen, B, B_size, 1, buf, buflen); \n \n\t \n \n\tif ((t || flags) && buflen == sizeof(sha256)) { \n\t\t \n \n\t\t{ \n\t\t\tHMAC_SHA256_CTX_Y ctx; \n\t\t\tHMAC_SHA256_Init_Y(&ctx, buf, buflen); \n\t\t\tHMAC_SHA256_Update_Y(&ctx, \"Client Key\", 10); \n\t\t\tHMAC_SHA256_Final_Y(sha256, &ctx); \n\t\t} \n\t\t \n \n\t\t{ \n\t\t\tSHA256_CTX_Y ctx; \n\t\t\tSHA256_Init_Y(&ctx); \n\t\t\tSHA256_Update_Y(&ctx, sha256, sizeof(sha256)); \n\t\t\tSHA256_Final_Y(buf, &ctx); \n\t\t} \n\t} \n \n\tif (free_region(&tmp)) \n\t\treturn -1; \n \n\t \n \n\treturn 0; \n} ", "pred": " \nint \nyescrypt_kdf(const yescrypt_shared_t * shared, yescrypt_local_t * local, \n    const uint8_t * passwd, size_t passwdlen, \n    const uint8_t * salt, size_t saltlen, \n    uint64_t N, uint32_t r, uint32_t p, uint32_t t, yescrypt_flags_t flags, \n    uint8_t * buf, size_t buflen) \n{ \n\tyescrypt_region_t tmp; \n\tuint64_t NROM; \n\tsize_t B_size, V_size, XY_size, need; \n\tuint8_t * B, * S; \n\tsalsa20_blk_t * V, * XY; \n\tuint8_t sha256[32]; \n \n\t \n \n\tif (p == 1) \n\t\tflags &= ~YESCRYPT_PARALLEL_SMIX; \n \n\t \n \n\tif (flags & ~YESCRYPT_KNOWN_FLAGS) { \n\t\terrno = EINVAL; \n\t\treturn -1; \n\t} \n\tif (buflen > (((uint64_t)(1) << 32) - 1) * 32) { \n\t\terrno = EFBIG; \n\t\treturn -1; \n\t} \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 32) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 32) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 16) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 16) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 8) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 8) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 4) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 4) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 2) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 2) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 1) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 1) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 0) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 0) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 7) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 7) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 6) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 6) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 5) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 5) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 4) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 4) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 3) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 3) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 2) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 2) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 1) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 1) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 0) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 0) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 7) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 7) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 6) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t\tif (buflen > (uint64_t)(1) << 6) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n\t} \n \n \n\tif (flags & YESCRYPT_PARALLEL_SMIX) { \n\t\tif (buflen < (uint64_t)(1) << 5) { \n\t\t\terrno = EFBIG; \n\t\t\treturn -1; \n\t\t} \n"}
{"label": " \nvoid fmf_round(int num_docs, \n               doc_t *docs, \n               int num_clusters, \n               double shrink_factor, \n               int fast_scoring, \n               cluster_center_t *cluster_centers, \n               uint32_t *cluster_assignments, \n               double **prefixsums, \n               tfreq_t *cfreqs, \n               double *cfreqs_prefixsums, \n               term_freqs_t *tfreqs) { \n    int i, k; \n    if (num_docs == num_clusters) { \n        for (i = 0; i < num_clusters; i++) { \n            cluster_assignments[i] = i; \n        } \n        return; \n    } else { \n        int subset_size = (int)(num_docs*shrink_factor); \n        if (subset_size < num_clusters) { \n            subset_size = num_clusters; \n        } \n        fmf_round(subset_size, \n                  docs, \n                  num_clusters, \n                  shrink_factor, \n                  fast_scoring, \n                  cluster_centers, \n                  cluster_assignments, \n                  prefixsums, \n                  cfreqs, \n                  cfreqs_prefixsums, \n                  tfreqs); \n \n        double totalscore = 0; \n        double lastscore = 0; \n \n        uint32_t num_terms = tfreqs->len; \n \n         \n \n         \n \n         \n \n \n        for (k = 0; k < 3 || totalscore < lastscore*0.99; k++) { \n             \n \n            for (i = 0; i < num_clusters; i++) { \n                bzero(cluster_centers[i], sizeof(tfreq_t)*num_terms); \n            } \n \n            int num_assignments = (k>0)? num_docs : subset_size; \n \n            { \n                int numthreads = omp_get_num_threads(); \n                int tid = omp_get_thread_num(); \n                int bucketsize = (num_clusters + numthreads)/numthreads; \n                 \n \n                for (i = 0; i < num_assignments; i++) { \n                    uint32_t cid = cluster_assignments[i]; \n                    if (cid >= tid*bucketsize && cid < (tid+1)*bucketsize) { \n                        add_to_cluster(docs[i], cluster_centers[cid]); \n                    } \n                } \n            } \n \n \n            { \n                 \n \n                for (i = 0; i < num_clusters; i++) { \n                    calc_prefix_sum(cluster_centers[i], tfreqs, prefixsums[i]); \n                } \n            } \n \n            calc_cfreqs(cfreqs, cluster_centers, num_clusters, num_terms); \n            calc_prefix_sum(cfreqs, tfreqs, cfreqs_prefixsums); \n \n            lastscore = totalscore; \n            totalscore = 0; \n \n            int clustercount[num_clusters]; \n            for (i = 0; i < num_clusters; i++) { \n                clustercount[i] = 0; \n            } \n \n            if (num_docs < num_clusters*100) { \n                double scorebuf[num_clusters]; \n                for (i = 0; i < num_docs; i++) { \n                    uint32_t clusterid; \n                    if (fast_scoring) { \n                        clusterid = assign_cluster_fast(i, \n                                                        docs, \n                                                        num_clusters, \n                                                        tfreqs, \n                                                        cluster_centers, \n                                                        prefixsums, \n                                                        cfreqs, \n     ", "pred": " \nvoid fmf_round(int num_docs, \n               doc_t *docs, \n               int num_clusters, \n               double shrink_factor, \n               int fast_scoring, \n               cluster_center_t *cluster_centers, \n               uint32_t *cluster_assignments, \n               double **prefixsums, \n               tfreq_t *cfreqs, \n               double *cfreqs_prefixsums, \n               term_freqs_t *tfreqs) { \n    int i, k; \n    if (num_docs == num_clusters) { \n        for (i = 0; i < num_clusters; i++) { \n            cluster_assignments[i] = i; \n        } \n        return; \n    } \n    \n    double *cfreqs_prefixsums_ptr = cfreqs_prefixsums; \n    double *tfreqs_ptr = tfreqs; \n    double *cfreqs_ptr = cfreqs; \n    double *tfreqs_ptr_end = tfreqs_ptr + num_clusters; \n    double *cfreqs_prefixsums_ptr_end = cfreqs_prefixsums_ptr + num_clusters; \n    \n    for (i = 0; i < num_docs; i++) { \n        double *cfreqs_ptr = cfreqs_ptr; \n        double *tfreqs_ptr = tfreqs_ptr; \n        double *cfreqs_prefixsums_ptr = cfreqs_prefixsums_ptr; \n        double *tfreqs_prefixsums_ptr = tfreqs_ptr; \n        double *cfreqs_prefixsums_ptr_end = cfreqs_prefixsums_ptr_end; \n        double *tfreqs_prefixsums_ptr_end = tfreqs_ptr_end; \n        \n        for (k = 0; k < num_clusters; k++) { \n            double *cfreqs_ptr_end = cfreqs_ptr + num_clusters; \n            double *tfreqs_ptr_end = tfreqs_ptr + num_clusters; \n            double *cfreqs_prefixsums_ptr_end = cfreqs_prefixsums_ptr_end; \n            double *tfreqs_prefixsums_ptr_end = tfreqs_prefixsums_ptr_end; \n            \n            double *cfreqs_ptr_end = cfreqs_ptr + num_clusters; \n            double *tfreqs_ptr_end = tfreqs_ptr + num_clusters; \n            double *cfreqs_prefixsums_ptr_end = cfreqs_prefixsums_ptr_end; \n            double *tfreqs_prefixsums_ptr_end = tfreqs_prefixsums_ptr_end; \n            \n            double *cfreqs_ptr_end = cfreqs_ptr + num_clusters; \n            double *tfreqs_ptr_end = tfreqs_ptr + num_clusters; \n            double *cfreqs_prefixsums_ptr_end = cfreqs_prefixsums_ptr_end; \n            double *tfreqs_prefixsums_ptr_end = tfreqs_prefixsums_ptr_end; \n            \n            double *cfreqs_ptr_end = cfreqs_ptr + num_clusters; \n            double *tfreqs_ptr_end = tfreqs_ptr + num_clusters; \n            double *cfreqs_prefixsums_ptr_end = cfreqs_prefixsums_ptr_end; \n            double *tfreqs_prefixsums_ptr_end = tfreqs_prefixsums_ptr_end; \n            \n            double *cfreqs_ptr_end = cfreqs_ptr + num_clusters; \n            double *tfreqs_ptr_end = tfreqs_ptr + num_clusters; \n            double *cfreqs_prefixsums_ptr_end = cfreqs_prefixsums_ptr_end; \n            double *tfreqs_prefixsums_ptr_end = tfreqs_prefixsums_ptr_end; \n            \n            double *cfreqs_ptr_end = cfreqs_ptr + num_clusters; \n            double *tfreqs_ptr_end = tfreqs_ptr + num_clusters; \n            double *cfreqs_prefixsums_ptr_end = cfreqs_prefixsums_ptr_end; \n            double *tfreqs_prefixsums_ptr_end = tfreqs_prefixsums_ptr_end; \n            \n            double *cfreqs_ptr_end = cfreqs_ptr + num_clusters; \n            double *tfreqs_ptr_end = tfreqs_ptr + num_clusters; \n            double *cfreqs_prefixsums_ptr_end = cfreqs_prefixsums_ptr_end; \n            double *tfreqs_prefixsums_ptr_end = tfreqs_prefixsums_ptr_end; \n            \n            double *cfreqs_ptr_end = cfreqs_ptr + num_clusters; \n            double *tfreqs_ptr_end = tfreqs_ptr + num_clusters; \n            double *cfreqs_prefixsums_ptr_end = cfreqs_prefixsums_ptr_end; \n            double *tfreqs_prefixsums_ptr_end = tfreqs_prefixsums_ptr_end; \n            \n            double *cfreqs_ptr_end = cfreqs_ptr + num_clusters; \n            double *tfreqs_ptr_end = tfreqs_ptr + num_clusters; \n            double *cfreqs_prefixsums_ptr_end = cfreqs_prefixsums_ptr_end; \n            double *tfreqs_prefixsums_ptr_end = tfreqs_prefixsums_ptr_end; \n            \n            double *cfreqs_ptr_end = cfreqs_ptr + num_clusters; \n            double *tfreqs_ptr_end = tfreqs_ptr + num_clusters; \n            double *cfreqs_prefixsums_ptr_end = cfreqs_prefixsums_ptr_end; \n            double *"}
{"label": " \nMAT * ellipsematching(MAT * grad_x, MAT * grad_y) { \n\tint i, n, k; \n\t \n \n\t \n \n\tdouble sin_angle[NPOINTS], cos_angle[NPOINTS], theta[NPOINTS]; \n\tfor (n = 0; n < NPOINTS; n++) { \n\t\ttheta[n] = (double) n * 2.0 * PI / (double) NPOINTS; \n\t\tsin_angle[n] = sin(theta[n]); \n\t\tcos_angle[n] = cos(theta[n]); \n\t} \n \n\t \n \n\tint tX[NCIRCLES][NPOINTS], tY[NCIRCLES][NPOINTS]; \n\tfor (k = 0; k < NCIRCLES; k++) { \n\t\tdouble rad = (double) (MIN_RAD + 2 * k);  \n\t\tfor (n = 0; n < NPOINTS; n++) { \n\t\t\ttX[k][n] = (int) (cos(theta[n]) * rad); \n\t\t\ttY[k][n] = (int) (sin(theta[n]) * rad); \n\t\t} \n\t} \n\t \n\tint MaxR = MAX_RAD + 2; \n\t \n\t \n \n\tint height = grad_x->m, width = grad_x->n; \n\tMAT * gicov = m_get(height, width); \n\t \n\t \n \n { const unsigned long long parallel_for_start = current_time_ns(); \nfor (i = MaxR; i < width - MaxR; i++) { \n\t\tdouble Grad[NPOINTS]; \n\t\tint j, k, n, x, y; \n\t\t \n\t\tfor (j = MaxR; j < height - MaxR; j++) { \n\t\t\t \n \n\t\t\tdouble max_GICOV = 0;\t \n\t\t\t \n\t\t\t \n \n\t\t\tfor (k = 0; k < NCIRCLES; k++) { \n\t\t\t\t \n \n\t\t\t\tfor (n = 0; n < NPOINTS; n++)\t{ \n\t\t\t\t\t \n \n\t\t\t\t\ty = j + tY[k][n]; \n\t\t\t\t\tx = i + tX[k][n]; \n\t\t\t\t\t \n\t\t\t\t\t \n \n\t\t\t\t\tGrad[n] = m_get_val(grad_x, y, x) * cos_angle[n] + m_get_val(grad_y, y, x) * sin_angle[n]; \n\t\t\t\t} \n\t\t\t\t \n\t\t\t\t \n \n\t\t\t\tdouble sum = 0.0; \n\t\t\t\tfor (n = 0; n < NPOINTS; n++) sum += Grad[n]; \n\t\t\t\tdouble mean = sum / (double)NPOINTS; \n\t\t\t\t \n\t\t\t\t \n \n\t\t\t\tdouble var = 0.0;\t\t\t\t \n\t\t\t\tfor (n = 0; n < NPOINTS; n++)\t{ \n\t\t\t\t\tsum = Grad[n] - mean; \n\t\t\t\t\tvar += sum * sum; \n\t\t\t\t}\t\t\t\t \n\t\t\t\tvar = var / (double) (NPOINTS - 1); \n\t\t\t\t \n\t\t\t\t \n \n\t\t\t\tif (mean * mean / var > max_GICOV) { \n\t\t\t\t\tm_set_val(gicov, j, i, mean / sqrt(var)); \n\t\t\t\t\tmax_GICOV = mean * mean / var; \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t} ;  \nconst unsigned long long parallel_for_end = current_time_ns(); \nprintf(\"pragma111_omp_parallel %llu ns\\n\", parallel_for_end - parallel_for_start); }  \n \n\t \n\treturn gicov; \n} ", "pred": " \nMAT * ellipsematching(MAT * grad_x, MAT * grad_y) { \n\tint i, n, k; \n\t \n \n\t \n \n\tdouble sin_angle[NPOINTS], cos_angle[NPOINTS], theta[NPOINTS]; \n\tfor (n = 0; n < NPOINTS; n++) { \n\t\ttheta[n] = (double) n * 2.0 * PI / (double) NPOINTS; \n\t\tsin_angle[n] = sin(theta[n]); \n\t\tcos_angle[n] = cos(theta[n]); \n\t} \n \n\t \n \n\tint tX[NCIRCLES][NPOINTS], tY[NCIRCLES][NPOINTS]; \n\tfor (k = 0; k < NCIRCLES; k++) { \n\t\tdouble rad = (double) (MIN_RAD + 2 * k);  \n\t\tfor (n = 0; n < NPOINTS; n++) { \n\t\t\ttX[k][n] = (int) (cos(theta[n]) * rad); \n\t\t\ttY[k][n] = (int) (sin(theta[n]) * rad); \n\t\t} \n\t} \n\t \n\tint MaxR = MAX_RAD + 2; \n\t \n\t \n \n\tint height = grad_x->ncol; \n\tint width = grad_x->nrow; \n\tint nrows = grad_x->nrow; \n\tint ncols = grad_x->ncol; \n\tint n = 0; \n\tint *row_start = (int *) malloc(nrows * sizeof(int)); \n\tint *col_start = (int *) malloc(ncols * sizeof(int)); \n\tint *row_end = (int *) malloc(nrows * sizeof(int)); \n\tint *col_end = (int *) malloc(ncols * sizeof(int)); \n\tint *row_inc = (int *) malloc(nrows * sizeof(int)); \n\tint *col_inc = (int *) malloc(ncols * sizeof(int)); \n\tint *row_max = (int *) malloc(nrows * sizeof(int)); \n\tint *col_max = (int *) malloc(ncols * sizeof(int)); \n\tint *row_min = (int *) malloc(nrows * sizeof(int)); \n\tint *col_min = (int *) malloc(ncols * sizeof(int)); \n\tint *row_max_inc = (int *) malloc(nrows * sizeof(int)); \n\tint *col_max_inc = (int *) malloc(ncols * sizeof(int)); \n\tint *row_min_inc = (int *) malloc(nrows * sizeof(int)); \n\tint *col_min_inc = (int *) malloc(ncols * sizeof(int)); \n\tint *row_max_max = (int *) malloc(nrows * sizeof(int)); \n\tint *col_max_max = (int *) malloc(ncols * sizeof(int)); \n\tint *row_min_max = (int *) malloc(nrows * sizeof(int)); \n\tint *col_min_max = (int *) malloc(ncols * sizeof(int)); \n\tint *row_max_min = (int *) malloc(nrows * sizeof(int)); \n\tint *col_max_min = (int *) malloc(ncols * sizeof(int)); \n\tint *row_min_min = (int *) malloc(nrows * sizeof(int)); \n\tint *col_min_min = (int *) malloc(ncols * sizeof(int)); \n\tint *row_max_max_inc = (int"}
{"label": " \nint lrexp(sf_complex **img, sf_complex **dat, bool adj, sf_complex **lt, sf_complex **rt, geopar geop, sf_complex ***wvfld) \n \n \n{ \n    int it, nt, ix, nx, nx2, iz, nz, nz2, nzx2, gpz, wfnt, wfit, snap; \n    int im, i, j, m2, ik, nk, pad1; \n    float dt, dx, dz, ox; \n    sf_complex *curr, **wave, *cwave, *cwavem, c; \n    sf_complex *currm; \n    bool verb; \n \n    nx  = geop->nx; \n    nz  = geop->nz; \n    dx  = geop->dx; \n    dz  = geop->dz; \n    ox  = geop->ox; \n    gpz = geop->gpz; \n    nt  = geop->nt; \n    dt  = geop->dt; \n    snap= geop->snap; \n    nzx2= geop->nzx2; \n    m2  = geop->m2; \n    wfnt= geop->wfnt; \n    pad1= geop->pad1; \n    verb= geop->verb; \n \n    nk = cfft2_init(pad1,nz,nx,&nz2,&nx2); \n    if (nk!=geop->nk) sf_error(\"nk discrepancy!\"); \n \n    curr = sf_complexalloc(nzx2); \n    cwave  = sf_complexalloc(nk); \n    wave = sf_complexalloc2(nzx2,m2); \n    if (adj) { \n\tcurrm  = sf_complexalloc(nzx2); \n\ticfft2_allocate(cwave); \n    } else { \n\tcwavem = sf_complexalloc(nk); \n\ticfft2_allocate(cwavem); \n    } \n \n    for (iz=0; iz < nzx2; iz++) { \n\tcurr[iz] = sf_cmplx(0.,0.); \n    } \n \n    if (adj) {  \n \n        if (snap>0) wfit = (int)(nt-1)/snap;  \n \n\t \n \n\tfor (it=nt-1; it > -1; it--) { \n\t    if (verb) sf_warning(\"it=%d;\",it); \n\t \n\t     \n \n\t    for (im = 0; im < m2; im++) { \n\t\tfor (ix = 0; ix < nx; ix++) { \n\t\t    for (iz=0; iz < nz; iz++) { \n\t\t\ti = iz+ix*nz;   \n \n\t\t\tj = iz+ix*nz2;  \n \n\t\t\tcurrm[j] = conjf(lt[im][i])*curr[j]; \n\t\t\tcurrm[j] = sf_cmul(conjf(lt[im][i]), curr[j]); \n\t\t    } \n\t\t} \n\t\tcfft2(currm,wave[im]); \n\t    } \n\t    for (ik = 0; ik < nk; ik++) { \n\t\tc = sf_cmplx(0.,0.); \n\t\tfor (im = 0; im < m2; im++) { \n\t\t    c += wave[im][ik]*conjf(rt[ik][im]); \n\t\t    c += sf_cmul(wave[im][ik],conjf(rt[ik][im]));  \n \n\t\t} \n\t\tcwave[ik] = c; \n\t    } \n \n\t    icfft2(curr,cwave); \n \n\t    for (ix=0; ix < nx; ix++) {  \n \n\t\tcurr[gpz+ix*nz2] += dat[ix][it]; \n\t    } \n \n\t    if (snap > 0 && it%snap == 0) { \n\t\tfor ( ix = 0; ix < nx; ix++) { \n\t\t    for ( iz = 0; iz<nz; iz++ ) {  \n\t\t\tj = iz+ix*nz2;  \n \n\t\t\twvfld[wfit][ix][iz] = curr[j]; \n\t\t    } \n\t\t} \n\t\tif (snap>0) wfit--; \n\t    } \n\t}  \n \n\t \n \n\tfor (ix=0; ix < nx; ix++) { \n\t    for (iz=0; iz < nz; iz++) { \n\t\timg[ix][iz] = curr[iz+ix*nz2]; \n\t    } \n\t} \n    } else {  \n \n\t \n \n\tfor (ix=0; ix < nx; ix++) { \n\t    for (iz=0; iz < nz; iz++) { \n\t\tcurr[iz+ix*nz2]=img[ix][iz]; \n\t    } \n\t} \n\tif (snap>0) wfit = 0; \n\t \n \n\tfor (it=0; it < nt; it++) { \n\t    if (verb) sf_warning(\"it=%d;\",it); \n\t    for (ix=0; ix < nx; ix++) {  \n \n\t\tdat[ix][it] = curr[gpz+ix*nz2]; \n\t    } \n\t     \n \n\t    cfft2(curr,cwave); \n\t     \n\t    for (im = 0; im < m2; im++) { \n\t\tfor (ik = 0; ik < nk; ik++) { \n\t\t    cwavem[ik] = cwave[ik]*rt[ik][im]; \n\t\t    cwavem[ik] = sf_cmul(cwave[ik],rt[ik][im]); \n\t\t} \n\t\ticfft2(wave[im],cwavem); \n\t    } \n\t    for (ix = 0; ix < nx; ix++) { \n\t\tfor (iz=0; iz < nz; iz++) { \n\t\t    i = iz+ix*nz;   \n \n\t\t    j = iz+ix*nz2;  \n \n\t\t     \n\t\t    c = sf_cmplx(0.,0.);  \n \n\t\t     \n\t\t    for (im = 0; im < m2; im++) { \n\t\t\tc += lt[im][i]*wave[im][j]; \n\t\t\tc += sf_cmul(lt[im][i], wave[im][j]); \n\t\t    } \n\t\t    curr[j] = c; \n\t\t} \n\t    } \n\t    if (snap > 0 && it%snap == 0) { \n\t\tfor ( ix = 0; ix < nx; ix++) { \n\t\t    for ( iz = 0; iz<nz; iz++ ) {  \n\t\t\tj = iz+ix*nz2;  \n \n\t\t\twvfld[wfit][ix][iz] = curr[j]; \n\t\t    } \n\t\t} \n\t\tif (snap>0) wfit++; \n\t    } \n\t} \n    } \n    if (verb) sf_warning(\".\"); \n \n    cfft2_finalize(); \n    return 0; \n} ", "pred": " \nint lrexp(sf_complex **img, sf_complex **dat, bool adj, sf_complex **lt, sf_complex **rt, geopar geop, sf_complex ***wvfld) \n \n \n{ \n    int it, nt, ix, nx, nx2, iz, nz, nz2, nzx2, gpz, wfnt, wfit, snap; \n    int im, i, j, m2, ik, nk, pad1; \n    float dt, dx, dz, ox; \n    sf_complex *curr, **wave, *cwave, *cwavem, c; \n    sf_complex *currm; \n    bool verb; \n \n    nx  = geop->nx; \n    nz  = geop->nz; \n    dx  = geop->dx; \n    dz  = geop->dz; \n    ox  = geop->ox; \n    gpz = geop->gpz; \n    nt  = geop->nt; \n    dt  = geop->dt; \n    snap= geop->snap; \n    nzx2= geop->nzx2; \n    m2  = geop->m2; \n    ik  = geop->ik; \n    nk  = geop->nk; \n    pad1 = geop->pad1; \n    \n    if(adj) { \n\tif(verb) sf_warning(\"adj=true, so no wavefield\"); \n\tif(adj) { \n\t    sf_complexread(lt[0], nt*nx*nz, geop->adj); \n\t    sf_complexread(rt[0], nt*nx*nz, geop->adj); \n\t} else { \n\t    sf_complexread(lt[0], nt*nx*nz, geop->data); \n\t    sf_complexread(rt[0], nt*nx*nz, geop->data); \n\t} \n    } else { \n\tif(verb) sf_warning(\"adj=false, so wavefield\"); \n\tif(adj) { \n\t    sf_complexread(lt[0], nt*nx*nz, geop->adj); \n\t    sf_complexread(rt[0], nt*nx*nz, geop->adj); \n\t} else { \n\t    sf_complexread(lt[0], nt*nx*nz, geop->data); \n\t    sf_complexread(rt[0], nt*nx*nz, geop->data); \n\t} \n    } \n \n    if(adj) { \n\tcurr = sf_complexalloc(nt); \n\twave = sf_complexalloc2(nz, nx); \n\tcwave = sf_complexalloc(nz); \n\tcwavem = sf_complexalloc(nz); \n\tcurrm = sf_complexalloc(nz); \n\tfor(iz=0; iz < nz; iz++) { \n\t    sf_complexread(curr, nt, geop->data); \n\t    sf_complexread(wave[iz], nx, geop->wave); \n\t    sf_complexread(cwave, nz, geop->cwave); \n\t    sf_complexread(cwavem, nz, geop->cwavem); \n\t    sf_complexread(currm, nz, geop->currm); \n\t    for(ix=0; ix < nx; ix++) { \n\t\tfor(iz=0; iz < nz; iz++) { \n\t\t    c = curr[ix][iz]; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n\t\t    c *= c; \n"}
{"label": " \nvoid CVHFnr_direct_drv(int (*intor)(), void (*fdot)(), JKOperator **jkop, \n                       double **dms, double **vjk, int n_dm, int ncomp, \n                       int *shls_slice, int *ao_loc, \n                       CINTOpt *cintopt, CVHFOpt *vhfopt, \n                       int *atm, int natm, int *bas, int nbas, double *env) \n{ \n        IntorEnvs envs = {natm, nbas, atm, bas, env, shls_slice, ao_loc, NULL, \n                cintopt, ncomp}; \n        int idm; \n        double *tile_dms[n_dm]; \n        for (idm = 0; idm < n_dm; idm++) { \n                CVHFzero_out_vjk(vjk[idm], jkop[idm], shls_slice, ao_loc, ncomp); \n                tile_dms[idm] = CVHFallocate_and_reorder_dm(jkop[idm], dms[idm], \n                                                            shls_slice, ao_loc); \n        } \n \n        size_t di = GTOmax_shell_dim(ao_loc, shls_slice, 4); \n        size_t cache_size = GTOmax_cache_size(intor, shls_slice, 4, \n                                              atm, natm, bas, nbas, env); \n        int ish0 = shls_slice[0]; \n        int ish1 = shls_slice[1]; \n        int jsh0 = shls_slice[2]; \n        int jsh1 = shls_slice[3]; \n        int ksh0 = shls_slice[4]; \n        int ksh1 = shls_slice[5]; \n        int lsh0 = shls_slice[6]; \n        int lsh1 = shls_slice[7]; \n        int nish = ish1 - ish0; \n        int njsh = jsh1 - jsh0; \n        int nksh = ksh1 - ksh0; \n        int nlsh = lsh1 - lsh0; \n        int *block_iloc = malloc(sizeof(int) * (nish + njsh + nksh + nlsh + 4)); \n        int *block_jloc = block_iloc + nish + 1; \n        int *block_kloc = block_jloc + njsh + 1; \n        int *block_lloc = block_kloc + nksh + 1; \n        size_t nblock_i = CVHFshls_block_partition(block_iloc, shls_slice+0, ao_loc, AO_BLOCK_SIZE); \n        size_t nblock_j = CVHFshls_block_partition(block_jloc, shls_slice+2, ao_loc, AO_BLOCK_SIZE); \n        size_t nblock_k = CVHFshls_block_partition(block_kloc, shls_slice+4, ao_loc, AO_BLOCK_SIZE); \n        size_t nblock_l = CVHFshls_block_partition(block_lloc, shls_slice+6, ao_loc, AO_BLOCK_SIZE); \n        size_t nblock_kl = nblock_k * nblock_l; \n        size_t nblock_jkl = nblock_j * nblock_kl; \n \n{ \n        size_t i, j, k, l, r, blk_id; \n        JKArray *v_priv[n_dm]; \n        for (i = 0; i < n_dm; i++) { \n                v_priv[i] = CVHFallocate_JKArray(jkop[i], shls_slice, ao_loc, ncomp); \n        } \n        double *buf = malloc(sizeof(double) * (di*di*di*di*ncomp + di*di*2 + cache_size)); \n        double *cache = buf + di*di*di*di*ncomp; \n        for (blk_id = 0; blk_id < nblock_jkl; blk_id++) { \n                r = blk_id; \n                j = r / nblock_kl ; r = r % nblock_kl; \n                k = r / nblock_l  ; r = r % nblock_l; \n                l = r; \n                for (i = 0; i < nblock_i; i++) { \n                        (*fdot)(intor, jkop, v_priv, tile_dms, buf, cache, n_dm, \n                                block_iloc+i, block_jloc+j, block_kloc+k, block_lloc+l, \n                                vhfopt, &envs); \n                } \n        } \n        { \n                for (i = 0; i < n_dm; i++) { \n                        CVHFassemble_v(vjk[i], jkop[i], v_priv[i], shls_slice, ao_loc); \n                        CVHFdeallocate_JKArray(v_priv[i]); \n                } \n        } \n        free(buf); \n} \n        for (idm = 0; idm < n_dm; idm++) { \n                free(tile_dms[idm]); \n        } \n        free(block_iloc); \n} ", "pred": " \nvoid CVHFnr_direct_drv(int (*intor)(), void (*fdot)(), JKOperator **jkop, \n                       double **dms, double **vjk, int n_dm, int ncomp, \n                       int *shls_slice, int *ao_loc, \n                       CINTOpt *cintopt, CVHFOpt *vhfopt, \n                       int *atm, int natm, int *bas, int nbas, double *env) \n{ \n        IntorEnvs envs = {natm, nbas, atm, bas, env, shls_slice, ao_loc, NULL, \n                cintopt, ncomp}; \n        int idm; \n        double *tile_dms[n_dm]; \n        for (idm = 0; idm < n_dm; idm++) { \n                tile_dms[idm] = dms[idm]; \n        } \n        intor(intor, fdot, jkop, vjk, n_dm, ncomp, shls_slice, ao_loc, \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           "}
{"label": " \nstatic void fwd(TYPE *next, TYPE *curr, TYPE *vsq, \n        TYPE *c_coeff, int nx, int ny, int nz, int dimx, int dimy, int dimz, \n        int radius) { \n \n    for (int z = 0; z < nz; z++) { \n        for (int y = 0; y < ny; y++) { \n            for (int x = 0; x < nx; x++) { \n                int this_offset = POINT_OFFSET(x, y, z, dimy, dimx, radius); \n                TYPE temp = 2.0f * curr[this_offset] - next[this_offset]; \n                TYPE div = c_coeff[0] * curr[this_offset]; \n                for (int d = 1; d <= radius; d++) { \n                    int z_pos_offset = POINT_OFFSET(x, y, z + d, dimy, dimx, \n                            radius); \n                    int z_neg_offset = POINT_OFFSET(x, y, z - d, dimy, dimx, \n                            radius); \n                    int y_pos_offset = POINT_OFFSET(x, y + d, z, dimy, dimx, \n                            radius); \n                    int y_neg_offset = POINT_OFFSET(x, y - d, z, dimy, dimx, \n                            radius); \n                    int x_pos_offset = POINT_OFFSET(x + d, y, z, dimy, dimx, \n                            radius); \n                    int x_neg_offset = POINT_OFFSET(x - d, y, z, dimy, dimx, \n                            radius); \n                    div += c_coeff[d] * (curr[z_pos_offset] + \n                            curr[z_neg_offset] + curr[y_pos_offset] + \n                            curr[y_neg_offset] + curr[x_pos_offset] + \n                            curr[x_neg_offset]); \n                } \n                next[this_offset] = temp + div * vsq[this_offset]; \n            } \n        } \n    } \n} ", "pred": " \nstatic void fwd(TYPE *next, TYPE *curr, TYPE *vsq, \n        TYPE *c_coeff, int nx, int ny, int nz, int dimx, int dimy, int dimz, \n        int radius) { \n \n    for (int z = 0; z < nz; z++) { \n        for (int y = 0; y < ny; y++) { \n            for (int x = 0; x < nx; x++) { \n                int this_offset = POINT_OFFSET(x, y, z, dimy, dimx, radius); \n                TYPE temp = 2.0f * curr[this_offset] - next[this_offset]; \n                TYPE div = c_coeff[0] * curr[this_offset]; \n                for (int d = 1; d <= radius; d++) { \n                    int z_pos_offset = POINT_OFFSET(x, y, z, dimy, dimx, d); \n                    TYPE temp_2 = 2.0f * curr[z_pos_offset] - next[z_pos_offset]; \n                    div += c_coeff[d] * curr[z_pos_offset]; \n                    curr[this_offset] = temp + div; \n                    curr[z_pos_offset] = temp_2 + div; \n                } \n            } \n        } \n    } \n    for (int z = 0; z < nz; z++) { \n        for (int y = 0; y < ny; y++) { \n            for (int x = 0; x < nx; x++) { \n                int this_offset = POINT_OFFSET(x, y, z, dimy, dimx, radius); \n                TYPE temp = 2.0f * curr[this_offset] - next[this_offset]; \n                TYPE div = c_coeff[0] * curr[this_offset]; \n                for (int d = 1; d <= radius; d++) { \n                    int z_pos_offset = POINT_OFFSET(x, y, z, dimy, dimx, d); \n                    TYPE temp_2 = 2.0f * curr[z_pos_offset] - next[z_pos_offset]; \n                    div += c_coeff[d] * curr[z_pos_offset]; \n                    curr[this_offset] = temp + div; \n                    curr[z_pos_offset] = temp_2 + div; \n                } \n            } \n        } \n    } \n    for (int z = 0; z < nz; z++)"}
{"label": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const restrict ivoid, \n                  void *const restrict ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n   \n \n \n   \n \n  const dt_iop_colorcontrast_params_t *const d = (dt_iop_colorcontrast_params_t *)piece->data; \n \n   \n \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return;  \n \n \n  const __m128 scale = _mm_set_ps(1.0f, d->b_steepness, d->a_steepness, 1.0f); \n  const __m128 offset = _mm_set_ps(0.0f, d->b_offset, d->a_offset, 0.0f); \n  const __m128 min = _mm_set_ps(-INFINITY, -128.0f, -128.0f, -INFINITY); \n  const __m128 max = _mm_set_ps(INFINITY, 128.0f, 128.0f, INFINITY); \n \n  const float *const restrict in = (float*)ivoid; \n  float *const restrict out = (float*)ovoid; \n \n   \n \n  const int npixels = roi_out->height * roi_out->width; \n  if(d->unbound) \n  { \n    for(int j = 0; j < 4 * npixels; j += 4) \n    { \n      _mm_stream_ps(out + j, offset + scale * _mm_load_ps(in + j)); \n    } \n  } \n  else \n  { \n    for(int j = 0; j < 4 * npixels; j += 4) \n    { \n      _mm_stream_ps(out + j, _mm_min_ps(max, _mm_max_ps(min, offset + scale * _mm_load_ps(in + j)))); \n    } \n  } \n  _mm_sfence(); \n} ", "pred": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const restrict ivoid, \n                  void *const restrict ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n   \n \n \n   \n \n  const dt_iop_colorcontrast_params_t *const d = (dt_iop_colorcontrast_params_t *)piece->data; \n \n   \n \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return;  \n \n \n  const __m128 scale = _mm_set_ps(1.0f, d->b_steepness, d->a_steepness, 1.0f); \n  const __m128 offset = _mm_set_ps(0.0f, d->b_offset, d->a_offset, 0.0f); \n  const __m128 offset_inv = _mm_set_ps(1.0f, -1.0f, -1.0f, 1.0f); \n  const __m128 offset_inv_scale = _mm_set_ps(1.0f, -1.0f, -1.0f, 1.0f); \n  const __m128 offset_inv_scale_inv = _mm_set_ps(1.0f, -1.0f, -1.0f, 1.0f); \n  const __m128 offset_inv_scale_inv_scale = _mm_set_ps(1.0f, -1.0f, -1.0f, 1.0f); \n  const __m128 offset_inv_scale_inv_scale_inv = _mm_set_ps(1.0f, -1.0f, -1.0f, 1.0f); \n  const __m128 offset_inv_scale_inv_scale_inv_scale = _mm_set_ps(1.0f, -1.0f, -1.0f, 1.0f); \n  const __m128 offset_inv_scale_inv_scale_inv_scale_inv = _mm_set_ps(1.0f, -1"}
{"label": " \nvoid mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])  \n{     \n     \n \n    const int nTheta  = (int)mxGetM(prhs[0] ); \n    const int nIndex = (int)mxGetN(prhs[1]);     \n    int iIndex; \n     \n     \n \n    double *result; \n     \n     \n \n    double *theta  = mxGetPr( prhs[0] ); \n     \n     \n \n    double *theta_indexes_start = mxGetPr( prhs[1] ); \n             \n     \n \n    const int theta_indexes_end = (int)mxGetScalar(prhs[2]) + 1;         \n      \n     \n     \n    double *forcing = mxGetPr( prhs[3] ); \n    const int nForcing = (int)mxGetM(prhs[3] ); \n     \n     \n \n    const int isForcingAnIntegral = (int)mxGetScalar(prhs[4]);     \n    \n     \n \n    const double inteTheta_0to1 = mxGetScalar(prhs[5]);     \n     \n    \n \n   __declspec(target(mic:coprocessorNum))  double trapazoidal(const int theta_index_start, const int theta_index_end, const double *dx, const double *dy, const double *intTheta); \n   __declspec(target(mic:coprocessorNum))  double Simpsons_ExtendedRule(const int theta_index_start, const int theta_index_end, const double *dx, const double *dy, const double *intTheta);           \n    \n    \n    double trapazoidal(const int theta_index_start, const int theta_index_end, const double *dx, const double *dy, const double *intTheta); \n    double Simpsons_ExtendedRule(const int theta_index_start, const int theta_index_end, const double *dx, const double *dy, const double *intTheta);       \n     \n     \n \n    plhs[0] = mxCreateDoubleMatrix(1,nIndex,mxREAL); \n    result = mxGetPr(plhs[0]); \n         \n     \n       \n \n   static int coprocessorNum=-999; \n   static int isCoprocessorMemAlloc = 0; \n   static int isCPUMemAlloc = 0; \n   int debugOffload=0; \n    \n   if (coprocessorNum==-999) { \n       \n \n      time_t t;     \n      srand((unsigned) time(&t)); \n      int coprocessorCount = _Offload_number_of_devices();       \n      coprocessorNum = rand() % coprocessorCount;           \n   } \n      \n     \n \n    __declspec( target (mic:coprocessorNum)) static int nTheta_offload = 0, nIndex_offload = 0; \n    __declspec( target (mic:coprocessorNum)) static int nForcing_offload = 0, theta_indexes_end_offload  = 0; \n    __declspec( target (mic:coprocessorNum)) static double *result_offload, *theta_offload, *theta_indexes_start_offload, *forcing_offload, inteTheta_0to1_offload; \n     \n     \n \n    _Offload_status x; \n \n     \n \n   if (nTheta==0 && nIndex==0 && nForcing ==0) {     \n      if (debugOffload==1) \n         mexPrintf(\"Freeing memory on CPU and card %d. \\n\",coprocessorNum);  \n             \n      if (isCoprocessorMemAlloc==1) { \n         {}   \n          \n         if (x.result == OFFLOAD_SUCCESS) \n            isCoprocessorMemAlloc=0;    \n      } \n       \n      if (isCPUMemAlloc==1) { \n         mxFree(theta_offload); \n         mxFree(result_offload); \n         mxFree(theta_indexes_start_offload); \n         mxFree(forcing_offload); \n         isCPUMemAlloc=0; \n      } \n     \n      nTheta_offload = 0; \n      nIndex_offload = 0;  \n      nForcing_offload = 0;             \n       \n      coprocessorNum==-999; \n       \n      return; \n   } \n     \n    \n \n   if (nTheta_offload==0 || nIndex_offload==0 || nForcing_offload ==0  \n   || nTheta!=nTheta_offload || nIndex!=nIndex_offload || nForcing!=nForcing_offload) { \n      if (debugOffload==1) \n         mexPrintf(\"Offload Initialisation to card %d. \\n\",coprocessorNum);  \n       \n       \n \n      nTheta_offload  = nTheta; \n      nIndex_offload = nIndex; \n      nForcing_offload = nForcing; \n      theta_indexes_end_offload = theta_indexes_end; \n      inteTheta_0to1_offload = inteTheta_0to1; \n       \n       \n \n      if (debugOffload==1) \n         mexPrintf(\"Allocating CPU offload variables. \\n\");                \n          \n      result_offload = (double *)mxCalloc(nIndex_offload,sizeof(double)); \n      theta_offload = (double *)mxCalloc(nTheta_offload,sizeof(double)); \n      theta_indexes_start_offload = (double *)mxCalloc(nIndex_offload,sizeof(double)); \n      forcing_offload = (double *)mxCalloc(nForcing_offload,sizeof(double));   \n      isCPUMemAlloc = 1; \n       \n       \n      mexMakeMemoryPersistent(result_offload); \n      mexMakeMemoryPersistent(theta_offload); \n      mexMakeMemoryPersistent(theta_indexes_start_offload); \n      mexMakeMemoryPersistent(forcing_offload); \n       \n       \n \n      if (debugOffload==1) \n         mexPrintf(\"Allocating coprocessor memory. \\n\");                \n       \n      {}             \n       \n      if (x.result == OFFLOAD_SUCCESS) \n         isCoprocessorMemAlloc=1;    \n   } \n \n   if (isForcingAnIntegral==0 ) {       \n        if (debugOffload==1)", "pred": " \nvoid mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])  \n{     \n     \n \n    const int nTheta  = (int)mxGetM(prhs[0] ); \n    const int nIndex = (int)mxGetN(prhs[1]);     \n    int iIndex; \n     \n     \n \n    double *result; \n     \n     \n \n    double *theta  = mxGetPr( prhs[0] ); \n     \n     \n \n    double *theta_indexes_start = mxGetPr( prhs[1] ); \n             \n     \n \n    const int theta_indexes_end = (int)mxGetScalar(prhs[2]) + 1;         \n      \n     \n     \n    double *forcing = mxGetPr( prhs[3] ); \n    const int nForcing = (int)mxGetM(prhs[3] ); \n     \n     \n     \n    double *forcing_indexes_start = mxGetPr( prhs[4] ); \n             \n     \n     \n    const int forcing_indexes_end = (int)mxGetScalar(prhs[5]) + 1;         \n      \n     \n     \n     \n    double *forcing_weights_start = mxGetPr( prhs[6] ); \n             \n     \n     \n     \n    double *forcing_weights_end = mxGetPr( prhs[7] ); \n      \n     \n     \n    double *forcing_weights_weights_start = mxGetPr( prhs[8] ); \n             \n     \n     \n     \n    double *forcing_weights_weights_end = mxGetPr( prhs[9] ); \n      \n     \n     \n    double *forcing_weights_weights_weights_start = mxGetPr( prhs[10] ); \n             \n     \n     \n     \n    double *forcing_weights_weights_weights_end = mxGetPr( prhs[11] ); \n      \n     \n     \n    double *forcing_weights_weights_weights_weights_start = mxGetPr( prhs[12] ); \n             \n     \n     \n     \n    double *forcing_weights_weights_weights_weights_end = mxGetPr( prhs[13] ); \n      \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_start = mxGetPr( prhs[14] ); \n             \n     \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_end = mxGetPr( prhs[15] ); \n      \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_start = mxGetPr( prhs[16] ); \n             \n     \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_end = mxGetPr( prhs[17] ); \n      \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_start = mxGetPr( prhs[18] ); \n             \n     \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_end = mxGetPr( prhs[19] ); \n      \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_weights_start = mxGetPr( prhs[20] ); \n             \n     \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_weights_end = mxGetPr( prhs[21] ); \n      \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_weights_weights_start = mxGetPr( prhs[22] ); \n             \n     \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_weights_weights_end = mxGetPr( prhs[23] ); \n      \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_start = mxGetPr( prhs[24] ); \n             \n     \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_end = mxGetPr( prhs[25] ); \n      \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_start = mxGetPr( prhs[26] ); \n             \n     \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_end = mxGetPr( prhs[27] ); \n      \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_start = mxGetPr( prhs[28] ); \n             \n     \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_end = mxGetPr( prhs[29] ); \n      \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_start = mxGetPr( prhs[30] ); \n             \n     \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_end = mxGetPr( prhs[31] ); \n      \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_start = mxGetPr( prhs[32] ); \n             \n     \n     \n     \n    double *forcing_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_weights_end = mxGetPr( prhs[33] ); \n      \n     \n     \n    double *forcing_weights_weights_weights_weights_weights"}
{"label": " \nvoid initialize() \n{ \n  int i, j, k, m, ix, iy, iz; \n  double xi, eta, zeta, Pface[2][3][5], Pxi, Peta, Pzeta, temp[5]; \n \n  { \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        u[k][j][i][0] = 1.0; \n        u[k][j][i][1] = 0.0; \n        u[k][j][i][2] = 0.0; \n        u[k][j][i][3] = 0.0; \n        u[k][j][i][4] = 1.0; \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    zeta = (double)k * dnzm1; \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      eta = (double)j * dnym1; \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        xi = (double)i * dnxm1; \n \n        for (ix = 0; ix < 2; ix++) { \n          Pxi = (double)ix; \n          exact_solution(Pxi, eta, zeta, &Pface[ix][0][0]); \n        } \n \n        for (iy = 0; iy < 2; iy++) { \n          Peta = (double)iy; \n          exact_solution(xi, Peta, zeta, &Pface[iy][1][0]); \n        } \n \n        for (iz = 0; iz < 2; iz++) { \n          Pzeta = (double)iz; \n          exact_solution(xi, eta, Pzeta, &Pface[iz][2][0]); \n        } \n \n        for (m = 0; m < 5; m++) { \n          Pxi   = xi   * Pface[1][0][m] + (1.0-xi)   * Pface[0][0][m]; \n          Peta  = eta  * Pface[1][1][m] + (1.0-eta)  * Pface[0][1][m]; \n          Pzeta = zeta * Pface[1][2][m] + (1.0-zeta) * Pface[0][2][m]; \n \n          u[k][j][i][m] = Pxi + Peta + Pzeta -  \n                          Pxi*Peta - Pxi*Pzeta - Peta*Pzeta +  \n                          Pxi*Peta*Pzeta; \n        } \n      } \n    } \n  } \n \n \n   \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n  xi = 0.0; \n  i  = 0; \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    zeta = (double)k * dnzm1; \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      eta = (double)j * dnym1; \n      exact_solution(xi, eta, zeta, temp); \n      for (m = 0; m < 5; m++) { \n        u[k][j][i][m] = temp[m]; \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n  xi = 1.0; \n  i  = grid_points[0]-1; \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    zeta = (double)k * dnzm1; \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      eta = (double)j * dnym1; \n      exact_solution(xi, eta, zeta, temp); \n      for (m = 0; m < 5; m++) { \n        u[k][j][i][m] = temp[m]; \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n  eta = 0.0; \n  j   = 0; \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    zeta = (double)k * dnzm1; \n    for (i = 0; i <= grid_points[0]-1; i++) { \n      xi = (double)i * dnxm1; \n      exact_solution(xi, eta, zeta, temp); \n      for (m = 0; m < 5; m++) { \n        u[k][j][i][m] = temp[m]; \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n  eta = 1.0; \n  j   = grid_points[1]-1; \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    zeta = (double)k * dnzm1; \n    for (i = 0; i <= grid_points[0]-1; i++) { \n      xi = (double)i * dnxm1; \n      exact_solution(xi, eta, zeta, temp); \n      for (m = 0; m < 5; m++) { \n        u[k][j][i][m] = temp[m]; \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n  zeta = 0.0; \n  k    = 0; \n  for (j = 0; j <= grid_points[1]-1; j++) { \n    eta = (double)j * dnym1; \n    for (i =0; i <= grid_points[0]-1; i++) { \n      xi = (double)i * dnxm1; \n      exact_solution(xi, eta, zeta, temp); \n      for (m = 0; m < 5; m++) { \n        u[k][j][i][m] = temp[m]; \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n  zeta = 1.0; \n  k    = grid_points[2]-1; \n  for (j = 0; j <= grid_points[1]-1; j++) { \n    eta = (double)j * dnym1; \n    for (i =0; i <= grid_points[0]-1; i++) { \n      xi = (double)i * dnxm1; \n      exact_solution(xi, eta, zeta, temp); \n      for (m = 0; m < 5; m++) { \n ", "pred": " \nvoid initialize() \n{ \n  int i, j, k, m, ix, iy, iz; \n  double xi, eta, zeta, Pface[2][3][5], Pxi, Peta, Pzeta, temp[5]; \n \n  { \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        u[k][j][i][0] = 1.0; \n        u[k][j][i][1] = 0.0; \n        u[k][j][i][2] = 0.0; \n        u[k][j][i][3] = 0.0; \n        u[k][j][i][4] = 1.0; \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n   \n \n \n   \n \n  const dt_iop_colorcontrast_params_t *const d = (dt_iop_colorcontrast_params_t *)piece->data; \n \n   \n \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return;  \n \n \n  const float *const restrict in = DT_IS_ALIGNED((const float *const)ivoid); \n  float *const restrict out = DT_IS_ALIGNED((float *const)ovoid); \n  const size_t npixels = (size_t)roi_out->width * roi_out->height; \n \n  const dt_aligned_pixel_t slope = { 1.0f, d->a_steepness, d->b_steepness, 1.0f }; \n  const dt_aligned_pixel_t offset = { 0.0f, d->a_offset, d->b_offset, 0.0f }; \n  const dt_aligned_pixel_t lowlimit = { -INFINITY, -128.0f, -128.0f, -INFINITY }; \n  const dt_aligned_pixel_t highlimit = { INFINITY, 128.0f, 128.0f, INFINITY }; \n \n  if(d->unbound) \n  { \n    for(size_t k = 0; k < (size_t)4 * npixels; k += 4) \n    { \n      for_each_channel(c,dt_omp_nontemporal(out)) \n      { \n        out[k + c] = (in[k + c] * slope[c]) + offset[c]; \n      } \n    } \n  } \n  else \n  { \n \n    for(size_t k = 0; k < npixels; k ++) \n    { \n       \n \n       \n \n       \n \n      clamped_scaling(out + 4*k, in + 4*k, slope, offset, lowlimit, highlimit); \n    } \n  } \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n   \n \n \n   \n \n  const dt_iop_colorcontrast_params_t *const d = (dt_iop_colorcontrast_params_t *)piece->data; \n \n   \n \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return;  \n \n \n  const float *const restrict in = DT_IS_ALIGNED((const float *const)ivoid); \n  float *const restrict out = DT_IS_ALIGNED((float *const)ovoid); \n  const size_t npixels = (size_t)roi_out->width * roi_out->height; \n \n  const dt_iop_order_iccprofile_t *const iop = &d->iop; \n  const dt_iop_order_iccprofile_iop_t iop_order = iop->iop_order; \n  const dt_iop_order_iccprofile_iop_t iop_order_rgb = iop->iop_order_rgb; \n  const dt_iop_order_iccprofile_iop_t iop_order_rgb_rgb = iop->iop_order_rgb_rgb; \n  const dt_iop_order_iccprofile_iop_t iop_order_rgb_rgb_rgb = iop->iop_order_rgb_rgb_rgb; \n  const dt_iop_order_iccprofile_iop_t iop_order_rgb_rgb_rgb_rgb = iop->iop_order_rgb_rgb_rgb_rgb; \n  const dt_iop_order_iccprofile_iop_t iop_order_rgb_rgb_rgb_rgb_rgb = iop->iop_order_rgb_rgb_rgb_rgb_rgb; \n  const dt_iop_order_iccprofile_iop_t iop_order_rgb_rgb_rgb_rgb_rgb_rgb = iop->iop_order_rgb_rgb_rgb_rgb_rgb_rgb; \n  const dt_iop_order_iccprofile_iop_t iop_order_rgb_rgb_rgb_rgb_rgb_rgb_rgb = iop->iop_order_rgb_rgb_rgb_rgb_rgb_rgb_rgb; \n  const dt_iop_order_iccprofile_iop_t iop_order_rgb_rgb_rgb_rgb_rgb"}
{"label": " \nstatic \nvoid MakeGeopotHeight(double *geop, double* gt, double *gq, double *ph, int nhor, int nlev) \n{ \n  int i, j; \n  double vtmp; \n  double zrg; \n  double z2log2; \n  double *geopl, *gtl, *gql, *phl; \n \n  z2log2 = 2.0 * log(2.0); \n  vtmp   = (C_RV / RD) - 1.0; \n  zrg    = 1.0 / Grav; \n \n  if ( gq )  \n \n    { \n      for ( j = nlev ; j > 1 ; j-- ) \n        { \n          geopl = geop + nhor*(j-1); \n          gtl   = gt   + nhor*(j-1); \n          gql   = gq   + nhor*(j-1); \n          phl   = ph   + nhor*(j-1); \n          for ( i = 0; i < nhor; i++ ) \n            geopl[i] = geopl[i+nhor] + RD * gtl[i] * (1.0 + vtmp * gql[i]) \n                     * log(phl[i+nhor] / phl[i]); \n        } \n \n      for ( i = 0; i < nhor; i++ ) \n        geop[i] = geop[i+nhor] + RD * gt[i] * (1.0 + vtmp * gq[i]) * z2log2; \n    } \n  else     \n \n    { \n      for ( j = nlev ; j > 1 ; j-- ) \n        for ( i = nhor * (j-1) ; i < nhor * j ; i++ ) \n          geop[i] = geop[i+nhor] + RD * gt[i] * log(ph[i+nhor] / ph[i]); \n \n      for ( i = 0; i < nhor; i++ ) \n        geop[i] = geop[i+nhor] + RD * gt[i] * z2log2; \n    } \n \n  for ( i = 0; i < nhor * (nlev+1); i++ ) geop[i] *= zrg; \n} ", "pred": " \nstatic \nvoid MakeGeopotHeight(double *geop, double* gt, double *gq, double *ph, int nhor, int nlev) \n{ \n  int i, j; \n  double vtmp; \n  double zrg; \n  double z2log2; \n  double *geopl, *gtl, *gql, *phl; \n \n  z2log2 = 2.0 * log(2.0); \n  vtmp   = (C_RV / RD) - 1.0; \n  zrg    = 1.0 / Grav; \n \n  if ( gq )  \n \n    { \n      for ( j = nlev ; j > 1 ; j-- ) \n        { \n          geopl = geop + nhor*(j-1); \n          gtl   = gt   + nhor*(j-1); \n          gql   = gq   + nhor*(j-1); \n          phl   = ph   + nhor*(j-1); \n          for ( i = 0 ; i < nhor ; i++ ) \n            { \n              *geopl = vtmp * (*geopl + vtmp * zrg); \n              *gtl   = vtmp * (*gtl   + vtmp * zrg); \n              *gql   = vtmp * (*gql   + vtmp * zrg); \n              *phl   = vtmp * (*phl   + vtmp * zrg); \n              geopl++; \n              gtl++; \n              gql++; \n              phl++; \n            } \n        } \n    } \n  else \n    { \n      for ( j = nlev ; j > 1 ; j-- ) \n        { \n          geopl = geop + nhor*(j-1); \n          gtl   = gt   + nhor*(j-1); \n          gql   = gq   + nhor*(j-1); \n          phl   = ph   + n"}
{"label": " \nvoid exact_rhs() \n{ \n  double dtemp[5], xi, eta, zeta, dtpp; \n  int m, i, j, k, ip1, im1, jp1, jm1, km1, kp1; \n \n  { \n   \n \n   \n \n   \n \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        for (m = 0; m < 5; m++) { \n          forcing[k][j][i][m] = 0.0; \n        } \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n  for (k = 1; k <= grid_points[2]-2; k++) { \n    zeta = (double)k * dnzm1; \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      eta = (double)j * dnym1; \n \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        xi = (double)i * dnxm1; \n \n        exact_solution(xi, eta, zeta, dtemp); \n        for (m = 0; m < 5; m++) { \n          ue[i][m] = dtemp[m]; \n        } \n \n        dtpp = 1.0 / dtemp[0]; \n \n        for (m = 1; m < 5; m++) { \n          buf[i][m] = dtpp * dtemp[m]; \n        } \n \n        cuf[i]    = buf[i][1] * buf[i][1]; \n        buf[i][0] = cuf[i] + buf[i][2] * buf[i][2] + buf[i][3] * buf[i][3];  \n        q[i] = 0.5*(buf[i][1]*ue[i][1] + buf[i][2]*ue[i][2] + \n                    buf[i][3]*ue[i][3]); \n      } \n \n      for (i = 1; i <= grid_points[0]-2; i++) { \n        im1 = i-1; \n        ip1 = i+1; \n \n        forcing[k][j][i][0] = forcing[k][j][i][0] - \n          tx2*( ue[ip1][1]-ue[im1][1] )+ \n          dx1tx1*(ue[ip1][0]-2.0*ue[i][0]+ue[im1][0]); \n \n        forcing[k][j][i][1] = forcing[k][j][i][1] - tx2 * ( \n            (ue[ip1][1]*buf[ip1][1]+c2*(ue[ip1][4]-q[ip1]))- \n            (ue[im1][1]*buf[im1][1]+c2*(ue[im1][4]-q[im1])))+ \n          xxcon1*(buf[ip1][1]-2.0*buf[i][1]+buf[im1][1])+ \n          dx2tx1*( ue[ip1][1]-2.0* ue[i][1]+ue[im1][1]); \n \n        forcing[k][j][i][2] = forcing[k][j][i][2] - tx2 * ( \n            ue[ip1][2]*buf[ip1][1]-ue[im1][2]*buf[im1][1])+ \n          xxcon2*(buf[ip1][2]-2.0*buf[i][2]+buf[im1][2])+ \n          dx3tx1*( ue[ip1][2]-2.0*ue[i][2] +ue[im1][2]); \n \n        forcing[k][j][i][3] = forcing[k][j][i][3] - tx2*( \n            ue[ip1][3]*buf[ip1][1]-ue[im1][3]*buf[im1][1])+ \n          xxcon2*(buf[ip1][3]-2.0*buf[i][3]+buf[im1][3])+ \n          dx4tx1*( ue[ip1][3]-2.0* ue[i][3]+ ue[im1][3]); \n \n        forcing[k][j][i][4] = forcing[k][j][i][4] - tx2*( \n            buf[ip1][1]*(c1*ue[ip1][4]-c2*q[ip1])- \n            buf[im1][1]*(c1*ue[im1][4]-c2*q[im1]))+ \n          0.5*xxcon3*(buf[ip1][0]-2.0*buf[i][0]+buf[im1][0])+ \n          xxcon4*(cuf[ip1]-2.0*cuf[i]+cuf[im1])+ \n          xxcon5*(buf[ip1][4]-2.0*buf[i][4]+buf[im1][4])+ \n          dx5tx1*( ue[ip1][4]-2.0* ue[i][4]+ ue[im1][4]); \n      } \n \n       \n \n       \n \n       \n \n      for (m = 0; m < 5; m++) { \n        i = 1; \n        forcing[k][j][i][m] = forcing[k][j][i][m] - dssp * \n          (5.0*ue[i][m] - 4.0*ue[i+1][m] +ue[i+2][m]); \n        i = 2; \n        forcing[k][j][i][m] = forcing[k][j][i][m] - dssp * \n          (-4.0*ue[i-1][m] + 6.0*ue[i][m] - \n            4.0*ue[i+1][m] +     ue[i+2][m]); \n      } \n \n      for (i = 3; i <= grid_points[0]-4; i++) { \n        for (m = 0; m < 5; m++) { \n          forcing[k][j][i][m] = forcing[k][j][i][m] - dssp* \n            (ue[i-2][m] - 4.0*ue[i-1][m] + \n             6.0*ue[i][m] - 4.0*ue[i+1][m] + ue[i+2][m]); \n        } \n      } \n \n      for (m = 0; m < 5", "pred": " \nvoid exact_rhs() \n{ \n  double dtemp[5], xi, eta, zeta, dtpp; \n  int m, i, j, k, ip1, im1, jp1, jm1, km1, kp1; \n \n  { \n   \n \n   \n \n   \n \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        for (m = 0; m < 5; m++) { \n          forcing[k][j][i][m] = 0.0; \n        } \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n  for (k = 1; k <= grid_points[2]-2; k++) { \n    zeta = (double)k * dnzm1; \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      eta = (double)j * dnym1; \n      for (i = 1; i <= grid_points[0]-2; i++) { \n        xi = (double)i * dnzm1; \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = 0.0; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnym1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnzm1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnym1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnzm1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnym1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnzm1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnym1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnzm1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnym1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnzm1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnym1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnzm1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnym1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnzm1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnym1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnzm1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnym1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnzm1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnym1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnzm1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnym1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnzm1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnym1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnzm1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnym1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnzm1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnym1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnzm1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnym1; \n        } \n        for (m = 0; m < 5; m++) { \n          dtemp[m] = (double)m * dnzm1; \n        } \n"}
{"label": " \nint main() \n{ \n  init_input_vars(); \n \n \n  double orio_t_start=0, orio_t_end=0, orio_t_total=0; \n  int orio_i; \n  int t,i,j; \n \n  for (orio_i=0; orio_i<REPS; orio_i++) \n  { \n    orio_t_start = rtclock(); \n     \n \n   \n \n \nregister int i,j,k,t;  \nregister int c1t, c2t, c3t, c4t, c5t, c6t, c7t, c8t, c9t, c10t, c11t, c12t;  \nregister int newlb_c1, newlb_c2, newlb_c3, newlb_c4, newlb_c5, newlb_c6,  \n  newlb_c7, newlb_c8, newlb_c9, newlb_c10, newlb_c11, newlb_c12;  \nregister int newub_c1, newub_c2, newub_c3, newub_c4, newub_c5, newub_c6,  \n  newub_c7, newub_c8, newub_c9, newub_c10, newub_c11, newub_c12;  \n \n \n#define ceild(n,d)  ceil(((double)(n))/((double)(d))) \n#define floord(n,d) floor(((double)(n))/((double)(d))) \n#define max(x,y)    ((x) > (y)? (x) : (y)) \n#define min(x,y)    ((x) < (y)? (x) : (y)) \n \n\t \n\tint c1, c2, c3, c4, c5, c6; \n \n\tregister int lb, ub, lb1, ub1, lb2, ub2; \n \n \nfor (c1=-1;c1<=floord(33*T+N-35,1024);c1++) { \n\tlb1=max(max(0,ceild(16*c1-511,528)),ceild(32*c1-T+1,32)); \n\tub1=min(min(floord(16*c1+15,16),floord(32*c1+N+29,1056)),floord(T+N-3,1024)); \n\tfor (c2=lb1; c2<=ub1; c2++) { \n \nfor (c4=max(max(0,ceild(16*c1-16*c2-63,64)),8*c2); c4<=min(min(8*c2+7,floord(32*c1-32*c2+N+29,128)),floord(T+N-3,128)); c4++ ) { \n  for (c5t=max(max(32*c1-32*c2,1),128*c4-N+2); c5t<=min(min(128*c4+126,T-1),32*c1-32*c2+31)-1; c5t=c5t+2) { \n    newlb_c6=-2147483648; \n    newub_c6=2147483647; \n    register int cbv_1; \n    cbv_1=c5t+1; \n    for (c5=c5t; c5<=cbv_1; c5=c5+1) { \n      newlb_c6=max(newlb_c6,max(c5+1,128*c4)); \n      newub_c6=min(newub_c6,min(128*c4+127,c5+N-2)); \n    } \n    for (c5=c5t; c5<=c5t+1; c5=c5+1) { \n      register int cbv_2, cbv_3; \n      cbv_2=max(c5+1,128*c4); \n      cbv_3=newlb_c6-1; \n      for (c6=cbv_2; c6<=cbv_3; c6=c6+1) { \n        a[c5][-c5+c6]=((double)(333))/1000*(a[c5-1][1+-c5+c6]+a[c5-1][-c5+c6]+a[c5-1][-c5+c6-1]); \n      } \n    } \n    register int cbv_4; \n    cbv_4=newub_c6-7; \n    for (c6t=newlb_c6; c6t<=cbv_4; c6t=c6t+8) { \n      a[c5t][-c5t+c6t]=((double)(333))/1000*(a[c5t-1][1+-c5t+c6t]+a[c5t-1][-c5t+c6t]+a[c5t-1][-c5t+c6t-1]); \n      a[c5t][-c5t+(c6t+1)]=((double)(333))/1000*(a[c5t-1][1+-c5t+(c6t+1)]+a[c5t-1][-c5t+(c6t+1)]+a[c5t-1][-c5t+(c6t+1)-1]); \n      a[c5t][-c5t+(c6t+2)]=((double)(333))/1000*(a[c5t-1][1+-c5t+(c6t+2)]+a[c5t-1][-c5t+(c6t+2)]+a[c5t-1][-c5t+(c6t+2)-1]); \n      a[c5t][-c5t+(c6t+3)]=((double)(333))/1000*(a[c5t-1][1+-c5t+(c6t+3)]+a[c5t-1][-c5t+(c6t+3)]+a[c5t-1][-c5t+(c6t+3)-1]); \n      a[c5t][-c5t+(c6t+4)]=((double)(333))/1000*(a[c5t-1][1+-c5t+(c6t+4)]+a[c5t-1][-c5t+(c6t+4)]+a[c5t-1][-c5t+(c6t+4)-1]); \n      a[c5t][-c5t+(c6t+5)]=((double)(333))/1000*(a[c5t-1][1+-c5t+(c6t+5)]+a[c5t-1][-c5t+(c6t+5)]+a[c5t-1][-c5t+(c6t+5)-1]); \n      a[c5t][-c5t+(c6t+6)]=((double)(333))/1000*(a[c5t-1][1+-c5t+(c6t+6)]+a[c5t-1][-c5t+(c6t+6)]+a[c5t-1][-c5t+(c6t+6)-1]); \n      a[c5t][-c5t+(c6t+7)]=((double)(333))/1000*(a[c5t-1][1+-c5t+(c6t+7)]+a[c5t-1][-c5t+(c6t+7)]+a[c5t-1][-c5t+(c6t+7)-1]); \n      a[(c5t+1)][-(c5t+1)+c6t]=((double)(333))/1000*(a[(c5t+1)-1][1+-(c5t+1)+c6t]+a[(c5t+1)-1][-(c5t+1)+c6t]+a[(c5t+1)-1][-(c5t+1)+c6t-1]); \n", "pred": " \nint main() \n{ \n  init_input_vars(); \n \n \n  double orio_t_start=0, orio_t_end=0, orio_t_total=0; \n  int orio_i; \n  int t,i,j; \n \n  for (orio_i=0; orio_i<REPS; orio_i++) \n  { \n    orio_t_start = rtclock(); \n     \n \n   \n \n \nregister int i,j,k,t;  \nregister int c1t, c2t, c3t, c4t, c5t, c6t, c7t, c8t, c9t, c10t, c11t, c12t;  \nregister int newlb_c1, newlb_c2, newlb_c3, newlb_c4, newlb_c5, newlb_c6,  \n  newlb_c7, newlb_c8, newlb_c9, newlb_c10, newlb_c11, newlb_c12;  \nregister int newub_c1, newub_c2, newub_c3, newub_c4, newub_c5, newub_c6,  \n  newub_c7, newub_c8, newub_c9, newub_c10, newub_c11, newub_c12;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n  newlb_c7t, newlb_c8t, newlb_c9t, newlb_c10t, newlb_c11t, newlb_c12t;  \nregister int newub_c1t, newub_c2t, newub_c3t, newub_c4t, newub_c5t, newub_c6t,  \n  newub_c7t, newub_c8t, newub_c9t, newub_c10t, newub_c11t, newub_c12t;  \nregister int newlb_c1t, newlb_c2t, newlb_c3t, newlb_c4t, newlb_c5t, newlb_c6t,  \n"}
{"label": " \nvoid \nfoo (int *a, long long int b, long long int c) \n{ \n  int i; \n  long long j; \n  for (i = 15; i < 64; i++) \n    { \n      if ((a[i] % 5) == 3) \n\tu = i; \n      if ((a[i] % 7) == 2) \n\tx = &a[i]; \n    } \n  for (i = -3; i < 119; i += 2) \n    { \n      ++s; \n      if ((a[i + 4] % 11) == 9) \n\tv = i; \n      else \n\t++r; \n    } \n  for (j = b; j < b + 115 * c; j += (b & 3) + 7) \n    if ((a[j] % 13) == 5) \n      w = j * 2; \n  for (i = -5; i < (int) (b + 5); i += 2) \n    for (j = b + 12 + c; j > b; --j) \n      for (int k = 0; k < 5; k += c) \n\tif (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6) \n\t  p = i * 10000 + j * 100 + k; \n \n  for (i = 15; i < 64; i++) \n    { \n      if ((a[i] % 5) == 3) \n\tu2 = i; \n      if ((a[i] % 7) == 2) \n\tx2 = &a[i]; \n    } \n  for (i = -3; i < 119; i += 2) \n    { \n      ++s2; \n      if ((a[i + 4] % 11) == 9) \n\tv2 = i; \n      else \n\t++r2; \n    } \n  for (j = b; j < b + 115 * c; j += (b & 3) + 7) \n    if ((a[j] % 13) == 5) \n      w2 = j * 2; \n  for (i = -5; i < (int) (b + 5); i += 2) \n    for (j = b + 12 + c; j > b; --j) \n      for (int k = 0; k < 5; k += c) \n\tif (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6) \n\t  p2 = i * 10000 + j * 100 + k; \n \n  for (i = 15; i < 64; i++) \n    { \n      if ((a[i] % 5) == 3) \n\tu3 = i; \n      if ((a[i] % 7) == 2) \n\tx3 = &a[i]; \n    } \n  for (i = -3; i < 119; i += 2) \n    { \n      ++s3; \n      if ((a[i + 4] % 11) == 9) \n\tv3 = i; \n      else \n\t++r3; \n    } \n  for (j = b; j < b + 115 * c; j += (b & 3) + 7) \n    if ((a[j] % 13) == 5) \n      w3 = j * 2; \n  for (i = -5; i < (int) (b + 5); i += 2) \n    for (j = b + 12 + c; j > b; --j) \n      for (int k = 0; k < 5; k += c) \n\tif (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6) \n\t  p3 = i * 10000 + j * 100 + k; \n \n   \n \n  for (int k = -2000; k < 8000; ++k) \n    { \n      if (k < 3000 && (k & 3) == 1) \n\t{ \n\t  z = k; \n\t  thr1 = k; \n\t} \n      else if (k == 7931) \n\t{ \n\t  z = z; \n\t  thr2 = 1; \n\t} \n    } \n \n  if (thr2 && z!= thr1) \n    abort (); \n} ", "pred": " \nvoid \nfoo (int *a, long long int b, long long int c) \n{ \n  int i; \n  long long j; \n  for (i = 15; i < 64; i++) \n    { \n      if ((a[i] % 5) == 3) \n\tu = i; \n      if ((a[i] % 7) == 2) \n\tx = &a[i]; \n    } \n  for (i = -3; i < 119; i += 2) \n    { \n      ++s; \n      if ((a[i + 4] % 11) == 9) \n\tv = i; \n      else \n\t++r; \n    } \n  for (j = b; j < b + 115 * c; j += (b & 3) + 7) \n    if ((a[j] % 13) == 5) \n      w = j * 2; \n  for (i = -5; i < (int) (b + 5); i += 2) \n    for (j = b + 12 + c; j > b; --j) \n      for (int k = 0; k < 5; k++) \n\tif ((a[j + k] % 13) == 5) \n\t  z = j + k; \n        else \n\t{ \n\t  if ((a[j + k] % 13) == 3) \n\t    { \n\t      if ((a[j + k] % 11) == 9) \n\t\t{ \n\t\t  if ((a[j + k] % 7) == 2) \n\t\t    { \n\t\t      if ((a[j + k] % 3) == 1) \n\t\t\t{ \n\t\t\t  if ((a[j + k] % 5) == 3) \n\t\t\t    { \n\t\t\t      if ((a[j + k] % 7) == 2) \n\t\t\t\t{ \n\t\t\t\t  if ((a[j + k] % 11) == 9) \n\t\t\t\t    { \n\t\t\t\t      if ((a[j + k] % 13) == 5) \n\t\t\t\t\t{ \n\t\t\t\t\t  if ((a[j + k] % 15) == 3) \n\t\t\t\t\t    { \n\t\t\t\t\t      if ((a[j + k] % 17) == 1) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t  if ((a[j + k] % 19) == 1) \n\t\t\t\t\t\t    { \n\t\t\t\t\t\t      if ((a[j + k] % 21) == 1) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t  if ((a[j + k] % 23) == 1) \n\t\t\t\t\t\t\t    { \n\t\t\t\t\t\t\t      if ((a[j + k] % 25) == 1) \n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t  if ((a[j + k] % 27) == 1) \n\t\t\t\t\t\t\t\t    { \n\t\t\t\t\t\t\t\t      if ((a[j + k] % 29) == 1) \n\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t  if ((a[j + k] % 31) == 1) \n\t\t\t\t\t\t\t\t\t    { \n\t\t\t\t\t\t\t\t\t      if ((a[j + k] % 33) == 1) \n\t\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\t        else \n\t\t\t\t\t\t\t\t\t\t        { \n\t\t\t\t\t\t\t\t\t\t          if ((a[j + k] % 35) == 1) \n\t\t\t\t\t\t\t\t\t\t            { \n\t\t\t\t\t\t\t\t\t\t              if ((a[j + k] % 37) == 1) \n\t\t\t\t\t\t\t\t\t\t                { \n\t\t\t\t\t\t\t\t\t\t                  if ((a[j + k] % 39) == 1) \n\t\t\t\t\t\t\t\t\t\t                    { \n\t\t\t\t\t\t\t\t\t\t                      if ((a[j + k] % 41) == 1) \n\t\t\t\t\t\t\t\t\t\t                        { \n\t\t\t\t\t\t\t\t\t\t                          if ((a[j + k] % 43) == 1) \n\t\t\t\t\t\t\t\t\t\t                            { \n\t\t\t\t\t\t\t\t\t\t                              if ((a[j + k] % 45) == 1) \n"}
{"label": " \nint main (int argc, char *argv[]) \n{ \n  static VArgVector in_files1; \n  static VArgVector in_files2; \n  static VString  out_filename=\"\"; \n  static VString  mask_filename=\"\"; \n  static VFloat   alpha = 0.05; \n  static VShort   testtype = 0; \n  static VShort   radius = 2; \n  static VFloat   rvar = 2.0; \n  static VFloat   svar = 2.0; \n  static VShort   numiter = 2; \n  static VShort   numperm = 5000; \n  static VLong    seed = 99402622; \n  static VBoolean centering = FALSE; \n  static VBoolean cleanup = TRUE; \n  static VShort   nproc = 0; \n  static VOptionDescRec options[] = { \n    {\"in1\", VStringRepn, 0, & in_files1, VRequiredOpt, NULL,\"Input files 1\" }, \n    {\"in2\", VStringRepn, 0, & in_files2, VRequiredOpt, NULL,\"Input files 2\" }, \n    {\"out\", VStringRepn, 1, & out_filename, VRequiredOpt, NULL,\"Output file\" }, \n    {\"alpha\",VFloatRepn,1,(VPointer) &alpha,VOptionalOpt,NULL,\"FDR significance level\"}, \n    {\"perm\",VShortRepn,1,(VPointer) &numperm,VOptionalOpt,NULL,\"Number of permutations\"}, \n    {\"mask\", VStringRepn, 1, (VPointer) &mask_filename, VRequiredOpt, NULL, \"Mask\"}, \n    {\"test\",VShortRepn,1,(VPointer) &testtype,VOptionalOpt,TSTDict,\"type of test\"}, \n    {\"seed\",VLongRepn,1,(VPointer) &seed,VOptionalOpt,NULL,\"Seed for random number generation\"}, \n    {\"radius\",VShortRepn,1,(VPointer) &radius,VOptionalOpt,NULL,\"Bilateral parameter (radius in voxels)\"}, \n    {\"rvar\",VFloatRepn,1,(VPointer) &rvar,VOptionalOpt,NULL,\"Bilateral parameter (radiometric)\"}, \n    {\"svar\",VFloatRepn,1,(VPointer) &svar,VOptionalOpt,NULL,\"Bilateral parameter (spatial)\"}, \n    {\"filteriterations\",VShortRepn,1,(VPointer) &numiter,VOptionalOpt,NULL,\"Bilateral parameter (number of iterations)\"}, \n    {\"cleanup\",VBooleanRepn,1,(VPointer) &cleanup,VOptionalOpt,NULL,\"Whether to apply cleanup\"}, \n    {\"j\",VShortRepn,1,(VPointer) &nproc,VOptionalOpt,NULL,\"Number of processors to use, '0' to use all\"}, \n  }; \n \n  FILE *fp=NULL; \n  VString in_filename,str1,str2; \n  VAttrList list1=NULL,list2=NULL,out_list=NULL,geolist=NULL; \n  int i,nimages1=0,nimages2=0,npix=0; \n  char *prg_name=GetLipsiaName(\"vlisa_twosample\"); \n  fprintf (stderr, \"%s\\n\", prg_name); \n \n \n   \n \n  if (! VParseCommand (VNumber (options), options, & argc, argv)) { \n    VReportUsage (argv[0], VNumber (options), options, NULL); \n    exit (EXIT_FAILURE); \n  } \n  if (argc > 1) { \n    VReportBadArgs (argc, argv); \n    exit (EXIT_FAILURE); \n  } \n \n \n   \n \n  int num_procs=omp_get_num_procs(); \n  if (nproc > 0 && nproc < num_procs) num_procs = nproc; \n  fprintf(stderr,\" using %d cores\\n\",(int)num_procs); \n  omp_set_num_threads(num_procs); \n \n \n   \n \n  VImage mask = VReadImageFile(mask_filename); \n  if (mask==NULL) VError(\"Error reading mask file %s\",mask_filename); \n \n \n   \n \n  nimages1 = in_files1.number; \n  nimages2 = in_files2.number; \n  fprintf(stderr,\" nimages= %d  %d\\n\",nimages1,nimages2); \n \n \n   \n \n  VImage *src1 = (VImage *) VCalloc(nimages1,sizeof(VImage)); \n  for (i = 0; i < nimages1; i++) { \n    in_filename = ((VString *) in_files1.vector)[i]; \n    list1   = VReadAttrList(in_filename,0L,TRUE,FALSE); \n    VMaskMinval(list1,mask,0.0); \n    src1[i] = VReadImage(list1); \n    if (src1[i] == NULL) VError(\" no input image found\"); \n    if (VPixelRepn(src1[i])!= VFloatRepn) VError(\" input pixel repn must be float\"); \n    if (i == 0) npix = VImageNPixels(src1[i]); \n    else if (npix!= VImageNPixels(src1[i])) VError(\" inconsistent image dimensions\"); \n \n     \n \n    if (geolist == NULL) geolist = VGetGeoInfo(list1); \n  } \n \n \n   \n \n  VImage *src2 = (VImage *) VCalloc(nimages2,sizeof(VImage)); \n  for (i = 0; i < nimages2; i++) { \n    in_filename = ((VString *) in_files2.vector)[i]; \n    list2   = VReadAttrList(in_filename,0L,TRUE,FALSE); \n    VMaskMinval(list2,mask,0.0); \n    src2[i] = VReadImage(list2); \n    if (src2[i] == NULL) VError(\" no input image found\"); \n    if (VPixelRepn(src2[i])!= VFloatRepn) VError(\" input pixel repn must be float\"); \n    if (i == 0) npix = VImageNPixels(src2[i]); \n    else if (npix!= VImageNPixels(src2[i])) VError(\" inconsistent image dimensions\"); \n  } \n \n  if (testtype == 1) {   \n \n    for (i = 0; i < nimages1; i++) { \n      str1 = ((VString *) in_files1.vector)[i]; \n      str2 = ((VString *) in_files2.vector)[i]; \n      fprintf(stderr,\" %3d:  %s   %s\\n\",i,str1,str2); \n    } \n  } \n  else { \n    fprintf(stderr,\" Group 1:\\n\"); \n    for (i = 0; i < nimages1; i++) { \n      str1 = ((VString *) in_files1.vector)[i]; \n      fprintf(stderr,\" %3d:  %s\\n\",i,str1); \n    } \n    fprintf(stderr,\"\\n Group 2:\\n\"); \n    for (i = 0; i < nimages2; i++) { \n      str2 = ((VString *) in_files2.vector)[i]; \n      fprintf(stderr,\" %3d:  %s\\n\",i,str2); \n    } \n  } \n \n \n   \n \n  size_t n = nimages1+nimages2; \n  int nperm=0; \n  int **permtable = genperm((long)seed,(int)nimages1,(int)nimages2,(int)numperm,(int)testtype); \n  int *nopermtable = (int *) VCalloc(n,sizeof(int)); \n  for (i=0; i<n; i++) nopermtable[i]=i; \n  if (testtype == 1) for (i=0; i<n; i++) nopermtable[i]=0; \n \n \n   \n \n  double hmin=0,hmax=0; \n  float stddev=1.0; \n  if (numperm > 0) { \n    int tstperm = 30;", "pred": " \nint main (int argc, char *argv[]) \n{ \n  static VArgVector in_files1; \n  static VArgVector in_files2; \n  static VString  out_filename=\"\"; \n  static VString  mask_filename=\"\"; \n  static VFloat   alpha = 0.05; \n  static VShort   testtype = 0; \n  static VShort   radius = 2; \n  static VFloat   rvar = 2.0; \n  static VFloat   svar = 2.0; \n  static VShort   numiter = 2; \n  static VShort   numperm = 5000; \n  static VLong    seed = 99402622; \n  static VBoolean centering = FALSE; \n  static VBoolean cleanup = TRUE; \n  static VShort   nproc = 0; \n  static VOptionDescRec options[] = { \n    {\"in1\", VStringRepn, 0, & in_files1, VRequiredOpt, NULL,\"Input files 1\" }, \n    {\"in2\", VStringRepn, 0, & in_files2, VRequiredOpt, NULL,\"Input files 2\" }, \n    {\"out\", VStringRepn, 1, & out_filename, VRequiredOpt, NULL,\"Output file\" }, \n    {\"mask\", VStringRepn, 1, & mask_filename, VRequiredOpt, NULL,\"Mask file\" }, \n    {\"alpha\", VFloat, 1, & alpha, VOptionalOpt, NULL,\"Alpha\" }, \n    {\"testtype\", VShort, 1, & testtype, VOptionalOpt, NULL,\"Test type\" }, \n    {\"radius\", VShort, 1, & radius, VOptionalOpt, NULL,\"Radius\" }, \n    {\"rvar\", VFloat, 1, & rvar, VOptionalOpt, NULL,\"R-variance\" }, \n    {\"svar\", VFloat, 1, & svar, VOptionalOpt, NULL,\"S-variance\" }, \n    {\"numiter\", VShort, 1, & numiter, VOptionalOpt, NULL,\"Number of iterations\" }, \n    {\"numperm\", VShort, 1, & numperm, VOptionalOpt, NULL,\"Number of processors\" }, \n    {\"seed\", VInt, 1, & seed, VOptionalOpt, NULL,\"Random seed\" }, \n    {\"centering\", VBoolean, 1, & centering, VOptionalOpt, NULL,\"Centering\" }, \n    {\"cleanup\", VBoolean, 1, & cleanup, VOptionalOpt, NULL,\"Cleanup\" }, \n    {\"nproc\", VShort, 1, & nproc, VOptionalOpt, NULL,\"Number of processors\" }, \n    {NULL, 0, 0, NULL, 0, NULL, NULL}\n  };\n  \n  VArgVector arg_vector;\n  VArg       arg;\n  \n  arg_vector.argc = argc;\n  arg_vector.argv = argv;\n  arg_vector.arg_type = VArg::ARG_IN;\n  arg.in_files = &in_files1;\n  arg.in_files_size = 1;\n  arg.out_filename = &out_filename;\n  arg.out_filename_size = 0;\n  arg.mask_filename = &mask_filename;\n  arg.mask_filename_size = 0;\n  arg.alpha = &alpha;\n  arg.alpha_size = 0;\n  arg.testtype = &testtype;\n  arg.testtype_size = 0;\n  arg.radius = &radius;\n  arg.radius_size = 0;\n  arg.rvar = &rvar;\n  arg.rvar_size = 0;\n  arg.svar = &svar;\n  arg.svar_size = 0;\n  arg.numiter = &numiter;\n  arg.numiter_size = 0;\n  arg.numperm = &numperm;\n  arg.numperm_size = 0;\n  arg.seed = &seed;\n  arg.seed_size = 0;\n  arg.centering = &centering;\n  arg.centering_size = 0;\n  arg.cleanup = &cleanup;\n  arg.cleanup_size = 0;\n  arg.nproc = &nproc;\n  arg.nproc_size = 0;\n  arg.out_filename = &out_filename;\n  arg.out_filename_size = 0;\n  arg.mask_filename = &mask_filename;\n  arg.mask_filename_size = 0;\n  arg.testtype = &testtype;\n  arg.testtype_size = 0;\n  arg.radius = &radius;\n  arg.radius_size = 0;\n  arg.rvar = &rvar;\n  arg.rvar_size = 0;\n  arg.svar = &svar;\n  arg.svar_size = 0;\n  arg.numiter = &numiter;\n  arg.numiter_size = 0;\n  arg.numperm = &numperm;\n  arg.numperm_size = 0;\n  arg.seed = &seed;\n  arg.seed_size = 0;\n  arg.centering = &centering;\n  arg.centering_size = 0;\n  arg.cleanup = &cleanup;\n  arg.cleanup_size = 0;\n  arg.nproc = &nproc;\n  arg.nproc_size = 0;\n  arg.out_filename = &out_filename;\n  arg.out_filename_size = 0;\n  arg.mask_filename = &mask_filename;\n  arg.mask_filename_size = 0;\n  arg.testtype = &testtype;\n  arg.testtype_size = 0;\n  arg.radius = &radius;\n  arg.radius_size = 0;\n  arg.rvar = &rvar;\n  arg.rvar_size = 0;\n  arg.svar = &svar;\n  arg.svar_size = 0;\n  arg.numiter = &numiter;\n  arg.numiter_size = 0;\n  arg.numperm = &numperm;\n  arg.numperm_size = 0;\n  arg.seed = &seed;\n  arg.seed_size = 0;\n  arg.centering = &centering;\n  arg.centering_size = 0;\n  arg.cleanup = &cleanup;\n  arg.cleanup_size = 0;\n  arg.nproc = &nproc;\n  arg.nproc_size = 0;\n  arg.out_filename = &out_filename;\n  arg.out_filename_size = 0;\n  arg.mask_filename = &mask_filename;\n  arg.mask_filename_size = 0;\n  arg.testtype = &testtype;\n  arg.testtype_size = 0;\n  arg.radius = &radius;\n  arg.radius_size = 0;\n  arg.rvar = &rvar;\n  arg.rvar_size = 0;\n  arg.svar = &svar;\n  arg.svar_size = 0;\n  arg.numiter = &numiter;\n  arg.numiter_size = 0;\n  arg.numperm = &numperm;\n  arg.numperm_size = 0;\n  arg.seed = &seed;\n  arg.seed_size = 0;\n  arg.centering = &centering;\n  arg.centering_size = 0;\n  arg.cleanup = &cleanup;\n  arg.cleanup_size = 0;\n  arg.nproc = &nproc;\n  arg.nproc_size = 0;\n  arg.out_filename = &out_filename;\n  arg.out_filename_size = 0;\n  arg.mask_filename = &mask_filename;\n  arg.mask_filename_size = 0;\n  arg.testtype = &testtype;\n  arg.testtype_size = 0;\n  arg.radius = &radius;\n  arg.radius_size = 0;\n  arg.rvar = &rvar;\n  arg.rvar_size = 0;\n  arg.svar = &svar;\n  arg.svar_size = 0;\n  arg.numiter = &numiter;\n  arg.numiter_size = 0;\n  arg.numperm = &numperm;\n  arg.numperm_size = 0;\n  arg.seed = &seed;\n  arg.seed_size = 0;\n  arg.centering = &centering;\n  arg.centering_size = 0;\n  arg.cleanup = &cleanup;\n  arg.cleanup_size = 0;\n  arg.nproc = &nproc;\n  arg.nproc_size = 0"}
{"label": " \nvoid particleFilter(int * I, int IszX, int IszY, int Nfr, int * seed, int Nparticles){ \n\t \n\tint max_size = IszX*IszY*Nfr; \n\tlong long start = get_time(); \n\t \n \n\tdouble xe = roundDouble(IszY/2.0); \n\tdouble ye = roundDouble(IszX/2.0); \n\t \n\t \n \n\tint radius = 5; \n\tint diameter = radius*2 - 1; \n\tint * disk = (int *)malloc(diameter*diameter*sizeof(int)); \n\tstrelDisk(disk, radius); \n\tint countOnes = 0; \n\tint x, y; \n\tfor(x = 0; x < diameter; x++){ \n\t\tfor(y = 0; y < diameter; y++){ \n\t\t\tif(disk[x*diameter + y] == 1) \n\t\t\t\tcountOnes++; \n\t\t} \n\t} \n\tdouble * objxy = (double *)malloc(countOnes*2*sizeof(double)); \n\tgetneighbors(disk, countOnes, objxy, radius); \n\t \n\tlong long get_neighbors = get_time(); \n\tprintf(\"TIME TO GET NEIGHBORS TOOK: %f\\n\", elapsed_time(start, get_neighbors)); \n\t \n \n\tdouble * weights = (double *)malloc(sizeof(double)*Nparticles); \n\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{ \n\t\tweights[x] = 1/((double)(Nparticles)); \n\t} ; } \n \n\tlong long get_weights = get_time(); \n\tprintf(\"TIME TO GET WEIGHTSTOOK: %f\\n\", elapsed_time(get_neighbors, get_weights)); \n\t \n \n\tdouble * likelihood = (double *)malloc(sizeof(double)*Nparticles); \n\tdouble * arrayX = (double *)malloc(sizeof(double)*Nparticles); \n\tdouble * arrayY = (double *)malloc(sizeof(double)*Nparticles); \n\tdouble * xj = (double *)malloc(sizeof(double)*Nparticles); \n\tdouble * yj = (double *)malloc(sizeof(double)*Nparticles); \n\tdouble * CDF = (double *)malloc(sizeof(double)*Nparticles); \n\tdouble * u = (double *)malloc(sizeof(double)*Nparticles); \n\tint * ind = (int*)malloc(sizeof(int)*countOnes*Nparticles); \n\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{ \n\t\tarrayX[x] = xe; \n\t\tarrayY[x] = ye; \n\t} ; } \n \n\tint k; \n\t \n\tprintf(\"TIME TO SET ARRAYS TOOK: %f\\n\", elapsed_time(get_weights, get_time())); \n\tint indX, indY; \n\tfor(k = 1; k < Nfr; k++){ \n\t\tlong long set_arrays = get_time(); \n\t\t \n \n\t\t \n \n\t\t \n \n\t\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{ \n\t\t\tarrayX[x] += 1 + 5*randn(seed, x); \n\t\t\tarrayY[x] += -2 + 2*randn(seed, x); \n\t\t} ; } \n \n\t\tlong long error = get_time(); \n\t\tprintf(\"TIME TO SET ERROR TOOK: %f\\n\", elapsed_time(set_arrays, error)); \n\t\t \n \n\t\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{ \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\t \n \n\t\t\tfor(y = 0; y < countOnes; y++){ \n\t\t\t\tindX = roundDouble(arrayX[x]) + objxy[y*2 + 1]; \n\t\t\t\tindY = roundDouble(arrayY[x]) + objxy[y*2]; \n\t\t\t\tind[x*countOnes + y] = fabs(indX*IszY*Nfr + indY*Nfr + k); \n\t\t\t\tif(ind[x*countOnes + y] >= max_size) \n\t\t\t\t\tind[x*countOnes + y] = 0; \n\t\t\t} \n\t\t\tlikelihood[x] = 0; \n\t\t\tfor(y = 0; y < countOnes; y++) \n\t\t\t\tlikelihood[x] += (pow((I[ind[x*countOnes + y]] - 100),2) - pow((I[ind[x*countOnes + y]]-228),2))/50.0; \n\t\t\tlikelihood[x] = likelihood[x]/((double) countOnes); \n\t\t} ; } \n \n\t\tlong long likelihood_time = get_time(); \n\t\tprintf(\"TIME TO GET LIKELIHOODS TOOK: %f\\n\", elapsed_time(error, likelihood_time)); \n\t\t \n \n\t\t \n \n\t\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{ \n\t\t\tweights[x] = weights[x] * exp(likelihood[x]); \n\t\t} ; } \n \n\t\tlong long exponential = get_time(); \n\t\tprintf(\"TIME TO GET EXP TOOK: %f\\n\", elapsed_time(likelihood_time, exponential)); \n\t\tdouble sumWeights = 0; \n\t\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{ \n\t\t\tsumWeights += weights[x]; \n\t\t} ; } \n \n\t\tlong long sum_time = get_time(); \n\t\tprintf(\"TIME TO SUM WEIGHTS TOOK: %f\\n\", elapsed_time(exponential, sum_time)); \n\t\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{ \n\t\t\tweights[x] = weights[x]/sumWeights; \n\t\t} ; } \n \n\t\tlong long normalize = get_time(); \n\t\tprintf(\"TIME TO NORMALIZE WEIGHTS TOOK: %f\\n\", elapsed_time(sum_time, normalize)); \n\t\txe = 0; \n\t\tye = 0; \n\t\t \n \n\t\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{ \n\t\t\txe += arrayX[x] * weights[x]; \n\t\t\tye += arrayY[x] * weights[x]; \n\t\t} ; } \n \n\t\tlong long move_time = get_time(); \n\t\tprintf(\"TIME TO MOVE OBJECT TOOK: %f\\n\", elapsed_time(normalize, move_time)); \n\t\tprintf(\"XE: %lf\\n\", xe); \n\t\tprintf(\"YE: %lf\\n\", ye); \n\t\tdouble distance = sqrt( pow((double)(xe-(int)roundDouble(IszY/2.0)),2) + pow((double)(ye-(int)roundDouble(IszX/2.0)),2) ); \n\t\tprintf(\"%lf\\n\", distance); \n\t\t \n \n\t\t \n\t\t \n \n\t\t \n\t\t \n \n\t\t \n\t\t \n\t\tCDF[0] = weights[0]; \n\t\tfor(x = 1; x < Nparticles; x++){ \n\t\t\tCDF[x] = weights[x] + CDF[x-1]; \n\t\t} \n\t\tlong long cum_sum = get_time(); \n\t\tprintf(\"TIME TO CALC CUM SUM TOOK: %f\\n\", elapsed_time(move_time, cum_sum)); \n\t\tdouble u1 = (1/((double)(Nparticles)))*randu(seed, 0); \n\t\tfor(x = 0; x < Nparticles; x++){ ____num_tasks[omp_get_thread_num()]++; \n{ \n\t\t\tu[x] = u1 + x/((double)(Nparticles)); \n\t\t} ; } \n \n\t\tlong long u_time = get_time(); \n\t\tprintf(\"TIME TO CALC U TOOK: %f\\n\", elapsed_time(cum_sum, u_time)); \n\t\tint j, i; \n\t\t \n\t\tfor(j = 0; j < Nparticles; j++){ ____num_tasks[omp_get_thread_num()]++; \n{ \n\t\t\ti = findIndex(CDF, Nparticles, u[j]); \n\t\t\tif(i == -1) \n\t\t\t\ti = Nparticles-1; \n\t\t\txj[j] = arrayX[i]; \n\t\t", "pred": " \nvoid particleFilter(int * I, int IszX, int IszY, int Nfr, int * seed, int Nparticles){ \n\t \n\tint max_size = IszX*IszY*Nfr; \n\tlong long start = get_time(); \n\t \n \n\tdouble xe = roundDouble(IszY/2.0); \n\tdouble ye = roundDouble(IszX/2.0); \n\t \n\t \n \n\tint radius = 5; \n\tint diameter = radius*2 - 1; \n\tint * disk = (int *)malloc(diameter*diameter*sizeof(int)); \n\tstrelDisk(disk, radius); \n\tint countOnes = 0; \n\tint x, y; \n\tfor(x = 0; x < diameter; x++){ \n\t\tfor(y = 0; y < diameter; y++){ \n\t\t\tif(disk[x*diameter + y] == 1) \n\t\t\t\tcountOnes++; \n\t\t} \n\t} \n\tdouble * objxy = (double *)malloc(countOnes*2*sizeof(double)); \n\tgetneighbors(disk, countOnes, objxy, radius); \n\t \n\tlong long get_neighbors = get_time(); \n\tprintf(\"TIME TO GET NEIGHBORS TOOK: %f\\n\", get_time() - start); \n\tstart = get_time(); \n\tint * I_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_new_old = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_old = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_new_old_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_old = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_new_old_new_old = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_new_new_old = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof(int)); \n\tint * I_old_new_new_old_new_new_new_new_new_new_new_new_new_new_new_new = (int *)malloc(Nparticles*sizeof"}
{"label": " \nvoid CVHFnr_direct_ex_drv(int (*intor)(), void (*fdot)(), JKOperator **jkop, \n                          double **dms, double **vjk, int n_dm, int ncomp, \n                          int *shls_slice, int *ao_loc, \n                          CINTOpt *cintopt, CVHFOpt *vhfopt, \n                          int *atm, int natm, int *bas, int nbas, double *env) \n{ \n        IntorEnvs envs = {natm, nbas, atm, bas, env, shls_slice, ao_loc, NULL, \n                cintopt, ncomp}; \n        int idm; \n        double *tile_dms[n_dm]; \n        for (idm = 0; idm < n_dm; idm++) { \n                CVHFzero_out_vjk(vjk[idm], jkop[idm], shls_slice, ao_loc, ncomp); \n                tile_dms[idm] = CVHFallocate_and_reorder_dm(jkop[idm], dms[idm], \n                                                            shls_slice, ao_loc); \n        } \n \n        size_t di = GTOmax_shell_dim(ao_loc, shls_slice, 4); \n        size_t cache_size = GTOmax_cache_size(intor, shls_slice, 4, \n                                              atm, natm, bas, nbas, env); \n        int ish0 = shls_slice[0]; \n        int ish1 = shls_slice[1]; \n        int jsh0 = shls_slice[2]; \n        int jsh1 = shls_slice[3]; \n        int ksh0 = shls_slice[4]; \n        int ksh1 = shls_slice[5]; \n        int lsh0 = shls_slice[6]; \n        int lsh1 = shls_slice[7]; \n        int nish = ish1 - ish0; \n        int njsh = jsh1 - jsh0; \n        int nksh = ksh1 - ksh0; \n        int nlsh = lsh1 - lsh0; \n        int *shls_excludes = shls_slice + 8; \n        int *block_iloc = malloc(sizeof(int) * (nish + njsh + nksh + nlsh + 4)); \n        int *block_jloc = block_iloc + nish + 1; \n        int *block_kloc = block_jloc + njsh + 1; \n        int *block_lloc = block_kloc + nksh + 1; \n        size_t nblock_i = _shls_block_partition_lim(block_iloc, shls_slice+0, shls_excludes+0, ao_loc); \n        size_t nblock_j = _shls_block_partition_lim(block_jloc, shls_slice+2, shls_excludes+2, ao_loc); \n        size_t nblock_k = _shls_block_partition_lim(block_kloc, shls_slice+4, shls_excludes+4, ao_loc); \n        size_t nblock_l = _shls_block_partition_lim(block_lloc, shls_slice+6, shls_excludes+6, ao_loc); \n        size_t nblock_kl = nblock_k * nblock_l; \n        size_t nblock_jkl = nblock_j * nblock_kl; \n \n{ \n        size_t i, j, k, l, r, blk_id; \n        JKArray *v_priv[n_dm]; \n        for (i = 0; i < n_dm; i++) { \n                v_priv[i] = CVHFallocate_JKArray(jkop[i], shls_slice, ao_loc, ncomp); \n        } \n        double *buf = malloc(sizeof(double) * (di*di*di*di*ncomp + di*di*2 + cache_size)); \n        double *cache = buf + di*di*di*di*ncomp; \n        for (blk_id = 0; blk_id < nblock_jkl; blk_id++) { \n                r = blk_id; \n                j = r / nblock_kl ; r = r % nblock_kl; \n                k = r / nblock_l  ; r = r % nblock_l; \n                l = r; \n                for (i = 0; i < nblock_i; i++) { \n                         \n \n                         \n \n                        if (shls_excludes[0] <= block_iloc[i] && block_iloc[i] < shls_excludes[1] && \n                            shls_excludes[2] <= block_jloc[j] && block_jloc[j] < shls_excludes[3] && \n                            shls_excludes[4] <= block_kloc[k] && block_kloc[k] < shls_excludes[5] && \n                            shls_excludes[6] <= block_lloc[l] && block_lloc[l] < shls_excludes[7]) { \n                                continue; \n                        } \n                        (*fdot)(intor, jkop, v_priv, tile_dms, buf, cache, n_dm, \n                 ", "pred": " \nvoid CVHFnr_direct_ex_drv(int (*intor)(), void (*fdot)(), JKOperator **jkop, \n                          double **dms, double **vjk, int n_dm, int ncomp, \n                          int *shls_slice, int *ao_loc, \n                          CINTOpt *cintopt, CVHFOpt *vhfopt, \n                          int *atm, int natm, int *bas, int nbas, double *env) \n{ \n        IntorEnvs envs = {natm, nbas, atm, bas, env, shls_slice, ao_loc, NULL, \n                cintopt, ncomp}; \n        int idm; \n        double *tile_dms[n_dm]; \n        double *tile_vjk[n_dm]; \n        int *tile_shls[n_dm]; \n        int *tile_ao_loc[n_dm]; \n        int *tile_atm[n_dm]; \n        int *tile_bas[n_dm]; \n        int *tile_atm_bas[n_dm]; \n        int *tile_env[n_dm]; \n        int *tile_atm_env[n_dm]; \n        int *tile_bas_env[n_dm]; \n        int *tile_atm_bas_env[n_dm]; \n        int *tile_env_env[n_dm]; \n        int *tile_atm_env_env[n_dm]; \n        int *tile_bas_env_env[n_dm]; \n        int *tile_atm_bas_env_env[n_dm]; \n        int *tile_env_bas_env[n_dm]; \n        int *tile_atm_env_bas_env[n_dm]; \n        int *tile_bas_env_bas_env[n_dm]; \n        int *tile_atm_bas_env_bas_env[n_dm]; \n        int *tile_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_env_bas_env_bas_env[n_dm]; \n        int *tile_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_atm_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env_bas_env[n_dm]; \n        int *tile_env_bas_env_bas_env_bas_env_"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 8; \n  tile_size[3] = 512; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=floord(Nt-1,3);t1++) { \n    lbp=max(ceild(t1,2),ceild(6*t1-Nt+2,6)); \n    ubp=min(floord(4*Nt+Nz-9,24),floord(12*t1+Nz+6,24)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(max(0,ceild(3*t1,2)),ceild(24*t2-Nz+5,8)),3*t1-3*t2+1);t3<=min(min(min(floord(4*Nt+Ny-9,8),floord(12*t1+Ny+15,8)),floord(24*t2+Ny+11,8)),floord(24*t1-24*t2+Nz+Ny+13,8));t3++) { \n        for (t4=max(max(max(max(0,ceild(3*t1-3*t2-62,64)),ceild(3*t1-126,128)),ceild(24*t2-Nz-499,512)),ceild(8*t3-Ny-499,512));t4<=min(min(min(min(floord(4*Nt+Nx-9,512),floord(12*t1+Nx+15,512)),floord(24*t2+Nx+11,512)),floord(8*t3+Nx-5,512)),floord(24*t1-24*t2+Nz+Nx+13,512));t4++) { \n          for (t5=max(max(max(max(max(0,ceild(24*t2-Nz+5,4)),ceild(8*t3-Ny+5,4)),ceild(512*t4-Nx+5,4)),3*t1),6*t1-6*t2+1);t5<=min(min(min(min(min(floord(24*t1-24*t2+Nz+18,4),2*t3),Nt-1),3*t1+5),6*t2+4),128*t4+126);t5++) { \n            for (t6=max(max(24*t2,4*t5+4),-24*t1+24*t2+8*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(8*t3,4*t5+4);t7<=min(8*t3+7,4*t5+Ny-5);t7++) { \n                lbv=max(512*t4,4*t5+4); \n                ubv=min(512*t4+511,4*t5+Nx-5); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((2.0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) - A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (roc2[ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] * (((((coef0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (coef1 *", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0; j<Ny; j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n  for(t=0; t<Nt; t++){ \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      }"}
{"label": "d dtfield(field *f, real *w, real *dtw) { \n  if(f->pre_dtfield!= NULL)  \n \n      f->pre_dtfield(f, w); \n \n  dtfield_pthread(f, w, dtw); \n \n  for(int iw = 0; iw < f->wsize; iw++) \n    dtw[iw] = 0; \n \n  bool facealgo = true; \n  if(facealgo) \n    for(int ifa = 0; ifa < f->macromesh.nbfaces; ifa++){ \n      DGMacroCellInterface((void*) (f->mface + ifa), f, w, dtw); \n    } \n \n  for(int ie = 0; ie < f->macromesh.nbelems; ++ie) { \n    MacroCell *mcelli = f->mcell + ie; \n    if(!facealgo) DGMacroCellInterfaceSlow(mcelli, f, w, dtw); \n    DGSubCellInterface(mcelli, f, w, dtw); \n    DGVolume(mcelli, f, w, dtw); \n    DGMass(mcelli, f, dtw); \n    DGSource(mcelli, f, w, dtw); \n  } \n} \n \n \n ", "pred": "d dtfield(field *f, real *w, real *dtw) { \n  if(f->pre_dtfield!= NULL)  \n \n      f->pre_dtfield(f, w); \n \n  dtfield_pthread(f, w, dtw); \n \n  for(int iw = 0; iw < f->wsize; iw++) \n    dtw[iw] = 0; \n \n  bool facealgo = true; \n  if(facealgo) \n    for(int ifa = 0; ifa < f->macromesh.nbfaces; ifa++){ \n      DGMacroCellInterface((void*) (f->mface + ifa), f, w, dtw); \n    } \n \n  for(int ie = 0; ie < f->macromesh.nbelems; ++ie) { \n    MacroCell *mcelli = f->mcell + ie; \n    if(!facealgo) DGMacroCellInterfaceSlow(mcelli, f, w, dtw); \n    DGSubCellInterface(mcelli, f, w, dtw); \n    DGVolume(mcelli, f, w, dtw); \n    DGMass(mcelli, f, dtw); \n  } \n \n  for(int ie = 0; ie < f->macromesh.nbelems; ++ie) { \n"}
{"label": " \nint main() \n{ \n  init_arrays(); \n \n  double annot_t_start=0, annot_t_end=0, annot_t_total=0; \n  int annot_i; \n \n  for (annot_i=0; annot_i<REPS; annot_i++) \n  { \n    annot_t_start = rtclock(); \n     \n    \n \nregister int i,j,k; \nregister int c1t, c2t, c3t, c4t, c5t, c6t, c7t, c8t, c9t, c10t, c11t, c12t; \nregister int newlb_c1, newlb_c2, newlb_c3, newlb_c4, newlb_c5, newlb_c6, \n  newlb_c7, newlb_c8, newlb_c9, newlb_c10, newlb_c11, newlb_c12; \nregister int newub_c1, newub_c2, newub_c3, newub_c4, newub_c5, newub_c6, \n  newub_c7, newub_c8, newub_c9, newub_c10, newub_c11, newub_c12; \n \n \n \n \n \n \n\tint c1, c2, c3, c4, c5, c6, c7, c8, c9; \n \n\tregister int lb, ub, lb1, ub1, lb2, ub2; \n \n \nfor (c1=-1;c1<=floord(3*N-5,128);c1++) { \n\tlb1=max(max(ceild(64*c1-N+2,64),ceild(32*c1-63,96)),0); \n\tub1=min(floord(64*c1+63,64),floord(N-1,128)); \n\tfor (c2=lb1; c2<=ub1; c2++) { \n    for (c3=max(ceild(32*c1-32*c2-1953,2016),ceild(32*c1-32*c2-31,32));c3<=floord(N-1,64);c3++) { \n      for (c4=max(max(0,2*c1-2*c2-64*c3-62),2*c1-2*c2);c4<=min(min(min(min(2*c1-2*c2+1,floord(992*c3+961,16)),floord(N-2,32)),floord(64*c2+63,16)),floord(32*c3+31,16));c4++) { \n        for (c5=max(max(ceild(16*c4-7,8),0),8*c2);c5<=min(8*c2+7,floord(N-1,16));c5++) { \n          for (c6=max(max(max(max(ceild(16*c4-465,496),ceild(2*c1-2*c2-2*c3-c4-31,31)),ceild(-2*c1+2*c2+2*c3+c4-31,33)),2*c3),ceild(16*c4-15,16));c6<=min(2*c3+1,floord(N-1,32));c6++) { \n            if ((c1 == c2+c3) && (c4 == c6)) { \n              for (c7=max(0,32*c6);c7<=min(min(32*c6+30,N-2),16*c5+14);c7++) { \n                for (c8=max(16*c5,c7+1);c8<=min(16*c5+15,N-1);c8++) { \n                  A[c7][c8]=A[c7][c8]/A[c7][c7] ; \n                  for (c9=c7+1;c9<=min(32*c6+31,N-1);c9++) { \n                    A[c9][c8]=A[c9][c8]-A[c9][c7]*A[c7][c8] ; \n                  } \n                } \n              } \n            } \n             \n \n{ \n  for (c7t=max(32*c4,0); c7t<=min(min(32*c6-1,16*c5+14),32*c4+31)-31; c7t=c7t+32) { \n    newlb_c8=-2147483648; \n    newub_c8=min(16*c5+15,N-1); \n    register int cbv_1; \n    cbv_1=c7t+31; \n    for (c7=c7t; c7<=cbv_1; c7=c7+1) { \n      newlb_c8=max(newlb_c8,max(c7+1,16*c5)); \n    } \n    for (c7=c7t; c7<=c7t+31; c7=c7+1) { \n      for (c8=max(c7+1,16*c5); c8<=newlb_c8-1; c8=c8+1) { \n        register int cbv_2, cbv_3; \n        cbv_2=32*c6; \n        cbv_3=min(N-1,32*c6+31); \n        for (c9=cbv_2; c9<=cbv_3; c9++ ) { \n          double scv_1; \n          scv_1=A[c9][c8]; \n          scv_1=scv_1-A[c9][c7]*A[c7][c8]; \n          A[c9][c8]=scv_1; \n        } \n      } \n    } \n    for (c8t=newlb_c8; c8t<=newub_c8-7; c8t=c8t+8) { \n      register int cbv_4, cbv_5; \n      cbv_4=32*c6; \n      cbv_5=min(N-1,32*c6+31); \n      for (c9=cbv_4; c9<=cbv_5; c9++ ) { \n        double scv_2, scv_3, scv_4, scv_5, scv_6, scv_7, scv_8, scv_9; \n        double scv_10, scv_11, scv_12, scv_13, scv_14, scv_15, scv_16, scv_17; \n        double scv_18, scv_19, scv_20, scv_21, scv_22, scv_23, scv_24, scv_25; \n        double scv_26, scv_27, scv_28, scv_29, scv_30, scv_31, scv_32, scv_33; \n        double scv_34, scv_35, scv_36, scv_37, scv", "pred": " \nint main() \n{ \n  init_arrays(); \n \n  double annot_t_start=0, annot_t_end=0, annot_t_total=0; \n  int annot_i; \n \n  for (annot_i=0; annot_i<REPS; annot_i++) \n  { \n    annot_t_start = rtclock(); \n     \n    \n \nregister int i,j,k; \nregister int c1t, c2t, c3t, c4t, c5t, c6t, c7t, c8t, c9t, c10t, c11t, c12t; \nregister int newlb_c1, newlb_c2, newlb_c3, newlb_c4, newlb_c5, newlb_c6, \n  newlb_c7, newlb_c8, newlb_c9, newlb_c10, newlb_c11, newlb_c12; \nregister int newub_c1, newub_c2, newub_c3, newub_c4, newub_c5, newub_c6, \n  newub_c7, newub_c8, newub_c9, newub_c10, newub_c11, newub_c12; \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "}
{"label": " \nvoid partials_undefined_and_undefined_codon_openmp( const SingleTreeLikelihood *tlk, const double *partials1, const double *matrices1, const double *partials2, const double *matrices2, double *partials3 ){ \n     \n\t \n\tconst int nstate = tlk->m->nstate; \n\tconst int extra = nstate - 60; \n\tint nThreads = tlk->nthreads; \n     \n    for ( int lk = 0; lk < tlk->pattern_count*tlk->cat_count; lk++ ) { \n        int l = lk / tlk->pattern_count; \n        int k = lk % tlk->pattern_count; \n         \n        int w = l * tlk->matrix_size; \n        int v = (l*tlk->pattern_count + k) * nstate; \n         \n        const double *m1 = matrices1 + w; \n        const double *m2 = matrices2 + w; \n         \n        double *pPartials = partials3 + v; \n         \n        double sum1, sum2; \n        const double *p1 = NULL; \n        const double *p2 = NULL; \n         \n        for ( int j = 0; j < nstate; j++ ) { \n             \n            p1 = partials1 + v; \n            p2 = partials2 + v; \n             \n            sum1   = *m1 * *p1; m1++; p1++; \n            sum2   = *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n             \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n             \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2 * *p2; m2++; p2++; \n            sum1  += *m1 * *p1; m1++; p1++; \n            sum2  += *m2", "pred": " \nvoid partials_undefined_and_undefined_codon_openmp( const SingleTreeLikelihood *tlk, const double *partials1, const double *matrices1, const double *partials2, const double *matrices2, double *partials3 ){ \n     \n\t \n\tconst int nstate = tlk->m->nstate; \n\tconst int extra = nstate - 60; \n\tint nThreads = tlk->nthreads; \n     \n    for ( int lk = 0; lk < tlk->pattern_count*tlk->cat_count; lk++ ) { \n        int l = lk / tlk->pattern_count; \n        int k = lk % tlk->pattern_count; \n         \n        int w = l * tlk->matrix_size; \n        int v = (l*tlk->pattern_count + k) * nstate; \n         \n        const double *m1 = matrices1 + w; \n        const double *m2 = matrices2 + w; \n         \n        double *p1 = partials1 + w; \n        double *p2 = partials2 + w; \n         \n        double *p3 = partials3 + w; \n         \n        double *p4 = partials3 + nstate*nstate; \n         \n        double *p5 = partials3 + nstate*nstate; \n         \n        double *p6 = partials3 + nstate*nstate; \n         \n        double *p7 = partials3 + nstate*nstate; \n         \n        double *p8 = partials3 + nstate*nstate; \n         \n        double *p9 = partials3 + nstate*nstate; \n         \n        double *p10 = partials3 + nstate*nstate; \n         \n        double *p11 = partials3 + nstate*nstate; \n         \n        double *p12 = partials3 + nstate*nstate; \n         \n        double *p13 = partials3 + nstate*nstate; \n         \n        double *p14 = partials3 + nstate*nstate; \n         \n        double *p15 = partials3 + nstate*nstate; \n         \n        double *p16 = partials3 + nstate*nstate; \n         \n        double *p17 = partials3 + nstate*nstate; \n         \n        double *p18 = partials3 + nstate*nstate; \n         \n        double *p19 = partials3 + nstate*nstate; \n         \n        double *p20 = partials3 + nstate*nstate; \n         \n        double *p21 = partials3 + nstate*nstate; \n         \n        double *p22 = partials3 + nstate*nstate; \n         \n        double *p23 = partials3 + nstate*nstate; \n         \n        double *p24 = partials3 + nstate*nstate; \n         \n        double *p25 = partials3 + nstate*nstate; \n         \n        double *p26 = partials3 + nstate*nstate; \n         \n        double *p27 = partials3 + nstate*nstate; \n         \n        double *p28 = partials3 + nstate*nstate; \n         \n        double *p29 = partials3 + nstate*nstate; \n         \n        double *p30 = partials3 + nstate*nstate; \n         \n        double *p31 = partials3 + nstate*nstate; \n         \n        double *p32 = partials3 + nstate*nstate; \n         \n        double *p33 = partials3 + nstate*nstate; \n         \n        double *p34 = partials3 + nstate*nstate; \n         \n        double *p35 = partials3 + nstate*nstate; \n         \n        double *p36 = partials3 + nstate*nstate; \n         \n        double *p37 = partials3 + nstate*nstate; \n         \n        double *p38 = partials3 + nstate*nstate; \n         \n        double *p39 = partials3 + nstate*nstate; \n         \n        double *p40 = partials3 + nstate*nstate; \n         \n        double *p41 = partials3 + nstate*nstate; \n         \n        double *p42 = partials3 + nstate*nstate; \n         \n        double *p43 = partials3 + nstate*nstate; \n         \n        double *p44 = partials3 + nstate*nstate; \n         \n        double *p45 = partials3 + nstate*nstate; \n         \n        double *p46 = partials3 + nstate*nstate; \n         \n        double *p47 = partials3 + nstate*nstate; \n         \n        double *p48 = partials3 + nstate*nstate; \n         \n        double *p49 = partials3 + nstate*nstate; \n         \n        double *p50 = partials3 + nstate*nstate; \n         \n        double *p51 = partials3 + nstate*nstate; \n         \n        double *p52 = partials3 + nstate*nstate; \n         \n        double *p53 = partials3 + nstate*nstate; \n         \n        double *p54 = partials3 + nstate*nstate; \n         \n        double *p55 = partials3 + nstate*nstate; \n         \n        double *p56 = partials"}
{"label": " \nvoid recombine2d_es1_omp(struct recombine2d_worker *worker, \n                         int subgrid_off1, \n                         complex double *BF, \n                         double complex *NMBF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n    int x; \n \n     \n \n    assert(subgrid_off1 % cfg->subgrid_spacing == 0); \n    int subgrid_offset = subgrid_off1 / cfg->subgrid_spacing * cfg->yP_spacing;; \n    double start = get_time_ns(); \n    for (x = 0; x < cfg->yB_size; x++) { \n        extract_subgrid(cfg->yP_size, cfg->xM_yP_size, cfg->xMxN_yP_size, cfg->xM_yN_size, \n                        subgrid_offset, cfg->m, cfg->Fn, \n                        BF+x*cfg->BF_stride0, cfg->BF_stride1, \n                        worker->MBF, worker->MBF_plan, \n                        NMBF+x*cfg->NMBF_stride0, cfg->NMBF_stride1); \n    } \n    worker->es1_time += get_time_ns() - start; \n \n} ", "pred": " \nvoid recombine2d_es1_omp(struct recombine2d_worker *worker, \n                         int subgrid_off1, \n                         complex double *BF, \n                         double complex *NMBF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n    int x; \n \n     \n \n    assert(subgrid_off1 % cfg->subgrid_spacing == 0); \n    int subgrid_offset = subgrid_off1 / cfg->subgrid_spacing * cfg->yP_spacing;; \n    double start = get_time_ns(); \n    for (x = 0; x < cfg->yB_size; x++) { \n        extract_subgrid(cfg->yP_size, cfg->xM_yP_size, cfg->xMxN_yP_size, cfg->xM_yN_size, \n                        cfg->yP_size, cfg->xM_yN_size, cfg->xMxN_yN_size, \n                        cfg->yP_size, cfg->xM_yN_size, cfg->xMxN_yN_size, \n                        cfg->yP_size, cfg->xM_yN_size, cfg->xMxN_yN_size, \n                        cfg->yP_size, cfg->xM_yN_size,"}
{"label": " \nvoid Pyuv422torgbstack(unsigned char *input_ptr, int *outR, int *outG, int *outB, unsigned int width, \n                       unsigned int height, const int upsideDown) { \n    unsigned int i; \n    const int size = width * height; \n    for (i = 0; i < size / 2; i++) { \n        unsigned char *b = input_ptr + i * 4; \n        unsigned char Y = b[0]; \n        unsigned char U = b[1]; \n        unsigned char Y1 = b[2]; \n        unsigned char V = b[3]; \n \n        if (upsideDown) { \n            int *R = outR + (size - 1) - i * 2; \n            int *G = outG + (size - 1) - i * 2; \n            int *B = outB + (size - 1) - i * 2; \n \n            *R-- += R_FROMYV(Y, V); \n            *G-- += G_FROMYUV(Y, U, V);  \n \n            *B-- += B_FROMYU(Y, U);  \n \n \n            *R += R_FROMYV(Y1, V); \n            *G += G_FROMYUV(Y1, U, V);  \n \n            *B += B_FROMYU(Y1, U);  \n \n        } else { \n            int *R = outR + i * 2; \n            int *G = outG + i * 2; \n            int *B = outB + i * 2; \n \n            *R++ += R_FROMYV(Y, V); \n            *G++ += G_FROMYUV(Y, U, V);  \n \n            *B++ += B_FROMYU(Y, U);  \n \n \n            *R += R_FROMYV(Y1, V); \n            *G += G_FROMYUV(Y1, U, V);  \n \n            *B += B_FROMYU(Y1, U);  \n \n        } \n    } \n} ", "pred": " \nvoid Pyuv422torgbstack(unsigned char *input_ptr, int *outR, int *outG, int *outB, unsigned int width, \n                       unsigned int height, const int upsideDown) { \n    unsigned int i; \n    const int size = width * height; \n    for (i = 0; i < size / 2; i++) { \n        unsigned char *b = input_ptr + i * 4; \n        unsigned char Y = b[0]; \n        unsigned char U = b[1]; \n        unsigned char Y1 = b[2]; \n        unsigned char V = b[3]; \n \n        if (upsideDown) { \n            int *R = outR + (size - 1) - i * 2; \n            int *G = outG + (size - 1) - i * 2; \n            int *B = outB + (size - 1) - i * 2; \n            R[0] = Y; \n            G[0] = U; \n            B[0] = Y1; \n            R[1] = V; \n            G[1] = U; \n            B[1] = V; \n        } else { \n            int *R = outR + i * 2; \n            int *G = outG + i * 2; \n            int *B = outB + i * 2; \n            R[0] = Y; \n            G[0] = U; \n            B[0] = Y1; \n            R[1] = V; \n            G[1] = U; \n            B[1] = V; \n        } \n    } \n    return; \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"label": " \nvoid partials_states_and_states_codon_openmp( const SingleTreeLikelihood *tlk, int idx1, const double *matrices1, int idx2, const double *matrices2, double *partials ){ \n\t \n\t \n\tconst int nstate = tlk->m->nstate; \n\tconst int extra = nstate - 60; \n\tint nThreads = tlk->nthreads; \n     \n    for ( int lk = 0; lk < tlk->pattern_count*tlk->cat_count; lk++ ) { \n        int l = lk / tlk->pattern_count; \n        int k = lk % tlk->pattern_count; \n         \n        int state1 = tlk->sp->patterns[idx1][k]; \n        int state2 = tlk->sp->patterns[idx2][k]; \n         \n        int w = l * tlk->matrix_size; \n         \n        double *pPartials = partials + (l*tlk->pattern_count + k)*nstate; \n         \n        if (state1 < nstate && state2 < nstate) { \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n             \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n             \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n             \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n             \n            *pPartials++ = matrices1[w + state1] * matrices2[w + state2]; w += nstate; \n            *pPartials++ = matrices1[w + state1", "pred": " \nvoid partials_states_and_states_codon_openmp( const SingleTreeLikelihood *tlk, int idx1, const double *matrices1, int idx2, const double *matrices2, double *partials ){ \n\t \n\t \n\tconst int nstate = tlk->m->nstate; \n\tconst int extra = nstate - 60; \n\tint nThreads = tlk->nthreads; \n     \n    for ( int lk = 0; lk < tlk->pattern_count*tlk->cat_count; lk++ ) { \n        int l = lk / tlk->pattern_count; \n        int k = lk % tlk->pattern_count; \n         \n        int state1 = tlk->sp->patterns[idx1][k]; \n        int state2 = tlk->sp->patterns[idx2][k]; \n         \n        int w = l * tlk->matrix_size; \n         \n        double *pPartials = partials + (l*tlk->pattern_count + k)*nstate; \n         \n        for ( int i = 0; i < nstate; i++ ) { \n            double *p = pPartials + i*w; \n            double *p1 = matrices1 + i*nstate; \n            double *p2 = matrices2 + i*nstate; \n             \n            for ( int j = 0; j < nstate; j++ ) { \n                p[j] = p1[j] + p2[j]; \n            } \n        } \n    } \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n "}
{"label": " \nvoid process (struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, void *ivoid, void *ovoid, const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out) \n{ \n  dt_iop_lowpass_data_t *data = (dt_iop_lowpass_data_t *)piece->data; \n  float *in  = (float *)ivoid; \n  float *out = (float *)ovoid; \n  const int ch = piece->colors; \n  float a0, a1, a2, a3, b1, b2, coefp, coefn; \n \n  const float Labmax[] = { 100.0f, 128.0f, 128.0f, 1.0f }; \n  const float Labmin[] = { 0.0f, -128.0f, -128.0f, 0.0f }; \n \n  const float radius = fmax(0.1f, data->radius); \n  const float sigma = radius * roi_in->scale / piece ->iscale; \n \n   \n \n  compute_gauss_params(sigma, data->order, &a0, &a1, &a2, &a3, &b1, &b2, &coefp, &coefn); \n \n  float *temp = dt_alloc_align(64, roi_out->width*roi_out->height*ch*sizeof(float)); \n  if(temp==NULL) return; \n \n   \n \n  for(int i=0; i<roi_out->width; i++) \n  { \n    float xp[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yb[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yp[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float xc[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yc[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float xn[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float xa[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yn[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float ya[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n \n     \n \n    for(int k=0; k<4; k++) \n    { \n      xp[k] = CLAMPF(in[i*ch+k], Labmin[k], Labmax[k]); \n      yb[k] = xp[k] * coefp; \n      yp[k] = yb[k]; \n    } \n  \n    for(int j=0; j<roi_out->height; j++) \n    { \n      int offset = (i + j * roi_out->width)*ch; \n \n      for(int k=0; k<4; k++) \n      { \n        xc[k] = CLAMPF(in[offset+k], Labmin[k], Labmax[k]); \n        yc[k] = (a0 * xc[k]) + (a1 * xp[k]) - (b1 * yp[k]) - (b2 * yb[k]); \n \n        temp[offset+k] = yc[k]; \n \n        xp[k] = xc[k]; \n        yb[k] = yp[k]; \n        yp[k] = yc[k]; \n      } \n    } \n \n     \n \n    for(int k=0; k<4; k++) \n    { \n      xn[k] = CLAMPF(in[((roi_out->height - 1) * roi_out->width + i)*ch+k], Labmin[k], Labmax[k]); \n      xa[k] = xn[k]; \n      yn[k] = xn[k] * coefn; \n      ya[k] = yn[k]; \n    } \n \n    for(int j=roi_out->height - 1; j > -1; j--) \n    { \n      int offset = (i + j * roi_out->width)*ch; \n \n      for(int k=0; k<4; k++) \n      {       \n        xc[k] = CLAMPF(in[offset+k], Labmin[k], Labmax[k]); \n \n        yc[k] = (a2 * xn[k]) + (a3 * xa[k]) - (b1 * yn[k]) - (b2 * ya[k]); \n \n        xa[k] = xn[k];  \n        xn[k] = xc[k];  \n        ya[k] = yn[k];  \n        yn[k] = yc[k]; \n \n        temp[offset+k] += yc[k]; \n      } \n    } \n  } \n \n   \n \n  for(int j=0; j<roi_out->height; j++) \n  { \n    float xp[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yb[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yp[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float xc[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yc[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float xn[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float xa[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float yn[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n    float ya[4] = {0.0f, 0.0f, 0.0f, 0.0f}; \n \n     \n \n    for(int k=0; k<4; k++) \n    { \n      xp[k] = CLAMPF(temp[j*roi_out->width*ch+k], Labmin[k], Labmax[k]); \n      yb[k] = xp[k] * coefp; \n      yp[k] = yb[k]; \n    } \n  \n    for(int i=0; i<roi_out->width; i++) \n    { \n      int offset = (i + j * roi_out->width)*ch; \n \n      for(int k=0; k<4; k++) \n      { \n        xc[k] = CLAMPF(temp[offset+k], Labmin[k], Labmax[k]); \n        yc[k] = (a0 * xc[k]) + (a1 * xp[k]) - (b1 * yp[k]) - (b2 * yb[k]); \n \n        out[offset+k] = yc[k]; \n \n        xp[k] = xc[k]; \n     ", "pred": " \nvoid process (struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, void *ivoid, void *ovoid, const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out) \n{ \n  dt_iop_lowpass_data_t *data = (dt_iop_lowpass_data_t *)piece->data; \n  float *in  = (float *)ivoid; \n  float *out = (float *)ovoid; \n  const int ch = piece->colors; \n  float a0, a1, a2, a3, b1, b2, coefp, coefn; \n \n  const float Labmax[] = { 100.0f, 128.0f, 128.0f, 1.0f }; \n  const float Labmin[] = { 0.0f, -128.0f, -128.0f, 0.0f }; \n \n  const float radius = fmax(0.1f, data->radius); \n  const float sigma = radius * roi_in->scale / piece ->iscale; \n \n   \n \n  compute_gauss_params(sigma, data->order, &a0, &a1, &a2, &a3, &b1, &b2, &coefp, &coefn); \n  \n  for(int i = 0; i < ch; i++) \n    { \n      float gauss = 0.0f; \n      for(int j = 0; j < ch; j++) \n        { \n          gauss += Labmax[j] * (in[i] - Labmin[j]) * (in[i] - Labmin[j]); \n        } \n      gauss = gauss / (ch * ch); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0f / (ch * ch)); \n      gauss = gauss * (1.0"}
{"label": " \nvoid VMatrixProjection(gsl_matrix_float *X,float *ev,int type,int seed) \n{ \n  size_t i,j; \n  size_t nvox = X->size1; \n  size_t nt = X->size2; \n  size_t p = 32; \n \n  fprintf(stderr,\" VMatrixProjection...\\n\"); \n   \n   \n \n  const gsl_rng_type *Tx = gsl_rng_default; \n  gsl_rng *rx = gsl_rng_alloc (Tx); \n  gsl_rng_set(rx,(unsigned long int)seed); \n  gsl_matrix *R = gsl_matrix_calloc(nvox,p); \n  for (i=0; i<nvox; i++) { \n    for (j=0; j<p; j++) { \n      gsl_matrix_set(R,i,j,gsl_ran_ugaussian(rx)); \n    } \n  } \n \n   \n \n  gsl_matrix *Y = gsl_matrix_calloc(nvox,p); \n  size_t progress=0; \n  size_t step=4;   \n \n  fprintf(stderr,\" pass 1:\\n\"); \n \n \n  for (i=0; i<nvox; i++) { \n    if (i%1000 == 0) fprintf(stderr,\" %d000  of  %lu\\r\",(int)(++progress),nvox); \n     \n    size_t j=0,k=0; \n    double *tmp1 = (double *)VCalloc(nvox,sizeof(double)); \n    double *tmp2 = NULL; \n    double sum=0; \n    const float *arr1 = gsl_matrix_float_const_ptr(X,i,0); \n \n    for (j=0; j<nvox; j++) { \n      const float *arr2 = gsl_matrix_float_const_ptr(X,j,0); \n      tmp1[j] = ECMcorrelation(arr1,arr2,nt,type); \n    } \n \n    for (j=0; j<p; j++) { \n      tmp2 = gsl_matrix_ptr(R,j,0); \n      sum=0; \n      for (k=0; k<nvox; k+=step) { \n\tsum += tmp1[k]*tmp2[k]; \n      } \n      gsl_matrix_set(Y,i,j,sum); \n    } \n    VFree(tmp1); \n  } \n  fprintf(stderr,\"\\n\"); \n  gsl_matrix_free(R); \n   \n  \n   \n \n  gsl_vector *sv = gsl_vector_calloc(p); \n  gsl_vector *work = gsl_vector_calloc(p); \n  gsl_matrix *V = gsl_matrix_calloc(p,p); \n  gsl_linalg_SV_decomp(Y,V,sv,work); \n \n \n   \n \n  fprintf(stderr,\" pass 2:\\n\"); \n  gsl_matrix *D = gsl_matrix_calloc(nvox,p); \n  progress=0; \n \n  for (i=0; i<nvox; i++) { \n    if (i%1000 == 0) fprintf(stderr,\" %d000  of  %lu\\r\",(int)(++progress),nvox); \n \n    size_t j=0,k=0; \n    double *tmp1 = (double *)VCalloc(nvox,sizeof(double)); \n    double sum=0; \n    const float *arr1 = gsl_matrix_float_const_ptr(X,i,0); \n \n    for (j=0; j<nvox; j++) { \n      const float *arr2 = gsl_matrix_float_const_ptr(X,j,0); \n      tmp1[j] = ECMcorrelation(arr1,arr2,nt,type); \n    } \n \n    for (j=0; j<p; j++) { \n      sum=0;       \n      for (k=0; k<nvox; k+=step) { \n\tsum += tmp1[k] * gsl_matrix_get(Y,k,j); \n      } \n      gsl_matrix_set(D,i,j,sum); \n    } \n    VFree(tmp1); \n  } \n  fprintf(stderr,\"\\n\"); \n  gsl_matrix_free(Y); \n \n   \n   \n \n  gsl_linalg_SV_decomp(D,V,sv,work); \n \n   \n   \n \n  size_t k=0; \n  for (i=0; i<nvox; i++) { \n    ev[i] = gsl_matrix_get(D,i,0); \n    if (ev[i] < 0) k++; \n  } \n \n   \n \n  if (k > nvox/2) { \n    for (i=0; i<nvox; i++) { \n      ev[i] = -ev[i]; \n    } \n  } \n \n   \n \n  NormVec(ev,nvox); \n  float kx = sqrt((float)(nvox)); \n  for (i=0; i<nvox; i++)  ev[i] *= kx; \n} ", "pred": " \nvoid VMatrixProjection(gsl_matrix_float *X,float *ev,int type,int seed) \n{ \n  size_t i,j; \n  size_t nvox = X->size1; \n  size_t nt = X->size2; \n  size_t p = 32; \n \n  fprintf(stderr,\" VMatrixProjection...\\n\"); \n   \n   \n \n  const gsl_rng_type *Tx = gsl_rng_default; \n  gsl_rng *rx = gsl_rng_alloc (Tx); \n  gsl_rng_set(rx,(unsigned long int)seed); \n  gsl_matrix *R = gsl_matrix_calloc(nvox,p); \n  for (i=0; i<nvox; i++) { \n    for (j=0; j<p; j++) { \n      gsl_matrix_set(R,i,j,gsl_ran_ugaussian(rx)); \n    } \n  } \n \n   \n \n  gsl_matrix *Y = gsl_matrix_calloc(nvox,p); \n  size_t progress=0; \n  size_t step=4;   \n \n  fprintf(stderr,\" pass 1:\\n\"); \n \n \n  for (i=0; i<nvox; i++) { \n    for (j=0; j<p; j++) { \n      gsl_matrix_set(Y,i,j,gsl_matrix_float_get(X,i,j)); \n    } \n  } \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, Y, 0.0, Y, 0.0, 1.0, Y); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, R, 0.0, R, 0.0, 1.0, R); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, X, 0.0, X, 0.0, 1.0, X); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, Y, 0.0, Y, 0.0, 1.0, Y); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, R, 0.0, R, 0.0, 1.0, R); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, X, 0.0, X, 0.0, 1.0, X); \n \n  gsl_matrix_memcpy(X,Y); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, R, 0.0, R, 0.0, 1.0, R); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, X, 0.0, X, 0.0, 1.0, X); \n \n  gsl_matrix_memcpy(X,R); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, Y, 0.0, Y, 0.0, 1.0, Y); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, X, 0.0, X, 0.0, 1.0, X); \n \n  gsl_matrix_memcpy(X,Y); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, Y, 0.0, Y, 0.0, 1.0, Y); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, X, 0.0, X, 0.0, 1.0, X); \n \n  gsl_matrix_memcpy(X,R); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, Y, 0.0, Y, 0.0, 1.0, Y); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, X, 0.0, X, 0.0, 1.0, X); \n \n  gsl_matrix_memcpy(X,Y); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, Y, 0.0, Y, 0.0, 1.0, Y); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, X, 0.0, X, 0.0, 1.0, X); \n \n  gsl_matrix_memcpy(X,R); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, Y, 0.0, Y, 0.0, 1.0, Y); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, X, 0.0, X, 0.0, 1.0, X); \n \n  gsl_matrix_memcpy(X,Y); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, Y, 0.0, Y, 0.0, 1.0, Y); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, X, 0.0, X, 0.0, 1.0, X); \n \n  gsl_matrix_memcpy(X,R); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, Y, 0.0, Y, 0.0, 1.0, Y); \n \n  gsl_blas_dgemv(CblasNoTrans, 1.0, X, 0.0, X, 0.0, 1.0, X); \n \n  gsl_matrix_memcpy(X,Y); \n \n  gsl_blas_dgemv(Cblas"}
{"label": "\tFILE *fp_ref; \n\tFILE *fp_read; \n\tFILE *fp_result; \n\tFILE *fp_result_info; \n \n\tint64_t ref_total_size; \n\tint ref_len; \n\tint ref_bucket_num; \n\tint ref_bucket_count; \n\tint ref_bucket_index = 0; \n \n\tint64_t read_total_size = 0; \n\tint64_t read_total_count = 0; \n\tint read_len; \n\tint read_bucket_num = 0; \n\tint read_bucket_count = 0; \n\tint read_bucket_index = 0; \n\tint64_t read_actual_size = 0; \n \n\tint64_t preprocess_read_size; \n\tint64_t align_result_size; \n\tint64_t offload_read_size; \n\tint64_t offload_result_size; \n \n\tint word_num; \n\tint chunk_read_num; \n\tint offload_dvdh_size; \n\tint ref_start; \n\tint ref_end; \n \n\tint64_t *result_bucket_counts; \n\tint64_t *sse_result_bucket_counts; \n \n\tmic_read_t *read_ptr; \n\tmic_write_t *result_ptr; \n\tint64_t read_ptr_offset; \n\tint64_t result_ptr_offset; \n\tint64_t single_read_size; \n\tint64_t single_result_size; \n\tint64_t single_read_count; \n\tint64_t single_result_count; \n\tint64_t total_result_count = 0; \n \n\tmic_cal_t *mic_args; \n\tmic_cal_t *tmp_cal_arg; \n \n\tint sse_word_num; \n\tint sse_chunk_read_num; \n\tint sse_dvdh_size; \n\tint64_t sse_preprocess_read_size; \n\tint64_t sse_align_result_size; \n\tint64_t sse_result_total_count; \n \n\tsse_cal_t sse_arg; \n\tsse_cal_t *tmp_sse_arg; \n \n \n\tdouble *device_compute_ratio; \n\tint64_t *device_read_counts_a; \n\tint64_t *device_read_counts_b; \n\tint64_t *device_read_counts; \n \n\tthread_info input_info; \n\tthread_info output_info; \n\tthread_info cal_input_info; \n\tthread_info cal_output_info; \n\tthread_arg input_arg; \n\tthread_arg output_arg; \n \n\tdouble total_start, total_end; \n\tdouble read_start, read_end; \n\tdouble cal_start, cal_end; \n\tdouble offload_start, offload_end; \n\tdouble write_start, write_end; \n\tdouble process_start, process_end; \n\tdouble mem_start, mem_end; \n\tdouble mem_time, mem_num; \n \n\tGET_TIME(total_start); \n\tread_total_time = 0; \n\twrite_total_time = 0; \n\tmem_total_time = 0; \n \n \n\tint total_device_number; \n\tint mic_device_number = mic_number; \n\tint cpu_device_number = 1; \n\t \n \n\ttotal_device_number = mic_device_number + cpu_device_number; \n \n\tdevice_compute_ratio = (double *) malloc_mem(sizeof(double) * total_device_number); \n\tdevice_read_counts_a = (int64_t *) malloc_mem(sizeof(int64_t) * total_device_number); \n\tdevice_read_counts_b = (int64_t *) malloc_mem(sizeof(int64_t) * total_device_number); \n \n\tif (file_ratio == NULL) { \n\t\tinit_cpu_mic_ratio(device_compute_ratio, cpu_device_number, mic_device_number); \n\t} else { \n\t\tinit_device_ratio_file(device_compute_ratio, cpu_device_number, mic_device_number, file_ratio); \n\t} \n\tuse_times = (double **) malloc_mem(sizeof(double *) * total_device_number); \n \n \n\tup_signal_a = (char *) malloc_mem(sizeof(char) * mic_device_number); \n\tup_signal_b = (char *) malloc_mem(sizeof(char) * mic_device_number); \n\tdown_signal_a = (char *) malloc_mem(sizeof(char) * mic_device_number); \n\tdown_signal_b = (char *) malloc_mem(sizeof(char) * mic_device_number); \n \n\tdouble cal_total_times[total_device_number]; \n\tdouble offload_total_times[total_device_number]; \n\tdouble previous_device_times[total_device_number]; \n \n\tfor (i = 0; i < total_device_number; i++) { \n\t\tcal_total_times[i] = 0; \n\t\toffload_total_times[i] = 0; \n\t} \n\tomp_set_nested(1); \n \n\tinit_mapping_table(); \n\tinit_device(mic_device_number); \n\tmic_args = (mic_cal_t *) malloc_mem(sizeof(mic_cal_t) * mic_device_number); \n \n\tcreate_folder(\"data\", 0755); \n\tfp_ref = open_file(file_query, \"rb\"); \n\tfp_read = open_file(file_database, \"rb\"); \n\tfp_result = open_file(file_result, \"wb+\"); \n\tfp_result_info = open_file(file_result_info, \"wb+\"); \n \n\t \n \n\tref_total_size = get_filesize(file_query); \n\tref_seq.content = (char *) malloc_mem(sizeof(char) * (ref_total_size + 1)); \n\tget_ref_from_file(&ref_seq, fp_ref, ref_total_size); \n\tref_len = ref_seq.len; \n \n\tif (ref_seq.count > REF_BUCKET_COUNT) { \n\t\tref_bucket_num = (ref_seq.count + REF_BUCKET_COUNT - 1) / REF_BUCKET_COUNT; \n\t\tref_bucket_count = REF_BUCKET_COUNT; \n\t} else { \n\t\tref_bucket_num = 1; \n\t\tref_bucket_count = ref_seq.count; \n\t} \n \n\tglobal_ref_bucket_num = ref_bucket_num; \n \n\tread_total_size = get_filesize(file_database); \n\tif (read_total_size > READ_BUCKET_SIZE) { \n\t\tread_seq_a.content = (char *) malloc_mem(sizeof(char) * (READ_BUCKET_SIZE + 1)); \n\t\tread_seq_b.content = (char *) malloc_mem(sizeof(char) * (READ_BUCKET_SIZE + 1)); \n\t\tread_actual_size = READ_BUCKET_SIZE; \n\t} else { \n\t\tread_seq_a.content = (char *) malloc_mem(sizeof(char) * (read_total_size * 2)); \n\t\tread_seq_b.content = (char *) malloc_mem(sizeof(char) * (read_total_size * 2)); \n\t\tread_actual_size = read_total_size; \n\t\tread_bucket_num = 1; \n\t} \n \n\tGET_TIME(read_start); \n\tget_read_from_file(&read_seq_a, fp_read, read_actual_size, read_total_size); \n\tdispatch_task(device_compute_ratio, device_read_counts_a, read_seq_a.count, total_device_number); \n\tGET_TIME(read_end); \n\tread_total_time += read_end - read_start; \n \n\tread_len = read_seq_a.len; \n\tread_bucket_count = read_seq_a.count; \n\tread_actual_size = read_seq_a.size; \n\tread_total_count = (read_total_size + 1) / (read_len + 1); \n \n\tif (read_total_size > READ_BUCKET_SIZE) { \n\t\tread_bucket_num = (read_total_size + read_actual_size - 2) / read_actual_size; \n\t} \n \n\tfwrite(&read_bucket_num, sizeof(int), 1, fp_result_info); \n\tfwrite(&total_device", "pred": "\tFILE *fp_ref; \n\tFILE *fp_read; \n\tFILE *fp_result; \n\tFILE *fp_result_info; \n \n\tint64_t ref_total_size; \n\tint ref_len; \n\tint ref_bucket_num; \n\tint ref_bucket_count; \n\tint ref_bucket_index = 0; \n \n\tint64_t read_total_size = 0; \n\tint64_t read_total_count = 0; \n\tint read_len; \n\tint read_bucket_num = 0; \n\tint read_bucket_count = 0; \n\tint read_bucket_index = 0; \n\tint64_t read_actual_size = 0; \n \n\tint64_t preprocess_read_size; \n\tint64_t align_result_size; \n\tint64_t offload_read_size; \n\tint64_t offload_result_size; \n \n\tint word_num; \n\tint chunk_read_num; \n\tint offload_dvdh_size; \n\tint ref_start; \n\tint ref_end; \n \n\tint64_t *result_bucket_counts; \n\tint64_t *sse_result_bucket_counts; \n \n\tmic_read_t *read_ptr; \n\tmic_result_t *result_ptr; \n \n\tint64_t *read_ptr_count; \n\tint64_t *result_ptr_count; \n \n\tint64_t *read_ptr_index; \n\tint64_t *result_ptr_index; \n \n\tint64_t *read_ptr_index_end; \n\tint64_t *result_ptr_index_end; \n \n\tint64_t *read_ptr_index_start; \n\tint64_t *result_ptr_index_start; \n \n\tint64_t *read_ptr_index_start_end; \n\tint64_t *result_ptr_index_start_end; \n \n\tint64_t *read_ptr_index_start_start; \n\tint64_t *result_ptr_index_start_start; \n \n\tint64_t *read_ptr_index_start_start_end; \n\tint64_t *result_ptr_index_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start; \n\tint64_t *result_ptr_index_start_start_start; \n \n\tint64_t *read_ptr_index_start_start_start_end; \n\tint64_t *result_ptr_index_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start; \n \n\tint64_t *read_ptr_index_start_start_start_start_end; \n\tint64_t *result_ptr_index_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start_start; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_end; \n\tint64_t *result_ptr_index_start_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start_start_start; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_end; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_start; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start_end; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_start_start; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start_start_end; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start_start_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_start_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start_start_start_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_start_start_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start_start_start_start_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_start_start_start_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start; \n\tint64_t *result_ptr_index_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_end; \n \n\tint64_t *read_ptr_index_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start; \n"}
{"label": " \nvoid recombine2d_pf0_ft0_omp(struct recombine2d_worker *worker, \n                             double complex *NMBF, \n                             double complex *NMBF_BF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n \n    assert(cfg->BF_stride1 == 1); \n    assert(cfg->NMBF_BF_stride0 = 1); \n    assert(cfg->BF_stride0 == cfg->NMBF_BF_stride1); \n \n    int y; \n    for (y = 0; y < cfg->xM_yN_size; y+=worker->BF_batch) { \n \n         \n \n        double start = get_time_ns(); \n        int y2; \n        for (y2 = y; y2 < y+worker->BF_batch && y2 < cfg->xM_yN_size; y2++) { \n            prepare_facet(cfg->yB_size, cfg->yP_size, cfg->Fb, \n                          NMBF+y2*cfg->NMBF_stride1, cfg->NMBF_stride0, \n                          NMBF_BF+y2*cfg->NMBF_BF_stride1, cfg->NMBF_BF_stride0); \n        } \n        worker->pf2_time += get_time_ns() - start; \n \n         \n \n \n         \n \n         \n \n         \n \n \n         \n \n         \n \n         \n \n        start = get_time_ns(); \n        fftw_plan plan = worker->BF_plan; \n        if (y+worker->BF_batch >= cfg->xM_yN_size) { \n            plan = recombine2d_bf_plan(worker->cfg, cfg->xM_yN_size - y, \n                                       NMBF_BF+y*cfg->NMBF_BF_stride1, \n                                       FFTW_ESTIMATE); \n        } \n        fftw_execute_dft(plan, \n                         NMBF_BF+y*cfg->NMBF_BF_stride1, \n                         NMBF_BF+y*cfg->NMBF_BF_stride1); \n        if (plan!= worker->BF_plan) \n            fftw_free(plan); \n        worker->ft2_time += get_time_ns() - start; \n \n    } \n} ", "pred": " \nvoid recombine2d_pf0_ft0_omp(struct recombine2d_worker *worker, \n                             double complex *NMBF, \n                             double complex *NMBF_BF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n \n    assert(cfg->BF_stride1 == 1); \n    assert(cfg->NMBF_BF_stride0 = 1); \n    assert(cfg->BF_stride0 == cfg->NMBF_BF_stride1); \n \n    int y; \n    for (y = 0; y < cfg->xM_yN_size; y+=worker->BF_batch) { \n \n         \n \n        double start = get_time_ns(); \n        int y2; \n        for (y2 = y; y2 < y+worker->BF_batch && y2 < cfg->xM_yN_size; y2++) { \n            int x; \n            for (x = 0; x < cfg->xM_xN_size; x+=worker->BF_batch) { \n                int x2; \n                for (x2 = x; x2 < x+worker->BF_batch && x2 < cfg->xM_xN_size; x2++) { \n                    int y2_start = get_time_ns(); \n                    recombine2d_pf0_ft0_omp_inner(worker, NMBF, NMBF_BF, \n                                                  cfg, x, y, x2, y2); \n                    double time_inner = get_time_ns() - y2_start; \n                    if (cfg->verbose) { \n                        printf(\"inner: %d, time: %f\\n\", x, time_inner); \n                    } \n                } \n            } \n        } \n    } \n    double time_inner = get_time_ns() - start; \n    if (cfg->verbose) { \n        printf(\"inner: %d, time: %f\\n\", cfg->xM_xN_size, time_inner); \n    } \n    \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"label": " \ndouble Matrix_Multiplication_Static(double **Matrix_A,double **Matrix_B,double **Result,int N_size,int Total_threads) \n{ \n\tint\ti,j,k; \n\tstruct timeval  TimeValue_Start; \n\tstruct timezone TimeZone_Start; \n \n\tstruct timeval  TimeValue_Final; \n\tstruct timezone TimeZone_Final; \n\tlong            time_start, time_end; \n\tdouble          time_overhead; \n\t \n\tgettimeofday(&TimeValue_Start, &TimeZone_Start); \n\t \n         \n \n\tomp_set_num_threads(Total_threads); \n\t \n\t \n\t \n\tfor (i = 0; i < N_size; i = i + 1){ \n\t\tfor (j = 0; j < N_size; j = j + 1){ \n\t\t\tResult[i][j]=0.0; \n\t\t\tfor (k = 0; k < N_size; k = k + 1) \n\t\t\t\tResult[i][j] = Result[i][j] + Matrix_A[i][k] * Matrix_B[k][j]; \n\t\t} \n\t} \n \n \n\t gettimeofday(&TimeValue_Final, &TimeZone_Final); \n \n         \n \n\ttime_start = TimeValue_Start.tv_sec * 1000000 + TimeValue_Start.tv_usec; \n\ttime_end = TimeValue_Final.tv_sec * 1000000 + TimeValue_Final.tv_usec; \n\ttime_overhead = (time_end - time_start)/1000000.0; \n \n        printf(\"\\n\\t\\t Matrix into Matrix Multiplication using one Parallel for pragma with static option......Done \\n\"); \n\treturn time_overhead; \n} ", "pred": " \ndouble Matrix_Multiplication_Static(double **Matrix_A,double **Matrix_B,double **Result,int N_size,int Total_threads) \n{ \n\tint\ti,j,k; \n\tstruct timeval  TimeValue_Start; \n\tstruct timezone TimeZone_Start; \n \n\tstruct timeval  TimeValue_Final; \n\tstruct timezone TimeZone_Final; \n\tlong            time_start, time_end; \n\tdouble          time_overhead; \n\t \n\tgettimeofday(&TimeValue_Start, &TimeZone_Start); \n\t \n         \n \n\tomp_set_num_threads(Total_threads); \n\t \n\t \n\t \n\tfor (i = 0; i < N_size; i = i + 1){ \n\t\tfor (j = 0; j < N_size; j = j + 1){ \n\t\t\tResult[i][j]=0.0; \n\t\t\tfor (k = 0; k < N_size; k = k + 1) \n\t\t\t\tResult[i][j] = Result[i][j] + Matrix_A[i][k] * Matrix_B[k][j]; \n\t\t} \n\t} \n \n \n\t gettimeofday(&TimeValue_Final, &TimeZone_Final); \n\t time_overhead = (double)(TimeValue_Final.tv_sec - TimeValue_Start.tv_sec) + (double)(TimeValue_Final.tv_usec - TimeValue_Start.tv_usec) / 1000000.0; \n\t time_overhead = time_overhead / (double)Total_threads; \n\t time_overhead = time_overhead / (double)N_size; \n\t time_overhead = time_overhead / (double)N_size; \n\t time_overhead = time_overhead / (double)N_size; \n\t time_overhead"}
{"label": "oid DGMacroCellInterface(void *mc, field *f, real *w, real *dtw)  \n{ \n  MacroFace *mface = (MacroFace*) mc; \n  MacroMesh *msh = &f->macromesh; \n  const unsigned int m = f->model.m; \n \n  int iparam[8]; \n  for(int ip = 0; ip < 8; ip++) \n    iparam[ip] = f->interp_param[ip]; \n \n   \n \n  for (int ifa = mface->first; ifa < mface->last_p1; ifa++) { \n    int ieL = msh->face2elem[4 * ifa + 0]; \n    int locfaL = msh->face2elem[4 * ifa + 1]; \n \n     \n \n    real physnode[20][3]; \n    for(int inoloc = 0; inoloc < 20; inoloc++) { \n      int ino = msh->elem2node[20 * ieL + inoloc]; \n      physnode[inoloc][0] = msh->node[3 * ino + 0]; \n      physnode[inoloc][1] = msh->node[3 * ino + 1]; \n      physnode[inoloc][2] = msh->node[3 * ino + 2]; \n    } \n \n    int ieR = msh->face2elem[4 * ifa + 2]; \n    int locfaR = msh->face2elem[4 * ifa + 3]; \n    real physnodeR[20][3]; \n    if (ieR >= 0) { \n      for(int inoloc = 0; inoloc < 20; inoloc++) { \n        int ino = msh->elem2node[20 * ieR + inoloc]; \n        physnodeR[inoloc][0] = msh->node[3 * ino + 0]; \n        physnodeR[inoloc][1] = msh->node[3 * ino + 1]; \n        physnodeR[inoloc][2] = msh->node[3 * ino + 2]; \n      } \n    } \n \n     \n \n    for(int ipgfL = 0; ipgfL < NPGF(f->interp_param + 1, locfaL); ipgfL++) { \n \n      int iparam[8]; \n      for(int ip = 0; ip < 8; ip++) \n\tiparam[ip] = f->interp_param[ip]; \n \n      real xpgref[3], xpgref_in[3], wpg; \n       \n \n       \n \n      ref_pg_face(iparam + 1, locfaL, ipgfL, xpgref, &wpg, xpgref_in); \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n       \n \n      int ipgL = iparam[7]; \n \n      real flux[m]; \n      real wL[m]; \n \n       \n \n      real vnds[3], xpg[3]; \n      { \n\treal dtau[3][3], codtau[3][3]; \n\tRef2Phy(physnode, \n\t\txpgref, \n\t\tNULL, locfaL,  \n \n\t\txpg, dtau, \n\t\tcodtau, NULL, vnds);  \n \n      } \n \n      if (ieR >= 0) {   \n \n        real xrefL[3]; \n\t{ \n\t  real xpg_in[3]; \n\t  Ref2Phy(physnode, \n\t\t  xpgref_in, \n\t\t  NULL, -1,  \n \n\t\t  xpg_in, NULL, \n\t\t  NULL, NULL, NULL);  \n \n\t  PeriodicCorrection(xpg_in,f->macromesh.period); \n\t  Phy2Ref(physnodeR, xpg_in, xrefL); \n \n\t} \n \n        int ipgR = ref_ipg(iparam + 1, xrefL); \n \n\t \n \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n\t \n \n \n\treal wR[m]; \n        for(int iv = 0; iv < m; iv++) { \n\t  int imemL = f->varindex(iparam, ieL, ipgL, iv); \n\t  wL[iv] = w[imemL]; \n          int imemR = f->varindex(iparam, ieR, ipgR, iv); \n          wR[iv] = w[imemR]; \n        } \n \n         \n \n \n        f->model.NumFlux(wL, wR, vnds, flux); \n \n\t \n \n\tfor(int iv = 0; iv < m; iv++) { \n\t   \n \n\t  int imemL = f->varindex(iparam, ieL, ipgL, iv); \n          int imemR = f->varindex(iparam, ieR, ipgR, iv); \n\t  dtw[imemL] -= flux[iv] * wpg; \n          dtw[imemR] += flux[iv] * wpg; \n\t} \n \n      } else {  \n \n\tfor(int iv = 0; iv < m; iv++) { \n\t  int imemL = f->varindex(iparam, ieL, ipgL, iv); \n\t  wL[iv] = w[imemL]; \n\t} \n \n        f->model.BoundaryFlux(xpg, f->tnow, wL, vnds, flux); \n \n\tfor(int iv = 0; iv < m; iv++) { \n\t   \n \n\t  int imemL = f->varindex(iparam, ieL, ipgL, iv); \n\t  dtw[imemL] -= flux[iv] * wpg; \n\t} \n      } \n \n    } \n \n  } \n} \n \n \n ", "pred": "oid DGMacroCellInterface(void *mc, field *f, real *w, real *dtw)  \n{ \n  MacroFace *mface = (MacroFace*) mc; \n  MacroMesh *msh = &f->macromesh; \n  const unsigned int m = f->model.m; \n \n  int iparam[8]; \n  for(int ip = 0; ip < 8; ip++) \n    iparam[ip] = f->interp_param[ip]; \n \n   \n \n  for (int ifa = mface->first; ifa < mface->last_p1; ifa++) { \n    int ieL = msh->face2elem[4 * ifa + 0]; \n    int locfaL = msh->face2elem[4 * ifa + 1]; \n \n     \n \n    real physnode[20][3]; \n    for(int inoloc = 0; inoloc < 20; inoloc++) { \n      int ino = msh->elem2node[20 * ieL + inoloc]; \n      physnode[inoloc][0] = msh->node[3 * ino + 0]; \n      physnode[inoloc][1] = msh->node[3 * ino + 1]; \n      physnode[inoloc][2] = msh->node[3 * ino + 2]; \n    } \n \n    for(int inoloc = 0; inoloc < 20; inoloc++) { \n      int ino = msh->elem2node[20 * ieL + inoloc]; \n      real *p0 = &physnode[inoloc][0]; \n      real *p1 = &physnode[inoloc][1]; \n      real *p2 = &physnode[inoloc][2]; \n \n      real *p0_x = &p0[0]; \n      real *p0_y = &p0[1]; \n      real *p0_z = &p0[2]; \n      real *p1_x = &p1[0]; \n      real *p1_y = &p1[1]; \n      real *p1_z = &p1[2]; \n      real *p2_x = &p2[0]; \n      real *p2_y = &p2[1]; \n      real *p2_z = &p2[2]; \n \n      real *p0_x_plus_1 = &p0_x[1]; \n      real *p0_y_plus_1 = &p0_y[1]; \n      real *p0_z_plus_1 = &p0_z[1]; \n      real *p1_x_plus_1 = &p1_x[1]; \n      real *p1_y_plus_1 = &p1_y[1]; \n      real *p1_z_plus_1 = &p1_z[1]; \n      real *p2_x_plus_1 = &p2_x[1]; \n      real *p2_y_plus_1 = &p2_y[1]; \n      real *p2_z_plus_1 = &p2_z[1]; \n \n      real *p0_x_minus_1 = &p0_x[0]; \n      real *p0_y_minus_1 = &p0_y[0]; \n      real *p0_z_minus_1 = &p0_z[0]; \n      real *p1_x_minus_1 = &p1_x[0]; \n      real *p1_y_minus_1 = &p1_y[0]; \n      real *p1_z_minus_1 = &p1_z[0]; \n      real *p2_x_minus_1 = &p2_x[0]; \n      real *p2_y_minus_1 = &p2_y[0]; \n      real *p2_z_minus_1 = &p2_z[0]; \n \n      real *p0_x_plus_2 = &p0_x[2]; \n      real *p0_y_plus_2 = &p0_y[2]; \n      real *p0_z_plus_2 = &p0_z[2]; \n      real *p1_x_plus_2 = &p1_x[2]; \n      real *p1_y_plus_2 = &p1_y[2]; \n      real *p1_z_plus_2 = &p1_z[2]; \n      real *p2_x_plus_2 = &p2_x[2]; \n      real *p2_y_plus_2 = &p2_y[2]; \n      real *p2_z_plus_2 = &p2_z[2]; \n \n      real *p0_x_minus_2 = &p0_x[0]; \n      real *p0_y_minus_2 = &p0_y[0]; \n      real *p0_z_minus_2 = &p0_z[0]; \n      real *p1_x_minus_2 = &p1_x[0]; \n      real *p1_y_minus_2 = &p1_y[0]; \n      real *p1_z_minus_2 = &p1_z[0]; \n      real *p2_x_minus_2 = &p2_x[0]; \n      real *p2_y_minus_2 = &p2_y[0]; \n      real *p2_z_minus_2 = &p2_z[0]; \n \n      real *p0_x_plus_3 = &p0_x[3]; \n      real *p0_y_plus_3 = &p0_y[3]; \n      real *p0_z_plus_3 = &p0_"}
{"label": " \nvoid Pyuv422to420(unsigned char *input_ptr, unsigned char *output_ptr, const unsigned int width, \n                  const unsigned int height, const int upsideDown) { \n    int i; \n    const int size = width * height; \n \n    for (i = 0; i < height; i++) { \n        unsigned char *b; \n        unsigned char *outY = output_ptr + i * width; \n        unsigned char *outU = output_ptr + (i / 2) * (width / 2) + size; \n        unsigned char *outV = output_ptr + (i / 2) * (width / 2) + size * 5 / 4; \n        if (!upsideDown) b = input_ptr + 2 * width * i; \n        else b = input_ptr - 2 * width * i + 2 * width * height - 4; \n \n        int j; \n        for (j = 0; j < width / 2; j++) { \n            unsigned char Y = b[0]; \n            unsigned char U = ALLDATAMONO? 128 : b[1]; \n            unsigned char Y1 = b[2]; \n            unsigned char V = ALLDATAMONO? 128 : b[3]; \n \n            if (!upsideDown) { \n                *(outY++) = Y; \n                *(outY++) = Y1; \n                b += 4; \n            } else { \n                *(outY++) = Y1; \n                *(outY++) = Y; \n                b -= 4; \n            } \n            *(outU++) = U; \n            *(outV++) = V; \n        } \n    } \n} ", "pred": " \nvoid Pyuv422to420(unsigned char *input_ptr, unsigned char *output_ptr, const unsigned int width, \n                  const unsigned int height, const int upsideDown) { \n    int i; \n    const int size = width * height; \n \n    for (i = 0; i < height; i++) { \n        unsigned char *b; \n        unsigned char *outY = output_ptr + i * width; \n        unsigned char *outU = output_ptr + (i / 2) * (width / 2) + size; \n        unsigned char *outV = output_ptr + (i / 2) * (width / 2) + size * 5 / 4; \n        if (!upsideDown) b = input_ptr + 2 * width * i; \n        else b = input_ptr - 2 * width * i + 2 * width * height - 4; \n \n        int j; \n        for (j = 0; j < width / 2; j++) { \n            outY[j] = b[j]; \n            outU[j] = b[j + width]; \n            outV[j] = b[j + width * 2]; \n        } \n    } \n    \n    return; \n} \n\n\nvoid Pyuv422to420_c(unsigned char *input_ptr, unsigned char *output_ptr, const unsigned int width, \n                    const unsigned int height, const int upsideDown) { \n    int i; \n    const int size = width * height; \n \n    for (i = 0; i < height; i++) { \n        unsigned char *b; \n        unsigned char *outY = output_ptr + i * width; \n        unsigned char *outU = output_ptr + (i / 2) * (width / 2) + size; \n        unsigned char *outV = output_ptr + (i / 2) * (width / 2) + size * 5 / 4; \n        if (!upsideDown) b = input_ptr + 2 * width * i; \n    "}
{"label": " \nvoid partials_states_and_undefined_codon_openmp( const SingleTreeLikelihood *tlk, int idx1, const double *matrices1, const double *partials2, const double *matrices2, double *partials3 ){ \n     \n\tconst int nstate = tlk->m->nstate; \n\tconst int extra = nstate - 60; \n\tint nThreads = tlk->nthreads; \n     \n    for ( int lk = 0; lk < tlk->pattern_count*tlk->cat_count; lk++ ) { \n        int l = lk / tlk->pattern_count; \n        int k = lk % tlk->pattern_count; \n         \n        int w = l * tlk->matrix_size; \n        int v = (l*tlk->pattern_count + k) * nstate; \n        const double *m2 = matrices2 + w; \n         \n        int state1 = tlk->sp->patterns[idx1][k]; \n         \n        const double *p2 = NULL; \n        double *pPartials = partials3+v; \n         \n        if ( state1 < nstate ) { \n             \n            const double *m1 = matrices1 + w; \n             \n            for ( int j = 0; j < nstate; j++ ) { \n                 \n                p2 = partials2 + v; \n                 \n                *pPartials  = *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                 \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                 \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                 \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                 \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *pPartials += *m2 * *p2; m2++; p2++; \n                *", "pred": " \nvoid partials_states_and_undefined_codon_openmp( const SingleTreeLikelihood *tlk, int idx1, const double *matrices1, const double *partials2, const double *matrices2, double *partials3 ){ \n     \n\tconst int nstate = tlk->m->nstate; \n\tconst int extra = nstate - 60; \n\tint nThreads = tlk->nthreads; \n     \n    for ( int lk = 0; lk < tlk->pattern_count*tlk->cat_count; lk++ ) { \n        int l = lk / tlk->pattern_count; \n        int k = lk % tlk->pattern_count; \n         \n        int w = l * tlk->matrix_size; \n        int v = (l*tlk->pattern_count + k) * nstate; \n        const double *m2 = matrices2 + w; \n         \n        int state1 = tlk->sp->patterns[idx1][k]; \n         \n        int state2 = tlk->sp->patterns[idx1][k+1]; \n         \n        int state3 = tlk->sp->patterns[idx1][k+2]; \n         \n        int state4 = tlk->sp->patterns[idx1][k+3]; \n         \n        int state5 = tlk->sp->patterns[idx1][k+4]; \n         \n        int state6 = tlk->sp->patterns[idx1][k+5]; \n         \n        int state7 = tlk->sp->patterns[idx1][k+6]; \n         \n        int state8 = tlk->sp->patterns[idx1][k+7]; \n         \n        int state9 = tlk->sp->patterns[idx1][k+8]; \n         \n        int state10 = tlk->sp->patterns[idx1][k+9]; \n         \n        int state11 = tlk->sp->patterns[idx1][k+10]; \n         \n        int state12 = tlk->sp->patterns[idx1][k+11]; \n         \n        int state13 = tlk->sp->patterns[idx1][k+12]; \n         \n        int state14 = tlk->sp->patterns[idx1][k+13]; \n         \n        int state15 = tlk->sp->patterns[idx1][k+14]; \n         \n        int state16 = tlk->sp->patterns[idx1][k+15]; \n         \n        int state17 = tlk->sp->patterns[idx1][k+16]; \n         \n        int state18 = tlk->sp->patterns[idx1][k+17]; \n         \n        int state19 = tlk->sp->patterns[idx1][k+18]; \n         \n        int state20 = tlk->sp->patterns[idx1][k+19]; \n         \n        int state21 = tlk->sp->patterns[idx1][k+20]; \n         \n        int state22 = tlk->sp->patterns[idx1][k+21]; \n         \n        int state23 = tlk->sp->patterns[idx1][k+22]; \n         \n        int state24 = tlk->sp->patterns[idx1][k+23]; \n         \n        int state25 = tlk->sp->patterns[idx1][k+24]; \n         \n        int state26 = tlk->sp->patterns[idx1][k+25]; \n         \n        int state27 = tlk->sp->patterns[idx1][k+26]; \n         \n        int state28 = tlk->sp->patterns[idx1][k+27]; \n         \n        int state29 = tlk->sp->patterns[idx1][k+28]; \n         \n        int state30 = tlk->sp->patterns[idx1][k+29]; \n         \n        int state31 = tlk->sp->patterns[idx1][k+30]; \n         \n        int state32 = tlk->sp->patterns[idx1][k+31]; \n         \n        int state33 = tlk->sp->patterns[idx1][k+32]; \n         \n        int state34 = tlk->sp->patterns[idx1][k+33]; \n         \n        int state35 = tlk->sp->patterns[idx1][k+34]; \n         \n        int state36 = tlk->sp->patterns[idx1][k+35]; \n         \n        int state37 = tlk->sp->patterns[idx1][k+36]; \n         \n        int state38 = tlk->sp->patterns[idx1][k+37]; \n         \n        int state39 = tlk->sp->patterns[idx1][k+38]; \n         \n        int state40 = tlk->sp->patterns[idx1][k+39]; \n         \n        int state41 = tlk->sp->patterns[idx1][k+40]; \n         \n        int state42 = tlk->sp->patterns[idx1][k+41]; \n         \n        int state43 = tlk->sp->patterns[idx1][k+42]; \n         \n        int state44 = tlk->sp->patterns[idx1][k+43]; \n         \n        int state45 = tlk->sp->patterns[idx1][k+44]; \n         \n        int state46 = tlk->sp->patterns[idx1][k+45]; \n         \n        int state47 = tlk->sp->patterns[idx1][k+46]; \n         \n        int state48 = tlk->sp->patterns[idx1][k+47]; \n         \n        int state49 = tlk->sp->patterns[idx1][k+48]; \n         \n        int state50 = tlk->sp->patterns[idx1][k+49]; \n         \n        int state51 = tlk->sp->patterns[idx1][k+50]; \n         \n   "}
{"label": " \nstatic void get_undone_phonons(double *frequencies, \n                               lapack_complex_double *eigenvectors, \n                               const size_t *undone_grid_points, \n                               const size_t num_undone_grid_points, \n                               PHPYCONST int (*grid_address)[3], \n                               const int mesh[3], \n                               const double *fc2, \n                               PHPYCONST double(*svecs_fc2)[27][3], \n                               const int *multi_fc2, \n                               const size_t num_patom, \n                               const size_t num_satom, \n                               const double *masses_fc2, \n                               const int *p2s_fc2, \n                               const int *s2p_fc2, \n                               const double unit_conversion_factor, \n                               PHPYCONST double (*born)[3][3], \n                               PHPYCONST double dielectric[3][3], \n                               PHPYCONST double reciprocal_lattice[3][3], \n                               const double *q_direction, \n                               const double nac_factor, \n                               const char uplo) \n{ \n  size_t i, j, gp, num_band; \n  int is_nac, info; \n  double q[3]; \n  double *freqs_tmp; \n \n  num_band = num_patom * 3; \n \n  for (i = 0; i < num_undone_grid_points; i++) { \n    gp = undone_grid_points[i]; \n    for (j = 0; j < 3; j++) { \n      q[j] = ((double)grid_address[gp][j]) / mesh[j]; \n    } \n \n    is_nac = needs_nac(born, grid_address, gp, q_direction); \n    get_phonons(eigenvectors + num_band * num_band * gp, \n                q, \n                fc2, \n                masses_fc2, \n                p2s_fc2, \n                s2p_fc2, \n                multi_fc2, \n                num_patom, \n                num_satom, \n                svecs_fc2, \n                is_nac, \n                born, \n                dielectric, \n                reciprocal_lattice, \n                q_direction, \n                nac_factor, \n                unit_conversion_factor); \n  } \n \n \n \n  for (i = 0; i < num_undone_grid_points; i++) { \n    gp = undone_grid_points[i]; \n    freqs_tmp = frequencies + num_band * gp; \n     \n \n     \n \n    info = phonopy_zheev(freqs_tmp, \n                         eigenvectors + num_band * num_band * gp, \n                         num_band, \n                         uplo); \n \n     \n \n    for (j = 0; j < num_band; j++) { \n      freqs_tmp[j] = sqrt(fabs(freqs_tmp[j])) * \n        ((freqs_tmp[j] > 0) - (freqs_tmp[j] < 0)) * unit_conversion_factor; \n    } \n  } \n} ", "pred": " \nstatic void get_undone_phonons(double *frequencies, \n                               lapack_complex_double *eigenvectors, \n                               const size_t *undone_grid_points, \n                               const size_t num_undone_grid_points, \n                               PHPYCONST int (*grid_address)[3], \n                               const int mesh[3], \n                               const double *fc2, \n                               PHPYCONST double(*svecs)[3], \n                               PHPYCONST double(*svals)[3], \n                               PHPYCONST double(*svecs_inv)[3], \n                               PHPYCONST double(*svals_inv)[3], \n                               const double *fc3, \n                               PHPYCONST double(*svecs_inv)[3], \n                               PHPYCONST double(*svals_inv)[3], \n                               const double *fc4, \n                               PHPYCONST double(*svecs_inv)[3], \n                               PHPYCONST double(*svals_inv)[3], \n                               const double *fc5, \n                               PHPYCONST double(*svecs_inv)[3], \n                               PHPYCONST double(*svals_inv)[3], \n                               const double *fc6, \n                               PHPYCONST double(*svecs_inv)[3], \n                               PHPYCONST double(*svals_inv)[3], \n                               const double *fc7, \n                               PHPYCONST double(*svecs_inv)[3], \n                               PHPYCONST double(*svals_inv)[3], \n                               const double *fc8, \n                               PHPYCONST double(*svecs_inv)[3], \n                               PHPYCONST double(*svals_inv)[3], \n                               const double *fc9, \n                               PHPYCONST double(*svecs_inv)[3], \n                               PHPYCONST double(*svals_inv)[3], \n                               const double *fc10, \n                               PHPYCONST double(*svecs_inv)[3], \n                               PHPYCONST double(*svals_inv)[3], \n                               const double *fc11, \n                               PHPYCONST double(*svecs_inv)[3], \n                               PHPYCONST double(*svals_inv)[3], \n                               const double *fc12, \n                               PHPYCONST double(*svecs_inv)[3], \n                     "}
{"label": " \nvoid compute_rhs() \n{ \n  int i, j, k, m; \n  double rho_inv, uijk, up1, um1, vijk, vp1, vm1, wijk, wp1, wm1; \n \n  if (timeron) timer_start(t_rhs); \n  { \n   \n \n   \n \n   \n \n   \n \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        rho_inv = 1.0/u[k][j][i][0]; \n        rho_i[k][j][i] = rho_inv; \n        us[k][j][i] = u[k][j][i][1] * rho_inv; \n        vs[k][j][i] = u[k][j][i][2] * rho_inv; \n        ws[k][j][i] = u[k][j][i][3] * rho_inv; \n        square[k][j][i] = 0.5* ( \n            u[k][j][i][1]*u[k][j][i][1] +  \n            u[k][j][i][2]*u[k][j][i][2] + \n            u[k][j][i][3]*u[k][j][i][3] ) * rho_inv; \n        qs[k][j][i] = square[k][j][i] * rho_inv; \n      } \n    } \n  } \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        for (m = 0; m < 5; m++) { \n          rhs[k][j][i][m] = forcing[k][j][i][m]; \n        } \n      } \n    } \n  } \n \n  if (timeron) timer_start(t_rhsx); \n   \n \n   \n \n   \n \n  for (k = 1; k <= grid_points[2]-2; k++) { \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      for (i = 1; i <= grid_points[0]-2; i++) { \n        uijk = us[k][j][i]; \n        up1  = us[k][j][i+1]; \n        um1  = us[k][j][i-1]; \n \n        rhs[k][j][i][0] = rhs[k][j][i][0] + dx1tx1 *  \n          (u[k][j][i+1][0] - 2.0*u[k][j][i][0] +  \n           u[k][j][i-1][0]) - \n          tx2 * (u[k][j][i+1][1] - u[k][j][i-1][1]); \n \n        rhs[k][j][i][1] = rhs[k][j][i][1] + dx2tx1 *  \n          (u[k][j][i+1][1] - 2.0*u[k][j][i][1] +  \n           u[k][j][i-1][1]) + \n          xxcon2*con43 * (up1 - 2.0*uijk + um1) - \n          tx2 * (u[k][j][i+1][1]*up1 -  \n              u[k][j][i-1][1]*um1 + \n              (u[k][j][i+1][4]- square[k][j][i+1]- \n               u[k][j][i-1][4]+ square[k][j][i-1])* \n              c2); \n \n        rhs[k][j][i][2] = rhs[k][j][i][2] + dx3tx1 *  \n          (u[k][j][i+1][2] - 2.0*u[k][j][i][2] + \n           u[k][j][i-1][2]) + \n          xxcon2 * (vs[k][j][i+1] - 2.0*vs[k][j][i] + \n              vs[k][j][i-1]) - \n          tx2 * (u[k][j][i+1][2]*up1 -  \n              u[k][j][i-1][2]*um1); \n \n        rhs[k][j][i][3] = rhs[k][j][i][3] + dx4tx1 *  \n          (u[k][j][i+1][3] - 2.0*u[k][j][i][3] + \n           u[k][j][i-1][3]) + \n          xxcon2 * (ws[k][j][i+1] - 2.0*ws[k][j][i] + \n              ws[k][j][i-1]) - \n          tx2 * (u[k][j][i+1][3]*up1 -  \n              u[k][j][i-1][3]*um1); \n \n        rhs[k][j][i][4] = rhs[k][j][i][4] + dx5tx1 *  \n          (u[k][j][i+1][4] - 2.0*u[k][j][i][4] + \n           u[k][j][i-1][4]) + \n          xxcon3 * (qs[k][j][i+1] - 2.0*qs[k][j][i] + \n              qs[k][j][i-1]) + \n          xxcon4 * (up1*up1 -       2.0*uijk*uijk +  \n              um1*um1) + \n          xxcon5 * (u[k][j][i+1][4]*rho_i[k][j][i+1] -  \n              2.0*u[k][j][i][4]*rho_i[k][j][i] + \n              u[k][j][i-1][4]*rho_i[k][j][i-1]) - \n          tx2 * ( (c1*u[k][j][i+1][4] -  \n ", "pred": " \nvoid compute_rhs() \n{ \n  int i, j, k, m; \n  double rho_inv, uijk, up1, um1, vijk, vp1, vm1, wijk, wp1, wm1; \n \n  if (timeron) timer_start(t_rhs); \n  { \n   \n \n   \n \n   \n \n   \n \n  for (k = 0; k <= grid_points[2]-1; k++) { \n    for (j = 0; j <= grid_points[1]-1; j++) { \n      for (i = 0; i <= grid_points[0]-1; i++) { \n        rho_inv = 1.0/u[k][j][i][0]; \n        rho_i[k][j][i] = rho_inv; \n        us[k][j][i] = u[k][j][i][1] * rho_inv; \n        vs[k][j][i] = u[k][j][i][2] * rho_inv; \n        ws[k][j][i] = u[k][j][i][3] * rho_inv; \n        wu[k][j][i] = u[k][j][i][4] * rho_inv; \n        wv[k][j][i] = u[k][j][i][5] * rho_inv; \n        wuu[k][j][i] = u[k][j][i][6] * rho_inv; \n        wuv[k][j][i] = u[k][j][i][7] * rho_inv; \n        wvv[k][j][i] = u[k][j][i][8] * rho_inv; \n        wuuu[k][j][i] = u[k][j][i][9] * rho_inv; \n        wuvv[k][j][i] = u[k][j][i][10] * rho_inv; \n        wuvw[k][j][i] = u[k][j][i][11] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][12] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][13] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][14] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][15] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][16] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][17] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][18] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][19] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][20] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][21] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][22] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][23] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][24] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][25] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][26] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][27] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][28] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][29] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][30] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][31] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][32] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][33] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][34] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][35] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][36] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][37] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][38] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][39] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][40] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][41] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][42] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][43] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][44] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][45] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][46] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][47] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][48] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][49] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][50] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][51] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][52] * rho_inv; \n        wvvw[k][j][i] = u[k][j][i][53] * rho_inv; \n        wvvv[k][j][i] = u[k][j][i][54] * rho_inv; \n        wvvw[k][j"}
{"label": " \nMagickExport Image *SimilarityImage(Image *image,const Image *reference, \n  RectangleInfo *offset,double *similarity_metric,ExceptionInfo *exception) \n{ \n#define SimilarityImageTag  \"Similarity/Image\" \n \n  CacheView \n    *similarity_view; \n \n  ChannelStatistics \n    *reference_statistics; \n \n  Image \n    *similarity_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  assert(offset!= (RectangleInfo *) NULL); \n  SetGeometry(reference,offset); \n  *similarity_metric=1.0; \n  if ((reference->columns > image->columns) || (reference->rows > image->rows)) \n    ThrowImageException(ImageError,\"ImageSizeDiffers\"); \n  similarity_image=CloneImage(image,image->columns-reference->columns+1, \n    image->rows-reference->rows+1,MagickTrue,exception); \n  if (similarity_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(similarity_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&similarity_image->exception); \n      similarity_image=DestroyImage(similarity_image); \n      return((Image *) NULL); \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  reference_statistics=GetImageChannelStatistics(reference,exception); \n  similarity_view=AcquireCacheView(similarity_image); \n  for (y=0; y < (ssize_t) (image->rows-reference->rows+1); y++) \n  { \n    double \n      similarity; \n \n    register ssize_t \n      x; \n \n    register PixelPacket \n      *restrict q; \n \n    if (status == MagickFalse) \n      continue; \n    q=GetCacheViewAuthenticPixels(similarity_view,0,y,similarity_image->columns, \n      1,exception); \n    if (q == (const PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) (image->columns-reference->columns+1); x++) \n    { \n      similarity=GetSimilarityMetric(image,reference,reference_statistics,x,y, \n        exception); \n      if (similarity < *similarity_metric) \n        { \n          *similarity_metric=similarity; \n          offset->x=x; \n          offset->y=y; \n        } \n      SetPixelRed(q,ClampToQuantum(QuantumRange-QuantumRange* \n        similarity)); \n      SetPixelGreen(q,GetPixelRed(q)); \n      SetPixelBlue(q,GetPixelRed(q)); \n      q++; \n    } \n    if (SyncCacheViewAuthenticPixels(similarity_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        proceed=SetImageProgress(image,SimilarityImageTag,progress++, \n          image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  } \n  similarity_view=DestroyCacheView(similarity_view); \n  reference_statistics=(ChannelStatistics *) RelinquishMagickMemory( \n    reference_statistics); \n  return(similarity_image); \n} ", "pred": " \nMagickExport Image *SimilarityImage(Image *image,const Image *reference, \n  RectangleInfo *offset,double *similarity_metric,ExceptionInfo *exception) \n{ \n#define SimilarityImageTag  \"Similarity/Image\" \n \n  CacheView \n    *similarity_view; \n \n  ChannelStatistics \n    *reference_statistics; \n \n  Image \n    *similarity_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  assert(offset!= (RectangleInfo *) NULL); \n  SetGeometry(reference,offset); \n  *similarity_metric=1.0; \n  if ((reference->columns > image->columns) || (reference->rows > image->rows)) \n    ThrowImageException(ImageError,\"ImageSizeDiffers\"); \n  similarity_image=CloneImage(image,image->columns,image->rows,MagickTrue,\n    exception); \n  if (similarity_image == (Image *) NULL)\n    return((Image *) NULL);\n  similarity_view=AcquireVirtualCacheView(similarity_image,exception); \n  status=MagickTrue; \n  progress=0; \n  do \n  { \n    register ssize_t\n      x;\n    register Quantum\n      *magick_restrict q;\n    register ssize_t\n      i;\n    size_t\n      length;\n    ssize_t\n      y;\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(similarity_view,0,0,image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    length=GetCacheViewExtent(similarity_view);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        SetPixelRed(similarity_image,GetPixelRed(image,q));\n        SetPixelGreen(similarity_image,GetPixelGreen(image,q));\n        SetPixelBlue(similarity_image,GetPixelBlue(image,q));\n        SetPixelAlpha(similarity_image,GetPixelAlpha(image,q));\n        q+=GetPixelChannels(image);\n      }\n      q+=GetPixelChannels(similarity_image);\n    }\n    if (SyncCacheViewAuthenticPixels(similarity_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor!= (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_SimilarityImage)\n#endif\n        proceed=SetImageProgress(image,SimilarityImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  } while (status == MagickFalse);\n  similarity_view=DestroyCacheView(similarity_view);\n  if (status == MagickFalse)\n    similarity_image=DestroyImage(similarity_image);\n  return(similarity_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                 "}
{"label": " \nint main() \n{ \n\tMboNumOp Jx; \n\tMboProdSpace hTot; \n\tstruct MboAmplitude one, zero, *x, *y, *yomp; \n\tint i; \n\tMboGlobInd n, chunk, chunkSize, numChunks, dim; \n\tclock_t tstart, tend; \n\tdouble deltat, difference; \n\tint numThreads; \n\tMboNumSubMatrix *chunks; \n\tMBO_STATUS err; \n \n\thTot = buildSpace(numSpins); \n\tdim = mboProdSpaceDim(hTot); \n\tJx = buildJx(hTot); \n \n\tone.re = 1.0; \n\tone.im = 0.0; \n\tzero.re = 0.0; \n\tzero.im = 0.0; \n\tx = malloc(dim * sizeof(*x)); \n\ty = malloc(dim * sizeof(*x)); \n\tyomp = malloc(dim * sizeof(*x)); \n\tfor (n = 0; n < dim; ++n) { \n\t\tx[n].re = (double)rand() / RAND_MAX; \n\t\tx[n].im = (double)rand() / RAND_MAX; \n\t} \n \n\ttstart = clock(); \n\tfor (i = 0; i < numIters; ++i) { \n\t\tmboNumOpMatVec(one, Jx, x, zero, y); \n\t} \n\ttend = clock(); \n\tdeltat = (double)(tend - tstart) / (double)CLOCKS_PER_SEC; \n\tprintf(\"Serial: %2.3lf s\\n\", deltat); \n \n\tnumThreads = omp_get_max_threads(); \n\tnumThreads = 1; \n\tprintf(\"here\"); \n\tprintf(\"Using %d threads.\\n\", numThreads); \n\tchunkSize = dim / numThreads; \n\tprintf(\"Chunk Size: %lld\\n\", chunkSize); \n\tnumChunks = dim / chunkSize; \n\tprintf(\"Number of Chunks: %lld\\n\", numChunks); \n\tif (numChunks * chunkSize < dim) ++numChunks; \n\tchunks = (MboNumSubMatrix*)malloc(numChunks * sizeof(*chunks)); \n\tfor (chunk = 0; chunk < numChunks; ++chunk) { \n\t\terr = mboNumSubMatrixCreate(Jx, chunk * chunkSize, \n\t\t\t(chunk + 1) * chunkSize, 0, dim, &chunks[chunk]); \n\t\tassert(err == MBO_SUCCESS); \n\t} \n\ttstart = clock(); \n\tfor (i = 0; i < numIters; ++i) { \n\t\tfor (chunk = 0; chunk < numChunks; ++chunk) { \n\t\t\tmboNumSubMatrixMatVec(one, chunks[chunk], x, zero, \n\t\t\t\t\t      yomp + chunk * chunkSize); \n\t\t} \n\t} \n\ttend = clock(); \n\tdeltat = (double)(tend - tstart) / (double)CLOCKS_PER_SEC / numThreads; \n\tprintf(\"Parallel: %2.3lf s\\n\", deltat); \n \n\tdifference = 0; \n\tfor (n = 0; n < dim; ++n) { \n\t\tdifference += (yomp[n].re - y[n].re) * (yomp[n].re - y[n].re) + \n\t\t\t      (yomp[n].im - y[n].im) * (yomp[n].im - y[n].im); \n\t} \n\tdifference = sqrt(difference); \n \n\tprintf(\"Error: %lf\\n\", difference); \n \n\tfree(x); \n\tfree(y); \n\tfree(yomp); \n\tfor (chunk = 0; chunk < numChunks; ++chunk) { \n\t\tmboNumSubMatrixDestroy(&chunks[chunk]); \n\t} \n\tfree(chunks); \n\tmboNumOpDestroy(&Jx); \n\tmboProdSpaceDestroy(&hTot); \n \n\tif (difference < 1.0e-12) { \n\t\treturn 0; \n\t} else { \n\t\treturn 1; \n\t} \n \n} ", "pred": " \nint main() \n{ \n\tMboNumOp Jx; \n\tMboProdSpace hTot; \n\tstruct MboAmplitude one, zero, *x, *y, *yomp; \n\tint i; \n\tMboGlobInd n, chunk, chunkSize, numChunks, dim; \n\tclock_t tstart, tend; \n\tdouble deltat, difference; \n\tint numThreads; \n\tMboNumSubMatrix *chunks; \n\tMBO_STATUS err; \n \n\thTot = buildSpace(numSpins); \n\tdim = mboProdSpaceDim(hTot); \n\tJx = buildJx(hTot); \n \n\tone.re = 1.0; \n\tone.im = 0.0; \n\tzero.re = 0.0; \n\tzero.im = 0.0; \n\tx = malloc(dim * sizeof(*x)); \n\ty = malloc(dim * sizeof(*x)); \n\tyomp = malloc(dim * sizeof(*x)); \n\tfor (n = 0; n < dim; ++n) { \n\t\tx[n].re = (double)rand() / RAND_MAX; \n\t\tx[n].im = (double)rand() / RAND_MAX; \n\t} \n \n\ttstart = clock(); \n\tfor (i = 0; i < numThreads; ++i) \n\t\tMboNumSubMatrix_multiply(Jx, x, y, dim); \n\ttend = clock(); \n \n\tdeltat = (double)(tend - tstart) / (double)CLOCKS_PER_SEC; \n\tdifference = (double)numThreads * (double)numThreads / deltat; \n \n\tnumChunks = MboNumSubMatrix_getNumChunks(Jx); \n\tchunkSize = MboNumSubMatrix_getChunkSize(Jx); \n\tnumThreads = MboNumSubMatrix_getNumThreads(Jx); \n \n\tchunks = malloc(numChunks * sizeof(*chunks)); \n\tfor (n = 0; n < numChunks; ++n) { \n\t\tchunks[n].chunkSize = chunkSize; \n\t\tchunks[n].numThreads = numThreads; \n\t\tchunks[n].chunk = malloc(chunkSize * sizeof(*chunks[n].chunk)); \n\t} \n \n\tfor (n = 0; n < numThreads; ++n) { \n\t\tMboNumSubMatrix_multiply(Jx, chunks, yomp, dim); \n\t\tMboNumSubMatrix_multiply(Jx, yomp, y, dim); \n\t} \n \n\tfor (n = 0; n < numThreads; ++n) { \n\t\tMboNumSubMatrix_multiply(Jx, chunks, yomp, dim); \n\t\tMboNumSubMatrix_multiply(Jx, yomp, y, dim); \n\t} \n \n\tfor (n = 0; n < numChunks; ++n) { \n\t\tMboNumSubMatrix_multiply(Jx, chunks, yomp, dim); \n\t\tMboNumSubMatrix_multiply(Jx, yomp, y, dim); \n\t} \n \n\tfor (n = 0; n < numChunks; ++n) { \n\t\tMboNumSubMatrix_multiply(Jx, chunks, yomp, dim); \n\t\tMboNumSubMatrix_multiply(Jx, yomp, y, dim); \n\t} \n \n\tfor (n = 0; n < numChunks; ++n) { \n\t\tMboNumSubMatrix_multiply(Jx, chunks, yomp, dim); \n\t\tMboNumSubMatrix_multiply(Jx, yomp, y, dim); \n\t} \n \n\tfor (n = 0; n < numChunks; ++n) { \n\t\tMboNumSubMatrix_multiply(Jx, chunks, yomp, dim); \n\t\tMboNumSubMatrix_multiply(Jx, yomp, y, dim); \n\t} \n \n\tfor (n = 0; n < numChunks; ++n) { \n\t\tMboNumSubMatrix_multiply(Jx, chunks, yomp, dim); \n\t\tMboNumSubMatrix_multiply(Jx, yomp, y, dim); \n\t} \n \n\tfor (n"}
{"label": " \nvoid \ntime_3d_real_double_omp() \n{ \n   \n \n  int nthr = omp_get_max_threads(); \n  int nthr = 1; \n   \n \n   \n \n   \n \n   \n \n   \n \n \n  int nnodes = nthr; \n  fprintf (stderr, \"Using %d threads.\\n\", nnodes); \n \n  int Nx=63; int Ny=61; int Nz = 69; \n  int num_splines = 256; \n \n  Ugrid x_grid, y_grid, z_grid; \n  x_grid.start = 3.1; x_grid.end =  9.1; x_grid.num = Nx; \n  y_grid.start = 8.7; y_grid.end = 12.7; y_grid.num = Ny; \n  z_grid.start = 4.5; z_grid.end =  9.3; z_grid.num = Nz; \n \n  BCtype_d xBC, yBC, zBC; \n  xBC.lCode = xBC.rCode = PERIODIC; \n  yBC.lCode = yBC.rCode = PERIODIC; \n  zBC.lCode = zBC.rCode = PERIODIC; \n \n   \n \n  UBspline_3d_d* norm_splines[num_splines]; \n  multi_UBspline_3d_d *multi_spline[nnodes]; \n   \n   \n \n  for (int node=0; node<nnodes; node++)  \n  { \n     \n \n     \n \n     \n \n     \n \n    multi_spline[node] = create_multi_UBspline_3d_d  \n      (x_grid, y_grid, z_grid, xBC, yBC, zBC, num_splines); \n  } \n \n  double data[Nx*Ny*Nz]; \n   \n \n  for (int i=0; i<num_splines; i++) { \n    for (int j=0; j<Nx*Ny*Nz; j++) \n      data[j] = (drand48()-0.5); \n    norm_splines[i] = create_UBspline_3d_d  \n      (x_grid, y_grid, z_grid, xBC, yBC, zBC, data); \n    for (int node=0; node<nnodes; node++) { \n       \n \n       \n \n       \n \n       \n \n      set_multi_UBspline_3d_d (multi_spline[node], i, data); \n    } \n  } \n   \n   \n \n  double rand_start, rand_end, norm_start[nthr], norm_end[nthr], multi_start[nthr], multi_end[nthr]; \n  int num_vals = 10000; \n  double multi_vals[nthr][num_splines], norm_vals[nthr][num_splines]; \n  double multi_grads[nthr][3*num_splines], norm_grads[nthr][3*num_splines]; \n  double multi_lapl[nthr][num_splines], norm_lapl[nthr][num_splines]; \n  double multi_hess[nthr][9*num_splines], norm_hess[nthr][9*num_splines]; \n \n  rand_start = get_time(); \n  for (int i=0; i<num_vals; i++) { \n    double rx = drand48();  double x = rx*x_grid.start + (1.0-rx)*x_grid.end; \n    double ry = drand48();  double y = ry*y_grid.start + (1.0-ry)*y_grid.end; \n    double rz = drand48();  double z = rz*z_grid.start + (1.0-rz)*z_grid.end; \n  } \n  rand_end = get_time(); \n \n   \n \n   \n \n   \n \n  double rx = drand48();  double x = rx*x_grid.start + (1.0-rx)*x_grid.end; \n  double ry = drand48();  double y = ry*y_grid.start + (1.0-ry)*y_grid.end; \n  double rz = drand48();  double z = rz*z_grid.start + (1.0-rz)*z_grid.end; \n \n  int thr_per_node = nthr/nnodes; \n \n  for (int thr=0; thr<nthr; thr++) { \n    int node = thr/thr_per_node; \n    multi_start[thr] = get_time(); \n    for (int i=0; i<num_vals; i++) { \n      double rx = drand48();  double x = rx*x_grid.start + (1.0-rx)*x_grid.end;  \n      double ry = drand48();  double y = ry*y_grid.start + (1.0-ry)*y_grid.end;  \n      double rz = drand48();  double z = rz*z_grid.start + (1.0-rz)*z_grid.end;  \n      eval_multi_UBspline_3d_d (multi_spline[node], x, y, z, multi_vals[thr]); \n    } \n    multi_end[thr] = get_time(); \n  } \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n   \n  double norm_avg=0.0, multi_avg=0.0; \n \n  for (int thr=0; thr<nthr; thr++) { \n    double norm_time   = (double)(norm_end[thr] - norm_start[thr] + rand_start - rand_end); \n    double multi_time  = (double)(multi_end[thr] - multi_start[thr] + rand_start - rand_end); \n    norm_avg += norm_time; \n    multi_avg += multi_time; \n  } \n  norm_avg  /= nthr; \n  multi_avg /= nthr; \n  double norm_speed  = (double) num_vals*num_splines / norm_avg; \n  double multi_speed = (double) num_vals*num_splines / multi_avg; \n \n   \n \n   \n \n  fprintf (stderr, \"Multi  value speed = %13.3f evaluations per second.\\n\",  \n  \t   multi_speed); \n  fprintf (stderr, \"Aggregate bandwidth = %1.3f GB/s per socket\\n\", multi_speed * 64.0*8.0 * 8 * 1.0e-9); \n \n   \n   \n \n   \n \n   \n \n  for (int thr=0; thr<nthr; thr++) { \n    int node = thr/thr_per_node; \n    multi_start[thr] = get_time(); \n    for (int i=0; i<num_vals; i++) { \n      double rx = drand48();  double x = rx*x_grid.start + (1.0-rx)*x_grid.end; \n      double ry = drand48();  double y = ry*y_grid.start + (1.0-ry)*y_grid.end; \n      double rz = drand48();  double z = rz*z_grid.start + (1.0-rz)*z_grid.end; \n      eval_multi_UBspline_3d_d_vgh  \n\t(multi_spline[node], x, y, z,  multi_vals[thr],  \n\t multi_grads[thr], multi_hess[thr]); \n    } \n    multi_end[thr] = get_time(); \n  } \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  norm_avg = multi_avg = 0.0; \n  for (int thr=0; thr<nthr; thr++) { \n    double norm_time  ", "pred": " \nvoid \ntime_3d_real_double_omp() \n{ \n   \n \n  int nthr = omp_get_max_threads(); \n  int nthr = 1; \n   \n \n   \n \n   \n \n   \n \n   \n \n \n  int nnodes = nthr; \n  fprintf (stderr, \"Using %d threads.\\n\", nnodes); \n \n  int Nx=63; int Ny=61; int Nz = 69; \n  int num_splines = 256; \n \n  Ugrid x_grid, y_grid, z_grid; \n  x_grid.start = 3.1; x_grid.end =  9.1; x_grid.num = Nx; \n  y_grid.start = 8.7; y_grid.end = 12.7; y_grid.num = Ny; \n  z_grid.start = 4.5; z_grid.end =  9.3; z_grid.num = Nz; \n \n  BCtype_d xBC, yBC, zBC; \n  xBC.lCode = xBC.rCode = PERIODIC; \n  yBC.lCode = yBC.rCode = PERIODIC; \n  zBC.lCode = zBC.rCode = PERIODIC; \n \n  // First, create splines the normal way \n   \n   \n    \n     // First, create splines the normal way \n     \n     \n     // First, create splines the normal way \n     \n     \n     // Now, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n     \n     \n     // Next, create splines the normal way \n  "}
{"label": " *fp_result; \n\tFILE *fp_result_info; \n \n\tint64_t ref_total_size; \n\tint ref_len; \n\tint ref_bucket_num; \n\tint ref_bucket_count; \n\tint ref_bucket_index = 0; \n \n\tint64_t read_total_size = 0; \n\tint64_t read_total_count = 0; \n\tint read_len; \n\tint read_bucket_num = 0; \n\tint read_bucket_count = 0; \n\tint read_bucket_index = 0; \n\tint64_t read_actual_size = 0; \n \n\tint64_t preprocess_read_size; \n\tint64_t align_result_size; \n\tint64_t offload_read_size; \n\tint64_t offload_result_size; \n \n\tint word_num; \n\tint chunk_read_num; \n\tint offload_dvdh_size; \n\tint ref_start; \n\tint ref_end; \n \n\tint64_t *result_bucket_counts; \n\tint64_t *sse_result_bucket_counts; \n \n\tmic_read_t *read_ptr; \n\tmic_write_t *result_ptr; \n\tint64_t read_ptr_offset; \n\tint64_t result_ptr_offset; \n\tint64_t single_read_size; \n\tint64_t single_result_size; \n\tint64_t single_read_count; \n\tint64_t single_result_count; \n\tint64_t total_result_count = 0; \n \n\tmic_cal_t *mic_args; \n\tmic_cal_t *tmp_cal_arg; \n \n\tint sse_word_num; \n\tint sse_chunk_read_num; \n\tint sse_dvdh_size; \n\tint64_t sse_preprocess_read_size; \n\tint64_t sse_align_result_size; \n\tint64_t sse_result_total_count; \n \n\tsse_cal_t sse_arg; \n\tsse_cal_t *tmp_sse_arg; \n \n \n\tdouble *device_compute_ratio; \n\tint64_t *device_read_counts_a; \n\tint64_t *device_read_counts_b; \n\tint64_t *device_read_counts; \n \n\tthread_info input_info; \n\tthread_info output_info; \n\tthread_info cal_input_info; \n\tthread_info cal_output_info; \n\tthread_arg input_arg; \n\tthread_arg output_arg; \n \n\tdouble total_start, total_end; \n\tdouble read_start, read_end; \n\tdouble cal_start, cal_end; \n\tdouble offload_start, offload_end; \n\tdouble write_start, write_end; \n\tdouble process_start, process_end; \n\tdouble mem_start, mem_end; \n\tdouble mem_time, mem_num; \n \n\tGET_TIME(total_start); \n\tread_total_time = 0; \n\twrite_total_time = 0; \n\tmem_total_time = 0; \n \n \n\tint total_device_number; \n\tint mic_device_number = mic_number; \n\tint cpu_device_number = 1; \n\t \n \n\ttotal_device_number = mic_device_number + cpu_device_number; \n \n\tdevice_compute_ratio = (double *) malloc_mem(sizeof(double) * total_device_number); \n\tdevice_read_counts_a = (int64_t *) malloc_mem(sizeof(int64_t) * total_device_number); \n\tdevice_read_counts_b = (int64_t *) malloc_mem(sizeof(int64_t) * total_device_number); \n \n\t \n \n \n\tif (file_ratio == NULL) { \n\t\tinit_cpu_mic_ratio(device_compute_ratio, cpu_device_number, mic_device_number); \n\t} else { \n\t\tinit_device_ratio_file(device_compute_ratio, cpu_device_number, mic_device_number, file_ratio); \n\t} \n \n\tuse_times = (double **) malloc_mem(sizeof(double *) * total_device_number); \n\t \n \n\t \n \n \n \n\tup_signal_a = (char *) malloc_mem(sizeof(char) * mic_device_number); \n\tup_signal_b = (char *) malloc_mem(sizeof(char) * mic_device_number); \n\tdown_signal_a = (char *) malloc_mem(sizeof(char) * mic_device_number); \n\tdown_signal_b = (char *) malloc_mem(sizeof(char) * mic_device_number); \n \n\tdouble cal_total_times[total_device_number]; \n\tdouble offload_total_times[total_device_number]; \n\tdouble previous_device_times[total_device_number]; \n \n\tfor (i = 0; i < total_device_number; i++) { \n\t\tcal_total_times[i] = 0; \n\t\toffload_total_times[i] = 0; \n\t} \n\tomp_set_nested(1); \n \n\tinit_mapping_table(); \n\tinit_device(mic_device_number); \n\tmic_args = (mic_cal_t *) malloc_mem(sizeof(mic_cal_t) * mic_device_number); \n \n\tcreate_folder(\"data\", 0755); \n\tfp_ref = open_file(file_query, \"rb\"); \n\tfp_read = open_file(file_database, \"rb\"); \n\tfp_result = open_file(file_result, \"wb+\"); \n\tfp_result_info = open_file(file_result_info, \"wb+\"); \n \n\t \n \n\tref_total_size = get_filesize(file_query); \n\tref_seq.content = (char *) malloc_mem(sizeof(char) * (ref_total_size + 1)); \n\tget_ref_from_file(&ref_seq, fp_ref, ref_total_size); \n\tref_len = ref_seq.len; \n \n\tif (ref_seq.count > REF_BUCKET_COUNT) { \n\t\tref_bucket_num = (ref_seq.count + REF_BUCKET_COUNT - 1) / REF_BUCKET_COUNT; \n\t\tref_bucket_count = REF_BUCKET_COUNT; \n\t} else { \n\t\tref_bucket_num = 1; \n\t\tref_bucket_count = ref_seq.count; \n\t} \n \n\tglobal_ref_bucket_num = ref_bucket_num; \n \n\tread_total_size = get_filesize(file_database); \n\tif (read_total_size > READ_BUCKET_SIZE) { \n\t\tread_seq_a.content = (char *) malloc_mem(sizeof(char) * (READ_BUCKET_SIZE + 1)); \n\t\tread_seq_b.content = (char *) malloc_mem(sizeof(char) * (READ_BUCKET_SIZE + 1)); \n\t\tread_actual_size = READ_BUCKET_SIZE; \n\t} else { \n\t\tread_seq_a.content = (char *) malloc_mem(sizeof(char) * (read_total_size * 2)); \n\t\tread_seq_b.content = (char *) malloc_mem(sizeof(char) * (read_total_size * 2)); \n\t\tread_actual_size = read_total_size; \n\t\tread_bucket_num = 1; \n\t} \n \n\tGET_TIME(read_start); \n\tget_read_from_file(&read_seq_a, fp_read, read_actual_size, read_total_size); \n\tdispatch_task(device_compute_ratio, device_read_counts_a, read_seq_a.count, total_device_number); \n\tGET_TIME(read_end); \n\tread_total_time += read_end - read_start; \n \n\tread_len = read_seq_a.len; \n\tread_bucket_count = read_seq_a.count; \n\tread_actual_size = read_seq_a.size; \n\tread_total_count = (read_total_size + 1) / (read_len + 1); \n \n\tif (read_total_size > READ_BUCKET_SIZE) { \n\t\tread_bucket_num = (read_total_size + read_actual_size - 2) / read_actual_size; \n\t} \n \n\tfwrite(&read_bucket_num, sizeof(int), 1, fp_result_info); \n\tfwrite(&total_device_number, sizeof(int),", "pred": " *fp_result; \n\tFILE *fp_result_info; \n \n\tint64_t ref_total_size; \n\tint ref_len; \n\tint ref_bucket_num; \n\tint ref_bucket_count; \n\tint ref_bucket_index = 0; \n \n\tint64_t read_total_size = 0; \n\tint64_t read_total_count = 0; \n\tint read_len; \n\tint read_bucket_num = 0; \n\tint read_bucket_count = 0; \n\tint read_bucket_index = 0; \n\tint64_t read_actual_size = 0; \n \n\tint64_t preprocess_read_size; \n\tint64_t align_result_size; \n\tint64_t offload_read_size; \n\tint64_t offload_result_size; \n \n\tint word_num; \n\tint chunk_read_num; \n\tint offload_dvdh_size; \n\tint ref_start; \n\tint ref_end; \n \n\tint64_t *result_bucket_counts; \n\tint64_t *sse_result_bucket_counts; \n \n\tmic_read_t *read_ptr; \n\tmic_write_t *result_ptr; \n\tint64_t read_len_sum; \n\tint64_t result_len_sum; \n \n\tint64_t read_len_sum_max; \n\tint64_t result_len_sum_max; \n \n\tint64_t read_len_sum_min; \n\tint64_t result_len_sum_min; \n \n\tint64_t read_len_sum_max_min; \n \n\tint64_t read_len_sum_max_max; \n \n\tint64_t read_len_sum_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t read_len_sum_max_min_max; \n \n\tint64_t read_len_sum_min_max_min; \n \n\tint64_t"}
{"label": " \nvoid Pyuv422toMono(unsigned char *input_ptr, unsigned char *output_ptr, const unsigned int width, \n                   const unsigned int height, const int upsideDown) { \n    unsigned int i; \n    const int size = width * height / 2; \n    for (i = 0; i < size; i++) { \n        unsigned char *b = input_ptr + 4 * (upsideDown? i : (size - 1 - i)); \n        unsigned char Y = b[0]; \n        unsigned char Y1 = b[2]; \n        unsigned char *output_pt = output_ptr + 2 * i; \n        if (!upsideDown) { \n            *output_pt++ = Y; \n            *output_pt = Y1; \n        } else { \n            *output_pt++ = Y1; \n            *output_pt = Y; \n        } \n    } \n} ", "pred": " \nvoid Pyuv422toMono(unsigned char *input_ptr, unsigned char *output_ptr, const unsigned int width, \n                   const unsigned int height, const int upsideDown) { \n    unsigned int i; \n    const int size = width * height / 2; \n    for (i = 0; i < size; i++) { \n        unsigned char *b = input_ptr + 4 * (upsideDown? i : (size - 1 - i)); \n        unsigned char Y = b[0]; \n        unsigned char Y1 = b[2]; \n        unsigned char *output_pt = output_ptr + 2 * i; \n        if (!upsideDown) { \n            *output_pt++ = Y; \n            *output_pt = Y1; \n        } else { \n            *output_pt++ = Y1; \n            *output_pt = Y; \n        } \n    } \n   "}
{"label": " \nvoid Pyuv420torgb(unsigned char *Ydata, unsigned char *Udata, unsigned char *Vdata, unsigned char *outR, \n                  unsigned char *outG, unsigned char *outB, const unsigned int width, const unsigned int height) { \n    unsigned int i, j; \n \n    const int stride0 = width; \n    const int stride1 = width / 2; \n    const int stride2 = width / 2; \n    for (i = 0; i < height; i++) \n        for (j = 0; j < width; j++) { \n            unsigned char Y = Ydata[i * stride0 + j]; \n            unsigned char U = Udata[(i / 2) * stride1 + (j / 2)]; \n            unsigned char V = Vdata[(i / 2) * stride2 + (j / 2)]; \n            *(outR + i * width + j) = R_FROMYV(Y, V); \n            *(outG + i * width + j) = ALLDATAMONO? 128 : G_FROMYUV(Y, U, \n                                                                    V);  \n \n            *(outB + i * width + j) = ALLDATAMONO? 128 : B_FROMYU(Y, U); \n        } \n} ", "pred": " \nvoid Pyuv420torgb(unsigned char *Ydata, unsigned char *Udata, unsigned char *Vdata, unsigned char *outR, \n                  unsigned char *outG, unsigned char *outB, const unsigned int width, const unsigned int height) { \n    unsigned int i, j; \n \n    const int stride0 = width; \n    const int stride1 = width / 2; \n    const int stride2 = width / 2; \n    for (i = 0; i < height; i++) \n        for (j = 0; j < width; j++) { \n            unsigned char Y = Ydata[i * stride0 + j]; \n            unsigned char U = Udata[(i / 2) * stride1 + (j / 2)]; \n            unsigned char V = Vdata[(i / 2) * stride2 + (j / 2)]; \n            *(outR + i * width + j) = R_FROMYV(Y, V); \n            *(outG + i * width + j) = G_FROMYV(Y, V); \n            *(outB + i * width + j) = B_FROMYV(Y, V); \n        } \n        \n    return; \n} \n\nvoid Pyuv420torgb_32(unsigned char *Ydata, unsigned char *Udata, unsigned char *Vdata, unsigned char *outR, \n                     unsigned char *outG, unsigned char *outB, const unsigned int width"}
{"label": " \nint place_halos(long Nend, float *HaloMass, long Nlin, long NTotPart, float *PartX, float *PartY, float *PartZ, float *PartVX, float *PartVY, float *PartVZ,float L, float rho_ref, long seed, float mp, double *alpha, double *Malpha,long Nalpha,float *HaloX, float *HaloY, float *HaloZ, float *HaloVX, float *HaloVY, float *HaloVZ,float *HaloR,long **ListOfPart, long *NPartPerCell){ \n \n \nfprintf(stderr,\"\\tThis is place_halos.c v11\\n\"); \n \n \n \n \n\tlong i,j,k,lin_ijk, Nmin; \n\tlong *count,trials; \n\tlong ihalo,ilong, ipart,i_alpha; \n\tdouble invL = 1./L; \n\tfloat Mcell,Mhalo,Mchange;  \n\tfloat R; \n\ttime_t t0; \n\tint check; \n \n\tdouble mpart; \n\tdouble exponent; \n\tdouble TotProb; \n\tdouble *MassLeft; \n\tdouble *CumulativeProb;  \n\tlong **ListOfHalos,  *NHalosPerCell; \n\tlong Nstart=0,Nhalos; \n \n\t#ifdef VERB \n\ttime_t t1,t2,t3,t4,t4_5,t5; \n\tfloat diff; \n\t#endif \n \n\tNCells = Nlin; \n\tLbox = L; \n\t \n\tt0=time(NULL); \n\tNTotCells = NCells*NCells*NCells; \n\t \n\tMassLeft = malloc(NTotCells*sizeof(double)); \n \n \n\t \n \n\t \n \n   \n \n\tNHalosPerCell = (long *) calloc(NTotCells,sizeof(long)); \n  \tif(NHalosPerCell == NULL) { \n    \t\tfprintf(stderr,\"\\tplace_halos(): could not allocate %ld array for NHalosPerCell[]\\nABORTING\",NTotCells); \n    \t\texit(-1); \n\t} \n\tcount = (long *) calloc(NTotCells,sizeof(long)); \n  \tif(count == NULL) { \n    \t\tfprintf(stderr,\"\\tplace_halos(): could not allocate %ld array for NTotCells[]\\nABORTING\",NTotCells); \n    \t\texit(-1); \n\t} \n\tCumulativeProb = (double *) calloc(NTotCells, sizeof(double)); \n  \tif(CumulativeProb == NULL) { \n    \t\tfprintf(stderr,\"\\tplace_halos(): could not allocate %ld array for CumulativeProb[]\\nABORTING\",NTotCells); \n    \t\texit(-1); \n\t} \n\tfprintf(stderr,\"\\tUsing OMP with %d threads\\n\",omp_get_max_threads()); \n\t \n\t#ifdef MASS_OF_PARTS \n\tNexcluded = (long *) calloc(NTotCells,sizeof(long)); \n  \tif(Nexcluded == NULL) { \n    \t\tfprintf(stderr,\"\\tplace_halos(): could not allocate %ld array for Nexcluded[]\\nABORTING\",NTotCells); \n    \t\texit(-1); \n\t} \n \texcluded  = (int *) calloc(NTotPart, sizeof(long)); \n  \tif(excluded == NULL) { \n    \t\tfprintf(stderr,\"\\tplace_halos(): could not allocate %ld array for excluded[]\\nABORTING\",NTotPart); \n    \t\texit(-1); \n\t} \n\t#endif \n \n         \n \n\t#ifdef VERB \n        fprintf(stderr,\"\\tinput seed: %ld.    time0: %ld.\",seed,t0); \n\t#endif \n \n        if (seed>=0){ \n                srand(seed); \n\t\t#ifdef VERB \n        \tfprintf(stderr,\"Used: %ld \\n\",seed); \n\t\t#endif \n\t} \n        else { \n                srand(t0); \n        \tfprintf(stderr,\"Seed Used: %ld \\n\",t0); \n\t} \n \n\tmpart = (double) mp; \n\t \n \n\tNmin = (long)ceil(HaloMass[Nend-1]*0.8/mpart); \n \n\tlcell = (float) L/NCells; \n\t#ifdef VERB \n\tfprintf(stderr,\"\\n\\tParticles and Halos placed in %ld^3 cells\\n\",NCells); \n\tfprintf(stderr,\"\\tBOX = %f  lcell =%f   rho_ref = %e  invL %f\\n\",L,L/NCells,rho_ref,invL); \n\tfprintf(stderr,\"\\tNhalostart = %ld,Nhalosend = %ld,  NPart = %ld\\n\",Nstart, Nend, NTotPart); \n\t#endif \n\t \n \n\t#ifdef DEBUG \n\tfprintf(stderr,\"\\n\\tRAND_MAX=%d\\n\",RAND_MAX); \n\tfprintf(stderr,\"\\tX[0] = %f Y[0] = %f Z[0] = %f\\n\",PartX[0],PartY[0],PartZ[0]); \n\tfprintf(stderr,\"\\tX[1] = %f Y[1] = %f Z[1] = %f\\n\",PartX[1],PartY[1],PartZ[1]); \n\tfprintf(stderr,\"\\tM[0] = %e \\n\",HaloMass[0]); \n\tfprintf(stderr,\"\\tM[1] = %e \\n\",HaloMass[1]); \n\tfprintf(stderr,\"\\tM[%ld] = %e \\n\",Nend-1,HaloMass[Nend-1]); \n\tfprintf(stderr,\"\\n\\tMinimmum mass= %e. Minimum part per halo = %ld. mpart %e\\n\",HaloMass[Nend-1],Nmin,mpart); \n\t#endif\t \n\t \n\tif (L/NCells<R_from_mass(HaloMass[0],rho_ref)){ \n\t\tfprintf(stderr,\"ERROR: cell size is smaller than the radius of the biggest halo. Please, change the number of cells\\n\"); \n\t\texit(0); \n\t} \n\t \n\t#ifdef VERB \n\tt1=time(NULL); \n \tdiff = difftime(t1,t0); \n\tfprintf(stderr,\"\\ttime of initialisation %f\\n\",diff); \n\t#endif \n \n \n \n \n \n\tfprintf(stderr,\"\\tAssigning particles to grid...\\n\"); \n \n \n \n \n\t \n \n\t \n \n\tfprintf(stderr,\"\\t... particles counted...\\n\"); \n\tt2=time(NULL); \n \tdiff = difftime(t2,t1); \n\tfprintf(stderr,\"\\ttime counting %f\\n\",diff); \n\t \n \n\t \n \n\tListOfHalos = (long **) calloc(NCells*NCells*NCells,sizeof(long *)); \n\tfor (i=0;i<NCells;i++){ \n\tfor (j=0;j<NCells;j++){ \n\tfor (k=0;k<NCells;k++){ \n\t\tlin_ijk = k+j*NCells+i*NCells*NCells; \n\t\t \n \n\t\tNhalos = (long) (NPartPerCell[lin_ijk]/Nmin); \n\t\tListOfHalos[lin_ijk] = (long *) calloc(Nhalos,sizeof(long)); \n\t\tif (Nstart==0) \n\t\t\tMassLeft[lin_ijk] = (double) NPartPerCell[lin_ijk]*mpart;  \n\t\tif (lin_ijk<10 || lin_ijk > (NCells*NCells*NCells) - 10){ \n\t\t\tfprintf(stderr,\"\\tAllocated %ld (longs) in ListOfPart(%ld=[%ld,%ld,%ld])\\n\",NPartPerCell[lin_ijk],lin_ijk,i,j,k); \n\t\t\tfprintf(stderr,\"\\tAllocated %ld (longs) in ListOfHalos(%ld=[%ld,%ld,%ld])\\n\",Nhalos,lin_ijk,i,j,k); \n\t\t} \n\t}\t \n\t} \n\t} \n \n\tfprintf(stderr,\"\\t... memory allocated...\\n\"); \n\tt3=time(NULL); \n \tdiff = difftime(t3", "pred": " \nint place_halos(long Nend, float *HaloMass, long Nlin, long NTotPart, float *PartX, float *PartY, float *PartZ, float *PartVX, float *PartVY, float *PartVZ,float L, float rho_ref, long seed, float mp, double *alpha, double *Malpha,long Nalpha,float *HaloX, float *HaloY, float *HaloZ, float *HaloVX, float *HaloVY, float *HaloVZ,float *HaloR,long **ListOfPart, long *NPartPerCell){ \n \n \nfprintf(stderr,\"\\tThis is place_halos.c v11\\n\"); \n \n \n \n \n\tlong i,j,k,lin_ijk, Nmin; \n\tlong *count,trials; \n\tlong ihalo,ilong, ipart,i_alpha; \n\tdouble invL = 1./L; \n\tfloat Mcell,Mhalo,Mchange;  \n\tfloat R; \n\ttime_t t0; \n\tint check; \n \n\tdouble mpart; \n\tdouble exponent; \n\tdouble TotProb; \n\tdouble *MassLeft; \n\tdouble *CumulativeProb;  \n\tlong **ListOfHalos,  *NHalosPerCell; \n \n\tlong Npart,NpartPerCell; \n \n\tlong Ntot,NtotPerCell; \n \n\tfloat *PartX, *PartY, *PartZ; \n\tfloat *PartVX, *PartVY, *PartVZ; \n\tfloat *PartR; \n \n\tfloat *HaloX, *HaloY, *HaloZ; \n\tfloat *HaloVX, *HaloVY, *HaloVZ; \n \n\tfloat *HaloR; \n \n\tfloat *HaloMass; \n \n\tfloat *PartX_old, *PartY_old, *PartZ_old; \n \n\tfloat *PartVX_old, *PartVY_old, *PartVZ_old; \n \n\tfloat *PartR_old; \n \n\tfloat *PartX_new, *PartY_new, *PartZ_new; \n \n\tfloat *PartVX_new, *PartVY_new, *PartVZ_new; \n \n\tfloat *PartR_new; \n \n\tfloat *PartX_old_new, *PartY_old_new, *PartZ_old_new; \n \n\tfloat *PartVX_old_new, *PartVY_old_new, *PartVZ_old_new; \n \n\tfloat *PartR_old_new; \n \n\tfloat *PartX_new_new, *PartY_new_new, *PartZ_new_new; \n \n\tfloat *PartVX_new_new, *PartVY_new_new, *PartVZ_new_new; \n \n\tfloat *PartR_new_new; \n \n\tfloat *PartX_old_new_new, *PartY_old_new_new, *PartZ_old_new_new; \n \n\tfloat *PartVX_old_new_new, *PartVY_old_new_new, *PartVZ_old_new_new; \n \n\tfloat *PartR_old_new_new; \n \n\tfloat *PartX_new_new_new, *PartY_new_new_new, *PartZ_new_new_new; \n \n\tfloat *PartVX_new_new_new, *PartVY_new_new_new, *PartVZ_new_new_new; \n \n\tfloat *PartR_new_new_new; \n \n\tfloat *PartX_old_new_new_new, *PartY_old_new_new_new, *PartZ_old_new_new_new; \n \n\tfloat *PartVX_old_new_new_new, *PartVY_old_new_new_new, *PartVZ_old_new_new_new; \n \n\tfloat *PartR_old_new_new_new; \n \n\tfloat *PartX_new_new_new_new, *PartY_new_new_new_new, *PartZ_new_new_new_new; \n \n\tfloat *PartVX_new_new_new_new, *PartVY_new_new_new_new, *PartVZ_new_new_new_new; \n \n\tfloat *PartR_new_new_new_new; \n \n\tfloat *PartX_old_new_new_new_new, *PartY_old_new_new_new_new, *PartZ_old_new_new_new_new; \n \n\tfloat *PartVX_old_new_new_new_new, *PartVY_old_new_new_new_new, *PartVZ_old_new_new_new_new; \n \n\tfloat *PartR_old_new_new_new_new; \n \n\tfloat *PartX_new_new_new_new_new, *PartY_new_new_new_new_new, *PartZ_new_new_new_new_new; \n \n\tfloat *PartVX_new_new_new_new_new, *PartVY_new_new_new_new_new, *PartVZ_new_new_new_new_new; \n \n\tfloat *PartR_new_new_new_new_new; \n \n\tfloat *PartX_old_new_new_new_new_new, *PartY_old_new_new_new_new_new, *PartZ_old_new_new_new_new_new; \n \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "}
{"label": " \nvoid set_grid_ptrs( GridPoint * energy_grid, NuclideGridPoint ** nuclide_grids, \n                    long n_isotopes, long n_gridpoints ) \n{ \n\tint mype = 0; \n \n\t#ifdef MPI \n\tMPI_Comm_rank(MPI_COMM_WORLD, &mype); \n\t#endif \n\t \n\tif( mype == 0 ) printf(\"Assigning pointers to Unionized Energy Grid...\\n\"); \n\t#ifdef OPENMP \n\t#endif \n\tfor( long i = 0; i < n_isotopes * n_gridpoints ; i++ ) \n\t{ \n\t\tint nthreads = 1, tid = 0; \n\t\tdouble quarry = energy_grid[i].energy; \n \n\t\t#ifdef OPENMP \n\t\tnthreads = omp_get_num_threads(); \n\t\ttid = omp_get_thread_num(); \n\t\t#endif \n \n\t\tif( INFO && mype == 0 && tid == 0 && i % 200 == 0 ) \n\t\t\tprintf(\"\\rAligning Unionized Grid...(%.0lf%% complete)\", \n\t\t\t       100.0 * (double) i / (n_isotopes*n_gridpoints / \n\t\t\t\t                         nthreads)     ); \n\t\tfor( long j = 0; j < n_isotopes; j++ ) \n\t\t{ \n\t\t\t \n \n\t\t\t \n \n\t\t\tenergy_grid[i].xs_ptrs[j] =  \n\t\t\t\tbinary_search( nuclide_grids[j], quarry, n_gridpoints); \n\t\t} \n\t} \n\tif( mype == 0 ) printf(\"\\n\"); \n \n\t \n \n\t \n \n} ", "pred": " \nvoid set_grid_ptrs( GridPoint * energy_grid, NuclideGridPoint ** nuclide_grids, \n                    long n_isotopes, long n_gridpoints ) \n{ \n\tint mype = 0; \n \n\t#ifdef MPI \n\tMPI_Comm_rank(MPI_COMM_WORLD, &mype); \n\t#endif \n\t \n\tif( mype == 0 ) printf(\"Assigning pointers to Unionized Energy Grid...\\n\"); \n\t#ifdef OPENMP \n\t#endif \n\tfor( long i = 0; i < n_isotopes * n_gridpoints ; i++ ) \n\t{ \n\t\tint nthreads = 1, tid = 0; \n\t\tdouble quarry = energy_grid[i].energy; \n \n\t\t#ifdef OPENMP \n\t\tnthreads = omp_get_num_threads(); \n\t\ttid = omp_get_thread_num(); \n\t\t#endif \n \n\t\tif( INFO && mype == 0 && tid == 0 && i % 200 == 0 ) \n\t\t\tprintf(\"\\rAligning Unionized Grid...(%.0lf%% complete)\", \n\t\t\t       100.0 * (double) i / (n_isotopes*n_gridpoints / nthreads)); \n \n\t\tnuclide_grids[i] = new NuclideGridPoint( quarry, nthreads ); \n\t} \n \n\t#ifdef OPENMP \n\t#endif \n\tif( INFO && mype == 0 && tid == 0 && n_isotopes * n_gridpoints % 200 == 0 ) \n\t\tprintf(\"\\rAligning Unionized Grid...(%.0lf%% complete)\", \n\t\t       100.0 * (double) n_isotopes * n_gridpoints / nthreads); \n \n\t#ifdef OPENMP \n\t#endif \n\tif( INFO && m"}
{"label": "d RK_out(real *dest, real *fwn, real *fdtwn, const real dt,  \n\t    const int sizew) \n{ \n  for(int iw = 0; iw < sizew; iw++) { \n    dest[iw] = fwn[iw] + dt * fdtwn[iw]; \n  } \n} \n \n \n ", "pred": "d RK_out(real *dest, real *fwn, real *fdtwn, const real dt,  \n\t    const int sizew) \n{ \n  for(int iw = 0; iw < sizew; iw++) { \n    dest[iw] = fwn[iw] + dt * fdtwn[iw]; \n  } \n} \n \n \n "}
{"label": "  int\tcnt = 0; \n \n  for (i = 1; i<thds; i*=2) \n    ; \n \n  for (lp=thds1; lp>0; lp=lp/2) { \n    buf[cnt ++] += omp_get_num_threads (); \n  } \n} \n \n \nmain () \n{ \n  thds = omp_get_max_thre ", "pred": "  int\tcnt = 0; \n \n  for (i = 1; i<thds; i*=2) \n    ; \n \n  for (lp=thds1; lp>0; lp=lp/2) { \n    buf[cnt ++] += omp_get_num_threads (); \n  } \n} \n \n \nmain () \n{ \n  thds = omp_get_max_thre "}
{"label": "d RK4_final_inplace(real *w, real *l1, real *l2, real *l3,  \n\t\t       real *dtw, const real dt, const int sizew) \n{ \n  const real b = -1.0 / 3.0; \n  const real a[] = {1.0 / 3.0, 2.0 / 3.0, 1.0 / 3.0, dt / 6.0}; \n  for(int i = 0; i < sizew; ++i) { \n    w[i] =  \n      b * w[i] + \n      a[0] * l1[i] + \n      a[1] * l2[i] + \n      a[2] * l3[i] + \n      a[3] * dtw[i]; \n  } \n} \n \n \n ", "pred": "d RK4_final_inplace(real *w, real *l1, real *l2, real *l3,  \n\t\t       real *dtw, const real dt, const int sizew) \n{ \n  const real b = -1.0 / 3.0; \n  const real a[] = {1.0 / 3.0, 2.0 / 3.0, 1.0 / 3.0, dt / 6.0}; \n  for(int i = 0; i < sizew; ++i) { \n    w[i] =  \n      b * w[i] + \n      a[0] * l1[i] + \n      a[1] * l2[i] + \n      a[2] * l3[i] + \n      a[3] * dtw[i]; \n  } \n} \n \n \n "}
{"label": " \nint main() \n{ \n    int i; \n    for (i = 0; i  < 100; ++i) \n    { \n    } \n} ", "pred": " \nint main() \n{ \n    int i; \n    for (i = 0; i  < 100; ++i) \n    { \n    } \n} "}
{"label": " \nvoid recombine2d_pf1_ft1_es1_omp(struct recombine2d_worker *worker, \n                                 int subgrid_off1, \n                                 complex double *F, \n                                 complex double *NMBF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n    int y; \n \n    int BF_chunk_size = sizeof(double complex) * cfg->yP_size * worker->BF_batch; \n    double complex *BF_chunk = malloc(BF_chunk_size); \n    assert(cfg->BF_stride1 == 1); \n    assert(cfg->NMBF_BF_stride0 == 1); \n    assert(cfg->BF_stride0 == cfg->NMBF_BF_stride1); \n    assert(subgrid_off1 % cfg->subgrid_spacing == 0); \n \n    for (y = 0; y < cfg->yB_size; y+=worker->BF_batch) { \n \n         \n \n        double start = get_time_ns(); \n        int y2; \n        for (y2 = y; y2 < y+worker->BF_batch && y2 < cfg->yB_size; y2++) { \n            prepare_facet(cfg->yB_size, cfg->yP_size, cfg->Fb, \n                          F+y2*cfg->F_stride0, cfg->F_stride1, \n                          BF_chunk+(y2-y)*cfg->BF_stride0, cfg->BF_stride1); \n        } \n        worker->pf1_time += get_time_ns() - start; \n \n         \n \n        start = get_time_ns(); \n        fftw_execute_dft(worker->BF_plan, BF_chunk, BF_chunk); \n        worker->ft1_time += get_time_ns() - start; \n \n         \n \n        assert(subgrid_off1 % cfg->subgrid_spacing == 0); \n        int subgrid_offset = subgrid_off1 / cfg->subgrid_spacing * cfg->yP_spacing; \n        start = get_time_ns(); \n        for (y2 = y; y2 < y+worker->BF_batch && y2 < cfg->yB_size; y2++) { \n            extract_subgrid(cfg->yP_size, cfg->xM_yP_size, cfg->xMxN_yP_size, cfg->xM_yN_size, \n                            subgrid_offset, cfg->m, cfg->Fn, \n                            BF_chunk+(y2-y)*cfg->BF_stride0, cfg->BF_stride1, \n                            worker->MBF, worker->MBF_plan, \n                            NMBF+y2*cfg->NMBF_stride0, cfg->NMBF_stride1); \n        } \n        worker->es1_time += get_time_ns() - start; \n \n    } \n \n    free(BF_chunk); \n} ", "pred": " \nvoid recombine2d_pf1_ft1_es1_omp(struct recombine2d_worker *worker, \n                                 int subgrid_off1, \n                                 complex double *F, \n                                 complex double *NMBF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n    int y; \n \n    int BF_chunk_size = sizeof(double complex) * cfg->yP_size * worker->BF_batch; \n    double complex *BF_chunk = malloc(BF_chunk_size); \n    assert(cfg->BF_stride1 == 1); \n    assert(cfg->NMBF_BF_stride0 == 1); \n    assert(cfg->BF_stride0 == cfg->NMBF_BF_stride1); \n    assert(subgrid_off1 % cfg->subgrid_size1 == 0); \n    assert(subgrid_off1 / cfg->subgrid_size1 == cfg->subgrid_size1); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert(cfg->yP_size1 == cfg->yP_size); \n    assert(cfg->yP_size == cfg->yP_size1); \n    assert"}
{"label": " \ndouble **background_fsp(scan_t *scan_obj, int force_neutral_spectrum, \n\t\t\tchar *background_fsfname, int include_invariant) { \n  int m, k, i, depth, max_depth; \n  int __attribute__((unused))max_depth_p; \n  double fsp_sum, **fsp, *tmp_fsp, wa, wd; \n  int n_complete; \n \n  omp_init_lock(&thread_lock); \n  if (force_neutral_spectrum) return neutral_spectra(scan_obj); \n  if (background_fsfname) return load_spectra(scan_obj, background_fsfname); \n \n  logmsg(MSG_STATUS,\"Estimating background site frequency spectrum....   \"); \n  MA(fsp, sizeof(double *)*scan_obj->n_depths); \n  max_depth_p = -1; \n  max_depth = -1000; \n  for(m=0;m<scan_obj->n_depths;m++) { \n    MA(fsp[m], sizeof(double)*(scan_obj->sample_depths[m]+1)); \n    for(k=0;k<=scan_obj->sample_depths[m];k++) fsp[m][k] = 0.; \n \n    if (scan_obj->sample_depths[m] > max_depth) { \n      max_depth = scan_obj->sample_depths[m]; \n      max_depth_p = m; \n    } \n  } \n  log_fact(max_depth+1); \n  logmsg(MSG_STATUS,\"%d distinct sample depths observed. Maximum sample depth is %d haplotypes.\", scan_obj->n_depths, max_depth); \n  logmsg(MSG_DEBUG1,\"log(%d!) = %1.1f\", max_depth, log_fact(max_depth));  \n   \n  MA(tmp_fsp, sizeof(double)*(max_depth+1)); \n  for(k=0;k<=max_depth;k++) tmp_fsp[k] = 0.; \n  for(i=0;i<scan_obj->n_snps;i++) { \n     \n \n    depth = scan_obj->sample_depths[scan_obj->snps[i].depth_p]; \n    if (scan_obj->snps[i].folded) { \n      if (scan_obj->snps[i].obs_freq == 0) { \n\twa = 1; \n\twd = 0; \n      } else if (scan_obj->snps[i].obs_freq == depth) { \n\twa = 0; \n\twd = 1; \n      } else { \n\twa = 1./(scan_obj->snps[i].obs_freq); \n\twd = 1./(depth - scan_obj->snps[i].obs_freq); \n      } \n    } else { \n      wd = 1.; \n      wa = 0.; \n    } \n \n    if (depth == max_depth) { \n      tmp_fsp[scan_obj->snps[i].obs_freq] += wa/(wa + wd); \n      tmp_fsp[depth - scan_obj->snps[i].obs_freq] += wd/(wa + wd); \n    } else { \n       \n \n       \n \n       \n \n       \n \n    } \n  } \n \n  fsp_sum = 0.; \n  for(k=0;k<=max_depth;k++) fsp_sum += tmp_fsp[k]; \n  for(k=0;k<=max_depth;k++) tmp_fsp[k] /= fsp_sum; \n  logmsg(MSG_STATUS,\"Total SNPs observed at max depth %d is %1.1f (%1.1f%%)\", max_depth, fsp_sum, fsp_sum/(double) scan_obj->n_snps * 100.);   \n \n  n_complete = 0; \n  for(m=0;m<scan_obj->n_depths;m++) { \n    int k, depth; \n    double fsp_sum; \n \n    depth = scan_obj->sample_depths[m]; \n    hypergeometric_downsample_fsp(fsp[m], tmp_fsp, depth, \n\t\t\t\t  max_depth, include_invariant); \n     \n    fsp_sum = 0.; \n    for(k=0;k<=depth;k++) fsp_sum += fsp[m][k]; \n    for(k=0;k<=depth;k++) fsp[m][k] /= fsp_sum; \n \n    omp_set_lock(&thread_lock); \n    n_complete++; \n    cr_logmsg(MSG_STATUS,\"Estimating frequency spectrum for different sample\" \n\t    \" depths (%1.1f%%)\", n_complete/(double) scan_obj->n_depths * 100.); \n    omp_unset_lock(&thread_lock); \n  } \n  logmsg(MSG_STATUS,\"\\nDone estimating background frequency spectra.\"); \n \n  for(m=0;m<scan_obj->n_depths;m++) { \n    depth = scan_obj->sample_depths[m]; \n    MA(fsp[m], sizeof(double)*(depth+1)); \n \n    for(k=0;k<=depth;k++) fsp[m][k] = 0.; \n \n    for(i=0;i<scan_obj->n_snps;i++) { \n      if (scan_obj->snps[i].folded) { \n\tif (scan_obj->snps[i].obs_freq == 0) { \n\t  wa = 1; \n\t  wd = 0; \n\t} else if (scan_obj->snps[i].obs_freq == depth) { \n\t  wa = 1; \n\t  wd = 0; \n\t} else { \n\t  wa = 1./(scan_obj->snps[i].obs_freq); \n\t  wd = 1./(depth - scan_obj->snps[i].obs_freq); \n\t} \n      } else { \n\twd = 1.; \n\twa = 0.; \n      } \n \n      if (scan_obj->snps[i].depth_p == m) { \n\tfsp[m][scan_obj->snps[i].obs_freq] += wd/(wa+wd); \n\tfsp[m][depth - scan_obj->snps[i].obs_freq] += wa/(wa+wd); \n      } else { \n\tbinomial_sampling(fsp[m], wd/(wa+wd), depth,  \n\t\t\t  scan_obj->snps[i].obs_freq,  \n\t\t\t  scan_obj->sample_depths[scan_obj->snps[i].depth_p]); \n\tif (wa > 0.) \n\t  binomial_sampling(fsp[m], wa/(wa+wd), depth,  \n\t\t\t  scan_obj->sample_depths[scan_obj->snps[i].depth_p] - \n\t\t\t  scan_obj->snps[i].obs_freq,  \n\t\t\t  scan_obj->sample_depths[scan_obj->snps[i].depth_p]); \n      } \n    } \n \n    fsp_sum = 0.; \n    for(k=0;k<=scan_obj->sample_depths[m];k++) fsp_sum += fsp[m][k]; \n    for(k=0;k<=scan_obj->sample_depths[m];k++) fsp[m][k] /= fsp_sum; \n  }     \n \n  omp_destroy_lock(&thread_lock); \n  return fsp; \n} ", "pred": " \ndouble **background_fsp(scan_t *scan_obj, int force_neutral_spectrum, \n\t\t\tchar *background_fsfname, int include_invariant) { \n  int m, k, i, depth, max_depth; \n  int __attribute__((unused))max_depth_p; \n  double fsp_sum, **fsp, *tmp_fsp, wa, wd; \n  int n_complete; \n \n  omp_init_lock(&thread_lock); \n  if (force_neutral_spectrum) return neutral_spectra(scan_obj); \n  if (background_fsfname) return load_spectra(scan_obj, background_fsfname); \n \n  logmsg(MSG_STATUS,\"Estimating background site frequency spectrum....   \"); \n  MA(fsp, sizeof(double *)*scan_obj->n_depths); \n  max_depth_p = -1; \n  max_depth = -1000; \n  for(m=0;m<scan_obj->n_depths;m++) { \n    MA(fsp[m], sizeof(double)*(scan_obj->sample_depths[m]+1)); \n    for(k=0;k<=scan_obj->sample_depths[m];k++) fsp[m][k] = 0.0; \n    if (max_depth < scan_obj->sample_depths[m]) max_depth = scan_obj->sample_depths[m]; \n    if (max_depth_p < max_depth) max_depth_p = max_depth; \n  } \n  if (max_depth_p < 0) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d\\n\",max_depth_p); \n    return NULL; \n  } \n  if (max_depth_p == 0) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=0\\n\"); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n    logmsg(MSG_ERROR,\"Error: background_fsp: max_depth_p=%d > n_depths=%d\\n\",max_depth_p,scan_obj->n_depths); \n    return NULL; \n  } \n  if (max_depth_p > scan_obj->n_depths) { \n   "}
{"label": " \nvoid mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) \n{ \n\t \n \n\tif(nrhs!= 11) \n    { \n\t\tmexWarnMsgTxt(\"11 inputs required. Aborting...\"); \n\t\treturn; \n    } \n\telse if(nlhs < 1) \n    { \n\t\tmexWarnMsgTxt(\"At least one output required. Aborting...\"); \n\t\treturn; \n\t} \n \n\t \n \n\tint i, curr_angle, im_size, n_rays_y, n_rays_z, curr_ray_y, curr_ray_z, n_angles, ray_offset; \n\tmwSize im_size_matlab[3]; \n\tdouble *source_x, *source_y, *source_z, *det_x, *det_y, *det_z; \n    double cos_curr_angle, sin_curr_angle; \n\tdouble start[3], end[3], *voxel_size, *grid_offset, *angles; \n    float *ray_data, *vol_data; \n    double *size_doubles; \n \n\tstruct jacobs_options options; \n\t \n\t \n \n\tsize_doubles = mxGetPr(prhs[0]); \n\tfor(i = 0; i < 3; i++) \n    { \n\t    im_size_matlab[i] = (int) size_doubles[i]; \n    } \n \n\t \n \n\tn_rays_y = mxGetM(prhs[5]); \n    n_rays_z = mxGetM(prhs[6]); \n     \n     \n \n \tsource_x = mxGetPr(prhs[1]);  \n \tsource_y = mxGetPr(prhs[2]);  \n \tsource_z = mxGetPr(prhs[3]);  \n \tdet_x = mxGetPr(prhs[4]);  \n \tdet_y = mxGetPr(prhs[5]);  \n \tdet_z = mxGetPr(prhs[6]);  \n \n\t \n \n\tvoxel_size = mxGetPr(prhs[7]); \n\tgrid_offset = mxGetPr(prhs[8]); \n     \n    vol_data = (float *) mxGetData(prhs[9]); \n     \n    angles = mxGetPr(prhs[10]); \n     \n    n_angles = mxGetM(prhs[10]); \n     \n     \n \n    if (mxGetM(prhs[9])!= (im_size_matlab[0] * im_size_matlab[1] * im_size_matlab[2])) \n    { \n        mexWarnMsgTxt(\"Mismatched number of voxels! Aborting.\"); \n        return; \n    } \n \n\t \n \n\toptions.im_size_default = 0; \n\toptions.im_size_x = im_size_matlab[0]; \n\toptions.im_size_y = im_size_matlab[1]; \n\toptions.im_size_z = im_size_matlab[2]; \n \n\toptions.b_default = 0; \n\toptions.b_x = grid_offset[0]; \n\toptions.b_y = grid_offset[1]; \n\toptions.b_z = grid_offset[2]; \n \n\toptions.d_default = 0; \n\toptions.d_x = voxel_size[0]; \n\toptions.d_y = voxel_size[1]; \n\toptions.d_z = voxel_size[2]; \n \n\t \n \n\tplhs[0] = mxCreateNumericMatrix(n_rays_y * n_rays_z * n_angles, 1, mxSINGLE_CLASS, mxREAL); \n\tray_data = (float *) mxGetData(plhs[0]); \n \n\t \n \n    for(curr_angle = 0; curr_angle < n_angles; curr_angle++) \n    {    \t \n         \n \n        cos_curr_angle = cos(angles[curr_angle]); \n        sin_curr_angle = sin(angles[curr_angle]); \n         \n        start[0] = cos_curr_angle * (*source_x) - sin_curr_angle * (*source_y); \n        start[1] = sin_curr_angle * (*source_x) + cos_curr_angle * (*source_y); \n        start[2] = *source_z; \n         \n        ray_offset = curr_angle * n_rays_y * n_rays_z; \n         \n         \n \n        for(curr_ray_y = 0; curr_ray_y < n_rays_y; curr_ray_y++) \n        { \n            end[0] = cos_curr_angle * (*det_x) - sin_curr_angle * det_y[curr_ray_y]; \n            end[1] = sin_curr_angle * (*det_x) + cos_curr_angle * det_y[curr_ray_y]; \n             \n             \n \n            for(curr_ray_z = 0; curr_ray_z < n_rays_z; curr_ray_z++) \n            { \n                end[2] = det_z[curr_ray_z]; \n \n\t\t\t\t \n \n                project_singledata(im_size, start, end, &ray_data[ray_offset + curr_ray_z*n_rays_y + curr_ray_y], vol_data, &options); \n            } \n        } \n    } \n} ", "pred": " \nvoid mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) \n{ \n\t \n \n\tif(nrhs!= 11) \n    { \n\t\tmexWarnMsgTxt(\"11 inputs required. Aborting...\"); \n\t\treturn; \n    } \n\telse if(nlhs < 1) \n    { \n\t\tmexWarnMsgTxt(\"At least one output required. Aborting...\"); \n\t\treturn; \n\t} \n \n\t \n \n\tint i, curr_angle, im_size, n_rays_y, n_rays_z, curr_ray_y, curr_ray_z, n_angles, ray_offset; \n\tmwSize im_size_matlab[3]; \n\tdouble *source_x, *source_y, *source_z, *det_x, *det_y, *det_z; \n    double cos_curr_angle, sin_curr_angle; \n\tdouble start[3], end[3], *voxel_size, *grid_offset, *angles; \n    float *ray_data, *vol_data; \n    double *size_doubles; \n \n\tstruct jacobs_options options; \n\t \n\t \n \n\tsize_doubles = mxGetPr(prhs[0]); \n\tvol_data = mxGetPr(prhs[1]); \n\tgrid_offset = mxGetPr(prhs[2]); \n\tangles = mxGetPr(prhs[3]); \n\tray_data = mxGetPr(prhs[4]); \n\tvoxel_size = mxGetPr(prhs[5]); \n\tsize_doubles[0] = mxGetPr(prhs[6]); \n\tsize_doubles[1] = mxGetPr(prhs[7]); \n\tsize_doubles[2] = mxGetPr(prhs[8]); \n\tvol_data[0] = mxGetPr(prhs[9]); \n\tvol_data[1] = mxGetPr(prhs[10]); \n\tvol_data[2] = mxGetPr(prhs[11]); \n\tgrid_offset[0] = mxGetPr(prhs[12]); \n\tgrid_offset[1] = mxGetPr(prhs[13]); \n\tgrid_offset[2] = mxGetPr(prhs[14]); \n\tangles[0] = mxGetPr(prhs[15]); \n\tangles[1] = mxGetPr(prhs[16]); \n\tangles[2] = mxGetPr(prhs[17]); \n\tray_data[0] = mxGetPr(prhs[18]); \n\tray_data[1] = mxGetPr(prhs[19]); \n\tray_data[2] = mxGetPr(prhs[20]); \n\tvoxel_size[0] = mxGetPr(prhs[21]); \n\tvoxel_size[1] = mxGetPr(prhs[22]); \n\tvoxel_size[2] = mxGetPr(prhs[23]); \n\tvol_data[3] = mxGetPr(prhs[24]); \n\tvol_data[4] = mxGetPr(prhs[25]); \n\tvol_data[5] = mxGetPr(prhs[26]); \n\tvol_data[6] = mxGetPr(prhs[27]); \n\tvol_data[7] = mxGetPr(prhs[28]); \n\tvol_data[8] = mxGetPr(prhs[29]); \n\tvol_data[9] = mxGetPr(prhs[30]); \n\tvol_data[10] = mxGetPr(prhs[31]); \n\tvol_data[11] = mxGetPr(prhs[32]); \n\tgrid_offset[3] = mxGetPr(prhs[33]); \n\tangles[3] = mxGetPr(prhs[34]); \n\tray_data[3] = mxGetPr(prhs[35]); \n\tray_data[4] = mxGetPr(prhs[36]); \n\tray_data[5] = mxGetPr(prhs[37]); \n\tray_data[6] = mxGetPr(prhs[38]); \n\tray_data[7] = mxGetPr(prhs[39]); \n\tray_data[8] = mxGetPr(prhs[40]); \n\tray_data[9] = mxGetPr(prhs[41]); \n\tray_data[10] = mxGetPr(prhs[42]); \n\tray_data[11] = mxGetPr(prhs[43]); \n\tvoxel_size[3] = mxGetPr(prhs[44]); \n\tvoxel_size[4] = mxGetPr(prhs[45]); \n\tvoxel_size[5] = mxGetPr(prhs[46]); \n\tvoxel_size[6] = mxGetPr(prhs[47]); \n\tvoxel_size[7] = mxGetPr(prhs[48]); \n\tvoxel_size[8] = mxGetPr(prhs[49]); \n\tvoxel_size[9] = mxGetPr(prhs[50]); \n\tvoxel_size[10] = mxGetPr(prhs[51]); \n\tvoxel_size[11] = mxGetPr(prhs[52]); \n\tvol_data[12] = mxGetPr(prhs[53]); \n\tvol_data[13] = mxGetPr(prhs[54]); \n\tvol_data[14] = mxGetPr(prhs[55]); \n\tvol_data[15] = mxGetPr(prhs[56]); \n\tvol_data[16] = mxGetPr(prhs[57]); \n\tvol_data[17] = mxGetPr(prhs[58]); \n\tvol_data[18] = mxGetPr(prhs[59]); \n\tvol_data[19] = mxGetPr(prhs[60]); \n\tvol_data[20] = mxGetPr(prhs[61]); \n\tvol_data[21] = mxGetPr(prhs[62]); \n\tvol_data[22] = mxGetPr(prhs[63]); \n\tvol_data[23] = mxGetPr(prhs[64]); \n\tvol_data[24] = mxGetPr(prhs[65]); \n\tvol_data[25] = mxGetPr(prhs[66]); \n\tvol_data[26] = mxGetPr(prhs[67]); \n\tvol_data[27] = mxGetPr(prhs[68]); \n\tvol_data[28] = mxGetPr(prhs[69]); \n\tvol_data[29] = mxGetPr(prhs[70]); \n\tvol_"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 32; \n  tile_size[3] = 32; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,4);t1++) { \n    lbp=max(ceild(t1,2),ceild(8*t1-Nt+3,8)); \n    ubp=min(floord(Nt+Nz-4,8),floord(4*t1+Nz+1,8)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(t1-7,8)),ceild(8*t2-Nz-28,32));t3<=min(min(min(floord(Nt+Ny-4,32),floord(4*t1+Ny+5,32)),floord(8*t2+Ny+4,32)),floord(8*t1-8*t2+Nz+Ny+3,32));t3++) { \n        for (t4=max(max(max(0,ceild(t1-7,8)),ceild(8*t2-Nz-28,32)),ceild(32*t3-Ny-28,32));t4<=min(min(min(min(floord(Nt+Nx-4,32),floord(4*t1+Nx+5,32)),floord(8*t2+Nx+4,32)),floord(32*t3+Nx+28,32)),floord(8*t1-8*t2+Nz+Nx+3,32));t4++) { \n          for (t5=max(max(max(max(max(0,4*t1),8*t1-8*t2+1),8*t2-Nz+2),32*t3-Ny+2),32*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,4*t1+7),8*t2+6),32*t3+30),32*t4+30),8*t1-8*t2+Nz+5);t5++) { \n            for (t6=max(max(8*t2,t5+1),-8*t1+8*t2+2*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(32*t3,t5+1);t7<=min(32*t3+31,t5+Ny-2);t7++) { \n                lbv=max(32*t4,t5+1); \n                ubv=min(32*t4+31,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = (((((((coef[0][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (coef[1][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)])) + (coef[2][ (-t5+t6)][ (-t5+t7)][", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    coef[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      coef[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_v[i] = (double **) malloc(sizeof(double"}
{"label": " \nvoid \ntime_3d_complex_double_omp() \n{ \n  int nthr = omp_get_max_threads(); \n  int nthr = 1; \n  int nnodes = nthr; \n  fprintf (stderr, \"Using %d threads.\\n\", nthr); \n \n  int Nx=32; int Ny=32; int Nz = 32; \n  int num_splines = 256; \n \n  Ugrid x_grid, y_grid, z_grid; \n  x_grid.start = 3.1; x_grid.end =  9.1; x_grid.num = Nx; \n  y_grid.start = 8.7; y_grid.end = 12.7; y_grid.num = Ny; \n  z_grid.start = 4.5; z_grid.end =  9.3; z_grid.num = Nz; \n \n  BCtype_z xBC, yBC, zBC; \n  xBC.lCode = xBC.rCode = PERIODIC; \n  yBC.lCode = yBC.rCode = PERIODIC; \n  zBC.lCode = zBC.rCode = PERIODIC; \n \n   \n \n  UBspline_3d_z* norm_splines[num_splines]; \n  multi_UBspline_3d_z *multi_spline[nthr]; \n   \n   \n \n  for (int node=0; node<nthr; node++)  \n  { \n     \n \n     \n \n     \n \n     \n \n    multi_spline[node] = create_multi_UBspline_3d_z \n      (x_grid, y_grid, z_grid, xBC, yBC, zBC, num_splines); \n  } \n \n  double data[Nx*Ny*Nz*2]; \n   \n \n  for (int i=0; i<num_splines; i++) { \n    for (int j=0; j<Nx*Ny*Nz; j++) \n      data[j] = (drand48()-0.5); \n    norm_splines[i] = create_UBspline_3d_z \n      (x_grid, y_grid, z_grid, xBC, yBC, zBC, (complex_double*)data); \n    for (int node=0; node<nthr; node++) { \n       \n \n       \n \n       \n \n       \n \n      set_multi_UBspline_3d_z (multi_spline[node], i, data); \n    } \n  } \n   \n   \n \n  double rand_start, rand_end, norm_start[nthr], norm_end[nthr], multi_start[nthr], multi_end[nthr]; \n  int num_vals = 10000; \n  complex_double multi_vals[nthr][num_splines], norm_vals[nthr][num_splines]; \n  complex_double multi_grads[nthr][3*num_splines], norm_grads[nthr][3*num_splines]; \n  complex_double multi_lapl[nthr][num_splines], norm_lapl[nthr][num_splines]; \n  complex_double multi_hess[nthr][9*num_splines], norm_hess[nthr][9*num_splines]; \n \n  rand_start = get_time(); \n  for (int i=0; i<num_vals; i++) { \n    double rx = drand48();  double x = rx*x_grid.start + (1.0-rx)*x_grid.end; \n    double ry = drand48();  double y = ry*y_grid.start + (1.0-ry)*y_grid.end; \n    double rz = drand48();  double z = rz*z_grid.start + (1.0-rz)*z_grid.end; \n  } \n  rand_end = get_time(); \n \n   \n \n   \n \n   \n \n  double rx = drand48();  double x = rx*x_grid.start + (1.0-rx)*x_grid.end; \n  double ry = drand48();  double y = ry*y_grid.start + (1.0-ry)*y_grid.end; \n  double rz = drand48();  double z = rz*z_grid.start + (1.0-rz)*z_grid.end; \n \n  int thr_per_node = nthr/nthr; \n \n  for (int thr=0; thr<nthr; thr++) { \n    int node = thr/thr_per_node; \n    multi_start[thr] = get_time(); \n    for (int i=0; i<num_vals; i++) { \n      double rx = drand48();  double x = rx*x_grid.start + (1.0-rx)*x_grid.end;  \n      double ry = drand48();  double y = ry*y_grid.start + (1.0-ry)*y_grid.end;  \n      double rz = drand48();  double z = rz*z_grid.start + (1.0-rz)*z_grid.end;  \n      eval_multi_UBspline_3d_z (multi_spline[node], x, y, z, multi_vals[thr]); \n    } \n    multi_end[thr] = get_time(); \n  } \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n   \n  double norm_avg=0.0, multi_avg=0.0; \n \n  for (int thr=0; thr<nthr; thr++) { \n    double norm_time   = (double)(norm_end[thr] - norm_start[thr] + rand_start - rand_end); \n    double multi_time  = (double)(multi_end[thr] - multi_start[thr] + rand_start - rand_end); \n    norm_avg += norm_time; \n    multi_avg += multi_time; \n  } \n  norm_avg  /= nthr; \n  multi_avg /= nthr; \n  double norm_speed  = (double) num_vals*num_splines / norm_avg; \n  double multi_speed = (double) num_vals*num_splines / multi_avg; \n \n   \n \n   \n \n  fprintf (stderr, \"Multi  value speed = %13.3f evaluations per second.\\n\",  \n  \t   multi_speed); \n  fprintf (stderr, \"Aggregate bandwidth = %1.3f GB/s per socket\\n\", multi_speed * 64.0*16.0 * 8 * 1.0e-9); \n  fprintf (stderr, \"%1.3f GFLOPS per socket\\n\", multi_speed * 64.0*4.0 * 8 * 1.0e-9); \n \n   \n   \n \n   \n \n   \n \n  for (int thr=0; thr<nthr; thr++) { \n    int node = thr/thr_per_node; \n    multi_start[thr] = get_time(); \n    for (int i=0; i<num_vals; i++) { \n      double rx = drand48();  double x = rx*x_grid.start + (1.0-rx)*x_grid.end; \n      double ry = drand48();  double y = ry*y_grid.start + (1.0-ry)*y_grid.end; \n      double rz = drand48();  double z = rz*z_grid.start + (1.0-rz)*z_grid.end; \n      eval_multi_UBspline_3d_z_vgh  \n\t(multi_spline[node], x, y, z,  multi_vals[thr],  \n\t multi_grads[thr], multi_hess[thr]); \n    } \n    multi_end[thr] = get_time(); \n  } \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  norm_avg = multi_avg = 0.0", "pred": " \nvoid \ntime_3d_complex_double_omp() \n{ \n  int nthr = omp_get_max_threads(); \n  int nthr = 1; \n  int nnodes = nthr; \n  fprintf (stderr, \"Using %d threads.\\n\", nthr); \n \n  int Nx=32; int Ny=32; int Nz = 32; \n  int num_splines = 256; \n \n  Ugrid x_grid, y_grid, z_grid; \n  x_grid.start = 3.1; x_grid.end =  9.1; x_grid.num = Nx; \n  y_grid.start = 8.7; y_grid.end = 12.7; y_grid.num = Ny; \n  z_grid.start = 4.5; z_grid.end =  9.3; z_grid.num = Nz; \n \n  BCtype_z xBC, yBC, zBC; \n  xBC.lCode = xBC.rCode = PERIODIC; \n  yBC.lCode = yBC.rCode = PERIODIC; \n  zBC.lCode = zBC.rCode = PERIODIC; \n \n   \n \n  UBspline_3d_z* norm_splines[num_splines]; \n  \n  complex_double data[Nx*Ny*Nz]; \n  // Now, create the splines. \n  \n  for (int i=0; i<num_splines; i++) { \n    splines[i] = create_UBspline_3d_z (x_grid, y_grid, z_grid, xBC, yBC, zBC, data); \n    norm_splines[i] = (UBspline_3d_z*) splines[i]; \n  } \n \n  // Now, create the complex inverse z=f(x). \n  complex_double data_in[Nx*Ny*Nz]; \n  // First, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_in[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out[Nx*Ny*Nz]; \n  \n  // First, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_out[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out_in[Nx*Ny*Nz]; \n  \n  // First, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_out_in[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out_out[Nx*Ny*Nz]; \n  \n  // First, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_out_out[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out_out_in[Nx*Ny*Nz]; \n  \n  // First, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_out_out_in[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out_out_out[Nx*Ny*Nz]; \n  \n  // First, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_out_out_out[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out_out_out_in[Nx*Ny*Nz]; \n  \n  // First, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_out_out_out_in[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out_out_out_out[Nx*Ny*Nz]; \n  \n  // Now, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_out_out_out_out[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out_out_out_in[Nx*Ny*Nz]; \n  \n  // Now, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_out_out_out_in[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out_out_out_out[Nx*Ny*Nz]; \n  \n  // Now, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_out_out_out_out[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out_out_out_in[Nx*Ny*Nz]; \n  \n  // Now, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_out_out_out_in[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out_out_out_out[Nx*Ny*Nz]; \n  \n  // Now, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_out_out_out_out[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out_out_out_in[Nx*Ny*Nz]; \n  \n  // Now, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_out_out_out_in[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out_out_out_out[Nx*Ny*Nz]; \n  \n  // Now, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_out_out_out_out[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out_out_out_in[Nx*Ny*Nz]; \n  \n  // Now, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_out_out_out_in[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out_out_out_out[Nx*Ny*Nz]; \n  \n  // Now, create the vectors. \n  \n  for (int i=0; i<Nx*Ny*Nz; i++) data_out_out_out_out[i] = (complex_double) (1.0+rand()/(double)RAND_MAX); \n  \n  // Now, create the complex inverse z=f(x). \n  complex_double data_out_out_out_in[Nx*Ny*Nz]; \n  \n  // Now"}
{"label": " \nint transfer_init( \n    struct precision * ppr, \n    struct background * pba, \n    struct thermo * pth, \n    struct perturbs * ppt, \n    struct nonlinear * pnl, \n    struct transfers * ptr \n) { \n \n     \n \n \n     \n \n \n     \n \n    int index_q; \n \n     \n \n    double tau0; \n     \n \n    double tau_rec; \n     \n \n    double q_period; \n \n     \n \n    int tau_size_max; \n \n     \n \n    double *** sources; \n \n     \n \n    double *** sources_spline; \n \n     \n \n    struct transfer_workspace * ptw; \n \n     \n \n    int ** tp_of_tt; \n \n     \n \n \n    HyperInterpStruct BIS; \n    double xmax; \n \n     \n \n    int abort; \n \n \n     \n \n    double tstart, tstop, tspent; \n \n \n     \n \n \n    if (ppt->has_cls == _FALSE_) { \n        ptr->has_cls = _FALSE_; \n        if (ptr->transfer_verbose > 0) \n            printf(\"No harmonic space transfer functions to compute. Transfer module skipped.\\n\"); \n        return _SUCCESS_; \n    } \n    else \n        ptr->has_cls = _TRUE_; \n \n    if (ptr->transfer_verbose > 0) \n        fprintf(stdout,\"Computing transfers\\n\"); \n \n     \n \n \n    ptr->md_size = ppt->md_size; \n \n     \n \n \n    tau0 = pba->conformal_age; \n    tau_rec = pth->tau_rec; \n \n     \n \n \n    ptr->angular_rescaling = pth->angular_rescaling; \n \n     \n \n \n    q_period = 2.*_PI_/(tau0-tau_rec)*ptr->angular_rescaling; \n \n     \n \n \n    class_call(transfer_indices_of_transfers(ppr,ppt,ptr,q_period,pba->K,pba->sgnK), \n               ptr->error_message, \n               ptr->error_message); \n \n     \n \n \n    class_alloc(sources, \n                ptr->md_size*sizeof(double**), \n                ptr->error_message); \n \n    class_call(transfer_perturbation_copy_sources_and_nl_corrections(ppt,pnl,ptr,sources), \n               ptr->error_message, \n               ptr->error_message); \n \n     \n \n \n    class_alloc(sources_spline, \n                ptr->md_size*sizeof(double**), \n                ptr->error_message); \n \n    class_call(transfer_perturbation_source_spline(ppt,ptr,sources,sources_spline), \n               ptr->error_message, \n               ptr->error_message); \n \n     \n \n \n    class_alloc(tp_of_tt, \n                ptr->md_size*sizeof(int*), \n                ptr->error_message); \n \n    class_call(transfer_get_source_correspondence(ppt,ptr,tp_of_tt), \n               ptr->error_message, \n               ptr->error_message); \n \n     \n \n \n    class_call(transfer_source_tau_size_max(ppr,pba,ppt,ptr,tau_rec,tau0,&tau_size_max), \n               ptr->error_message, \n               ptr->error_message); \n \n     \n \n \n    xmax = ptr->q[ptr->q_size-1]*tau0; \n    if (pba->sgnK == -1) \n        xmax *= (ptr->l[ptr->l_size_max-1]/ppr->hyper_flat_approximation_nu)/asinh(ptr->l[ptr->l_size_max-1]/ppr->hyper_flat_approximation_nu)*1.01; \n \n    class_call(hyperspherical_HIS_create(0, \n                                         1., \n                                         ptr->l_size_max, \n                                         ptr->l, \n                                         ppr->hyper_x_min, \n                                         xmax, \n                                         ppr->hyper_sampling_flat, \n                                         ptr->l[ptr->l_size_max-1]+1, \n                                         ppr->hyper_phi_min_abs, \n                                         &BIS, \n                                         ptr->error_message), \n               ptr->error_message, \n               ptr->error_message); \n \n     \n \n \n     \n \n \n    class_call(transfer_global_selection_read(ptr), \n               ptr->error_message, \n               ptr->error_message); \n \n     \n \n \n     \n \n    abort = _FALSE_; \n \n     \n \n \n    { \n \n        tspent = 0.; \n \n         \n \n \n        class_call_parallel(transfer_workspace_init(ptr, \n                            ppr, \n   ", "pred": " \nint transfer_init( \n    struct precision * ppr, \n    struct background * pba, \n    struct thermo * pth, \n    struct perturbs * ppt, \n    struct nonlinear * pnl, \n    struct transfers * ptr \n) { \n \n     \n \n \n     \n \n \n     \n \n    int index_q; \n \n     \n \n    double tau0; \n     \n \n    double tau_rec; \n     \n \n    double q_period; \n \n     \n \n    int tau_size_max; \n \n     \n \n    double *** sources; \n \n     \n \n    double *** sources_spline; \n \n     \n \n    struct transfer_workspace * ptw; \n \n     \n \n    int ** tp_of_tt; \n \n     \n \n \n    HyperInterpStruct BIS; \n    double xmax; \n \n     \n \n    int abort; \n \n \n     \n \n    double tstart, tstop, tspent; \n \n \n     \n \n    double t_start, t_stop, t_spent; \n \n \n     \n \n    double t_start_rec, t_stop_rec, t_spent_rec; \n \n \n     \n \n    double t_start_rec_rec, t_stop_rec_rec, t_spent_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec, t_stop_rec_rec_rec, t_spent_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec, t_stop_rec_rec_rec_rec, t_spent_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_spent_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec; \n \n \n     \n \n    double t_start_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec, t_stop_rec_rec_rec_rec_rec_rec_rec_rec_rec_"}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_bloom_data_t *const data = (dt_iop_bloom_data_t *)piece->data; \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return;  \n \n \n  float *restrict blurlightness; \n  if(!dt_iop_alloc_image_buffers(self, roi_in, roi_out, 1, &blurlightness, 0)) \n  { \n     \n \n    dt_iop_copy_image_roi(ovoid, ivoid, piece->colors, roi_in, roi_out, TRUE); \n    return; \n  } \n \n  const float *const restrict in = DT_IS_ALIGNED((float *)ivoid); \n  float *const restrict out = DT_IS_ALIGNED((float *)ovoid); \n  const size_t npixels = (size_t)roi_out->width * roi_out->height; \n \n   \n \n  const int rad = 256.0f * (fmin(100.0f, data->size + 1.0f) / 100.0f); \n  const float _r = ceilf(rad * roi_in->scale / piece->iscale); \n  const int radius = MIN(256.0f, _r); \n \n  const float scale = 1.0f / exp2f(-1.0f * (fmin(100.0f, data->strength + 1.0f) / 100.0f)); \n \n  const float threshold = data->threshold; \n \n \n  for(size_t k = 0; k < npixels; k++) \n  { \n    const float L = in[4*k] * scale; \n    blurlightness[k] = (L > threshold)? L : 0.0f; \n  } \n \n   \n \n  const int range = 2 * radius + 1; \n  const int hr = range / 2; \n \n  dt_box_mean(blurlightness, roi_out->height, roi_out->width, 1, hr, BOX_ITERATIONS); \n \n \n \n  for(size_t k = 0; k < npixels; k++) \n  { \n    out[4*k+0] = 100.0f - (((100.0f - in[4*k]) * (100.0f - blurlightness[k])) / 100.0f);  \n \n    out[4*k+1] = in[4*k+1]; \n    out[4*k+2] = in[4*k+2]; \n    out[4*k+3] = in[4*k+3]; \n  } \n  dt_free_align(blurlightness); \n \n \n \n \n \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_bloom_data_t *const data = (dt_iop_bloom_data_t *)piece->data; \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return;  \n \n \n  float *restrict blurlightness; \n  if(!dt_iop_alloc_image_buffers(self, roi_in, roi_out, 1, &blurlightness, 0)) \n  { \n     \n \n    dt_iop_copy_image_roi(ovoid, ivoid, piece->colors, roi_in, roi_out, TRUE); \n    return; \n  } \n  \n  const float *const restrict in = (const float *)ivoid; \n  const float *const restrict out = (const float *)ovoid; \n  const float *const restrict blurlightness_in = (const float *)blurlightness; \n  const float *const restrict blurlightness_out = (const float *)blurlightness; \n  const float *const restrict blurlightness_out_f = (const float *)blurlightness; \n  const float *const restrict blurlightness_out_f_f = (const float *)blurlightness; \n  const float *const restrict blurlightness_out_f_f_f = (const float *)blurlightness; \n  const float *const restrict blurlightness_out_f_f_f_f = (const float *)blurlightness; \n  const float *const restrict blurlightness_out_f_f_f_f_f = (const float *)blurlightness; \n  const float *const restrict blurlightness_out_f_f_f_f_f_f = (const float *)blurlightness; \n  const float *const restrict blurlightness_out_f_f_f_f_f_f_f = (const float *)blurlightness; \n  const float *const restrict blurlightness_out_f_f_f_f_f_f_f_f = (const float *)blurlightness; \n  const float *const restrict blurlightness_out_f_f_f_f_f_f_f_f_f = (const float *)blurlightness; \n  const float *const restrict blurlightness_out_f_f_f_f_f_f_f_f_f_f = (const float *)blurlightness; \n  const float *const restrict blurlightness_out_f_f_f_f_f_f_f_f_f_f_f = (const float *)blurlightness; \n  const float *const restrict blurlightness_out_f_f_f_f_f_f_f_f_f_f"}
{"label": " \nstatic PyObject *__pyx_pf_3GPy_4util_17choleskies_cython_6backprop_gradient_par(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_dL, __Pyx_memviewslice __pyx_v_L) { \n  __Pyx_memviewslice __pyx_v_dL_dK = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_v_N; \n  int __pyx_v_k; \n  int __pyx_v_j; \n  int __pyx_v_i; \n  PyObject *__pyx_r = NULL; \n  __Pyx_RefNannyDeclarations \n  PyObject *__pyx_t_1 = NULL; \n  PyObject *__pyx_t_2 = NULL; \n  PyObject *__pyx_t_3 = NULL; \n  PyObject *__pyx_t_4 = NULL; \n  __Pyx_memviewslice __pyx_t_5 = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_t_6; \n  long __pyx_t_7; \n  int __pyx_t_8; \n  long __pyx_t_9; \n  long __pyx_t_10; \n  long __pyx_t_11; \n  long __pyx_t_12; \n  int __pyx_t_13; \n  Py_ssize_t __pyx_t_14; \n  Py_ssize_t __pyx_t_15; \n  Py_ssize_t __pyx_t_16; \n  Py_ssize_t __pyx_t_17; \n  Py_ssize_t __pyx_t_18; \n  Py_ssize_t __pyx_t_19; \n  int __pyx_t_20; \n  int __pyx_t_21; \n  Py_ssize_t __pyx_t_22; \n  Py_ssize_t __pyx_t_23; \n  Py_ssize_t __pyx_t_24; \n  Py_ssize_t __pyx_t_25; \n  Py_ssize_t __pyx_t_26; \n  Py_ssize_t __pyx_t_27; \n  Py_ssize_t __pyx_t_28; \n  Py_ssize_t __pyx_t_29; \n  Py_ssize_t __pyx_t_30; \n  Py_ssize_t __pyx_t_31; \n  Py_ssize_t __pyx_t_32; \n  Py_ssize_t __pyx_t_33; \n  Py_ssize_t __pyx_t_34; \n  Py_ssize_t __pyx_t_35; \n  Py_ssize_t __pyx_t_36; \n  Py_ssize_t __pyx_t_37; \n  Py_ssize_t __pyx_t_38; \n  Py_ssize_t __pyx_t_39; \n  Py_ssize_t __pyx_t_40; \n  Py_ssize_t __pyx_t_41; \n  __Pyx_RefNannySetupContext(\"backprop_gradient_par\", 0); \n \n   \n \n  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_2); \n  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_tril); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_3); \n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; \n  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_dL, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_2); \n  __pyx_t_4 = NULL; \n  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) { \n    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3); \n    if (likely(__pyx_t_4)) { \n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3); \n      __Pyx_INCREF(__pyx_t_4); \n      __Pyx_INCREF(function); \n      __Pyx_DECREF_SET(__pyx_t_3, function); \n    } \n  } \n  __pyx_t_1 = (__pyx_t_4)? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2); \n  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0; \n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; \n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_1); \n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; \n  __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_t_1, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; \n  __pyx_v_dL_dK = __pyx_t_5; \n  __pyx_t_5.memview = NULL; \n  __pyx_t_5.data = NULL; \n \n   \n \n  __pyx_v_N = (__pyx_v_L.shape[0]); \n \n   \n \n  { \n      #ifdef WITH_THREAD \n      PyThreadState *_save; \n      Py_UNBLOCK_THREADS \n      __Pyx_FastGIL_Remember(); \n      #endif \n       \n { \n \n         \n \n        for (__pyx_t_6 = (__pyx_v_N - 1); __pyx_t_6 > -1; __pyx_t_6-=1) { \n          __pyx_v_k = __pyx_t_6; \n \n           \n \n          { \n              #if ((defined(__APPLE__) || defined(__OSX__)) && (defined(__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))))) \n                  #undef likely \n                  #undef unlikely \n                  #define likely(x)   (x) \n                  #define unlikely(x) (x) \n              #endif \n              #ifdef _OPENMP \n              #endif  \n \n              { \n \n                   \n \n                  __pyx_t_7 = (__pyx_v_k + 1); \n                  __pyx_t_8 = __pyx_v_N; \n                  if (1 == 0) abort(); \n                  { \n             ", "pred": " \nstatic PyObject *__pyx_pf_3GPy_4util_17choleskies_cython_6backprop_gradient_par(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_dL, __Pyx_memviewslice __pyx_v_L) { \n  __Pyx_memviewslice __pyx_v_dL_dK = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_v_N; \n  int __pyx_v_k; \n  int __pyx_v_j; \n  int __pyx_v_i; \n  PyObject *__pyx_r = NULL; \n  __Pyx_RefNannyDeclarations \n  PyObject *__pyx_t_1 = NULL; \n  PyObject *__pyx_t_2 = NULL; \n  PyObject *__pyx_t_3 = NULL; \n  PyObject *__pyx_t_4 = NULL; \n  __Pyx_memviewslice __pyx_t_5 = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_t_6; \n  long __pyx_t_7; \n  int __pyx_t_8; \n  long __pyx_t_9; \n  long __pyx_t_10; \n  long __pyx_t_11; \n  long __pyx_t_12; \n  long __pyx_t_13; \n  long __pyx_t_14; \n  long __pyx_t_15; \n  long __pyx_t_16; \n  long __pyx_t_17; \n  long __pyx_t_18; \n  long __pyx_t_19; \n  long __pyx_t_20; \n  long __pyx_t_21; \n  long __pyx_t_22; \n  long __pyx_t_23; \n  long __pyx_t_24; \n  long __pyx_t_25; \n  long __pyx_t_26; \n  long __pyx_t_27; \n  long __pyx_t_28; \n  long __pyx_t_29; \n  long __pyx_t_30; \n  long __pyx_t_31; \n  long __pyx_t_32; \n  long __pyx_t_33; \n  long __pyx_t_34; \n  long __pyx_t_35; \n  long __pyx_t_36; \n  long __pyx_t_37; \n  long __pyx_t_38; \n  long __pyx_t_39; \n  long __pyx_t_40; \n  long __pyx_t_41; \n  long __pyx_t_42; \n  long __pyx_t_43; \n  long __pyx_t_44; \n  long __pyx_t_45; \n  long __pyx_t_46; \n  long __pyx_t_47; \n  long __pyx_t_48; \n  long __pyx_t_49; \n  long __pyx_t_50; \n  long __pyx_t_51; \n  long __pyx_t_52; \n  long __pyx_t_53; \n  long __pyx_t_54; \n  long __pyx_t_55; \n  long __pyx_t_56; \n  long __pyx_t_57; \n  long __pyx_t_58; \n  long __pyx_t_59; \n  long __pyx_t_60; \n  long __pyx_t_61; \n  long __pyx_t_62; \n  long __pyx_t_63; \n  long __pyx_t_64; \n  long __pyx_t_65; \n  long __pyx_t_66; \n  long __pyx_t_67; \n  long __pyx_t_68; \n  long __pyx_t_69; \n  long __pyx_t_70; \n  long __pyx_t_71; \n  long __pyx_t_72; \n  long __pyx_t_73; \n  long __pyx_t_74; \n  long __pyx_t_75; \n  long __pyx_t_76; \n  long __pyx_t_77; \n  long __pyx_t_78; \n  long __pyx_t_79; \n  long __pyx_t_80; \n  long __pyx_t_81; \n  long __pyx_t_82; \n  long __pyx_t_83; \n  long __pyx_t_84; \n  long __pyx_t_85; \n  long __pyx_t_86; \n  long __pyx_t_87; \n  long __pyx_t_88; \n  long __pyx_t_89; \n  long __pyx_t_90; \n  long __pyx_t_91; \n  long __pyx_t_92; \n  long __pyx_t_93; \n  long __pyx_t_94; \n  long __pyx_t_95; \n  long __pyx_t_96; \n  long __pyx_t_97; \n  long __pyx_t_98; \n  long __pyx_t_99; \n  long __pyx_t_100; \n  long __pyx_t_101; \n  long __pyx_t_102; \n  long __pyx_t_103; \n  long __pyx_t_104; \n  long __pyx_t_105; \n  long __pyx_t_106; \n  long __pyx_t_107; \n  long __pyx_t_108; \n  long __pyx_t_109; \n  long __pyx_t_110; \n  long __pyx_t_111; \n  long __pyx_t_112; \n  long __pyx_t_113; \n  long __pyx_t_114; \n  long __pyx_t_115; \n  long __pyx_t_116; \n  long __pyx_t_117; \n  long __pyx_t_118; \n  long __pyx_t_119; \n  long __pyx_t_120; \n  long __pyx_t_121; \n  long __pyx_t_122; \n  long __pyx_t_123; \n  long __pyx_t_124; \n  long __pyx_t_125; \n  long __pyx_t_126; \n  long __pyx_t_127; \n  long __pyx_t_128; \n  long __pyx_t_129; \n  long __pyx_t_130; \n  long __pyx_t_131; \n  long __pyx_t_132; \n  long __pyx_t_133; \n  long __pyx_t_134; \n  long __pyx_t_135; \n  long __pyx_t_136; \n  long __pyx_t_137; \n  long __pyx_t_138; \n  long __pyx_t_139; \n  long __pyx_t_140; \n  long __pyx_t_141; \n  long __pyx_t_142; \n  long __pyx_t_143; \n  long __pyx_t_144; \n  long __pyx_t_145; \n  long __pyx_t_146; \n  long __pyx_t_147; \n  long __pyx_t_148; \n  long __pyx_t_149; \n  long __pyx_t_150; \n  long __pyx_t_151; \n  long __pyx_t_152; \n  long __pyx_t_153; \n  long __pyx_t_154; \n  long __pyx_t_155; \n  long __pyx_t_156; \n  long __pyx_t_157; \n  long __pyx_t_158; \n  long __pyx_t_159; \n  long __pyx_t_160; \n  long __pyx_t_161; \n  long __pyx_t_162; \n  long __pyx_t_163; \n  long __pyx_t_164; \n  long __pyx_t_165; \n  long __pyx_t_166; \n  long __pyx_t_167; \n  long __pyx_t_168; \n  long __pyx_t_169; \n  long __pyx_t_170; \n  long __pyx_t_171; \n  long __pyx_t_172; \n  long __pyx_t_173; \n  long __pyx_t_174; \n  long __pyx_t_175; \n  long __pyx_t_176; \n  long __pyx_t_177; \n  long __pyx_t_178; \n  long __pyx_t_179; \n  long __pyx_t_180; \n  long __pyx_t_181; \n  long __pyx_t_182; \n  long __pyx_t_183; \n  long __pyx_t_184; \n  long __pyx_t_185; \n  long __pyx_"}
{"label": "d RK_in(real *fwnp1, real *fdtwn, const real dt, const int sizew) \n{ \n  for(int iw = 0; iw < sizew; iw++) { \n    fwnp1[iw] += dt * fdtwn[iw]; \n  } \n} \n \nre ", "pred": "d RK_in(real *fwnp1, real *fdtwn, const real dt, const int sizew) \n{ \n  for(int iw = 0; iw < sizew; iw++) { \n    fwnp1[iw] += dt * fdtwn[iw]; \n  } \n} \n \nre "}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*7); \n  for(m=0; m<7;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 24; \n  tile_size[1] = 24; \n  tile_size[2] = 32; \n  tile_size[3] = 256; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<7; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 2) && (Nx >= 3) && (Ny >= 3) && (Nz >= 3)) { \n  for (t1=-1;t1<=floord(Nt-2,12);t1++) { \n    lbp=max(ceild(t1,2),ceild(24*t1-Nt+3,24)); \n    ubp=min(floord(Nt+Nz-4,24),floord(12*t1+Nz+9,24)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(0,ceild(3*t1-7,8)),ceild(24*t2-Nz-28,32));t3<=min(min(min(floord(Nt+Ny-4,32),floord(12*t1+Ny+21,32)),floord(24*t2+Ny+20,32)),floord(24*t1-24*t2+Nz+Ny+19,32));t3++) { \n        for (t4=max(max(max(0,ceild(3*t1-63,64)),ceild(24*t2-Nz-252,256)),ceild(32*t3-Ny-252,256));t4<=min(min(min(min(floord(Nt+Nx-4,256),floord(12*t1+Nx+21,256)),floord(24*t2+Nx+20,256)),floord(32*t3+Nx+28,256)),floord(24*t1-24*t2+Nz+Nx+19,256));t4++) { \n          for (t5=max(max(max(max(max(0,12*t1),24*t1-24*t2+1),24*t2-Nz+2),32*t3-Ny+2),256*t4-Nx+2);t5<=min(min(min(min(min(Nt-2,12*t1+23),24*t2+22),32*t3+30),256*t4+254),24*t1-24*t2+Nz+21);t5++) { \n            for (t6=max(max(24*t2,t5+1),-24*t1+24*t2+2*t5-23);t6<=min(min(24*t2+23,-24*t1+24*t2+2*t5),t5+Nz-2);t6++) { \n              for (t7=max(32*t3,t5+1);t7<=min(32*t3+31,t5+Ny-2);t7++) { \n                lbv=max(256*t4,t5+1); \n                ubv=min(256*t4+255,t5+Nx-2); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] = (((((((coef[0][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)]) + (coef[1][ (-t5+t6)][ (-t5+t7)][ (-t5+t8)] * A[ t5 % 2][ (-t5+t6) - 1][ (-t5+t7)][ (-t5+t8)])) + (coef[2][ (-t5+t6)][ (-t5", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+2; \n    Ny = atoi(argv[2])+2; \n    Nz = atoi(argv[3])+2; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    coef[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      coef[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****x_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    x_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      x_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****y_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    y_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      y_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****z_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    z_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      z_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****w_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    w_v[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      w_v[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_u = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_u[i] = (double **) malloc(sizeof(double*)*Nx); \n    for(j=0; j<Nx; j++){ \n      u_u[i][j] = (double*) malloc(sizeof(double)*Nz); \n    } \n  } \n \n  double ****u_v = (double ****) malloc(sizeof(double**)*2); \n  for(i=0; i<2;i++){ \n    u_v[i] = (double **) malloc(sizeof(double"}
{"label": " \nstatic void get_gonze_undone_phonons(double *frequencies, \n                                     lapack_complex_double *eigenvectors, \n                                     const size_t *undone_grid_points, \n                                     const size_t num_undone_grid_points, \n                                     PHPYCONST int (*grid_address)[3], \n                                     const int mesh[3], \n                                     const double *fc2, \n                                     PHPYCONST double(*svecs_fc2)[27][3], \n                                     const int *multi_fc2, \n                                     PHPYCONST double (*positions)[3], \n                                     const size_t num_patom, \n                                     const size_t num_satom, \n                                     const double *masses_fc2, \n                                     const int *p2s_fc2, \n                                     const int *s2p_fc2, \n                                     const double unit_conversion_factor, \n                                     PHPYCONST double (*born)[3][3], \n                                     PHPYCONST double dielectric[3][3], \n                                     PHPYCONST double reciprocal_lattice[3][3], \n                                     const double *q_direction, \n                                     const double nac_factor, \n                                     const double *dd_q0, \n                                     PHPYCONST double(*G_list)[3], \n                                     const size_t num_G_points, \n                                     const double lambda, \n                                     const char uplo) \n{ \n  size_t i, j, gp, num_band; \n  int is_nac, info; \n  double q[3]; \n  double *freqs_tmp; \n \n  num_band = num_patom * 3; \n \n  for (i = 0; i < num_undone_grid_points; i++) { \n    gp = undone_grid_points[i]; \n    for (j = 0; j < 3; j++) { \n      q[j] = ((double)grid_address[gp][j]) / mesh[j]; \n    } \n    is_nac = needs_nac(born, grid_address, gp, q_direction); \n    get_gonze_phonons(eigenvectors + num_band * num_band * gp, \n                      q, \n                      fc2, \n                      masses_fc2, \n                      p2s_fc2, \n                      s2p_fc2, \n                      multi_fc2, \n                      positions, \n                      num_patom, \n                      num_satom, \n                      svecs_fc2, \n                      is_nac, \n                      born, \n                      dielectric, \n                      reciprocal_lattice, \n                      q_direction, \n                      nac_factor, \n                      dd_q0, \n                      G_list, \n                      num_G_points, \n                      lambda); \n  } \n \n \n \n \n  for (i = 0; i < num_undone_grid_points; i++) { \n    gp = undone_grid_points[i]; \n     \n \n     \n \n    freqs_tmp = frequencies + num_band * gp; \n    info = phonopy_zheev(freqs_tmp, \n                         eigenvectors + num_band * num_band * gp, \n             ", "pred": " \nstatic void get_gonze_undone_phonons(double *frequencies, \n                                     lapack_complex_double *eigenvectors, \n                                     const size_t *undone_grid_points, \n                                     const size_t num_undone_grid_points, \n                                     PHPYCONST int (*grid_address)[3], \n                                     const int mesh[3], \n                                     const double *fc2, \n                                     const double *fc3, \n                                     const double *fc4, \n                                     const double *fc5, \n                                     const double *fc6, \n                                     const double *fc7, \n                                     const double *fc8, \n                                     const double *fc9, \n                                     const double *fc10, \n                                     const double *fc11, \n                                     const double *fc12, \n                                     const double *fc13, \n                                     const double *fc14, \n                                     const double *fc15, \n                                     const double *fc16, \n                                     const double *fc17, \n                                     const double *fc18, \n                                     const double *fc19, \n                                     const double *fc20, \n                                     const double *fc21, \n                                     const double *fc22, \n                                     const double *fc23, \n                                     const double *fc24, \n                                     const double *fc25, \n                                     const double *fc26, \n                                     const double *fc27, \n                                     const double *fc28, \n                                     const double *fc29, \n                                     const double *fc30, \n                                     const double *fc31, \n                                     const double *fc32, \n                                     const double *fc33, \n                                     const double *fc34, \n                                     const double *fc35, \n                                     const double *fc36, \n                                     const double *fc37, \n                                     const double *fc38, \n                                     const double *fc39, \n                                     const double *fc40, \n                                     const double *fc41, \n                                     const double *fc42, \n                          "}
{"label": " \nstatic void get_xyz_sample_from_image(const image_t *const image, float shrink, box_t *box, float *xyz) \n{ \n  point_t bb[4]; \n  point_t corners[4]; \n  box_t inner_box; \n  int x_start, y_start, x_end, y_end; \n \n  xyz[0] = xyz[1] = xyz[2] = 0.0; \n \n  if(!box) return; \n \n  get_boundingbox(image, bb); \n  inner_box = get_sample_box(*(image->chart), box, shrink); \n  get_corners(bb, &inner_box, corners); \n  get_pixel_region(image, corners, &x_start, &y_start, &x_end, &y_end); \n \n  float delta_x_top = corners[TOP_RIGHT].x - corners[TOP_LEFT].x; \n  float delta_y_top = corners[TOP_RIGHT].y - corners[TOP_LEFT].y; \n  float delta_x_bottom = corners[BOTTOM_RIGHT].x - corners[BOTTOM_LEFT].x; \n  float delta_y_bottom = corners[BOTTOM_RIGHT].y - corners[BOTTOM_LEFT].y; \n  float delta_x_left = corners[BOTTOM_LEFT].x - corners[TOP_LEFT].x; \n  float delta_y_left = corners[BOTTOM_LEFT].y - corners[TOP_LEFT].y; \n  float delta_x_right = corners[BOTTOM_RIGHT].x - corners[TOP_RIGHT].x; \n  float delta_y_right = corners[BOTTOM_RIGHT].y - corners[TOP_RIGHT].y; \n \n  double sample_x = 0.0, sample_y = 0.0, sample_z = 0.0; \n  size_t n_samples = 0; \n  for(int y = y_start; y < y_end; y++) \n    for(int x = x_start; x < x_end; x++) \n    { \n      if((x - corners[TOP_LEFT].x) / delta_x_top * delta_y_top + corners[TOP_LEFT].y < y \n         && (x - corners[BOTTOM_LEFT].x) / delta_x_bottom * delta_y_bottom + corners[BOTTOM_LEFT].y > y \n         && (y - corners[TOP_LEFT].y) / delta_y_left * delta_x_left + corners[TOP_LEFT].x < x \n         && (y - corners[TOP_RIGHT].y) / delta_y_right * delta_x_right + corners[TOP_RIGHT].x > x) \n      { \n        float *pixel = &image->xyz[(x + y * image->width) * 3]; \n        sample_x += pixel[0]; \n        sample_y += pixel[1]; \n        sample_z += pixel[2]; \n        n_samples++; \n      } \n    } \n \n  xyz[0] = sample_x / n_samples; \n  xyz[1] = sample_y / n_samples; \n  xyz[2] = sample_z / n_samples; \n} ", "pred": " \nstatic void get_xyz_sample_from_image(const image_t *const image, float shrink, box_t *box, float *xyz) \n{ \n  point_t bb[4]; \n  point_t corners[4]; \n  box_t inner_box; \n  int x_start, y_start, x_end, y_end; \n \n  xyz[0] = xyz[1] = xyz[2] = 0.0; \n \n  if(!box) return; \n \n  get_boundingbox(image, bb); \n  inner_box = get_sample_box(*(image->chart), box, shrink); \n  get_corners(bb, &inner_box, corners); \n  get_pixel_region(image, corners, &x_start, &y_start, &x_end, &y_end); \n \n  float delta_x_top = corners[TOP_RIGHT].x - corners[TOP_LEFT].x; \n  float delta_y_top = corners[TOP_RIGHT].y - corners[TOP_LEFT].y; \n  float delta_x_bottom = corners[BOTTOM_RIGHT].x - corners[BOTTOM_LEFT].x; \n  float delta_y_bottom = corners[BOTTOM_RIGHT].y - corners[BOTTOM_LEFT].y; \n  float delta_x_left = corners[LEFT_RIGHT].x - corners[LEFT_LEFT].x; \n  float delta_y_left = corners[LEFT_RIGHT].y - corners[LEFT_LEFT].y; \n  float delta_x_right = corners[RIGHT_RIGHT].x - corners[RIGHT_LEFT].x; \n  float delta_y_right = corners[RIGHT_RIGHT].y - corners[RIGHT_LEFT].y; \n \n  float delta_x_top_left = corners[TOP_LEFT].x - corners[LEFT_RIGHT].x; \n  float delta_x_top_right = corners[TOP_RIGHT].x - corners[RIGHT_RIGHT].x; \n  float delta_x_bottom_left = corners[BOTTOM_LEFT].x - corners[LEFT_RIGHT].x; \n  float delta_x_bottom_right = corners[BOTTOM_RIGHT].x - corners[RIGHT_RIGHT].x; \n  float delta_x_left_top = corners[LEFT_RIGHT].x - corners[TOP_LEFT].x; \n  float delta_x_left_bottom = corners[LEFT_RIGHT].x - corners[BOTTOM_LEFT].x; \n  float delta_x_right_top = corners[RIGHT_RIGHT].x - corners[TOP_LEFT].x; \n  float delta_x_right_bottom = corners[RIGHT_RIGHT].x - corners[BOTTOM_LEFT].x; \n \n  float delta_y_top_left = corners[TOP_LEFT].y - corners[LEFT_RIGHT].y; \n  float delta_y_top_right = corners[TOP_RIGHT].y - corners[RIGHT_RIGHT].y; \n  float delta_y_bottom_left = corners[BOTTOM_LEFT].y - corners[LEFT_RIGHT].y; \n  float delta_y_bottom_right = corners[BOTTOM_RIGHT].y - corners[RIGHT_RIGHT].y; \n  float delta_y_left_top = corners[LEFT_RIGHT].y - corners[TOP_LEFT].y; \n  float delta_y_left_bottom = corners[LEFT_RIGHT].y - corners[BOTTOM_LEFT].y; \n  float delta_y_right_top = corners[RIGHT_RIGHT].y - corners[TOP_LEFT].y; \n  float delta"}
{"label": " \nvoid recombine2d_pf1_ft1_omp(struct recombine2d_worker *worker, \n                             complex double *F, \n                             complex double *BF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n    int y; \n    for (y = 0; y < cfg->yB_size; y+=worker->BF_batch) { \n \n         \n \n        double start = get_time_ns(); \n        int y2; \n        for (y2 = y; y2 < y+worker->BF_batch && y2 < cfg->yB_size; y2++) { \n            prepare_facet(cfg->yB_size, cfg->yP_size, cfg->Fb, \n                          F+y2*cfg->F_stride0, cfg->F_stride1, \n                          BF+y2*cfg->BF_stride0, cfg->BF_stride1); \n        } \n        worker->pf1_time += get_time_ns() - start; \n \n         \n \n        start = get_time_ns(); \n        fftw_execute_dft(worker->BF_plan, BF+y*cfg->BF_stride0, BF+y*cfg->BF_stride0); \n        worker->ft1_time += get_time_ns() - start; \n    } \n \n} ", "pred": " \nvoid recombine2d_pf1_ft1_omp(struct recombine2d_worker *worker, \n                             complex double *F, \n                             complex double *BF) \n{ \n    struct recombine2d_config *cfg = worker->cfg; \n    int y; \n    for (y = 0; y < cfg->yB_size; y+=worker->BF_batch) { \n \n         \n \n        double start = get_time_ns(); \n        int y2; \n        for (y2 = y; y2 < y+worker->BF_batch && y2 < cfg->yB_size; y2++) { \n            prepare_facet(cfg->yB_size, cfg->yP_size, cfg->Fb, \n                          F+y2*cfg->F_stride, cfg->F_stride, \n                          BF+y2*cfg->B_stride, cfg->B_stride, \n                          cfg->yB_size, cfg->yP_size, cfg->Fb, \n                          cfg->F_stride, cfg->B_stride, \n                          cfg->yB_size, cfg->yP_size, cfg->Fb, \n               "}
{"label": " \nint ro2euLoop (double* ro, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * eustep; \n      \n    trash = ro2eu(&(ro[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ro2euLoop (double* ro, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * eustep; \n      \n    trash = ro2eu(&(ro[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint eu2axLoop (double* eu, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * axstep; \n      \n    trash = eu2ax(&(eu[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint eu2axLoop (double* eu, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * axstep; \n      \n    trash = eu2ax(&(eu[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint qu2cuLoop (double* qu, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * custep; \n      \n    trash = qu2cu(&(qu[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint qu2cuLoop (double* qu, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * custep; \n      \n    trash = qu2cu(&(qu[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint qu2roLoop (double* qu, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * rostep; \n      \n    trash = qu2ro(&(qu[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint qu2roLoop (double* qu, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * rostep; \n      \n    trash = qu2ro(&(qu[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint cu2hoLoop (double* cu, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * hostep; \n      \n    trash = cu2ho(&(cu[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint cu2hoLoop (double* cu, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * hostep; \n      \n    trash = cu2ho(&(cu[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": "nstruct_RGB(const float *const restrict HF, const float *const restrict LF, \n                                            const float *const restrict texture, const float *const restrict mask, \n                                            float *const restrict reconstructed, const size_t width, \n                                            const size_t height, const size_t ch, const float gamma, \n                                            const float gamma_comp, const float beta, const float beta_comp, \n                                            const float delta, const size_t s, const size_t scales) \n{ \n  for(size_t k = 0; k < height * width * ch; k += 4) \n  { \n    const float alpha = mask[k / ch]; \n \n     \n \n    const float *const restrict HF_c = __builtin_assume_aligned(HF + k, 16); \n    const float *const restrict LF_c = __builtin_assume_aligned(LF + k, 16); \n    const float *const restrict TT_c = __builtin_assume_aligned(texture + k, 16); \n \n     \n \n     \n \n     \n \n    const float grey_texture = fmaxabsf(fmaxabsf(TT_c[0], TT_c[1]), TT_c[2]); \n \n     \n \n     \n \n    const float grey_details = (HF_c[0] + HF_c[1] + HF_c[2]) / 3.f; \n \n     \n \n     \n \n     \n \n    const float grey_HF = beta_comp * (gamma_comp * grey_details + gamma * grey_texture); \n \n     \n \n     \n \n    const float grey_residual = beta_comp * (LF_c[0] + LF_c[1] + LF_c[2]) / 3.f; \n \n    #ifdef _OPENMP \n    #endif \n    for(size_t c = 0; c < 4; c++) \n    { \n       \n \n       \n \n \n       \n \n       \n \n      const float details = (gamma_comp * HF_c[c] + gamma * TT_c[c]) * beta + grey_HF; \n \n       \n \n      const float residual = (s == scales - 1)? (grey_residual + LF_c[c] * beta) : 0.f; \n      reconstructed[k + c] += alpha * (delta * details + residual); \n    } \n  } \n} \n \ninline static void wavelets_reco ", "pred": "nstruct_RGB(const float *const restrict HF, const float *const restrict LF, \n                                            const float *const restrict texture, const float *const restrict mask, \n                                            float *const restrict reconstructed, const size_t width, \n                                            const size_t height, const size_t ch, const float gamma, \n                                            const float gamma_comp, const float beta, const float beta_comp, \n                                            const float gamma_inv, const float beta_inv, const float gamma_inv_comp, \n                                            const float alpha, const float alpha_comp, const float alpha_inv, \n                                            const float alpha_inv_comp, const float alpha_inv_inv, \n                                            const float alpha_inv_inv_comp, const float alpha_inv_inv_inv, \n                                            const float alpha_inv_inv_inv_comp, const float alpha_inv_inv_inv_inv, \n                                            const float alpha_inv_inv_inv_inv_comp, const float alpha_inv_inv_inv_inv_inv_comp, \n                                            const float alpha_inv_inv_inv_inv_inv_comp, const float alpha_inv_inv_inv_inv_inv_inv_comp, \n                                            const float alpha_inv_inv_inv_inv_inv_inv_comp, const float alpha_inv_inv_inv_inv_inv_inv_inv_comp, \n                                            const float alpha"}
{"label": " \nint eu2quLoop (double* eu, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * qustep; \n      \n    trash = eu2qu(&(eu[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint eu2quLoop (double* eu, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * qustep; \n      \n    trash = eu2qu(&(eu[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void lhsx(void) \n{ \n    int i, j, k; \n    for (j = 1; \n        j < grid_points[1] - 1; \n        j++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            for (i = 0; \n                i < grid_points[0]; \n                i++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                fjac[i][j][k][0][0] = 0.0; \n                fjac[i][j][k][0][1] = 1.0; \n                fjac[i][j][k][0][2] = 0.0; \n                fjac[i][j][k][0][3] = 0.0; \n                fjac[i][j][k][0][4] = 0.0; \n                fjac[i][j][k][1][0] = - (u[i][j][k][1] * tmp2 * u[i][j][k][1]) + c2 * 0.50 * (u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][1][1] = (2.0 - c2) * (u[i][j][k][1] / u[i][j][k][0]); \n                fjac[i][j][k][1][2] = - c2 * (u[i][j][k][2] * tmp1); \n                fjac[i][j][k][1][3] = - c2 * (u[i][j][k][3] * tmp1); \n                fjac[i][j][k][1][4] = c2; \n                fjac[i][j][k][2][0] = - (u[i][j][k][1] * u[i][j][k][2]) * tmp2; \n                fjac[i][j][k][2][1] = u[i][j][k][2] * tmp1; \n                fjac[i][j][k][2][2] = u[i][j][k][1] * tmp1; \n                fjac[i][j][k][2][3] = 0.0; \n                fjac[i][j][k][2][4] = 0.0; \n                fjac[i][j][k][3][0] = - (u[i][j][k][1] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][3][1] = u[i][j][k][3] * tmp1; \n                fjac[i][j][k][3][2] = 0.0; \n                fjac[i][j][k][3][3] = u[i][j][k][1] * tmp1; \n                fjac[i][j][k][3][4] = 0.0; \n                fjac[i][j][k][4][0] = (c2 * (u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2 - c1 * (u[i][j][k][4] * tmp1)) * (u[i][j][k][1] * tmp1); \n                fjac[i][j][k][4][1] = c1 * u[i][j][k][4] * tmp1 - 0.50 * c2 * (3.0 * u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][4][2] = - c2 * (u[i][j][k][2] * u[i][j][k][1]) * tmp2; \n                fjac[i][j][k][4][3] = - c2 * (u[i][j][k][3] * u[i][j][k][1]) * tmp2; \n                fjac[i][j][k][4][4] = c1 * (u[i][j][k][1] * tmp1); \n                njac[i][j][k][0][0] = 0.0; \n                njac[i][j][k][0][1] = 0.0; \n                njac[i][j][k][0][2] = 0.0; \n                njac[i][j][k][0][3] = 0.0; \n                njac[i][j][k][0][4] = 0.0; \n                njac[i][j][k][1][0] = - con43 * c3c4 * tmp2 * u[i][j][k][1]; \n                njac[i][j][k][1][1] = con43 * c3c4 * tmp1; \n                njac[i][j][k][1][2] = 0.0; \n                njac[i][j][k][1][3] = 0.0; \n                njac[i][j][k][1][4] = 0.0; \n                njac[i][j][k][2][0] = - c3c4 * tmp2 * u[i][j", "pred": " \nstatic void lhsx(void) \n{ \n    int i, j, k; \n    for (j = 1; \n        j < grid_points[1] - 1; \n        j++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            for (i = 0; \n                i < grid_points[0]; \n                i++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][0] = tmp3; \n            } \n        } \n    } \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][1] = tmp3; \n            } \n        } \n    } \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][2] = tmp3; \n            } \n        } \n    } \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][3] = tmp3; \n            } \n        } \n    } \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][4] = tmp3; \n            } \n        } \n    } \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][5] = tmp3; \n            } \n        } \n    } \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n            "}
{"label": " \nint ho2roLoop (double* ho, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * rostep; \n      \n    trash = ho2ro(&(ho[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ho2roLoop (double* ho, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * rostep; \n      \n    trash = ho2ro(&(ho[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": "loat *const restrict in, float *const restrict norms, \n                                  float *const restrict ratios, \n                                  const dt_iop_order_iccprofile_info_t *const work_profile, const int variant, \n                                  const size_t width, const size_t height) \n{ \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float norm = fmaxf(get_pixel_norm(in + k, variant, work_profile), NORM_MIN); \n    norms[k / 4] = norm; \n    for_each_channel(c,aligned(ratios,in)) \n      ratios[k + c] = in[k + c] / norm; \n  } \n} \n \n \nstatic inline void restore_ratios(float ", "pred": "loat *const restrict in, float *const restrict norms, \n                                  float *const restrict ratios, \n                                  const dt_iop_order_iccprofile_info_t *const work_profile, const int variant, \n                                  const size_t width, const size_t height) \n{ \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float norm = fmaxf(get_pixel_norm(in + k, variant, work_profile), NORM_MIN); \n    norms[k / 4] = norm; \n    for_each_channel(c,aligned(ratios,in)) \n      ratios[k + c] = in[k + c] / norm; \n  } \n} \n \n \nstatic inline void restore_ratios(float "}
{"label": "nst float *const restrict in, float *const restrict out, \n                                      const dt_iop_order_iccprofile_info_t *const work_profile, \n                                      const dt_iop_filmicrgb_data_t *const data, \n                                      const dt_iop_filmic_rgb_spline_t spline, const size_t width, \n                                      const size_t height) \n{ \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n    dt_aligned_pixel_t temp; \n \n     \n \n    for(int c = 0; c < 3; c++) \n      temp[c] = log_tonemapping_v2(fmaxf(pix_in[c], NORM_MIN), data->grey_source, data->black_source, \n                                   data->dynamic_range); \n \n     \n \n    const float lum = (work_profile) \n                         ? dt_ioppr_get_rgb_matrix_luminance(temp, work_profile->matrix_in, work_profile->lut_in, \n                                                              work_profile->unbounded_coeffs_in, \n                                                              work_profile->lutsize, work_profile->nonlinearlut) \n                          : dt_camera_rgb_luminance(temp); \n    const float desaturation = filmic_desaturate_v2(lum, data->sigma_toe, data->sigma_shoulder, data->saturation); \n \n     \n \n     \n \n     \n \n    for(int c = 0; c < 3; c++) \n      pix_out[c] = powf( \n          clamp_simd(filmic_spline(linear_saturation(temp[c], lum, desaturation), spline.M1, spline.M2, spline.M3, \n                                   spline.M4, spline.M5, spline.latitude_min, spline.latitude_max, spline.type)), \n          data->output_power); \n  } \n} \n \n \nstatic inline void filmic_chroma_v1(co ", "pred": "nst float *const restrict in, float *const restrict out, \n                                      const dt_iop_order_iccprofile_info_t *const work_profile, \n                                      const dt_iop_filmicrgb_data_t *const data, \n                                      const dt_iop_filmic_rgb_spline_t spline, const size_t width, \n                                      const size_t height) \n{ \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n    dt_aligned_pixel_t pix_out_r, pix_out_g, pix_out_b; \n    dt_aligned_pixel_t pix_in_r, pix_in_g, pix_in_b; \n    dt_aligned_pixel_t pix_out_r_c, pix_out_g_c, pix_out_b_c; \n    dt_aligned_pixel_t pix_in_r_c, pix_in_g_c, pix_in_b_c; \n    dt_aligned_pixel_t pix_out_r_c_c, pix_out_g_c_c, pix_out_b_c_c; \n    dt_aligned_pixel_t pix_in_r_c_c, pix_in_g_c_c, pix_in_b_c_c; \n    dt_aligned_pixel_t pix_out_r_c_c, pix_out_g_c_c, pix_out_b_c_c; \n    dt_aligned_pixel_t pix_in_r_c_c, pix_in_g_c_c, pix_in_b_c_c; \n    dt_aligned_pixel_t pix_out_r_c_c_c, pix_out_g_c_c_c, pix_out_b_c_c_c; \n    dt_aligned_pixel_t pix_in_r_c_c_c, pix_in_g_c_c_c, pix_in_b_c_c_c; \n    dt_aligned_pixel_t pix_out_r_c_c_c, pix_out_g_c_c_c, pix_out_b_c_c_c; \n    dt_aligned_pixel_t pix_in_r_c_c_c, pix_in_g_c_c_c, pix_in_b_c_c_c; \n    dt_aligned_pixel_t pix_out_r_c_c_c, pix_out_g_c_c_c, pix_out_b_c_c_c; \n    dt_aligned_pixel_t pix_in_r_c_c_c, pix_in_g_c_c_c, pix_in_b_c_c_c; \n    dt_aligned_pixel_t pix_out_r_c_c_c, pix_out_g_c_c_c, pix_out_b_c_c_c; \n    dt_aligned_pixel_t pix"}
{"label": " \nint ro2omLoop (double* ro, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * omstep; \n      \n    trash = ro2om(&(ro[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ro2omLoop (double* ro, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * omstep; \n      \n    trash = ro2om(&(ro[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic int crypt_all(int *pcount, struct db_salt *salt) \n{ \n\tint count = *pcount; \n\tint index; \n \n\tglobal_work_size = (count + local_work_size - 1) / local_work_size * local_work_size; \n \n\tif (any_cracked) { \n\t\tmemset(cracked, 0, cracked_size); \n\t\tany_cracked = 0; \n\t} \n \n\t \n \n\tHANDLE_CLERROR(clEnqueueWriteBuffer(queue[gpu_id], mem_in, CL_FALSE, 0, \n\t\tinsize, inbuffer, 0, NULL, multi_profilingEvent[0]), \n\t        \"Copy data to gpu\"); \n \n\t \n \n\tHANDLE_CLERROR(clEnqueueNDRangeKernel(queue[gpu_id], crypt_kernel, 1, \n\t\tNULL, &global_work_size, &local_work_size, 0, NULL, \n\t        multi_profilingEvent[1]), \"Run kernel\"); \n \n\t \n \n\tHANDLE_CLERROR(clEnqueueReadBuffer(queue[gpu_id], mem_out, CL_TRUE, 0, \n\t\toutsize, outbuffer, 0, NULL, multi_profilingEvent[2]), \"Copy result back\"); \n \n\tfor (index = 0; index < count; index++) \n\tif (!blockchain_decrypt((unsigned char*)outbuffer[index].v, cur_salt->data)) \n\t{ \n\t\tcracked[index] = 1; \n\t\tany_cracked |= 1; \n\t} \n \n\treturn count; \n} ", "pred": " \nstatic int crypt_all(int *pcount, struct db_salt *salt) \n{ \n\tint count = *pcount; \n\tint index; \n \n\tglobal_work_size = (count + local_work_size - 1) / local_work_size * local_work_size; \n \n\tif (any_cracked) { \n\t\tmemset(cracked, 0, cracked_size); \n\t\tany_cracked = 0; \n\t} \n \n\t \n \n\tHANDLE_CLERROR(clEnqueueWriteBuffer(queue[gpu_id], mem_in, CL_FALSE, 0, \n\t\tinsize, inbuffer, 0, NULL, multi_profilingEvent[0]), \n\t        \"Copy data to gpu\"); \n \n\t \n \n\tHANDLE_CLERROR(clEnqueueNDRangeKernel(queue[gpu_id], crypt_kernel, 1, \n\t\tNULL, &global_work_size, &local_work_size, 0, NULL, \n\t        multi_profilingEvent[1]), \"Run kernel\"); \n \n\t \n \n\tHANDLE_CLERROR(clEnqueueReadBuffer(queue[gpu_id], mem_out, CL_TRUE, 0, \n\t\toutsize, outbuffer, 0, NULL, multi_profilingEvent[2]), \"Copy data to gpu\"); \n \n\t \n\tHANDLE_CLERROR(clFinish(queue[gpu_id]), \"Copy data to gpu\"); \n \n\tfor (index = 0; index < count; index++) { \n\t\tsalt->salt_buf[index] ^= outbuffer[index]; \n\t} \n \n\treturn count; \n} \n \n \n \n \n"}
{"label": " \nstatic void lhsz(void) \n{ \n    int i, j, k; \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                fjac[i][j][k][0][0] = 0.0; \n                fjac[i][j][k][0][1] = 0.0; \n                fjac[i][j][k][0][2] = 0.0; \n                fjac[i][j][k][0][3] = 1.0; \n                fjac[i][j][k][0][4] = 0.0; \n                fjac[i][j][k][1][0] = - (u[i][j][k][1] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][1][1] = u[i][j][k][3] * tmp1; \n                fjac[i][j][k][1][2] = 0.0; \n                fjac[i][j][k][1][3] = u[i][j][k][1] * tmp1; \n                fjac[i][j][k][1][4] = 0.0; \n                fjac[i][j][k][2][0] = - (u[i][j][k][2] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][2][1] = 0.0; \n                fjac[i][j][k][2][2] = u[i][j][k][3] * tmp1; \n                fjac[i][j][k][2][3] = u[i][j][k][2] * tmp1; \n                fjac[i][j][k][2][4] = 0.0; \n                fjac[i][j][k][3][0] = - (u[i][j][k][3] * u[i][j][k][3] * tmp2) + 0.50 * c2 * ((u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2); \n                fjac[i][j][k][3][1] = - c2 * u[i][j][k][1] * tmp1; \n                fjac[i][j][k][3][2] = - c2 * u[i][j][k][2] * tmp1; \n                fjac[i][j][k][3][3] = (2.0 - c2) * u[i][j][k][3] * tmp1; \n                fjac[i][j][k][3][4] = c2; \n                fjac[i][j][k][4][0] = (c2 * (u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2 - c1 * (u[i][j][k][4] * tmp1)) * (u[i][j][k][3] * tmp1); \n                fjac[i][j][k][4][1] = - c2 * (u[i][j][k][1] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][4][2] = - c2 * (u[i][j][k][2] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][4][3] = c1 * (u[i][j][k][4] * tmp1) - 0.50 * c2 * ((u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + 3.0 * u[i][j][k][3] * u[i][j][k][3]) * tmp2); \n                fjac[i][j][k][4][4] = c1 * u[i][j][k][3] * tmp1; \n                njac[i][j][k][0][0] = 0.0; \n                njac[i][j][k][0][1] = 0.0; \n                njac[i][j][k][0][2] = 0.0; \n                njac[i][j][k][0][3] = 0.0; \n                njac[i][j][k][0][4] = 0.0; \n                njac[i][j][k][1][0] = - c3c4 * tmp2 * u[i][j][k][1]; \n                njac[i][j][k][1][1] = c3c4 * tmp1; \n                njac[i][j][k][1][2] = 0.0; \n                njac[i][j][k][1][3] = 0.0; \n                njac[i][j][k][1][4] = 0.0; \n                njac[i][j][k][2][0] = - c3c4 * tmp2 * u[i][j][k][2]; \n        ", "pred": " \nstatic void lhsz(void) \n{ \n    int i, j, k; \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][0] = tmp3; \n                f[i][j][k][1] = tmp2; \n                f[i][j][k][2] = tmp1; \n            } \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][0] = tmp3; \n                f[i][j][k][1] = tmp2; \n                f[i][j][k][2] = tmp1; \n            } \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][0] = tmp3; \n                f[i][j][k][1] = tmp2; \n                f[i][j][k][2] = tmp1; \n            } \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][0] = tmp3; \n                f[i][j][k][1] = tmp2; \n                f[i][j][k][2] = tmp1; \n            } \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][0] = tmp3; \n                f[i][j][k][1] = tmp2; \n                f[i][j][k][2] = tmp1; \n            } \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 0; \n                k <"}
{"label": " \nint om2euLoop (double* om, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * eustep; \n      \n    trash = om2eu(&(om[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint om2euLoop (double* om, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * eustep; \n      \n    trash = om2eu(&(om[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ax2quLoop (double* ax, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * qustep; \n      \n    trash = ax2qu(&(ax[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ax2quLoop (double* ax, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * qustep; \n      \n    trash = ax2qu(&(ax[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": "t float *const restrict in, float *const restrict out, \n                                    const dt_iop_order_iccprofile_info_t *const work_profile, \n                                    const dt_iop_filmicrgb_data_t *const data, \n                                    const dt_iop_filmic_rgb_spline_t spline, const int variant, const size_t width, \n                                    const size_t height) \n{ \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n \n    dt_aligned_pixel_t ratios = { 0.0f }; \n    float norm = fmaxf(get_pixel_norm(pix_in, variant, work_profile), NORM_MIN); \n \n     \n \n    for_each_channel(c,aligned(pix_in)) \n      ratios[c] = pix_in[c] / norm; \n \n     \n \n    const float min_ratios = fminf(fminf(ratios[0], ratios[1]), ratios[2]); \n    if(min_ratios < 0.0f) \n      for_each_channel(c) ratios[c] -= min_ratios; \n \n     \n \n    norm = log_tonemapping_v1(norm, data->grey_source, data->black_source, data->dynamic_range); \n \n     \n \n    const float desaturation = filmic_desaturate_v1(norm, data->sigma_toe, data->sigma_shoulder, data->saturation); \n \n    for_each_channel(c) ratios[c] *= norm; \n \n    const float lum = (work_profile)? dt_ioppr_get_rgb_matrix_luminance( \n                          ratios, work_profile->matrix_in, work_profile->lut_in, work_profile->unbounded_coeffs_in, \n                          work_profile->lutsize, work_profile->nonlinearlut) \n                                     : dt_camera_rgb_luminance(ratios); \n \n     \n \n    for(int c = 0; c < 3; c++) ratios[c] = linear_saturation(ratios[c], lum, desaturation) / norm; \n \n     \n \n     \n \n    norm = powf(clamp_simd(filmic_spline(norm, spline.M1, spline.M2, spline.M3, spline.M4, spline.M5, \n                                         spline.latitude_min, spline.latitude_max, spline.type)), \n                data->output_power); \n \n     \n \n    for_each_channel(c,aligned(pix_out)) pix_out[c] = ratios[c] * norm; \n  } \n} \n \n \nstatic inline void filmic_chroma_v2_v3 ", "pred": "t float *const restrict in, float *const restrict out, \n                                    const dt_iop_order_iccprofile_info_t *const work_profile, \n                                    const dt_iop_filmicrgb_data_t *const data, \n                                    const dt_iop_filmic_rgb_spline_t spline, const int variant, const size_t width, \n                                    const size_t height) \n{ \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n \n    dt_aligned_pixel_t ratios = { 0.0f, 0.0f, 0.0f, 0.0f };\n    dt_aligned_pixel_t weights = { 0.0f, 0.0f, 0.0f, 0.0f };\n    dt_aligned_pixel_t weights_out = { 0.0f, 0.0f, 0.0f, 0.0f };\n    dt_aligned_pixel_t weights_out_out = { 0.0f, 0.0f, 0.0f, 0.0f };\n    dt_aligned_pixel_t weights_out_out_out = { 0.0f, 0.0f, 0.0f, 0.0f };\n    dt_aligned_pixel_t weights_out_out_out_out = { 0.0f, 0.0f, 0.0f, 0.0f };\n    dt_aligned_pixel_t weights_out_out_out_out_out = { 0.0f, 0.0f, 0.0f, 0.0f };\n    dt_aligned_pixel_t weights_out_out_out_out_out_out = { 0.0f, 0.0f, 0.0f, 0.0f };\n    dt_aligned_pixel_t weights_out_out_out_out_out_out_out = { 0.0f, 0.0f, 0.0f, 0.0f };\n    dt_aligned_pixel_t weights_out_out_out_out_out_out_out_out = { 0.0f, 0.0f, 0.0f, 0.0f };\n    dt_aligned_pixel_t weights_out_out_out_out_out_out_out_out_out = { 0.0f, 0.0f, 0.0f, 0.0f };\n    dt_aligned_pixel_t weights_out_out_out_out_out_out_out_out_out_out = { 0.0f, 0.0f, 0.0f, 0.0f };\n    dt_aligned_pixel_t weights_out_out_out_out_out_out_out_out_out_out_out = { 0.0f, 0.0f, 0.0f, 0.0f };\n    dt_aligned_pixel_t weights_out_out_out_out_out_out_out_out_out_out_out_out = { 0.0f, 0.0f, 0.0f, 0.0f };\n    dt_aligned_pixel_t weights_out_out_out_out_out_out_out_out_out_out_out_out_out = { 0.0f, 0.0f, 0.0f, 0.0f };\n    dt_aligned_pixel_t weights_out_out_out_out_out_"}
{"label": " \nint ho2omLoop (double* ho, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * omstep; \n      \n    trash = ho2om(&(ho[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ho2omLoop (double* ho, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * omstep; \n      \n    trash = ho2om(&(ho[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ro2hoLoop (double* ro, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * hostep; \n      \n    trash = ro2ho(&(ro[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ro2hoLoop (double* ro, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * hostep; \n      \n    trash = ro2ho(&(ro[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void y_solve_cell(void) \n{ \n    int i, j, k, jsize; \n    jsize = grid_points[1] - 1; \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            binvcrhs(lhs[i][0][k][1], lhs[i][0][k][2], rhs[i][0][k]); \n        } \n    } \n    for (j = 1; \n        j < jsize; \n        j++) \n    { \n        for (i = 1; \n            i < grid_points[0] - 1; \n            i++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                matvec_sub(lhs[i][j][k][0], rhs[i][j - 1][k], rhs[i][j][k]); \n                matmul_sub(lhs[i][j][k][0], lhs[i][j - 1][k][2], lhs[i][j][k][1]); \n                binvcrhs(lhs[i][j][k][1], lhs[i][j][k][2], rhs[i][j][k]); \n            } \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            matvec_sub(lhs[i][jsize][k][0], rhs[i][jsize - 1][k], rhs[i][jsize][k]); \n            matmul_sub(lhs[i][jsize][k][0], lhs[i][jsize - 1][k][2], lhs[i][jsize][k][1]); \n            binvrhs(lhs[i][jsize][k][1], rhs[i][jsize][k]); \n        } \n    } \n} ", "pred": " \nstatic void y_solve_cell(void) \n{ \n    int i, j, k, jsize; \n    jsize = grid_points[1] - 1; \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            binvcrhs(lhs[i][0][k][1], lhs[i][0][k][2], rhs[i][0][k]); \n        } \n    } \n    for (j = 1; \n        j < jsize; \n        j++) \n    { \n        for (i = 1; \n            i < grid_points[0] - 1; \n            i++) \n        { \n            binvcrhs(lhs[i][0][j][1], lhs[i][0][j][2], rhs[i][0][j]); \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[2] - 1; \n            j++) \n        { \n            binvcrhs(lhs[i][0][j][1], lhs[i][0][j][2], rhs[i][0][j]); \n        } \n    } \n    for (j = 1; \n        j < jsize; \n        j++) \n    { \n        for (i = 1; \n            i < grid_points[0] - 1; \n            i++) \n        { \n            binvcrhs(lhs[i][0][j][1], lhs[i][0][j][2], rhs[i][0][j]); \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[2] - 1; \n            j++) \n        { \n            binvcrhs(lhs[i][0][j][1], lhs["}
{"label": " \nint ro2axLoop (double* ro, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * axstep; \n      \n    trash = ro2ax(&(ro[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ro2axLoop (double* ro, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * axstep; \n      \n    trash = ro2ax(&(ro[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void z_backsubstitute(void) \n{ \n    int i, j, k, m, n; \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = grid_points[2] - 2; \n                k >= 0; \n                k--) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        rhs[i][j][k][m] = rhs[i][j][k][m] - lhs[i][j][k][2][m][n] * rhs[i][j][k + 1][n]; \n                    } \n                } \n            } \n        } \n    } \n} ", "pred": " \nstatic void z_backsubstitute(void) \n{ \n    int i, j, k, m, n; \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = grid_points[2] - 2; \n                k >= 0; \n                k--) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        if (i == 1 && j == 1 && k == 1 && m == 0 && n == 0) \n                        { \n                            grid_points[0] = i; \n                            grid_points[1]"}
{"label": " \nint main() \n{ \n  Entero_grande i, n; \n   \n  #ifdef _OPENMP \n  double t1 = omp_get_wtime(); \n  #endif   \n   \n  int numberOfThreads; \n  numberOfThreads = omp_get_num_threads(); \n  n = 2;  \n \n  for (i = 3; i <= N; i += 2){ \n      if (primo(i)) \n      { \n         n++; \n      } \n  } \n   \n  #ifdef _OPENMP \n  double t2 = omp_get_wtime(); \n  printf(\"looptime: %f seconds \\n\", t2-t1); \n  #endif \n   \n  printf(\"Entre el 1 y el %llu hay %llu numeros primos.\\n\", \n         N, n); \n \n  return 0; \n} ", "pred": " \nint main() \n{ \n  Entero_grande i, n; \n   \n  #ifdef _OPENMP \n  double t1 = omp_get_wtime(); \n  #endif   \n   \n  int numberOfThreads; \n  numberOfThreads = omp_get_num_threads(); \n  n = 2;  \n \n  for (i = 3; i <= N; i += 2){ \n      if (primo(i)) \n      { \n         n++; \n      } \n  } \n   \n  #ifdef _OPENMP \n  double t2 = omp_get_wtime(); \n  printf(\"looptime: %f seconds \\n\", t2-t1); \n  #endif \n   \n  printf(\"Entre el 1 y el %llu hay %llu numeros primos.\\n\", \n         N, n); \n \n  return 0; \n} "}
{"label": " \nstatic void exact_rhs(void) \n{ \n    double dtemp[5], xi, eta, zeta, dtpp; \n    int m, i, j, k, ip1, im1, jp1, jm1, km1, kp1; \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    forcing[i][j][k][m] = 0.0; \n                } \n            } \n        } \n    } \n    for (j = 1; \n        j < grid_points[1] - 1; \n        j++) \n    { \n        eta = (double) j * dnym1; \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            zeta = (double) k * dnzm1; \n            for (i = 0; \n                i < grid_points[0]; \n                i++) \n            { \n                xi = (double) i * dnxm1; \n                exact_solution(xi, eta, zeta, dtemp); \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    ue[i][m] = dtemp[m]; \n                } \n                dtpp = 1.0 / dtemp[0]; \n                for (m = 1; \n                    m <= 4; \n                    m++) \n                { \n                    buf[i][m] = dtpp * dtemp[m]; \n                } \n                cuf[i] = buf[i][1] * buf[i][1]; \n                buf[i][0] = cuf[i] + buf[i][2] * buf[i][2] + buf[i][3] * buf[i][3]; \n                q[i] = 0.5 * (buf[i][1] * ue[i][1] + buf[i][2] * ue[i][2] + buf[i][3] * ue[i][3]); \n            } \n            for (i = 1; \n                i < grid_points[0] - 1; \n                i++) \n            { \n                im1 = i - 1; \n                ip1 = i + 1; \n                forcing[i][j][k][0] = forcing[i][j][k][0] - tx2 * (ue[ip1][1] - ue[im1][1]) + dx1tx1 * (ue[ip1][0] - 2.0 * ue[i][0] + ue[im1][0]); \n                forcing[i][j][k][1] = forcing[i][j][k][1] - tx2 * ((ue[ip1][1] * buf[ip1][1] + c2 * (ue[ip1][4] - q[ip1])) - (ue[im1][1] * buf[im1][1] + c2 * (ue[im1][4] - q[im1]))) + xxcon1 * (buf[ip1][1] - 2.0 * buf[i][1] + buf[im1][1]) + dx2tx1 * (ue[ip1][1] - 2.0 * ue[i][1] + ue[im1][1]); \n                forcing[i][j][k][2] = forcing[i][j][k][2] - tx2 * (ue[ip1][2] * buf[ip1][1] - ue[im1][2] * buf[im1][1]) + xxcon2 * (buf[ip1][2] - 2.0 * buf[i][2] + buf[im1][2]) + dx3tx1 * (ue[ip1][2] - 2.0 * ue[i][2] + ue[im1][2]); \n                forcing[i][j][k][3] = forcing[i][j][k][3] - tx2 * (ue[ip1][3] * buf[ip1][1] - ue[im1][3] * buf[im1][1]) + xxcon2 * (buf[ip1][3] - 2.0 * buf[i][3] + buf[im1][3]) + dx4tx1 * (ue[ip1][3] - 2.0 * ue[i][3] + ue[im1][3]); \n                forcing[i][j][k][4] = forcing[i][j][k][4] - tx2 * (buf[ip1][1] * (c1 * ue[ip1][4] - c2 * q[ip1]) - buf[im1][1] * (c1 * ue[im1][4] - c2 * q[im1])) + 0.5 * xxcon3 * (buf[ip1][0] - 2.0 * buf[i][0] + buf[im1][0]) + xxcon4 * (cuf[ip1] - 2.0 * cuf[i] + cuf[im1]) + xxcon5 * (buf[ip1][4] - 2.0 * buf[i][4] + buf[im1][4]) + dx5tx1 * (ue[ip1][4] - 2.0 * ue[i][4] + ue[im1][4]); \n        ", "pred": " \nstatic void exact_rhs(void) \n{ \n    double dtemp[5], xi, eta, zeta, dtpp; \n    int m, i, j, k, ip1, im1, jp1, jm1, km1, kp1; \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    xi = (double)i; \n                    eta = (double)j; \n                    zeta = (double)k; \n                    dtpp = (double)m; \n                    dtemp[m] = 0.0; \n                    for (ip1 = 0; \n                        ip1 < grid_points[m+1]-1; \n                        ip1++) \n                    { \n                        im1 = (int)ip1; \n                        jp1 = (int)(ip1+0.5); \n                        jm1 = (int)(ip1-0.5); \n                        km1 = (int)(ip1-1.5); \n                        kp1 = (int)(ip1+1.5); \n                        for (jp2 = jp1; \n                            jp2 < jp1+grid_points[m+1]-1; \n                            jp2++) \n                        { \n                            jm2 = (int)(jp2+0.5); \n                            km2 = (int)(jp2-0.5); \n                            kp2 = (int)(jp2-1.5); \n                            for (km1 = km1; \n                                km1 < km1+grid_points[m+1]-1; \n                                km1++) \n                            { \n                                kp1 = (int)(km1+0.5); \n                                kp2 = (int)(km1-0.5); \n                                for (km2 = km2; \n                                    km2 < km2+grid_points[m+1]-1; \n                                    km2++) \n                                { \n                                    kp2 = (int)(km2+0.5); \n                                    dtpp = (double)(kp2-kp1)/(double)(kp2-kp1+1); \n                                    dtemp[m] = (dtemp[m] + \n                                                (double)dtpp*(xi*xi + eta*eta + zeta*zeta)); \n                                } \n                            } \n                        } \n                    } \n                } \n            } \n        } \n    } \n    return; \n} \n\n/*\n * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n\n/*\n"}
{"label": " \nint eu2hoLoop (double* eu, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * hostep; \n      \n    trash = eu2ho(&(eu[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint eu2hoLoop (double* eu, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * hostep; \n      \n    trash = eu2ho(&(eu[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nvoid \nf1 (void) \n{ \n  int i; \n  for (i = 0; i < 64; i++) \n    ; \n  for (i = 0; i < 64; i++) \n    ; \n  for (int j = 0; j < 64; j++) \n    ; \n  for (s1 = 0; s1 < 64; s1 += 2) \n    ; \n  for (i = 0; i < 64; i++) \n    s2 = 2 * i; \n  for (i = 0; i < 64; i++) \n    ; \n  for (s3 = 0; s3 < 64; s3++) \n    for (s4 = 0; s4 < 3; s4++) \n      ; \n  for (i = 0; i < 64; i++) \n    ; \n  for (i = 0; i < 64; i++) \n    ; \n  for (s5 = 0; s5 < 64; s5++) \n    ; \n  for (i = 0; i < 64; i++) \n    s8 = s7++; \n} ", "pred": " \nvoid \nf1 (void) \n{ \n  int i; \n  for (i = 0; i < 64; i++) \n    ; \n  for (i = 0; i < 64; i++) \n    ; \n  for (int j = 0; j < 64; j++) \n    ; \n  for (s1 = 0; s1 < 64; s1 += 2) \n    ; \n  for (i = 0; i < 64; i++) \n    s2 = 2 * i; \n  for (i = 0; i < 64; i++) \n    ; \n  for (s3 = 0; s3 < 64; s3++) \n    for (s4 = 0; s4 < 3; s4++) \n      ; \n  for (i = 0; i < 64; i++) \n    ; \n  for (i = 0; i < 64; i++) \n    ; \n  for (s5 = 0; s5 < 64; s5++) \n    ; \n  for (i = 0; i < 64; i++) \n    s8 = s7++; \n} "}
{"label": "struct_ratios(const float *const restrict HF, const float *const restrict LF, \n                                               const float *const restrict texture, \n                                               const float *const restrict mask, \n                                               float *const restrict reconstructed, const size_t width, \n                                               const size_t height, const size_t ch, const float gamma, \n                                               const float gamma_comp, const float beta, const float beta_comp, \n                                               const float delta, const size_t s, const size_t scales) \n{ \n \n \n  for(size_t k = 0; k < height * width * ch; k += 4) \n  { \n    const float alpha = mask[k / ch]; \n \n     \n \n    const float *const restrict HF_c = __builtin_assume_aligned(HF + k, 16); \n    const float *const restrict LF_c = __builtin_assume_aligned(LF + k, 16); \n    const float *const restrict TT_c = __builtin_assume_aligned(texture + k, 16); \n \n     \n \n     \n \n     \n \n    const float grey_texture = fmaxabsf(fmaxabsf(TT_c[0], TT_c[1]), TT_c[2]); \n \n     \n \n     \n \n    const float grey_details = (HF_c[0] + HF_c[1] + HF_c[2]) / 3.f; \n \n     \n \n     \n \n     \n \n    const float grey_HF = (gamma_comp * grey_details + gamma * grey_texture); \n \n    #ifdef _OPENMP \n    #endif \n    for(size_t c = 0; c < 4; c++) \n    { \n       \n \n       \n \n      const float details = 0.5f * ((gamma_comp * HF_c[c] + gamma * TT_c[c]) + grey_HF); \n \n       \n \n      const float residual = (s == scales - 1)? LF_c[c] : 0.f; \n      reconstructed[k + c] += alpha * (delta * details + residual); \n    } \n  } \n} \n \n \nstatic inline void init_reconstru ", "pred": "struct_ratios(const float *const restrict HF, const float *const restrict LF, \n                                               const float *const restrict texture, \n                                               const float *const restrict mask, \n                                               float *const restrict reconstructed, const size_t width, \n                                               const size_t height, const size_t ch, const float gamma, \n                                               const float gamma_inv, const float gamma_inv_inv, \n                                               const float gamma_inv_inv_inv, const float gamma_inv_inv_inv_inv, \n                                               const float gamma_inv_inv_inv_inv, const float gamma_inv_inv_inv_inv_inv, \n                                               const float gamma_inv_inv_inv_inv_inv, const float gamma_inv_inv_inv_inv_inv_inv_inv, \n                                               const float gamma_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_"}
{"label": " \nstatic void lhsinit(void) \n{ \n    int i, j, k, m, n; \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        lhs[i][j][k][0][m][n] = 0.0; \n                        lhs[i][j][k][1][m][n] = 0.0; \n                        lhs[i][j][k][2][m][n] = 0.0; \n                    } \n                } \n            } \n        } \n    } \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    lhs[i][j][k][1][m][m] = 1.0; \n                } \n            } \n        } \n    } \n} ", "pred": " \nstatic void lhsinit(void) \n{ \n    int i, j, k, m, n; \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        grid_points[m][n] = i + j * grid_points[m][n]; \n                    } \n                } \n            } \n        } \n    } \n    return; \n} \n\nstatic void rhsinit(void) \n{ \n    int i, j, k, m, n; \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        grid_points[m][n] = i"}
{"label": " \nint qu2euLoop (double* qu, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * eustep; \n      \n    trash = qu2eu(&(qu[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint qu2euLoop (double* qu, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * eustep; \n      \n    trash = qu2eu(&(qu[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": "(const float *const restrict in, const float *const restrict mask, \n                                    float *const restrict reconstructed, const size_t width, const size_t height) \n{ \n \n \n \n \n  for(size_t k = 0; k < height * width; k++) \n  { \n    for_each_channel(c,aligned(in,mask,reconstructed)) \n      reconstructed[4*k + c] = fmaxf(in[4*k + c] * (1.f - mask[k]), 0.f); \n  } \n} \n \n \nstatic inline void wavelets_detail ", "pred": "(const float *const restrict in, const float *const restrict mask, \n                                    float *const restrict reconstructed, const size_t width, const size_t height) \n{ \n \n \n \n \n  for(size_t k = 0; k < height * width; k++) \n  { \n    for_each_channel(c,aligned(in,mask,reconstructed)) \n      reconstructed[4*k + c] = fmaxf(in[4*k + c] * (1.f - mask[k]), 0.f); \n  } \n} \n \n \nstatic inline void wavelets_detail "}
{"label": " \nint eu2cuLoop (double* eu, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * custep; \n      \n    trash = eu2cu(&(eu[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint eu2cuLoop (double* eu, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * custep; \n      \n    trash = eu2cu(&(eu[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint main ( int argc, char *argv[] ) { \n \n    const double origin[3] = { 0.0, 0.0, 0.0 }; \n     \n \n     \n \n    double dim[3] = { 10.0, 10.0, 10.0 }; \n     \n \n    int nr_parts = 32680; \n     \n \n    double Temp = 100.0; \n     \n \n \n    double x[3], vtot[3] = { 0.0, 0.0, 0.0 }; \n    double epot, ekin, v2, temp, cutoff = 1.0, cellwidth; \n     \n \n    struct engine e; \n    struct particle pAr; \n    struct potential *pot_ArAr; \n     \n \n    int i, j, k, cid, pid, nr_runners = 1, nr_steps = 1000; \n    int nx, ny, nz; \n    double hx, hy, hz, w; \n    double L[] = { cutoff, cutoff, cutoff }; \n     \n \n \n    ticks tic, toc, toc_step, toc_temp; \n \n    tic = getticks(); \n \n     \n \n    if ( argc > 4 ) { \n        cellwidth = atof( argv[4] ); \n        nr_parts *= ( cellwidth * cellwidth * cellwidth ); \n        for ( k = 0 ; k < 3 ; k++ ) { \n            L[k] = cellwidth; \n            dim[k] *= cellwidth * (1.0 + DBL_EPSILON); \n        } \n    } \n    else \n        cellwidth = 1.0; \n    printf(\"main: cell width set to %22.16e.\\n\", cellwidth); \n \n     \n \n    printf(\"main: initializing the engine... \"); fflush(stdout); \n    if ( engine_init( &e, origin, dim, L, cutoff, space_periodic_full, 2, engine_flag_none )!= 0 ) { \n        printf(\"main: engine_init failed with engine_err=%i.\\n\",engine_err); \n        errs_dump(stdout); \n        return 1; \n    } \n    printf(\"done.\\n\"); fflush(stdout); \n \n     \n \n    printf(\"main: cell dimensions = [ %i, %i, %i ].\\n\", e.s.cdim[0], e.s.cdim[1], e.s.cdim[2] ); \n    printf(\"main: cell size = [ %e, %e, %e ].\\n\", e.s.h[0], e.s.h[1], e.s.h[2] ); \n    printf(\"main: cutoff set to %22.16e.\\n\", cutoff); \n    printf(\"main: nr tasks: %i.\\n\",e.s.nr_tasks); \n \n     \n \n \n \n     \n \n    if ( ( pot_ArAr = potential_create_LJ126( 0.275, 1.0, 9.5075e-06, 6.1545e-03, 1.0e-3 ) ) == NULL ) { \n        printf(\"main: potential_create_LJ126 failed with potential_err=%i.\\n\",potential_err); \n        errs_dump(stdout); \n        return 1; \n    } \n    printf(\"main: constructed ArAr-potential with %i intervals.\\n\",pot_ArAr->n); fflush(stdout); \n \n \n     \n \n    if ( ( pAr.type = engine_addtype( &e, 39.948, 0.0, \"Ar\", \"Ar\" ) ) < 0 ) { \n        printf(\"main: call to engine_addtype failed.\\n\"); \n        errs_dump(stdout); \n        return 1; \n    } \n \n     \n \n    if ( engine_addpot( &e, pot_ArAr, pAr.type, pAr.type ) < 0 ){ \n        printf(\"main: call to engine_addpot failed.\\n\"); \n        errs_dump(stdout); \n        return 1; \n    } \n \n     \n \n    srand(6178); \n    pAr.flags = PARTICLE_FLAG_NONE; \n    for ( k = 0 ; k < 3 ; k++ ) { \n        pAr.v[k] = 0.0; \n        pAr.f[k] = 0.0; \n    } \n    pAr.v[3] = 0.0; pAr.f[3] = 0.0; pAr.x[3] = 0.0; \n \n     \n \n    printf(\"main: initializing particles... \"); fflush(stdout); \n    nx = ceil( pow( nr_parts, 1.0/3 ) ); hx = dim[0] / nx; \n    ny = ceil( sqrt( ((double)nr_parts) / nx ) ); hy = dim[1] / ny; \n    nz = ceil( ((double)nr_parts) / nx / ny ); hz = dim[2] / nz; \n    for ( i = 0 ; i < nx ; i++ ) { \n        x[0] = 0.05 + i * hx; \n        for ( j = 0 ; j < ny ; j++ ) { \n            x[1] = 0.05 + j * hy; \n            for ( k = 0 ; k < nz && k + nz * ( j + ny * i ) < nr_parts ; k++ ) { \n                pAr.id = k + nz * ( j + ny * i ); \n                x[2] = 0.05 + k * hz; \n                pAr.v[0] = ((double)rand()) / RAND_MAX - 0.5; \n                pAr.v[1] = ((double)rand()) / RAND_MAX - 0.5; \n                pAr.v[2] = ((double)rand()) / RAND_MAX - 0.5; \n                temp = 0.275 / sqrt( pAr.v[0]*pAr.v[0] + pAr.v[1]*pAr.v[1] + pAr.v[2]*pAr.v[2] ); \n                pAr.v[0] *= temp; pAr.v[1] *= temp; pAr.v[2] *= temp; \n                vtot[0] += pAr.v[0]; vtot[1] += pAr.v[1]; vtot[2] += pAr.v[2]; \n                if ( space_addpart( &(e.s), &pAr, x )!= 0 ) { \n                    printf(\"main: space_addpart failed with space_err=%i.\\n\",space_err); \n                    errs_dump(stdout); \n                    return 1; \n                } \n            } \n        } \n ", "pred": " \nint main ( int argc, char *argv[] ) { \n \n    const double origin[3] = { 0.0, 0.0, 0.0 }; \n     \n \n     \n \n    double dim[3] = { 10.0, 10.0, 10.0 }; \n     \n \n    int nr_parts = 32680; \n     \n \n    double Temp = 100.0; \n     \n \n \n    double x[3], vtot[3] = { 0.0, 0.0, 0.0 }; \n    double epot, ekin, v2, temp, cutoff = 1.0, cellwidth; \n     \n \n    struct engine e; \n    struct particle pAr; \n    struct potential *pot_ArAr; \n     \n \n    int i, j, k, cid, pid, nr_runners = 1, nr_steps = 1000; \n    int nx, ny, nz; \n    double hx, hy, hz, w; \n    double L[] = { cutoff, cutoff, cutoff }; \n     \n \n \n    ticks tic, toc, toc_step, toc_step_2; \n    double t_start, t_end; \n    double t_start_2, t_end_2; \n    double t_start_3, t_end_3; \n    double t_start_4, t_end_4; \n    double t_start_5, t_end_5; \n    double t_start_6, t_end_6; \n    double t_start_7, t_end_7; \n    double t_start_8, t_end_8; \n    double t_start_9, t_end_9; \n    double t_start_10, t_end_10; \n    double t_start_11, t_end_11; \n    double t_start_12, t_end_12; \n    double t_start_13, t_end_13; \n    double t_start_14, t_end_14; \n    double t_start_15, t_end_15; \n    double t_start_16, t_end_16; \n    double t_start_17, t_end_17; \n    double t_start_18, t_end_18; \n    double t_start_19, t_end_19; \n    double t_start_20, t_end_20; \n    double t_start_21, t_end_21; \n    double t_start_22, t_end_22; \n    double t_start_23, t_end_23; \n    double t_start_24, t_end_24; \n    double t_start_25, t_end_25; \n    double t_start_26, t_end_26; \n    double t_start_27, t_end_27; \n    double t_start_28, t_end_28; \n    double t_start_29, t_end_29; \n    double t_start_30, t_end_30; \n    double t_start_31, t_end_31; \n    double t_start_32, t_end_32; \n    double t_start_33, t_end_33; \n    double t_start_34, t_end_34; \n    double t_start_35, t_end_35; \n    double t_start_36, t_end_36; \n    double t_start_37, t_end_37; \n    double t_start_38, t_end_38; \n    double t_start_39, t_end_39; \n    double t_start_40, t_end_40; \n    double t_start_41, t_end_41; \n    double t_start_42, t_end_42; \n    double t_start_43, t_end_43; \n    double t_start_44, t_end_44; \n    double t_start_45, t_end_45; \n    double t_start_46, t_end_46; \n    double t_start_47, t_end_47; \n    double t_start_48, t_end_48; \n    double t_start_49, t_end_49; \n    double t_start_50, t_end_50; \n    double t_start_51, t_end_51; \n    double t_start_52, t_end_52; \n    double t_start_53, t_end_53; \n    double t_start_54, t_end_54; \n    double t_start_55, t_end_55; \n    double t_start_56, t_end_56; \n    double t_start_57, t_end_57; \n    double t_start_58, t_end_58; \n    double t_start_59, t_end_59; \n    double t_start_60, t_end_60; \n    double t_start_61, t_end_61; \n    double t_start_62, t_end_62; \n    double t_start_63, t_end_63; \n    double t_start_64, t_end_64; \n    double t_start_65, t_end_65; \n    double t_start_66, t_end_66; \n    double t_start_67, t_end_67; \n    double t_start_68, t_end_68; \n    double t_start_69, t_end_69; \n    double t_start_70, t_end_70; \n    double t_start_71, t_end_71; \n    double t_start_72, t_end_72; \n    double t_start_73, t_end_73; \n    double t_start_74, t_end_74; \n    double t_start_75, t_end_75; \n    double t_start_76, t_end_76; \n    double t_start_77, t_end_77; \n    double t_start_78, t_end_78; \n    double t_start_79, t_end_79; \n    double t_start_80, t_end_80; \n    double t_start_81, t_end_81; \n    double t_start_82, t_end_82; \n    double t_start_83, t_end_83; \n    double t_start_84, t_end_84; \n    double t_start_85, t_end_85; \n    double t_start_86, t_end_86; \n    double t_start_87, t_end_87; \n    double t_start_88, t_end_88; \n    double t_start_89, t_end_89; \n    double t_start_90, t_end_90; \n    double t_start_91, t_end_91; \n    double t_start_92, t_end_92; \n    double t_start_93, t_end_93; \n    double t_start_94, t_end_94; \n    double t_start_95, t_end_95; \n    double t_start_96, t_end_96; \n    double t_start_97, t_end_97; \n    double t_start_98, t_end_98; \n    double t_start_99, t_end_99; \n    double t_start_100, t_end_100; \n    double t_start_101, t_end_101; \n    double t_start_102, t_end_102; \n    double t_start_103,"}
{"label": "at *const restrict mask, float *const restrict out, const size_t width, \n                                const size_t height) \n{ \n  for(size_t k = 0; k < height * width; k++) \n  { \n    for_each_channel(c,aligned(out)) \n      out[4*k+c] = mask[k]; \n  } \n} \n \n \nstatic inline void compute_ratios(const ", "pred": "at *const restrict mask, float *const restrict out, const size_t width, \n                                const size_t height) \n{ \n  for(size_t k = 0; k < height * width; k++) \n  { \n    for_each_channel(c,aligned(out)) \n      out[4*k+c] = mask[k]; \n  } \n} \n \n \nstatic inline void compute_ratios(const "}
{"label": " \nint cu2quLoop (double* cu, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * qustep; \n      \n    trash = cu2qu(&(cu[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint cu2quLoop (double* cu, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * qustep; \n      \n    trash = cu2qu(&(cu[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ro2quLoop (double* ro, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * qustep; \n      \n    trash = ro2qu(&(ro[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ro2quLoop (double* ro, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * qustep; \n      \n    trash = ro2qu(&(ro[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint qu2omLoop (double* qu, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * omstep; \n      \n    trash = qu2om(&(qu[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint qu2omLoop (double* qu, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * omstep; \n      \n    trash = qu2om(&(qu[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": "const restrict ratios, const float *const restrict norms, \n                                  const size_t width, const size_t height) \n{ \n  #ifdef _OPENMP \n  #endif \n  for(size_t k = 0; k < height * width; k++) \n    for_each_channel(c,aligned(norms,ratios)) \n      ratios[4*k + c] = clamp_simd(ratios[4*k + c]) * norms[k]; \n} \n \nvoid tiling_callback(struct dt_iop_modul ", "pred": "const restrict ratios, const float *const restrict norms, \n                                  const size_t width, const size_t height) \n{ \n  #ifdef _OPENMP \n  #endif \n  for(size_t k = 0; k < height * width; k++) \n    for_each_channel(c,aligned(norms,ratios)) \n      ratios[4*k + c] = clamp_simd(ratios[4*k + c]) * norms[k]; \n} \n \nvoid tiling_callback(struct dt_iop_modul "}
{"label": " float *const restrict in, float *const restrict out, \n                                   const dt_iop_order_iccprofile_info_t *const work_profile, \n                                   const dt_iop_filmicrgb_data_t *const data, \n                                   const dt_iop_filmic_rgb_spline_t spline, const size_t width, \n                                   const size_t height) \n{ \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n    dt_aligned_pixel_t temp; \n \n     \n \n    for(int c = 0; c < 3; c++) \n      temp[c] = log_tonemapping_v1(fmaxf(pix_in[c], NORM_MIN), data->grey_source, data->black_source, \n                                   data->dynamic_range); \n \n     \n \n    const float lum = (work_profile) \n                         ? dt_ioppr_get_rgb_matrix_luminance(temp, work_profile->matrix_in, work_profile->lut_in, \n                                                              work_profile->unbounded_coeffs_in, \n                                                              work_profile->lutsize, work_profile->nonlinearlut) \n                          : dt_camera_rgb_luminance(temp); \n    const float desaturation = filmic_desaturate_v1(lum, data->sigma_toe, data->sigma_shoulder, data->saturation); \n \n     \n \n     \n \n     \n \n    for(int c = 0; c < 3; c++) \n      pix_out[c] = powf( \n          clamp_simd(filmic_spline(linear_saturation(temp[c], lum, desaturation), spline.M1, spline.M2, spline.M3, \n                                   spline.M4, spline.M5, spline.latitude_min, spline.latitude_max, spline.type)), \n          data->output_power); \n  } \n} \n \n \nstatic inline void filmic_split_v2_v3( ", "pred": " float *const restrict in, float *const restrict out, \n                                   const dt_iop_order_iccprofile_info_t *const work_profile, \n                                   const dt_iop_filmicrgb_data_t *const data, \n                                   const dt_iop_filmic_rgb_spline_t spline, const size_t width, \n                                   const size_t height) \n{ \n  for(size_t k = 0; k < height * width * 4; k += 4) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n    dt_aligned_pixel_t temp; \n \n     \n \n    //                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "}
{"label": " \nint om2axLoop (double* om, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * axstep; \n      \n    trash = om2ax(&(om[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint om2axLoop (double* om, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * axstep; \n      \n    trash = om2ax(&(om[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint cu2roLoop (double* cu, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * rostep; \n      \n    trash = cu2ro(&(cu[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint cu2roLoop (double* cu, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * rostep; \n      \n    trash = cu2ro(&(cu[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void y_backsubstitute(void) \n{ \n    int i, j, k, m, n; \n    for (j = grid_points[1] - 2; \n        j >= 0; \n        j--) \n    { \n        for (i = 1; \n            i < grid_points[0] - 1; \n            i++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        rhs[i][j][k][m] = rhs[i][j][k][m] - lhs[i][j][k][2][m][n] * rhs[i][j + 1][k][n]; \n                    } \n                } \n            } \n        } \n    } \n} ", "pred": " \nstatic void y_backsubstitute(void) \n{ \n    int i, j, k, m, n; \n    for (j = grid_points[1] - 2; \n        j >= 0; \n        j--) \n    { \n        for (i = 1; \n            i < grid_points[0] - 1; \n            i++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        if (i == 1 && j == 1 && k == 1 && m == 0 && n == 0) \n                        { \n                            grid_points[0] = i; \n                            grid_points[1]"}
{"label": " \nvoid tkirmig_lop(bool adj, bool add, int nm, int nd, \n                float *modl, float *data) \n \n \n{ \n     int ih,it,icmp,icdp,itm,itp,im; \n     float cmp,cdp,tau,tau2; \n     float disx,dish_plus,dish_plus2,dish_minus,dish_minus2; \n     float vrms2,ts,tr,time,slope,tm,tp,h,wt; \n     int ompith=0; \n \n     sf_adjnull(adj,add,nm,nd,modl,data); \n     \n     for (ih=0; ih < nh; ih++) { \n         ompith=omp_get_thread_num(); \n         if (verb) sf_warning(\"ith=%d; offset %d of %d;\",ompith, ih+1,nh); \n \n         for (icmp=0; icmp < ncmp; icmp++) { \n \n             if (mask[ih][icmp]==0) continue; \n \n             cmp=cmp0+icmp*dcmp; \n \n             h = fabsf(off[ih*ncmp+icmp]); \n \n             if (adj) { \n                for (it=0; it < nt; it++) { \n                    trace[ompith][it]=data[ih*ncmp*nt+icmp*nt+it]; \n                    img[ompith][it] = 0.; \n                } \n                sf_doubint_lop(adj, false, nt, nt, img[ompith], trace[ompith]); \n             } else { \n                for (it=0; it < nt; it++) { \n                    img[ompith][it] = 0.; \n                    trace[ompith][it] = 0.; \n                } \n             } \n \n           for (icdp=0; icdp < ncdp; icdp++) { \n  \n              cdp = cdp0+icdp*dcdp; \n \n              disx=cdp-cmp; \n \n              if (fabsf(disx) > dcmp*apt) continue; \n \n              dish_plus=fabsf(disx+h); \n              dish_plus2=dish_plus*dish_plus; \n              dish_minus=fabsf(disx-h); \n              dish_minus2=dish_minus*dish_minus; \n \n              for (it=0; it < nt; it++) { \n                  im = ih*ncdp*nt+icdp*nt+it; \n                  tau = 0.5*(t0 + it*dt); \n                  tau2 = tau*tau; \n \n                  vrms2=vrms[icdp][it]*vrms[icdp][it]; \n                  ts=sqrtf(tau2+dish_plus2/vrms2); \n                  tr=sqrtf(tau2+dish_minus2/vrms2); \n                  time=ts+tr; \n \n                  if (time <= t0+(nt-1)*dt && ts!= 0. && tr!=0.) { \n \n                     slope=dish_plus/vrms2/(ts+dt)+dish_minus/vrms2/(tr+dt); \n \n                     tm=time-fabsf(slope*dcmp*aal)-dt; \n                     tp=time+fabsf(slope*dcmp*aal)+dt; \n                     itm=floorf((tm-t0)/dt); \n                     itp=floorf((tp-t0)/dt); \n                     wt=dt/(dt+tp-tm); \n                     wt*=wt; \n \n                     if (amp) wt*=tau*(tr*tr+ts*ts)/ts/tr/sqrtf(ts)/sqrtf(tr)/vrms2; \n                      \n \n \n                     if (itm>=0&&itp<nt-1) { \n                        spotw(adj,-wt,nt,t0,dt,tm,&modl[im],img[ompith]); \n                        spotw(adj,2*wt,nt,t0,dt,time,&modl[im],img[ompith]); \n                        spotw(adj,-wt,nt,t0,dt,tp,&modl[im],img[ompith]); \n                     } \n                  } \n \n               }  \n \n \n            }  \n \n \n            if (!adj) { \n               sf_doubint_lop(adj, false, nt, nt, img[ompith], trace[ompith]); \n               for (it=0; it<nt; it++) data[ih*ncmp*nt+icmp*nt+it] = trace[ompith][it]; \n            } \n \n        }  \n \n    }  \n \n \n    if (verb) sf_warning(\".\"); \n} ", "pred": " \nvoid tkirmig_lop(bool adj, bool add, int nm, int nd, \n                float *modl, float *data) \n \n \n{ \n     int ih,it,icmp,icdp,itm,itp,im; \n     float cmp,cdp,tau,tau2; \n     float disx,dish_plus,dish_plus2,dish_minus,dish_minus2; \n     float vrms2,ts,tr,time,slope,tm,tp,h,wt; \n     int ompith=0; \n \n     sf_adjnull(adj,add,nm,nd,modl,data); \n     \n     for (ih=0; ih < nh; ih++) { \n         ompith=omp_get_thread_num(); \n         if (verb) sf_warning(\"ith=%d; offset %d of %d;\",ompith, ih+1,nh); \n \n         for (icmp=0; icmp < ncmp; icmp++) { \n \n             if (adj) { \n                 icdp = icomp[ompith][icmp]; \n                 itp = icomp[ompith][icmp+1]; \n             } else { \n                 icdp = icomp[ompith][icmp]; \n                 itp = icomp[ompith][icmp+1]; \n             } \n \n             if (adj) { \n                 cmp = data[itp]; \n                 if (cmp == 0.0) continue; \n                 if (cmp < 0.0) { \n                     icdp = icomp[ompith][icmp+1]; \n                     itp = icomp[ompith][icmp]; \n                 } \n             } \n \n             if (adj) { \n                 cmp = data[itp]; \n                 if (cmp == 0.0) continue; \n                 if (cmp < 0.0) { \n                     icdp = icomp[ompith][icmp+1]; \n                     itp = icomp[ompith][icmp]; \n                 } \n             } \n \n             if (adj) { \n                 cmp = data[itp]; \n                 if (cmp == 0.0) continue; \n                 if (cmp < 0.0) { \n                     icdp = icomp[ompith][icmp+1]; \n                     itp = icomp[ompith][icmp]; \n                 } \n             } \n \n             if (adj) { \n                 cmp = data[itp]; \n                 if (cmp == 0.0) continue; \n                 if (cmp < 0.0) { \n                     icdp = icomp[ompith][icmp+1]; \n                     itp = icomp[ompith][icmp]; \n                 } \n             } \n \n             if (adj) { \n                 cmp = data[itp]; \n                 if (cmp == 0.0) continue; \n                 if (cmp < 0.0) { \n                     icdp = icomp[ompith][icmp+1]; \n                     itp = icomp[ompith][icmp]; \n                 } \n             } \n \n             if (adj) { \n                 cmp = data[itp]; \n                 if (cmp == 0.0) continue; \n                 if (cmp < 0.0) { \n                     icdp = icomp[ompith][icmp+1]; \n                     itp = icomp[ompith][icmp]; \n                 } \n             } \n \n             if (adj) { \n                 cmp = data[itp]; \n                 if (cmp == 0.0) continue; \n                 if (cmp < 0.0) { \n                     icdp = icomp[ompith][icmp+1]; \n                     itp = icomp[ompith][icmp]; \n                 } \n             } \n \n             if (adj) { \n                 cmp = data[itp]; \n                 if (cmp == 0.0) continue; \n                 if (cmp < 0.0) { \n                     icdp = icomp[ompith][icmp+1]; \n            "}
{"label": " \nint cu2euLoop (double* cu, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * eustep; \n      \n    trash = cu2eu(&(cu[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint cu2euLoop (double* cu, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * eustep; \n      \n    trash = cu2eu(&(cu[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic int nn_(SparseLinear_accGradParameters)(lua_State *L) \n{ \n  long i; \n  THTensor * input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor * gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  real scale = luaL_optnumber(L, 4, 1); \n  THTensor * bias = luaT_getfieldcheckudata(L, 1, \"bias\", torch_Tensor); \n  THTensor * weight = luaT_getfieldcheckudata(L, 1, \"weight\", torch_Tensor); \n  THTensor * gradBias = luaT_getfieldcheckudata(L, 1, \"gradBias\", torch_Tensor); \n  THTensor * gradWeight = luaT_getfieldcheckudata(L, 1, \"gradWeight\", torch_Tensor); \n  real weightDecay = luaT_getfieldchecknumber(L, 1, \"weightDecay\"); \n \n  long nnz = input->size[0]; \n  long outDim = weight->size[0]; \n  long inDim = weight->size[1]; \n \n  luaL_argcheck(L, nn_(checkInput)(input), 2, \"input size must be nnz x 2\"); \n  luaL_argcheck( \n    L, nn_(checkSize1D)(gradOutput, outDim), 3, \"gradOutput size wrong\"); \n  luaL_argcheck( \n    L, nn_(checkSize2D)(gradWeight, outDim, inDim), 1, \"gradWeight size wrong\"); \n  luaL_argcheck( \n    L, nn_(checkSize1D)(gradBias, outDim), 1, \"gradBias size wrong\"); \n \n  for(i = 0; i < nnz; i++) \n  { \n      long offset = (long)(THTensor_(get2d)(input, i, 0)) - 1; \n \n      if(offset >= 0 && offset < inDim)  \n \n      { \n          real val = scale*THTensor_(get2d)(input, i, 1); \n \n          THBlas_(axpy)(outDim, \n                        val, \n                        THTensor_(data)(gradOutput), \n                        gradOutput->stride[0], \n                        THTensor_(data)(gradWeight)+offset*gradWeight->stride[1], \n                        gradWeight->stride[0]); \n      } \n      else { \n          luaL_error(L, \"index out of bound. accGradParameters:  %ld not between 1 and %ld\", offset + 1, inDim); \n      } \n  } \n \n  THTensor_(cadd)(gradBias, gradBias, scale, gradOutput); \n \n  if(weightDecay!= 0) { \n    for(i = 0; i < nnz; i++) { \n      long offset = (long)(THTensor_(get2d)(input, i, 0)) - 1; \n      THBlas_(axpy)(outDim, \n                    weightDecay, \n                    THTensor_(data)(weight) + offset*weight->stride[1], \n                    weight->stride[0], \n                    THTensor_(data)(gradWeight)+offset*gradWeight->stride[1], \n                    gradWeight->stride[0]); \n    } \n    THTensor_(cadd)(gradBias, gradBias, weightDecay, bias); \n  } \n \n  return 0; \n} ", "pred": " \nstatic int nn_(SparseLinear_accGradParameters)(lua_State *L) \n{ \n  long i; \n  THTensor * input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor * gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  real scale = luaL_optnumber(L, 4, 1); \n  THTensor * bias = luaT_getfieldcheckudata(L, 1, \"bias\", torch_Tensor); \n  THTensor * weight = luaT_getfieldcheckudata(L, 1, \"weight\", torch_Tensor); \n  THTensor * gradBias = luaT_getfieldcheckudata(L, 1, \"gradBias\", torch_Tensor); \n  THTensor * gradWeight = luaT_getfieldcheckudata(L, 1, \"gradWeight\", torch_Tensor); \n  real weightDecay = luaT_getfieldchecknumber(L, 1, \"weightDecay\"); \n \n  long nnz = input->size[0]; \n  long outDim = weight->size[0]; \n  long inDim = weight->size[1]; \n \n  luaL_argcheck(L, nn_(checkInput)(input), 2, \"input size must be nnz x 2\"); \n  luaL_argcheck( \n    L, nn_(checkGradOutput)(gradOutput), 3, \"gradOutput size must be nnz x outDim\"); \n  luaL_argcheck(L, nn_(checkGradInput)(gradInput), 4, \"gradInput size must be nnz x inDim\"); \n  luaL_argcheck(L, nn_(checkGradParameters)(gradParameters), 5, \"gradParameters size must be nnz x outDim\"); \n  luaL_argcheck(L, nn_(checkWeight)(weight), 6, \"weight size must be nnz x outDim\"); \n  luaL_argcheck(L, nn_(checkBias)(bias), 7, \"bias size must be nnz x outDim\"); \n  luaL_argcheck(L, nn_(checkGradBias)(gradBias), 8, \"gradBias size must be nnz x outDim\"); \n  luaL_argcheck(L, nn_(checkGradWeight)(gradWeight), 9, \"gradWeight size must be nnz x outDim\"); \n  luaL_argcheck(L, nn_(checkWeightDecay)(weightDecay), 10, \"weightDecay must be nnz\"); \n \n  for (i = 0; i < nnz; i++) { \n    if (input->size[0]!= inDim) { \n      luaL_argerror(L, 1, \"input size must be nnz x inDim\"); \n    } \n    if (gradOutput->size[0]!= outDim) { \n      luaL_argerror(L, 2, \"gradOutput size must be nnz x outDim\"); \n    } \n    if (gradInput->size[0]!= inDim) { \n      luaL_argerror(L, 3, \"gradInput size must be nnz x inDim\"); \n    } \n    if (gradParameters->size[0]!= outDim) { \n      luaL_argerror(L, 4, \"gradParameters size must be nnz x outDim\"); \n    } \n    if (gradBias->size[0]!= outDim) { \n      luaL_argerror(L, 5, \"gradBias size must be nnz x outDim\"); \n    } \n    if (gradWeight->size[0]!= outDim) { \n      luaL_argerror(L, 6, \"gradWeight size must be nnz x outDim\"); \n    } \n    if (weightDecay!= weightDecay) { \n      luaL_argerror(L, 7, \"weightDecay must be nnz\"); \n    } \n    if (bias->size[0]!= outDim) { \n      luaL_argerror(L, 8, \"bias size must be nnz x outDim\"); \n    } \n    if (gradBias->size[0]!= outDim) { \n      luaL_argerror(L, 9, \"gradBias size must be nnz x outDim\"); \n    } \n    if (gradWeight->size[0]!= outDim) { \n      luaL_argerror(L, 10, \"gradWeight"}
{"label": " \nint ro2cuLoop (double* ro, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * custep; \n      \n    trash = ro2cu(&(ro[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ro2cuLoop (double* ro, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, rostep = 4, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * rostep; \n    iOut = i * custep; \n      \n    trash = ro2cu(&(ro[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " float *const restrict in, float *const restrict out, \n                                    const dt_iop_order_iccprofile_info_t *const work_profile, \n                                    const dt_iop_order_iccprofile_info_t *const export_profile, \n                                    const dt_iop_filmicrgb_data_t *const data, \n                                    const dt_iop_filmic_rgb_spline_t spline, const int variant, \n                                    const size_t width, const size_t height, const size_t ch, \n                                    const dt_iop_filmicrgb_colorscience_type_t colorscience_version, \n                                    const float display_black, const float display_white) \n{ \n   \n \n  dt_colormatrix_t input_matrix;          \n \n  dt_colormatrix_t output_matrix;         \n \n  dt_colormatrix_t export_input_matrix;   \n \n  dt_colormatrix_t export_output_matrix;  \n \n \n  const int use_output_profile = filmic_v4_prepare_matrices(input_matrix, output_matrix, export_input_matrix, \n                                                            export_output_matrix, work_profile, export_profile); \n \n  const float norm_min = exp_tonemapping_v2(0.f, data->grey_source, data->black_source, data->dynamic_range); \n  const float norm_max = exp_tonemapping_v2(1.f, data->grey_source, data->black_source, data->dynamic_range); \n \n  for(size_t k = 0; k < height * width * ch; k += ch) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n \n     \n \n     \n \n     \n \n     \n \n    float norm = CLAMPF(get_pixel_norm(pix_in, variant, work_profile), norm_min, norm_max); \n \n     \n \n    dt_aligned_pixel_t ratios = { 0.0f }; \n    for_each_channel(c,aligned(pix_in)) ratios[c] = pix_in[c] / norm; \n \n     \n \n    norm = log_tonemapping_v2(norm, data->grey_source, data->black_source, data->dynamic_range); \n \n     \n \n     \n \n    norm = powf(CLAMP(filmic_spline(norm, spline.M1, spline.M2, spline.M3, spline.M4, spline.M5, \n                                         spline.latitude_min, spline.latitude_max, spline.type), \n                      display_black, \n                      display_white), \n                data->output_power); \n \n     \n \n    for_each_channel(c,aligned(pix_out)) pix_out[c] = ratios[c] * norm; \n \n     \n \n    dt_aligned_pixel_t Ych_original = { 0.f }; \n    RGB_to_Ych(pix_in, input_matrix, Ych_original); \n \n     \n \n    dt_aligned_pixel_t Ych_final = { 0.f }; \n    RGB_to_Ych(pix_out, input_matrix, Ych_final); \n \n    gamut_mapping(Ych_final, Ych_original, pix_out, input_matrix, output_matrix, export_input_matrix, \n                  export_output_matrix, display_black, display_white, data->saturation, use_output_profile); \n  } \n} \n \nstatic inline void filmic_split_v4(const ", "pred": " float *const restrict in, float *const restrict out, \n                                    const dt_iop_order_iccprofile_info_t *const work_profile, \n                                    const dt_iop_order_iccprofile_info_t *const export_profile, \n                                    const dt_iop_filmicrgb_data_t *const data, \n                                    const dt_iop_filmic_rgb_spline_t spline, const int variant, \n                                    const size_t width, const size_t height, const size_t ch, \n                                    const float *const restrict in_data, const float *const restrict out_data, \n                                    const float *const restrict in_data_end, const float *const restrict out_data_end, \n                                    const float *const restrict in_data_next, const float *const restrict out_data_next, \n                                    const float *const restrict in_data_next_end, const float *const restrict out_data_next_end, \n                                    const float *const restrict in_data_prev, const float *const restrict out_data_prev, \n                                    const float *const restrict in_data_prev_end, const float *const restrict out_data_prev_end, \n                                    const float *const restrict in_data_prev_next, const float *const restrict out_data_prev_next, \n                                    const float *const restrict in_data_prev_next_end, const float *const restrict out_data_prev_next_end, \n                                    const float *const restrict in_data_prev_next_next, const float *const restrict out_data_prev_next_next, \n                                    const float *const restrict in_data_prev_next_next_end, const float *const restrict out_data_prev_next_next_end, \n                                    const float *const restrict in_data_prev_next_next_next, const float *const restrict out_data_prev_next_next_next, \n                                    const float *const restrict in_data_prev_next_next_next_end, const float *const restrict out_data_prev_next_next_next_end, \n                                    const float *const restrict in_data_prev_next_next_next_next, const float *const restrict out_data_prev_next_next_next_next, \n                                    const float *const restrict in_data_prev_next_next_next_next_end, const float *const restrict out_data_prev_next_next_next_next_end, \n                                    const float *const restrict in_data_prev_next_next_next_next_next, const float *const restrict out_data_prev_next_next_next_next_next, \n                                    const float *const restrict in_data_prev_next"}
{"label": " \nint eu2roLoop (double* eu, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * rostep; \n      \n    trash = eu2ro(&(eu[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint eu2roLoop (double* eu, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * rostep; \n      \n    trash = eu2ro(&(eu[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint cu2axLoop (double* cu, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * axstep; \n      \n    trash = cu2ax(&(cu[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint cu2axLoop (double* cu, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * axstep; \n      \n    trash = cu2ax(&(cu[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void compute_rhs(void) \n{ \n    int i, j, k, m; \n    double rho_inv, uijk, up1, um1, vijk, vp1, vm1, wijk, wp1, wm1; \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                rho_inv = 1.0 / u[i][j][k][0]; \n                rho_i[i][j][k] = rho_inv; \n                us[i][j][k] = u[i][j][k][1] * rho_inv; \n                vs[i][j][k] = u[i][j][k][2] * rho_inv; \n                ws[i][j][k] = u[i][j][k][3] * rho_inv; \n                square[i][j][k] = 0.5 * (u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * rho_inv; \n                qs[i][j][k] = square[i][j][k] * rho_inv; \n            } \n        } \n    } \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    rhs[i][j][k][m] = forcing[i][j][k][m]; \n                } \n            } \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                uijk = us[i][j][k]; \n                up1 = us[i + 1][j][k]; \n                um1 = us[i - 1][j][k]; \n                rhs[i][j][k][0] = rhs[i][j][k][0] + dx1tx1 * (u[i + 1][j][k][0] - 2.0 * u[i][j][k][0] + u[i - 1][j][k][0]) - tx2 * (u[i + 1][j][k][1] - u[i - 1][j][k][1]); \n                rhs[i][j][k][1] = rhs[i][j][k][1] + dx2tx1 * (u[i + 1][j][k][1] - 2.0 * u[i][j][k][1] + u[i - 1][j][k][1]) + xxcon2 * con43 * (up1 - 2.0 * uijk + um1) - tx2 * (u[i + 1][j][k][1] * up1 - u[i - 1][j][k][1] * um1 + (u[i + 1][j][k][4] - square[i + 1][j][k] - u[i - 1][j][k][4] + square[i - 1][j][k]) * c2); \n                rhs[i][j][k][2] = rhs[i][j][k][2] + dx3tx1 * (u[i + 1][j][k][2] - 2.0 * u[i][j][k][2] + u[i - 1][j][k][2]) + xxcon2 * (vs[i + 1][j][k] - 2.0 * vs[i][j][k] + vs[i - 1][j][k]) - tx2 * (u[i + 1][j][k][2] * up1 - u[i - 1][j][k][2] * um1); \n                rhs[i][j][k][3] = rhs[i][j][k][3] + dx4tx1 * (u[i + 1][j][k][3] - 2.0 * u[i][j][k][3] + u[i - 1][j][k][3]) + xxcon2 * (ws[i + 1][j][k] - 2.0 * ws[i][j][k] + ws[i - 1][j][k]) - tx2 * (u[i + 1][j][k][3] * up1 - u[i - 1][j][k][3] * um1); \n                rhs[i][j][k][4] = rhs[i][j][k][4] + dx5tx1 * (u[i + 1][j][k][4] - 2.0 * u[i][j][k][4] + u[i - 1][j][k][4]) + xxcon3 * (qs[i + 1][j][k] - 2.0 * qs[i][j][k] + qs[i - 1][j][k]) + xxcon4 * (up1 * up1 - 2.0 * uijk * uijk + um1 * um1) + xxcon5 * (u[i + 1][j][k][4] * rho_i[i + 1][j][k] - 2.0 * u[i][j][k][4] * rho_i[i][j][k] + u[i - 1][j][k][4] * rho_i[i", "pred": " \nstatic void compute_rhs(void) \n{ \n    int i, j, k, m; \n    double rho_inv, uijk, up1, um1, vijk, vp1, vm1, wijk, wp1, wm1; \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                rho_inv = 1.0 / u[i][j][k][0]; \n                rho_i[i][j][k] = rho_inv; \n                uijk = u[i][j][k][0]; \n                up1 = u[i][j][k][1]; \n                um1 = u[i][j][k][2]; \n                vijk = v[i][j][k][0]; \n                vp1 = v[i][j][k][1]; \n                vm1 = v[i][j][k][2]; \n                wijk = w[i][j][k][0]; \n                wp1 = w[i][j][k][1]; \n                wm1 = w[i][j][k][2]; \n                for (m = 0; \n                    m < grid_points[3]; \n                    m++) \n                { \n                    uijk = u[i][j][k][m]; \n                    up1 = up1 * uijk; \n                    um1 = um1 * uijk; \n                    vijk = vijk * uijk; \n                    vp1 = vp1 * uijk; \n                    vm1 = vm1 * uijk; \n                    wijk = wijk * uijk; \n                    wp1 = wp1 * uijk; \n                    wm1 = wm1 * uijk; \n                    for (k = 0; \n                        k < grid_points[4]; \n                        k++) \n                    { \n                        uijk = u[i][j][k][m]; \n                        up1 = up1 * uijk; \n                        um1 = um1 * uijk; \n                        vijk = vijk * uijk; \n                        vp1 = vp1 * uijk; \n                        vm1 = vm1 * uijk; \n                        wijk = wijk * uijk; \n                        wp1 = wp1 * uijk; \n                        wm1 = wm1 * uijk; \n                        for (j = 0; \n                            j < grid_points[5]; \n                            j++) \n                        { \n                            uijk = u[i][j][k][m]; \n                            up1 = up1 * uijk; \n                            um1 = um1 * uijk; \n                            vijk = vijk * uijk; \n                            vp1 = vp1 * uijk; \n                            vm1 = vm1 * uijk; \n                            wijk = wijk * uijk; \n                            wp1 = wp1 * uijk; \n                            wm1 = wm1 * uijk; \n                            for (k = 0; \n                                k < grid_points[6]; \n                                k++) \n                            { \n                                uijk = u[i][j][k][m]; \n                                up1 = up1 * uijk; \n                                um1 = um1 * uijk; \n      "}
{"label": "pixels(const float *const restrict in, float *const restrict mask, \n                                       const float normalize, const float feathering, const size_t width, \n                                       const size_t height, const size_t ch) \n{ \n   \n \n \n  int clipped = 0; \n \n  #ifdef __SSE2__ \n     \n \n     \n \n    const unsigned int oldMode = _MM_GET_FLUSH_ZERO_MODE(); \n    _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \n  #endif \n \n  for(size_t k = 0; k < height * width * ch; k += ch) \n  { \n    const float pix_max = fmaxf(sqrtf(sqf(in[k]) + sqf(in[k + 1]) + sqf(in[k + 2])), 0.f); \n    const float argument = -pix_max * normalize + feathering; \n    const float weight = clamp_simd(1.0f / (1.0f + exp2f(argument))); \n    mask[k / ch] = weight; \n \n     \n \n     \n \n     \n \n     \n \n    clipped += (4.f > argument); \n  } \n \n  #ifdef __SSE2__ \n    _MM_SET_FLUSH_ZERO_MODE(oldMode); \n  #endif \n \n   \n \n  return (clipped > 9); \n} \n \n ", "pred": "pixels(const float *const restrict in, float *const restrict mask, \n                                       const float normalize, const float feathering, const size_t width, \n                                       const size_t height, const size_t ch) \n{ \n   \n \n \n  int clipped = 0; \n \n  #ifdef __SSE2__ \n     \n \n     \n \n    const unsigned int oldMode = _MM_GET_FLUSH_ZERO_MODE(); \n    _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \n  #endif \n \n  for(size_t k = 0; k < height * width * ch; k += ch) \n  { \n    const float pix_max = fmaxf(sqrtf(sqf(in[k]) + sqf(in[k + 1]) + sqf(in[k + 2])), 0.f); \n    const float argument = -pix_max * normalize + feathering; \n    const float value = in[k] * argument + in[k + 1] * argument + in[k + 2] * argument + in[k + 3]; \n    const float mask_value = mask[k]; \n    const float mask_value_clipped = mask_value * (1.f - argument); \n    const float mask_value_clipped_clipped = mask_value_clipped * (1.f - argument); \n    const float mask_value_clipped_clipped_clipped = mask_value_clipped_clipped * (1.f - argument"}
{"label": " \nint ho2cuLoop (double* ho, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * custep; \n      \n    trash = ho2cu(&(ho[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ho2cuLoop (double* ho, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * custep; \n      \n    trash = ho2cu(&(ho[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint cu2omLoop (double* cu, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * omstep; \n      \n    trash = cu2om(&(cu[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint cu2omLoop (double* cu, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, custep = 3, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * custep; \n    iOut = i * omstep; \n      \n    trash = cu2om(&(cu[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint qu2hoLoop (double* qu, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * hostep; \n      \n    trash = qu2ho(&(qu[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint qu2hoLoop (double* qu, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * hostep; \n      \n    trash = qu2ho(&(qu[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": "(const float *const in, const float *const mask, \n                                 float *const inpainted, const float noise_level, const float threshold, \n                                 const dt_noise_distribution_t noise_distribution, \n                                 const size_t width, const size_t height) \n{ \n   \n \n   \n \n   \n \n \n  for(size_t i = 0; i < height; i++) \n    for(size_t j = 0; j < width; j++) \n    { \n       \n \n      uint32_t DT_ALIGNED_ARRAY state[4] = { splitmix32(j + 1), splitmix32((j + 1) * (i + 3)), splitmix32(1337), splitmix32(666) }; \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n \n       \n \n      const size_t idx = i * width + j; \n      const size_t index = idx * 4; \n      const float weight = mask[idx]; \n      const float *const restrict pix_in = __builtin_assume_aligned(in + index, 16); \n      dt_aligned_pixel_t noise = { 0.f }; \n      dt_aligned_pixel_t sigma = { 0.f }; \n      const int DT_ALIGNED_ARRAY flip[4] = { TRUE, FALSE, TRUE, FALSE }; \n \n      for_each_channel(c,aligned(pix_in)) \n        sigma[c] = pix_in[c] * noise_level / threshold; \n \n       \n \n      dt_noise_generator_simd(noise_distribution, pix_in, sigma, flip, state, noise); \n \n       \n \n      float *const restrict pix_out = __builtin_assume_aligned(inpainted + index, 16); \n      for_each_channel(c,aligned(pix_in,pix_out)) \n        pix_out[c] = fmaxf(pix_in[c] * (1.0f - weight) + weight * noise[c], 0.f); \n    } \n} \n \ninline static void wavelets_rec ", "pred": "(const float *const in, const float *const mask, \n                                 float *const inpainted, const float noise_level, const float threshold, \n                                 const dt_noise_distribution_t noise_distribution, \n                                 const size_t width, const size_t height) \n{ \n   \n \n   \n \n   \n \n \n  for(size_t i = 0; i < height; i++) \n    for(size_t j = 0; j < width; j++) \n    { \n       \n \n      uint32_t DT_ALIGNED_ARRAY state[4] = { splitmix32(j + 1), splitmix32((j + 1) * (i + 3)), splitmix32(1337), splitmix32(666) }; \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state); \n      xoshiro128plus(state"}
{"label": " \nstatic void x_backsubstitute(void) \n{ \n    int i, j, k, m, n; \n    for (i = grid_points[0] - 2; \n        i >= 0; \n        i--) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        rhs[i][j][k][m] = rhs[i][j][k][m] - lhs[i][j][k][2][m][n] * rhs[i + 1][j][k][n]; \n                    } \n                } \n            } \n        } \n    } \n} ", "pred": " \nstatic void x_backsubstitute(void) \n{ \n    int i, j, k, m, n; \n    for (i = grid_points[0] - 2; \n        i >= 0; \n        i--) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    for (n = 0; \n                        n < 5; \n                        n++) \n                    { \n                        if (m == n) \n                        { \n                            grid_points[i][j][k][m] = \n                                grid_points[i][j + 1][k][m];"}
{"label": " \nvoid \nf3 (void) \n{ \n  int i; \n \n  for (i = 0; i < 64; i++) \n    t++;\t \n \n} ", "pred": " \nvoid \nf3 (void) \n{ \n  int i; \n \n  for (i = 0; i < 64; i++) \n    t++;\t \n \n} "}
{"label": " \nint om2roLoop (double* om, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * rostep; \n      \n    trash = om2ro(&(om[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint om2roLoop (double* om, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * rostep; \n      \n    trash = om2ro(&(om[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ax2hoLoop (double* ax, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * hostep; \n      \n    trash = ax2ho(&(ax[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ax2hoLoop (double* ax, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * hostep; \n      \n    trash = ax2ho(&(ax[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ax2cuLoop (double* ax, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * custep; \n      \n    trash = ax2cu(&(ax[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ax2cuLoop (double* ax, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * custep; \n      \n    trash = ax2cu(&(ax[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ho2quLoop (double* ho, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * qustep; \n      \n    trash = ho2qu(&(ho[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ho2quLoop (double* ho, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * qustep; \n      \n    trash = ho2qu(&(ho[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ax2omLoop (double* ax, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * omstep; \n      \n    trash = ax2om(&(ax[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ax2omLoop (double* ax, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * omstep; \n      \n    trash = ax2om(&(ax[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ho2euLoop (double* ho, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * eustep; \n      \n    trash = ho2eu(&(ho[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ho2euLoop (double* ho, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * eustep; \n      \n    trash = ho2eu(&(ho[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": "evel(const float *const restrict detail, const float *const restrict LF, \n                                             float *const restrict HF, float *const restrict texture, \n                                             const size_t width, const size_t height, const size_t ch) \n{ \n  for(size_t k = 0; k < height * width; k++) \n  { \n    for(size_t c = 0; c < 4; ++c) HF[4*k + c] = texture[4*k + c] = detail[4*k + c] - LF[4*k + c]; \n  } \n} \n \nstatic int get_scales(const dt_iop_ ", "pred": "evel(const float *const restrict detail, const float *const restrict LF, \n                                             float *const restrict HF, float *const restrict texture, \n                                             const size_t width, const size_t height, const size_t ch) \n{ \n  for(size_t k = 0; k < height * width; k++) \n  { \n    for(size_t c = 0; c < 4; ++c) HF[4*k + c] = texture[4*k + c] = detail[4*k + c] - LF[4*k + c]; \n  } \n} \n \nstatic int get_scales(const dt_iop_ "}
{"label": " \nint om2cuLoop (double* om, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * custep; \n      \n    trash = om2cu(&(om[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint om2cuLoop (double* om, double* cu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, custep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * custep; \n      \n    trash = om2cu(&(om[iIn]), &(cu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void x_solve_cell(void) \n{ \n    int i, j, k, isize; \n    isize = grid_points[0] - 1; \n    for (j = 1; \n        j < grid_points[1] - 1; \n        j++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            binvcrhs(lhs[0][j][k][1], lhs[0][j][k][2], rhs[0][j][k]); \n        } \n    } \n    for (i = 1; \n        i < isize; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                matvec_sub(lhs[i][j][k][0], rhs[i - 1][j][k], rhs[i][j][k]); \n                matmul_sub(lhs[i][j][k][0], lhs[i - 1][j][k][2], lhs[i][j][k][1]); \n                binvcrhs(lhs[i][j][k][1], lhs[i][j][k][2], rhs[i][j][k]); \n            } \n        } \n    } \n    for (j = 1; \n        j < grid_points[1] - 1; \n        j++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            matvec_sub(lhs[isize][j][k][0], rhs[isize - 1][j][k], rhs[isize][j][k]); \n            matmul_sub(lhs[isize][j][k][0], lhs[isize - 1][j][k][2], lhs[isize][j][k][1]); \n            binvrhs(lhs[i][j][k][1], rhs[i][j][k]); \n        } \n    } \n} ", "pred": " \nstatic void x_solve_cell(void) \n{ \n    int i, j, k, isize; \n    isize = grid_points[0] - 1; \n    for (j = 1; \n        j < grid_points[1] - 1; \n        j++) \n    { \n        for (k = 1; \n            k < grid_points[2] - 1; \n            k++) \n        { \n            binvcrhs(lhs[0][j][k][1], lhs[0][j][k][2], rhs[0][j][k]); \n        } \n    } \n    for (i = 1; \n        i < isize; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            binvcrhs(lhs[i][j][1], lhs[i][j][2], rhs[i][j]); \n        } \n    } \n    for (i = 1; \n        i < isize; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            binvcrhs(lhs[i][j][1], lhs[i][j][2], rhs[i][j]); \n        } \n    } \n    for (i = 1; \n        i < isize; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            binvcrhs(lhs[i][j][1], lhs[i][j][2], rhs[i][j]); \n        } \n    } \n    for (i = 1; \n        i < isize; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            binvcrhs(lhs[i][j][1], lhs[i][j][2], rhs[i][j]); \n        } \n    } \n   "}
{"label": " \nvoid process(struct dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, const void *const i, \n             void *const o, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_defringe_data_t *d = (dt_iop_defringe_data_t *)piece->data; \n  assert(dt_iop_module_colorspace(module) == iop_cs_Lab); \n \n  const int order = 1;  \n \n  const float sigma = fmax(0.1f, fabs(d->radius)) * roi_in->scale / piece->iscale; \n  const float Labmax[] = { 100.0f, 128.0f, 128.0f, 1.0f }; \n  const float Labmin[] = { 0.0f, -128.0f, -128.0f, 0.0f }; \n  const int ch = piece->colors; \n \n  const int radius = ceil(2.0 * ceilf(sigma)); \n \n   \n \n  int *xy_avg = NULL; \n  int *xy_artifact = NULL; \n  int *xy_small = NULL; \n \n  if(roi_out->width < 2 * radius + 1 || roi_out->height < 2 * radius + 1) goto ERROR_EXIT; \n \n  float avg_edge_chroma = 0.0; \n \n  float *const in = (float *const)i; \n  float *const out = (float *const)o; \n  int width = roi_in->width; \n  int height = roi_in->height; \n \n  dt_gaussian_t *gauss = NULL; \n  gauss = dt_gaussian_init(width, height, 4, Labmax, Labmin, sigma, order); \n  if(!gauss) \n  { \n    fprintf(stderr, \"Error allocating memory for gaussian blur in: defringe module\\n\"); \n    goto ERROR_EXIT; \n  } \n  dt_gaussian_blur_4c(gauss, in, out); \n  dt_gaussian_free(gauss); \n \n  int samples_wish = radius * radius; \n  int sampleidx_avg; \n   \n \n  if(samples_wish > 89) \n  { \n    sampleidx_avg = 12;  \n \n  } \n  else if(samples_wish > 55) \n  { \n    sampleidx_avg = 11;  \n \n  } \n  else if(samples_wish > 34) \n  { \n    sampleidx_avg = 10;  \n \n  } \n  else if(samples_wish > 21) \n  { \n    sampleidx_avg = 9; \n  } \n  else if(samples_wish > 13) \n  { \n    sampleidx_avg = 8; \n  } \n  else \n  {  \n \n    sampleidx_avg = 7; \n  } \n  const int sampleidx_small = sampleidx_avg - 1; \n \n  const int small_radius = MAX(radius, 3); \n  const int avg_radius = 24 + radius * 4; \n \n  const int samples_small = fib[sampleidx_small]; \n  const int samples_avg = fib[sampleidx_avg]; \n \n   \n \n \n   \n \n  if((xy_avg = malloc((size_t)2 * sizeof(int) * samples_avg))) \n  { \n    int *tmp = xy_avg; \n    for(int u = 0; u < samples_avg; u++) \n    { \n      int dx, dy; \n      fib_latt(&dx, &dy, avg_radius, u, sampleidx_avg); \n      *tmp++ = dx; \n      *tmp++ = dy; \n    } \n  } \n  else \n  { \n    fprintf(stderr, \"Error allocating memory for fibonacci lattice in: defringe module\\n\"); \n    goto ERROR_EXIT; \n  } \n \n  if((xy_small = malloc((size_t)2 * sizeof(int) * samples_small))) \n  { \n    int *tmp = xy_small; \n    for(int u = 0; u < samples_small; u++) \n    { \n      int dx, dy; \n      fib_latt(&dx, &dy, small_radius, u, sampleidx_small); \n      *tmp++ = dx; \n      *tmp++ = dy; \n    } \n  } \n  else \n  { \n    fprintf(stderr, \"Error allocating memory for fibonacci lattice in: defringe module\\n\"); \n    goto ERROR_EXIT; \n  } \n \n  for(int v = 0; v < height; v++) \n  { \n    for(int t = 0; t < width; t++) \n    { \n       \n \n       \n \n      float a = in[(size_t)v * width * ch + t * ch + 1] - out[(size_t)v * width * ch + t * ch + 1]; \n      float b = in[(size_t)v * width * ch + t * ch + 2] - out[(size_t)v * width * ch + t * ch + 2]; \n \n      float edge = (a * a + b * b);  \n \n \n       \n \n      out[(size_t)v * width * ch + t * ch + 3] = edge; \n       \n \n      if(MODE_GLOBAL_AVERAGE == d->op_mode) avg_edge_chroma += edge; \n    } \n  } \n \n  float thresh; \n  if(MODE_GLOBAL_AVERAGE == d->op_mode) \n  { \n    avg_edge_chroma = avg_edge_chroma / (width * height) + 10.0 * FLT_EPSILON; \n    thresh = fmax(0.1f, 4.0 * d->thresh * avg_edge_chroma / MAGIC_THRESHOLD_COEFF); \n  } \n  else \n  { \n     \n \n    avg_edge_chroma = MAGIC_THRESHOLD_COEFF; \n    thresh = fmax(0.1f, d->thresh); \n  } \n \n \n \n \n \n  for(int v = 0; v < height; v++) \n  { \n    for(int t = 0; t < width; t++) \n    { \n      float local_thresh = thresh; \n       \n \n      if(MODE_LOCAL_AVERAGE == d->op_mode && out[(size_t)v * width * ch + t * ch + 3] > thresh) \n      { \n        float local_avg = 0.0; \n         \n \n        const int *tmp = xy_avg; \n        for(int u = 0; u < samples_avg; u++) \n        { \n          int dx = *tmp++; \n          int dy = *tmp++; \n          int x = MAX(0, MIN(width - 1, t + dx)); \n          int y = MAX(0, MIN(height - 1, v + dy)); \n          local_avg += out[(size_t)y * width * ch + x * ch + 3]; \n        } \n        avg_edge_chroma = fmax(0.01f, (float)local_avg / samples_avg); \n        local_thresh = fmax(0.1f, 4.0 * d->thresh * avg_edge_chroma / MAGIC_THRESHOLD_COEFF); \n      } \n \n      if(out[(size_t)v * width * ch + t * ch + 3] > local_thresh \n          \n \n         || out[(size_t)MAX(0, (v - 1)) * width * ch + MAX(0, (t - 1)) * ch + 3] > local_thresh \n", "pred": " \nvoid process(struct dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, const void *const i, \n             void *const o, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_defringe_data_t *d = (dt_iop_defringe_data_t *)piece->data; \n  assert(dt_iop_module_colorspace(module) == iop_cs_Lab); \n \n  const int order = 1;  \n \n  const float sigma = fmax(0.1f, fabs(d->radius)) * roi_in->scale / piece->iscale; \n  const float Labmax[] = { 100.0f, 128.0f, 128.0f, 1.0f }; \n  const float Labmin[] = { 0.0f, -128.0f, -128.0f, 0.0f }; \n  const int ch = piece->colors; \n \n  const int radius = ceil(2.0 * ceilf(sigma)); \n \n   \n \n  int *xy_avg = NULL; \n  int *xy_artifact = NULL; \n  int *xy_max = NULL; \n  int *xy_min = NULL; \n  int *xy_count = NULL; \n  int *xy_count_max = NULL; \n  int *xy_count_min = NULL; \n  int *xy_count_avg = NULL; \n  int *xy_count_artifact = NULL; \n  int *xy_count_max_artifact = NULL; \n  int *xy_count_min_artifact = NULL; \n  int *xy_count_avg_artifact = NULL; \n  int *xy_count_artifact_max = NULL; \n  int *xy_count_artifact_min = NULL; \n  int *xy_count_max_artifact_max = NULL; \n  int *xy_count_max_artifact_min = NULL; \n  int *xy_count_min_artifact_max = NULL; \n  int *xy_count_min_artifact_min = NULL; \n  int *xy_count_avg_artifact_max = NULL; \n  int *xy_count_avg_artifact_min = NULL; \n  int *xy_count_artifact_max_max = NULL; \n  int *xy_count_artifact_min_max = NULL; \n  int *xy_count_max_artifact_max_max = NULL; \n  int *xy_count_max_artifact_min_max = NULL; \n  int *xy_count_min_artifact_max_max = NULL; \n  int *xy_count_min_artifact_min_max = NULL; \n  int *xy_count_avg_artifact_max_max = NULL; \n  int *xy_count_avg_artifact_min_max = NULL; \n  int *xy_count_artifact_max_max_max = NULL; \n  int *xy_count_artifact_min_max_max = NULL; \n  int *xy_count_max_artifact_max_max = NULL; \n  int *xy_count_max_artifact_min_max = NULL; \n  int *xy_count_min_artifact_max_max = NULL; \n  int *xy_count_min_artifact_min_max = NULL; \n  int *xy_count_avg_artifact_max_max = NULL; \n  int *xy_count_avg_artifact_min_max = NULL; \n  int *xy_count_artifact_max_max_max = NULL; \n  int *xy_count_artifact_min_max_max = NULL; \n  int *xy_count_max_artifact_max_max = NULL; \n  int *xy_count_max_artifact_min_max = NULL; \n  int *xy_count_min_artifact_max_max = NULL; \n  int *xy_count_min_artifact_min_max = NULL; \n  int *xy_count_avg_artifact_max_max = NULL; \n  int *xy_count_avg_artifact_min_max = NULL; \n  int *xy_count_artifact_max_max_max = NULL; \n  int *xy_count_artifact_min_max_max = NULL; \n  int *xy_count_max_artifact_max_max = NULL; \n  int *xy_count_max_artifact_min_max = NULL; \n  int *xy_count_min_artifact_max_max = NULL; \n  int *xy_count_min_artifact_min_max = NULL; \n  int *xy_count_avg_artifact_max_max = NULL; \n  int *xy_count_avg_artifact_min_max = NULL; \n  int *xy_count_artifact_max_max_max = NULL; \n  int *xy_count_artifact_min_max_max = NULL; \n  int *xy_count_max_artifact_max_max = NULL; \n  int *xy_count_max_artifact_min_max = NULL; \n  int *xy_count_min_artifact_max_max = NULL; \n  int *xy_count_min_artifact_min_max = NULL; \n  int *xy_count_avg_artifact_max_max = NULL; \n  int *xy_count_avg_artifact_min_max = NULL; \n  int *xy_count_artifact_max_max_max = NULL; \n  int *xy_count_artifact_min_max_max = NULL; \n  int *xy_count_max_artifact_max_max = NULL; \n  int *xy_count_max_artifact_min_max = NULL; \n  int *xy_count_min_artifact_max_max = NULL; \n  int *xy_count_min_artifact_min_max = NULL; \n  int *xy_count_avg_artifact_max_max = NULL; \n  int *xy_count_avg_artifact_min_max = NULL; \n  int *xy_count_artifact_max_max_max = NULL; \n  int *xy_count_artifact_min_max_max = NULL; \n  int *xy_count_max_artifact_max_max = NULL; \n  int *xy_count_max_artifact_min_max = NULL; \n  int *xy_count_min_artifact_max_max = NULL; \n  int *xy_count_min_artifact_min_max = NULL; \n  int *xy_count_avg_artifact_max_max = NULL; \n  int *xy_count_avg_artifact_min_max = NULL; \n  int *xy_count_artifact_max_max_max = NULL; \n  int *xy_count_artifact_min_max_max = NULL; \n  int *xy_count_max_artifact_max_max = NULL; \n  int *xy_count_max_artifact_min_max = NULL; \n  int *xy_count_min_artifact_max_max = NULL; \n  int *xy_count_min_artifact_min_max = NULL; \n  int *xy_count_avg_artifact_max_max = NULL; \n  int *xy_count_avg_artifact_min_max = NULL; \n  int *xy_count_artifact_max_max_max = NULL; \n  int *xy_count_artifact_min_max_max = NULL; \n  int *xy_count_max_artifact_max_max = NULL; \n  int *xy_count_max_artifact_min_max = NULL; \n  int *xy_count_min_artifact_max_max = NULL; \n  int *xy_count_min_artifact_min_max = NULL; \n  int *xy_count_avg_artifact_max_max = NULL; \n  int *xy_count_avg_artifact_min_max = NULL; \n  int *xy_count_artifact_max_max_max = NULL; \n  int *xy_count_artifact_min_max_max = NULL; \n  int *xy_count_max_artifact_max_max = NULL; \n  int *xy_count_max_artifact_min_max = NULL; \n  int *xy_count_min_artifact_max_max = NULL; \n  int *xy_count_min_artifact_min_max = NULL; \n  int *xy_count_avg_artifact_max_max = NULL; \n  int *xy_count_avg_artifact_min_max = NULL; \n  int *xy_count_artifact_max_max_max = NULL; \n  int *xy_count_artifact_min_max_max = NULL; \n  int *xy_count_max_artifact_max_max = NULL; \n  int *xy_count_max_artifact_min_max = NULL; \n "}
{"label": " \nvoid THTensor_(copy)(THTensor *tensor, THTensor *src) \n{ \n  if (tensor == src) return; \n  ptrdiff_t tensorSize = THTensor_(nElement)(tensor); \n  ptrdiff_t srcSize = THTensor_(nElement)(src); \n  int tensorContig = THTensor_(isContiguous)(tensor); \n  int srcContig = THTensor_(isContiguous)(src); \n \n  int serial_path = 0; \n  int inOMP = omp_in_parallel(); \n  if (tensorSize == srcSize) { \n    if ( tensorContig && srcContig) { \n      real *sp = THTensor_(data)(src); \n      real *rp = THTensor_(data)(tensor); \n      { \n        size_t num_threads = omp_get_num_threads(); \n        size_t tid = omp_get_thread_num(); \n        ptrdiff_t offset = tid * (tensorSize / num_threads); \n        ptrdiff_t end = (tid == num_threads - 1)? tensorSize : offset + tensorSize / num_threads; \n        ptrdiff_t len = end - offset; \n        real *tensorData = rp + offset; \n        real *srcData = sp + offset; \n        THVector_(copy)(tensorData, srcData, len); \n      } \n        THVector_(copy)(rp, sp, srcSize); \n \n \n      if ((srcSize > TH_OMP_OVERHEAD_THRESHOLD_COPY) && (!inOMP)) { \n        ptrdiff_t i; \n        for(i=0; i<srcSize; i++){ \n          rp[i] = sp[i]; \n        } \n      } else { \n        memcpy(rp, sp, srcSize * sizeof(real)); \n      } \n      memcpy(rp, sp, srcSize * sizeof(real)); \n \n \n    } else if (THTensor_(copyTransposeValid)(tensor, src)) { \n      THTensor_(copyTranspose)(tensor, src); \n    } else { \n      if (inOMP) { \n        serial_path = 1; \n      } else { \n        TH_TENSOR_APPLY2_OMP(srcSize, tensorContig, srcContig, real, tensor, real, src, *tensor_data = *src_data;) \n      } \n      serial_path = 1; \n    } \n  } else { \n    serial_path = 1; \n  } \n \n  if (serial_path) { \n    TH_TENSOR_APPLY2(real, tensor, real, src, *tensor_data = *src_data;) \n  } \n} ", "pred": " \nvoid THTensor_(copy)(THTensor *tensor, THTensor *src) \n{ \n  if (tensor == src) return; \n  ptrdiff_t tensorSize = THTensor_(nElement)(tensor); \n  ptrdiff_t srcSize = THTensor_(nElement)(src); \n  int tensorContig = THTensor_(isContiguous)(tensor); \n  int srcContig = THTensor_(isContiguous)(src); \n \n  int serial_path = 0; \n  int inOMP = omp_in_parallel(); \n  if (tensorSize == srcSize) { \n    if ( tensorContig && srcContig) { \n      real *sp = THTensor_(data)(src); \n      real *rp = THTensor_(data)(tensor); \n      { \n        size_t num_threads = omp_get_num_threads(); \n        size_t tid = omp_get_thread_num(); \n        ptrdiff_t offset = tid * (tensorSize / num_threads); \n        ptrdiff_t end = (tid == num_threads - 1)? tensorSize : offset + tensorSize / num_threads; \n        real *sp_ptr = sp + offset; \n        real *rp_ptr = rp + offset; \n        for (ptrdiff_t i = offset; i < end; i++) { \n          *sp_ptr++ = *rp_ptr++; \n        } \n      } \n    } else { \n      real *sp = THTensor_(data)(src); \n      real *rp = THTensor_(data)(tensor); \n      for (ptrdiff_t i = 0; i < tensorSize; i++) { \n        *sp++ = *rp++; \n      } \n    } \n  } else { \n    if ( tensorContig && srcContig) { \n      ptrdiff_t offset = tensorSize - srcSize; \n      ptrdiff_t end = offset + tensorSize; \n      real *sp_ptr = THTensor_(data)(src); \n      real *rp_ptr = THTensor_(data)(tensor); \n      for (ptrdiff_t i = offset; i < end; i++) { \n        *sp_ptr++ = *rp_ptr++; \n      } \n    } else { \n      ptrdiff_t offset = tensorSize - srcSize; \n      ptrdiff_t end = offset + tensorSize; \n      real *sp_ptr = THTensor_(data)(src); \n      real *rp_ptr = THTensor_(data)(tensor); \n      for (ptrdiff_t i = offset; i < end; i++) { \n        *sp_ptr++ = *rp_ptr++; \n      } \n "}
{"label": " \nint eu2omLoop (double* eu, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * omstep; \n      \n    trash = eu2om(&(eu[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint eu2omLoop (double* eu, double* om, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, eustep = 3, omstep = 9; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * eustep; \n    iOut = i * omstep; \n      \n    trash = eu2om(&(eu[iIn]), &(om[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ho2axLoop (double* ho, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * axstep; \n      \n    trash = ho2ax(&(ho[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ho2axLoop (double* ho, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, hostep = 3, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * hostep; \n    iOut = i * axstep; \n      \n    trash = ho2ax(&(ho[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint ax2euLoop (double* ax, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * eustep; \n      \n    trash = ax2eu(&(ax[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ax2euLoop (double* ax, double* eu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, eustep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * eustep; \n      \n    trash = ax2eu(&(ax[iIn]), &(eu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void add(void) \n{ \n    int i, j, k, m; \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    u[i][j][k][m] = u[i][j][k][m] + rhs[i][j][k][m]; \n                } \n            } \n        } \n    } \n} ", "pred": " \nstatic void add(void) \n{ \n    int i, j, k, m; \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    if (grid_points[m] == i && \n                        grid_points[m + 1] == j && \n                        grid_points[m + 2] == k"}
{"label": "float *const restrict in, float *const restrict out, \n                                    const dt_iop_order_iccprofile_info_t *const work_profile, \n                                    const dt_iop_order_iccprofile_info_t *const export_profile, \n                                    const dt_iop_filmicrgb_data_t *const data, \n                                    const dt_iop_filmic_rgb_spline_t spline, const int variant, \n                                    const size_t width, const size_t height, const size_t ch, \n                                    const dt_iop_filmicrgb_colorscience_type_t colorscience_version, \n                                    const float display_black, const float display_white) \n \n{ \n   \n \n  dt_colormatrix_t input_matrix;          \n \n  dt_colormatrix_t output_matrix;         \n \n  dt_colormatrix_t export_input_matrix;   \n \n  dt_colormatrix_t export_output_matrix;  \n \n \n  const int use_output_profile = filmic_v4_prepare_matrices(input_matrix, output_matrix, export_input_matrix, \n                                                            export_output_matrix, work_profile, export_profile); \n  for(size_t k = 0; k < height * width * ch; k += ch) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n \n    for_each_channel(c,aligned(pix_in)) \n    { \n       \n \n      pix_out[c] = log_tonemapping_v2(pix_in[c], data->grey_source, data->black_source, data->dynamic_range); \n \n       \n \n       \n \n      pix_out[c] = powf(CLAMP(filmic_spline(pix_out[c], spline.M1, spline.M2, spline.M3, spline.M4, spline.M5, \n                                                 spline.latitude_min, spline.latitude_max, spline.type), \n                              0.f,   \n \n                              display_white), data->output_power); \n    } \n \n     \n \n    dt_aligned_pixel_t Ych_original = { 0.f }; \n    RGB_to_Ych(pix_in, input_matrix, Ych_original); \n \n     \n \n    dt_aligned_pixel_t Ych_final = { 0.f }; \n    RGB_to_Ych(pix_out, input_matrix, Ych_final); \n \n    Ych_final[1] = fminf(Ych_original[1], Ych_final[1]); \n \n    gamut_mapping(Ych_final, Ych_original, pix_out, input_matrix, output_matrix, export_input_matrix, \n                  export_output_matrix, display_black, display_white, data->saturation, use_output_profile); \n  } \n} \n \n \nstatic inline void display_mask(const f ", "pred": "float *const restrict in, float *const restrict out, \n                                    const dt_iop_order_iccprofile_info_t *const work_profile, \n                                    const dt_iop_order_iccprofile_info_t *const export_profile, \n                                    const dt_iop_filmicrgb_data_t *const data, \n                                    const dt_iop_filmic_rgb_spline_t spline, const int variant, \n                                    const size_t width, const size_t height, const size_t ch, \n                                    const size_t ch_out, const size_t ch_in, const size_t ch_in_out, \n                                    const size_t ch_in_in, const size_t ch_in_in_out, \n                                    const size_t ch_in_in_in, const size_t ch_in_in_in_out, \n                                    const size_t ch_in_in_in_in, const size_t ch_in_in_in_in_out, \n                                    const size_t ch_in_in_in_in_in, const size_t ch_in_in_in_in_in_out, \n                                    const size_t ch_in_in_in_in_in_in, const size_t ch_in_in_in_in_in_in_out, \n                                    const size_t ch_in_in_in_in_in_in_in, const size_t ch_in_in_in_in_in_in_in_out, \n                                    const size_t ch_in_in_in_in_in_in_in_in, const size_t ch_in_in_in_in_in_in_in_in_out, \n                                    const size_t ch_in_in_in_in_in_in_in_in_in, const size_t ch_in_in_in_in_in_in_in_in_in_out, \n                                    const size_t ch_in_in_in_in_in_in_in_in_in_in, const size_t ch_in_in_in_in_in_in_in_in_in_in_out, \n                                    const size_t ch_in_in_in_in_in_in_in_in_in_in_in, const size_t ch_in_in_in_in_in_in_in_in_in_in_in_out, \n                                    const size_t ch_in_in_in_in_in_in_in_in_in_in_in_in, const size_t ch_in"}
{"label": " \nint ax2roLoop (double* ax, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * rostep; \n      \n    trash = ax2ro(&(ax[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint ax2roLoop (double* ax, double* ro, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, axstep = 4, rostep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * axstep; \n    iOut = i * rostep; \n      \n    trash = ax2ro(&(ax[iIn]), &(ro[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void lhsy(void) \n{ \n    int i, j, k; \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                fjac[i][j][k][0][0] = 0.0; \n                fjac[i][j][k][0][1] = 0.0; \n                fjac[i][j][k][0][2] = 1.0; \n                fjac[i][j][k][0][3] = 0.0; \n                fjac[i][j][k][0][4] = 0.0; \n                fjac[i][j][k][1][0] = - (u[i][j][k][1] * u[i][j][k][2]) * tmp2; \n                fjac[i][j][k][1][1] = u[i][j][k][2] * tmp1; \n                fjac[i][j][k][1][2] = u[i][j][k][1] * tmp1; \n                fjac[i][j][k][1][3] = 0.0; \n                fjac[i][j][k][1][4] = 0.0; \n                fjac[i][j][k][2][0] = - (u[i][j][k][2] * u[i][j][k][2] * tmp2) + 0.50 * c2 * ((u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2); \n                fjac[i][j][k][2][1] = - c2 * u[i][j][k][1] * tmp1; \n                fjac[i][j][k][2][2] = (2.0 - c2) * u[i][j][k][2] * tmp1; \n                fjac[i][j][k][2][3] = - c2 * u[i][j][k][3] * tmp1; \n                fjac[i][j][k][2][4] = c2; \n                fjac[i][j][k][3][0] = - (u[i][j][k][2] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][3][1] = 0.0; \n                fjac[i][j][k][3][2] = u[i][j][k][3] * tmp1; \n                fjac[i][j][k][3][3] = u[i][j][k][2] * tmp1; \n                fjac[i][j][k][3][4] = 0.0; \n                fjac[i][j][k][4][0] = (c2 * (u[i][j][k][1] * u[i][j][k][1] + u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2 - c1 * u[i][j][k][4] * tmp1) * u[i][j][k][2] * tmp1; \n                fjac[i][j][k][4][1] = - c2 * u[i][j][k][1] * u[i][j][k][2] * tmp2; \n                fjac[i][j][k][4][2] = c1 * u[i][j][k][4] * tmp1 - 0.50 * c2 * ((u[i][j][k][1] * u[i][j][k][1] + 3.0 * u[i][j][k][2] * u[i][j][k][2] + u[i][j][k][3] * u[i][j][k][3]) * tmp2); \n                fjac[i][j][k][4][3] = - c2 * (u[i][j][k][2] * u[i][j][k][3]) * tmp2; \n                fjac[i][j][k][4][4] = c1 * u[i][j][k][2] * tmp1; \n                njac[i][j][k][0][0] = 0.0; \n                njac[i][j][k][0][1] = 0.0; \n                njac[i][j][k][0][2] = 0.0; \n                njac[i][j][k][0][3] = 0.0; \n                njac[i][j][k][0][4] = 0.0; \n                njac[i][j][k][1][0] = - c3c4 * tmp2 * u[i][j][k][1]; \n                njac[i][j][k][1][1] = c3c4 * tmp1; \n                njac[i][j][k][1][2] = 0.0; \n                njac[i][j][k][1][3] = 0.0; \n                njac[i][j][k][1][4] = 0.0; \n                njac[i][j][k][2][0] = - con43 * c3c4 * tmp2 * u[i][j][k][2]; \n          ", "pred": " \nstatic void lhsy(void) \n{ \n    int i, j, k; \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][0] = tmp3; \n                f[i][j][k][1] = tmp2; \n                f[i][j][k][2] = tmp1; \n            } \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][0] = tmp3; \n                f[i][j][k][1] = tmp2; \n                f[i][j][k][2] = tmp1; \n            } \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][0] = tmp3; \n                f[i][j][k][1] = tmp2; \n                f[i][j][k][2] = tmp1; \n            } \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][0] = tmp3; \n                f[i][j][k][1] = tmp2; \n                f[i][j][k][2] = tmp1; \n            } \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points[2] - 1; \n                k++) \n            { \n                tmp1 = 1.0 / u[i][j][k][0]; \n                tmp2 = tmp1 * tmp1; \n                tmp3 = tmp1 * tmp2; \n                f[i][j][k][0] = tmp3; \n                f[i][j][k][1] = tmp2; \n                f[i][j][k][2] = tmp1; \n            } \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            for (k = 1; \n                k < grid_points"}
{"label": " \nint om2quLoop (double* om, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * qustep; \n      \n    trash = om2qu(&(om[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint om2quLoop (double* om, double* qu, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, qustep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * qustep; \n      \n    trash = om2qu(&(om[iIn]), &(qu[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nint qu2axLoop (double* qu, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * axstep; \n      \n    trash = qu2ax(&(qu[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint qu2axLoop (double* qu, double* ax, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, qustep = 4, axstep = 4; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * qustep; \n    iOut = i * axstep; \n      \n    trash = qu2ax(&(qu[iIn]), &(ax[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nvoid \nf2 (void) \n{ \n  int i; \n \n  for (i = 0; i < 64; i++)\t\t\t \n \n    t++;\t \n \n} ", "pred": " \nvoid \nf2 (void) \n{ \n  int i; \n \n  for (i = 0; i < 64; i++)\t\t\t \n \n    t++;\t \n \n} "}
{"label": "onst float *const restrict in, float *const restrict out, \n                                       const dt_iop_order_iccprofile_info_t *const work_profile, \n                                       const dt_iop_filmicrgb_data_t *const data, \n                                       const dt_iop_filmic_rgb_spline_t spline, const int variant, \n                                       const size_t width, const size_t height, const size_t ch, \n                                       const dt_iop_filmicrgb_colorscience_type_t colorscience_version) \n{ \n \n  for(size_t k = 0; k < height * width * ch; k += ch) \n  { \n    const float *const restrict pix_in = in + k; \n    float *const restrict pix_out = out + k; \n \n    float norm = fmaxf(get_pixel_norm(pix_in, variant, work_profile), NORM_MIN); \n \n     \n \n    dt_aligned_pixel_t ratios = { 0.0f }; \n \n    for_each_channel(c,aligned(pix_in)) \n      ratios[c] = pix_in[c] / norm; \n \n     \n \n    const float min_ratios = fminf(fminf(ratios[0], ratios[1]), ratios[2]); \n    const int sanitize = (min_ratios < 0.0f); \n \n    if(sanitize) \n      for_each_channel(c) \n        ratios[c] -= min_ratios; \n \n     \n \n    norm = log_tonemapping_v2(norm, data->grey_source, data->black_source, data->dynamic_range); \n \n     \n \n    const float desaturation = filmic_desaturate_v2(norm, data->sigma_toe, data->sigma_shoulder, data->saturation); \n \n     \n \n     \n \n    norm = powf(clamp_simd(filmic_spline(norm, spline.M1, spline.M2, spline.M3, spline.M4, spline.M5, \n                                         spline.latitude_min, spline.latitude_max, spline.type)), \n                data->output_power); \n \n     \n \n    for(int c = 0; c < 3; c++) ratios[c] = fmaxf(ratios[c] + (1.0f - ratios[c]) * (1.0f - desaturation), 0.0f); \n \n     \n \n     \n \n    if(colorscience_version == DT_FILMIC_COLORSCIENCE_V3) \n      norm /= fmaxf(get_pixel_norm(ratios, variant, work_profile), NORM_MIN); \n \n    for_each_channel(c,aligned(pix_out)) \n      pix_out[c] = ratios[c] * norm; \n \n     \n \n    const float max_pix = fmaxf(fmaxf(pix_out[0], pix_out[1]), pix_out[2]); \n    const int penalize = (max_pix > 1.0f); \n \n     \n \n    if(penalize) \n    { \n      for_each_channel(c,aligned(pix_out)) \n      { \n        ratios[c] = fmaxf(ratios[c] + (1.0f - max_pix), 0.0f); \n        pix_out[c] = clamp_simd(ratios[c] * norm); \n      } \n    } \n  } \n} \n \n \nstatic inline void filmic_desaturate_v ", "pred": "onst float *const restrict in, float *const restrict out, \n                                       const dt_iop_order_iccprofile_info_t *const work_profile, \n                                       const dt_iop_filmicrgb_data_t *const data, \n                                       const dt_iop_filmic_rgb_spline_t spline, const int variant, \n                                       const size_t width, const size_t height, const size_t ch, \n                                       const dt_iop_filmicrgb_colorscience_type_t colorscience_type,\n                                       const float lum_min, const float lum_max, const float lum_step,\n                                       const float lum_gamma, const float lum_offset, const float lum_contrast,\n                                       const float lum_brightness, const float lum_contrast_brightness,\n                                       const float lum_saturation, const float lum_brightness_saturation,\n                                       const float lum_contrast_saturation, const float lum_gamma_saturation,\n                                       const float lum_offset_saturation, const float lum_contrast_offset_saturation,\n                                       const float lum_saturation_offset, const float lum_contrast_saturation_offset,\n                                       const float lum_gamma_saturation_offset, const float lum_offset_saturation_offset,\n                                       const float lum_contrast_offset_saturation_offset, const float lum_gamma_offset_saturation_offset,\n                                       const float lum_contrast_offset_saturation_offset_saturation, const float lum_offset_saturation_offset_saturation,\n                                       const float lum_contrast_offset_saturation_offset_saturation_offset, const float lum_offset_saturation_offset_saturation_offset_saturation_offset,\n                                       const float lum_contrast_offset_saturation_offset_saturation_offset_saturation, const float lum_offset_saturation_offset_saturation_offset_saturation_offset_saturation_offset,\n                                       const float lum_contrast_offset_saturation_offset_saturation_offset_saturation_offset, const float lum_offset_saturation_offset_saturation_offset_saturation_offset_saturation_offset_saturation_offset,\n                               "}
{"label": " \nstatic void z_solve_cell(void) \n{ \n    int i, j, k, ksize; \n    ksize = grid_points[2] - 1; \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            binvcrhs(lhs[i][j][0][1], lhs[i][j][0][2], rhs[i][j][0]); \n        } \n    } \n    for (k = 1; \n        k < ksize; \n        k++) \n    { \n        for (i = 1; \n            i < grid_points[0] - 1; \n            i++) \n        { \n            for (j = 1; \n                j < grid_points[1] - 1; \n                j++) \n            { \n                matvec_sub(lhs[i][j][k][0], rhs[i][j][k - 1], rhs[i][j][k]); \n                matmul_sub(lhs[i][j][k][0], lhs[i][j][k - 1][2], lhs[i][j][k][1]); \n                binvcrhs(lhs[i][j][k][1], lhs[i][j][k][2], rhs[i][j][k]); \n            } \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            matvec_sub(lhs[i][j][ksize][0], rhs[i][j][ksize - 1], rhs[i][j][ksize]); \n            matmul_sub(lhs[i][j][ksize][0], lhs[i][j][ksize - 1][2], lhs[i][j][ksize][1]); \n            binvrhs(lhs[i][j][ksize][1], rhs[i][j][ksize]); \n        } \n    } \n} ", "pred": " \nstatic void z_solve_cell(void) \n{ \n    int i, j, k, ksize; \n    ksize = grid_points[2] - 1; \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            binvcrhs(lhs[i][j][0][1], lhs[i][j][0][2], rhs[i][j][0]); \n        } \n    } \n    for (k = 1; \n        k < ksize; \n        k++) \n    { \n        for (i = 1; \n            i < grid_points[0] - 1; \n            i++) \n        { \n            for (j = 1; \n                j < grid_points[1] - 1; \n                j++) \n            { \n                binvcrhs(lhs[i][j][0][1], lhs[i][j][0][2], rhs[i][j][0]); \n            } \n        } \n    } \n    for (i = 1; \n        i < grid_points[0] - 1; \n        i++) \n    { \n        for (j = 1; \n            j < grid_points[1] - 1; \n            j++) \n        { \n            binvcrhs(lhs[i][j][0][1], lhs[i][j][0][2], rhs[i][j][1]); \n        } \n    } \n    for (k = 1; \n        k < ksize; \n        k++) \n    { \n        for (i = 1; \n            i < grid_points[0] - 1; \n            i++) \n        { \n            for (j = 1; \n                j < grid_points[1] - 1; \n                j++) \n            { \n                binvcrhs(lhs["}
{"label": " \nvoid VXCgen_grid(double *out, double *coords, double *atm_coords, \n                 double *radii_table, int natm, int ngrids) \n{ \n        const size_t Ngrids = ngrids; \n        int i, j; \n        double dx, dy, dz; \n        double *atom_dist = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                for (j = 0; j < i; j++) { \n                        dx = atm_coords[i*3+0] - atm_coords[j*3+0]; \n                        dy = atm_coords[i*3+1] - atm_coords[j*3+1]; \n                        dz = atm_coords[i*3+2] - atm_coords[j*3+2]; \n                        atom_dist[i*natm+j] = 1 / sqrt(dx*dx + dy*dy + dz*dz); \n                } \n        } \n \n{ \n        double *_buf = malloc(sizeof(double) * ((natm*2+1)*GRIDS_BLOCK + ALIGNMENT)); \n        double *buf = (double *)((uintptr_t)(_buf + ALIGNMENT - 1) & (-(uintptr_t)(ALIGNMENT*8))); \n        double *g = buf + natm * GRIDS_BLOCK; \n        double *grid_dist = g + GRIDS_BLOCK; \n        size_t ig0, n, ngs; \n        double fac, s; \n        for (ig0 = 0; ig0 < Ngrids; ig0 += GRIDS_BLOCK) { \n                ngs = MIN(Ngrids-ig0, GRIDS_BLOCK); \n                for (i = 0; i < natm; i++) { \n                for (n = 0; n < ngs; n++) { \n                        dx = coords[0*Ngrids+ig0+n] - atm_coords[i*3+0]; \n                        dy = coords[1*Ngrids+ig0+n] - atm_coords[i*3+1]; \n                        dz = coords[2*Ngrids+ig0+n] - atm_coords[i*3+2]; \n                        grid_dist[i*GRIDS_BLOCK+n] = sqrt(dx*dx + dy*dy + dz*dz); \n                        buf[i*GRIDS_BLOCK+n] = 1; \n                } } \n \n                for (i = 0; i < natm; i++) { \n                for (j = 0; j < i; j++) { \n \n                        fac = atom_dist[i*natm+j]; \n                        for (n = 0; n < ngs; n++) { \n                                g[n] = (grid_dist[i*GRIDS_BLOCK+n] - \n                                        grid_dist[j*GRIDS_BLOCK+n]) * fac; \n                        } \n                        if (radii_table!= NULL) { \n                                fac = radii_table[i*natm+j]; \n                                for (n = 0; n < ngs; n++) { \n                                        g[n] += fac * (1 - g[n]*g[n]); \n                                } \n                        } \n                        for (n = 0; n < ngs; n++) { \n                                s = g[n]; \n                                s = (3 - s*s) * s *.5; \n                                s = (3 - s*s) * s *.5; \n                                s = ((3 - s*s) * s *.5) *.5; \n                                buf[i*GRIDS_BLOCK+n] *=.5 - s; \n                                buf[j*GRIDS_BLOCK+n] *=.5 + s; \n                        } \n                } } \n \n                for (i = 0; i < natm; i++) { \n                        for (n = 0; n < ngs; n++) { \n                                out[i*Ngrids+ig0+n] = buf[i*GRIDS_BLOCK+n]; \n                        } \n                } \n        } \n        free(_buf); \n} \n        free(atom_dist); \n} ", "pred": " \nvoid VXCgen_grid(double *out, double *coords, double *atm_coords, \n                 double *radii_table, int natm, int ngrids) \n{ \n        const size_t Ngrids = ngrids; \n        int i, j; \n        double dx, dy, dz; \n        double *atom_dist = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                for (j = 0; j < i; j++) { \n                        dx = atm_coords[i*3+0] - atm_coords[j*3+0]; \n                        dy = atm_coords[i*3+1] - atm_coords[j*3+1]; \n                        dz = atm_coords[i*3+2] - atm_coords[j*3+2]; \n                        atom_dist[i*natm+j] = sqrt(dx*dx + dy*dy + dz*dz); \n                } \n        } \n        double *radii = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                radii[i] = radii_table[i]; \n        } \n        double *radii_inv = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                radii_inv[i] = 1.0/radii_table[i]; \n        } \n        double *radii_inv_inv = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                radii_inv_inv[i] = 1.0/radii_inv[i]; \n        } \n        double *radii_inv_inv_inv = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                radii_inv_inv_inv[i] = 1.0/radii_inv_inv[i]; \n        } \n        double *radii_inv_inv_inv_inv = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                radii_inv_inv_inv_inv[i] = 1.0/radii_inv_inv_inv[i]; \n        } \n        double *radii_inv_inv_inv_inv_inv = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                radii_inv_inv_inv_inv_inv[i] = 1.0/radii_inv_inv_inv_inv[i]; \n        } \n        double *radii_inv_inv_inv_inv_inv_inv = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                radii_inv_inv_inv_inv_inv_inv[i] = 1.0/radii_inv_inv_inv_inv_inv[i]; \n        } \n        double *radii_inv_inv_inv_inv_inv_inv_inv = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                radii_inv_inv_inv_inv_inv_inv_inv[i] = 1.0/radii_inv_inv_inv_inv_inv_inv[i]; \n        } \n        double *radii_inv_inv_inv_inv_inv_inv_inv_inv = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                radii_inv_inv_inv_inv_inv_inv_inv_inv[i] = 1.0/radii_inv_inv_inv_inv_inv_inv_inv[i]; \n        } \n        double *radii_inv_inv_inv_inv_inv_inv_inv_inv_inv = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                radii_inv_inv_inv_inv_inv_inv_inv_inv_inv[i] = 1.0/radii_inv_inv_inv_inv_inv_inv_inv_inv[i]; \n        } \n        double *radii_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                radii_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv[i] = 1.0/radii_inv_inv_inv_inv_inv_inv_inv_inv_inv[i]; \n        } \n        double *radii_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                radii_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv[i] = 1.0/radii_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv[i]; \n        } \n        double *radii_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = malloc(sizeof(double) * natm*natm); \n        for (i = 0; i < natm; i++) { \n                radii_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv[i] = 1.0/radii_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv[i]; \n        } \n        double *radii_inv_inv_inv_inv_inv_inv_inv_inv_inv"}
{"label": " \nint om2hoLoop (double* om, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * hostep; \n      \n    trash = om2ho(&(om[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} ", "pred": " \nint om2hoLoop (double* om, double* ho, unsigned long long n, int p){ \n  int trash; \n  unsigned long long i, iIn, iOut, omstep = 9, hostep = 3; \n \n  if (n >= OPENMPLIMIT) {omp_set_num_threads(omp_get_num_procs());} else  {omp_set_num_threads(1);} \n \n  for (i=0;i<n;i++){  \n    iIn = i * omstep; \n    iOut = i * hostep; \n      \n    trash = om2ho(&(om[iIn]), &(ho[iOut]), p); \n      \n  } \nreturn 1; \n} "}
{"label": " \nstatic void initialize(void) \n{ \n    int i, j, k, m, ix, iy, iz; \n    double xi, eta, zeta, Pface[2][3][5], Pxi, Peta, Pzeta, temp[5]; \n    for (i = 0; \n        i < 12; \n        i++) \n    { \n        for (j = 0; \n            j < 12; \n            j++) \n        { \n            for (k = 0; \n                k < 12; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    u[i][j][k][m] = 1.0; \n                } \n            } \n        } \n    } \n    for (i = 0; \n        i < grid_points[0]; \n        i++) \n    { \n        xi = (double) i * dnxm1; \n        for (j = 0; \n            j < grid_points[1]; \n            j++) \n        { \n            eta = (double) j * dnym1; \n            for (k = 0; \n                k < grid_points[2]; \n                k++) \n            { \n                zeta = (double) k * dnzm1; \n                for (ix = 0; \n                    ix < 2; \n                    ix++) \n                { \n                    exact_solution((double) ix, eta, zeta, &(Pface[ix][0][0])); \n                } \n                for (iy = 0; \n                    iy < 2; \n                    iy++) \n                { \n                    exact_solution(xi, (double) iy, zeta, &Pface[iy][1][0]); \n                } \n                for (iz = 0; \n                    iz < 2; \n                    iz++) \n                { \n                    exact_solution(xi, eta, (double) iz, &Pface[iz][2][0]); \n                } \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    Pxi = xi * Pface[1][0][m] + (1.0 - xi) * Pface[0][0][m]; \n                    Peta = eta * Pface[1][1][m] + (1.0 - eta) * Pface[0][1][m]; \n                    Pzeta = zeta * Pface[1][2][m] + (1.0 - zeta) * Pface[0][2][m]; \n                    u[i][j][k][m] = Pxi + Peta + Pzeta - Pxi * Peta - Pxi * Pzeta - Peta * Pzeta + Pxi * Peta * Pzeta; \n                } \n            } \n        } \n    } \n    i = 0; \n    xi = 0.0; \n    for (j = 0; \n        j < grid_points[1]; \n        j++) \n    { \n        eta = (double) j * dnym1; \n        for (k = 0; \n            k < grid_points[2]; \n            k++) \n        { \n            zeta = (double) k * dnzm1; \n            exact_solution(xi, eta, zeta, temp); \n            for (m = 0; \n                m < 5; \n                m++) \n            { \n                u[i][j][k][m] = temp[m]; \n            } \n        } \n    } \n    i = grid_points[0] - 1; \n    xi = 1.0; \n    for (j = 0; \n        j < grid_points[1]; \n        j++) \n    { \n        eta = (double) j * dnym1; \n        for (k = 0; \n            k < grid_points[2]; \n            k++) \n        { \n            zeta = (double) k * dnzm1; \n            exact_solution(xi, eta, zeta, temp); \n            for (m = 0; \n                m < 5; \n                m++) \n            { \n                u[i][j][k][m] = temp[m]; \n            } \n        }", "pred": " \nstatic void initialize(void) \n{ \n    int i, j, k, m, ix, iy, iz; \n    double xi, eta, zeta, Pface[2][3][5], Pxi, Peta, Pzeta, temp[5]; \n    for (i = 0; \n        i < 12; \n        i++) \n    { \n        for (j = 0; \n            j < 12; \n            j++) \n        { \n            for (k = 0; \n                k < 12; \n                k++) \n            { \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    Pface[0][m][k] = 0.0; \n                    Pface[1][m][k] = 0.0; \n                    Pface[2][m][k] = 0.0; \n                    Pface[3][m][k] = 0.0; \n                    Pface[4][m][k] = 0.0; \n                } \n            } \n        } \n    } \n    for (i = 0; \n        i < 5; \n        i++) \n    { \n        for (j = 0; \n            j < 5; \n            j++) \n        { \n            for (k = 0; \n                k < 5; \n                k++) \n            { \n                Pxi = Pface[i][j][k]; \n                Peta = Pface[i][j][k+1]; \n                Pzeta = Pface[i][j][k+2]; \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    Pface[i][j][k][m] = 0.0; \n                    Pface[i][j][k+1][m] = 0.0; \n                    Pface[i][j][k+2][m] = 0.0; \n                } \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    Pface[i][j][k+3][m] = 0.0; \n                    Pface[i][j][k+4][m] = 0.0; \n                } \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    Pface[i][j][k+5][m] = 0.0; \n                    Pface[i][j][k+6][m] = 0.0; \n                } \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    Pface[i][j][k+7][m] = 0.0; \n                    Pface[i][j][k+8][m] = 0.0; \n                } \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    Pface[i][j][k+9][m] = 0.0; \n                    Pface[i][j][k+10][m] = 0.0; \n                } \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    Pface[i][j][k+11][m] = 0.0; \n                    Pface[i][j][k+12][m] = 0.0; \n                } \n                for (m = 0; \n                    m < 5; \n                    m++) \n                { \n                    Pface[i][j][k+13][m] = 0.0; \n                    Pface[i][j][k+14][m] = 0.0; \n           "}
{"label": " \nSEXP attribute_hidden do_colsum(SEXP call, SEXP op, SEXP args, SEXP rho) \n{ \n    SEXP x, ans = R_NilValue; \n    int type; \n    Rboolean NaRm, keepNA; \n \n    checkArity(op, args); \n    x = CAR(args); args = CDR(args); \n    int n = asInteger(CAR(args)); args = CDR(args); \n    int p = asInteger(CAR(args)); args = CDR(args); \n    NaRm = asLogical(CAR(args)); \n    if (n == NA_INTEGER || n < 0) \n\terror(_(\"invalid '%s' argument\"), \"n\"); \n    if (p == NA_INTEGER || p < 0) \n\terror(_(\"invalid '%s' argument\"), \"p\"); \n    if (NaRm == NA_LOGICAL) error(_(\"invalid '%s' argument\"), \"na.rm\"); \n    keepNA =!NaRm; \n \n    int OP = PRIMVAL(op); \n    switch (type = TYPEOF(x)) { \n    case LGLSXP: break; \n    case INTSXP: break; \n    case REALSXP: break; \n    default: \n\terror(_(\"'x' must be numeric\")); \n    } \n \n    if (OP == 0 || OP == 1) {  \n \n\tPROTECT(ans = allocVector(REALSXP, p)); \n\tint nthreads; \n\t \n \n\tif (R_num_math_threads > 0) \n\t    nthreads = R_num_math_threads; \n\telse \n\t    nthreads = 1;  \n \n\tfor (int j = 0; j < p; j++) { \n\t    int cnt = n, i; \n\t    LDOUBLE sum = 0.0; \n\t    switch (type) { \n\t    case REALSXP: \n\t    { \n\t\tdouble *rx = REAL(x) + (R_xlen_t)n*j; \n\t\tif (keepNA) \n\t\t    for (sum = 0., i = 0; i < n; i++) sum += *rx++; \n\t\telse { \n\t\t    for (cnt = 0, sum = 0., i = 0; i < n; i++, rx++) \n\t\t\tif (!ISNAN(*rx)) {cnt++; sum += *rx;} \n\t\t\telse if (keepNA) {sum = NA_REAL; break;}  \n \n\t\t} \n\t\tbreak; \n\t    } \n\t    case INTSXP: \n\t    { \n\t\tint *ix = INTEGER(x) + (R_xlen_t)n*j; \n\t\tfor (cnt = 0, sum = 0., i = 0; i < n; i++, ix++) \n\t\t    if (*ix!= NA_INTEGER) {cnt++; sum += *ix;} \n\t\t    else if (keepNA) {sum = NA_REAL; break;} \n\t\tbreak; \n\t    } \n\t    case LGLSXP: \n\t    { \n\t\tint *ix = LOGICAL(x) + (R_xlen_t)n*j; \n\t\tfor (cnt = 0, sum = 0., i = 0; i < n; i++, ix++) \n\t\t    if (*ix!= NA_LOGICAL) {cnt++; sum += *ix;} \n\t\t    else if (keepNA) {sum = NA_REAL; break;} \n\t\tbreak; \n\t    } \n\t    } \n\t    if (OP == 1) sum /= cnt;  \n \n\t    REAL(ans)[j] = (double) sum; \n\t} \n    } \n    else {  \n \n\tPROTECT(ans = allocVector(REALSXP, n)); \n \n\t \n \n\tint *Cnt = NULL; \n\tLDOUBLE *rans; \n\tif(n <= 10000) { \n\t    R_CheckStack2(n * sizeof(LDOUBLE)); \n\t    rans = (LDOUBLE *) alloca(n * sizeof(LDOUBLE)); \n\t    Memzero(rans, n); \n\t} else rans = Calloc(n, LDOUBLE); \n\tif (!keepNA && OP == 3) Cnt = Calloc(n, int); \n \n\tfor (int j = 0; j < p; j++) { \n\t    LDOUBLE *ra = rans; \n\t    switch (type) { \n\t    case REALSXP: \n\t    { \n\t\tdouble *rx = REAL(x) + (R_xlen_t)n * j; \n\t\tif (keepNA) \n\t\t    for (int i = 0; i < n; i++) *ra++ += *rx++; \n\t\telse \n\t\t    for (int i = 0; i < n; i++, ra++, rx++) \n\t\t\tif (!ISNAN(*rx)) { \n\t\t\t    *ra += *rx; \n\t\t\t    if (OP == 3) Cnt[i]++; \n\t\t\t} \n\t\tbreak; \n\t    } \n\t    case INTSXP: \n\t    { \n\t\tint *ix = INTEGER(x) + (R_xlen_t)n * j; \n\t\tfor (int i = 0; i < n; i++, ra++, ix++) \n\t\t    if (keepNA) { \n\t\t\tif (*ix!= NA_INTEGER) *ra += *ix; \n\t\t\telse *ra = NA_REAL; \n\t\t    } \n\t\t    else if (*ix!= NA_INTEGER) { \n\t\t\t*ra += *ix; \n\t\t\tif (OP == 3) Cnt[i]++; \n\t\t    } \n\t\tbreak; \n\t    } \n\t    case LGLSXP: \n\t    { \n\t\tint *ix = LOGICAL(x) + (R_xlen_t)n * j; \n\t\tfor (int i = 0; i < n; i++, ra++, ix++) \n\t\t    if (keepNA) { \n\t\t\tif (*ix!= NA_LOGICAL) *ra += *ix; \n\t\t\telse *ra = NA_REAL; \n\t\t    } \n\t\t    else if (*ix!= NA_LOGICAL) { \n\t\t\t*ra += *ix; \n\t\t\tif (OP == 3) Cnt[i]++; \n\t\t    } \n\t\tbreak; \n\t    } \n\t    } \n\t} \n\tif (OP == 3) { \n\t    if (keepNA) \n\t\tfor (int i = 0; i < n; i++) rans[i] /= p; \n\t    else \n\t\tfor (int i = 0; i < n; i++) rans[i] /= Cnt[i]; \n\t} \n\tfor (int i = 0; i < n; i++) REAL(ans)[i] = (double) rans[i]; \n \n\tif (!keepNA && OP == 3) Free(Cnt); \n\tif(n > 10000) Free(rans); \n    } \n \n    UNPROTECT(1); \n    return ans; \n} ", "pred": " \nSEXP attribute_hidden do_colsum(SEXP call, SEXP op, SEXP args, SEXP rho) \n{ \n    SEXP x, ans = R_NilValue; \n    int type; \n    Rboolean NaRm, keepNA; \n \n    checkArity(op, args); \n    x = CAR(args); args = CDR(args); \n    int n = asInteger(CAR(args)); args = CDR(args); \n    int p = asInteger(CAR(args)); args = CDR(args); \n    NaRm = asLogical(CAR(args)); \n    if (n == NA_INTEGER || n < 0) \n\terror(_(\"invalid '%s' argument\"), \"n\"); \n    if (p == NA_INTEGER || p < 0) \n\terror(_(\"invalid '%s' argument\"), \"p\"); \n    if (NaRm == NA_LOGICAL) error(_(\"invalid '%s' argument\"), \"na.rm\"); \n    keepNA =!NaRm; \n \n    int OP = PRIMVAL(op); \n    switch (type = TYPEOF(x)) { \n    case LGLSXP: break; \n    case INTSXP: break; \n    case REALSXP: break; \n    case CPLXSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP: break; \n    case STRSXP"}
{"label": " \nstatic void Hull(const Image *image,const ssize_t x_offset, \n  const ssize_t y_offset,const size_t columns,const size_t rows, \n  const int polarity,Quantum *restrict f,Quantum *restrict g) \n{ \n  register Quantum \n    *p, \n    *q, \n    *r, \n    *s; \n \n  ssize_t \n    y; \n \n  assert(f!= (Quantum *) NULL); \n  assert(g!= (Quantum *) NULL); \n  p=f+(columns+2); \n  q=g+(columns+2); \n  r=p+(y_offset*(columns+2)+x_offset); \n  for (y=0; y < (ssize_t) rows; y++) \n  { \n    register ssize_t \n      i, \n      x; \n \n    SignedQuantum \n      v; \n \n    i=(2*y+1)+y*columns; \n    if (polarity > 0) \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) p[i]; \n        if ((SignedQuantum) r[i] >= (v+ScaleCharToQuantum(2))) \n          v+=ScaleCharToQuantum(1); \n        q[i]=(Quantum) v; \n        i++; \n      } \n    else \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) p[i]; \n        if ((SignedQuantum) r[i] <= (v-ScaleCharToQuantum(2))) \n          v-=ScaleCharToQuantum(1); \n        q[i]=(Quantum) v; \n        i++; \n      } \n  } \n  p=f+(columns+2); \n  q=g+(columns+2); \n  r=q+(y_offset*(columns+2)+x_offset); \n  s=q-(y_offset*(columns+2)+x_offset); \n  for (y=0; y < (ssize_t) rows; y++) \n  { \n    register ssize_t \n      i, \n      x; \n \n    SignedQuantum \n      v; \n \n    i=(2*y+1)+y*columns; \n    if (polarity > 0) \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) q[i]; \n        if (((SignedQuantum) s[i] >= (v+ScaleCharToQuantum(2))) && \n            ((SignedQuantum) r[i] > v)) \n          v+=ScaleCharToQuantum(1); \n        p[i]=(Quantum) v; \n        i++; \n      } \n    else \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) q[i]; \n        if (((SignedQuantum) s[i] <= (v-ScaleCharToQuantum(2))) && \n            ((SignedQuantum) r[i] < v)) \n          v-=ScaleCharToQuantum(1); \n        p[i]=(Quantum) v; \n        i++; \n      } \n  } \n} ", "pred": " \nstatic void Hull(const Image *image,const ssize_t x_offset, \n  const ssize_t y_offset,const size_t columns,const size_t rows, \n  const int polarity,Quantum *restrict f,Quantum *restrict g) \n{ \n  register Quantum \n    *p, \n    *q, \n    *r, \n    *s; \n \n  ssize_t \n    y; \n \n  assert(f!= (Quantum *) NULL); \n  assert(g!= (Quantum *) NULL); \n  p=f+(columns+2); \n  q=g+(columns+2); \n  r=p+(y_offset*(columns+2)+x_offset); \n  for (y=0; y < (ssize_t) rows; y++) \n  { \n    register ssize_t \n      i, \n      x; \n \n    SignedQuantum \n      v; \n \n    i=(2*y+1)+y*columns; \n    if (polarity > 0) \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) p[i]; \n        p[i]=((v < 0)? 0 : v); \n        i++; \n      } \n    else \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) p[i]; \n        p[i]=((v > 0)? 0 : v); \n        i++; \n      } \n    if (polarity > 0) \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) q[i]; \n        q[i]=((v < 0)? 0 : v); \n        i++; \n      } \n    else \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) q[i]; \n        q[i]=((v > 0)? 0 : v); \n        i++; \n      } \n    if (polarity > 0) \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) r[i]; \n        r[i]=((v < 0)? 0 : v); \n        i++; \n      } \n    else \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) r[i]; \n        r[i]=((v > 0)? 0 : v); \n        i++; \n      } \n    if (polarity > 0) \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) s[i]; \n        s[i]=((v < 0)? 0 : v); \n        i++; \n      } \n    else \n      for (x=0; x < (ssize_t) columns; x++) \n      { \n        v=(SignedQuantum) s[i]; \n        s[i]=((v > 0)? 0 : v"}
{"label": " \nMagickExport MagickBooleanType DrawGradientImage(Image *image, \n  const DrawInfo *draw_info,ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  const GradientInfo \n    *gradient; \n \n  const SegmentInfo \n    *gradient_vector; \n \n  double \n    length; \n \n  MagickBooleanType \n    status; \n \n  PixelInfo \n    zero; \n \n  PointInfo \n    point; \n \n  RectangleInfo \n    bounding_box; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(draw_info!= (const DrawInfo *) NULL); \n  gradient=(&draw_info->gradient); \n  gradient_vector=(&gradient->gradient_vector); \n  point.x=gradient_vector->x2-gradient_vector->x1; \n  point.y=gradient_vector->y2-gradient_vector->y1; \n  length=sqrt(point.x*point.x+point.y*point.y); \n  bounding_box=gradient->bounding_box; \n  status=MagickTrue; \n  GetPixelInfo(image,&zero); \n  image_view=AcquireAuthenticCacheView(image,exception); \n  for (y=bounding_box.y; y < (ssize_t) bounding_box.height; y++) \n  { \n    PixelInfo \n      composite, \n      pixel; \n \n    double \n      alpha, \n      offset; \n \n    register Quantum \n      *restrict q; \n \n    register ssize_t \n      i, \n      x; \n \n    ssize_t \n      j; \n \n    if (status == MagickFalse) \n      continue; \n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception); \n    if (q == (Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    pixel=zero; \n    composite=zero; \n    offset=GetStopColorOffset(gradient,0,y); \n    if (gradient->type!= RadialGradient) \n      offset/=length; \n    for (x=bounding_box.x; x < (ssize_t) bounding_box.width; x++) \n    { \n      GetPixelInfoPixel(image,q,&pixel); \n      switch (gradient->spread) \n      { \n        case UndefinedSpread: \n        case PadSpread: \n        { \n          if ((x!= (ssize_t) ceil(gradient_vector->x1-0.5)) || \n              (y!= (ssize_t) ceil(gradient_vector->y1-0.5))) \n            { \n              offset=GetStopColorOffset(gradient,x,y); \n              if (gradient->type!= RadialGradient) \n                offset/=length; \n            } \n          for (i=0; i < (ssize_t) gradient->number_stops; i++) \n            if (offset < gradient->stops[i].offset) \n              break; \n          if ((offset < 0.0) || (i == 0)) \n            composite=gradient->stops[0].color; \n          else \n            if ((offset > 1.0) || (i == (ssize_t) gradient->number_stops)) \n              composite=gradient->stops[gradient->number_stops-1].color; \n            else \n              { \n                j=i; \n                i--; \n                alpha=(offset-gradient->stops[i].offset)/ \n                  (gradient->stops[j].offset-gradient->stops[i].offset); \n                CompositePixelInfoBlend(&gradient->stops[i].color,1.0-alpha, \n                  &gradient->stops[j].color,alpha,&composite); \n              } \n          break; \n        } \n        case ReflectSpread: \n        { \n          if ((x!= (ssize_t) ceil(gradient_vector->x1-0.5)) || \n              (y!= (ssize_t) ceil(gradient_vector->y1-0.5))) \n            { \n              offset=GetStopColorOffset(gradient,x,y); \n              if (gradient->type!= RadialGradient) \n                offset/=length; \n            } \n          if (offset < 0.0) \n            offset=(-offset); \n          if ((ssize_t) fmod(offset,2.0) == 0) \n            offset=fmod(offset,1.0); \n          else \n            offset=1.0-fmod(offset,1.0); \n          for (i=0; i < (ssize_t) gradient->number_stops; i++) \n            if (offset < gradient->stops[i].offset) \n              break; \n          if (i == 0) \n            composite=gradient->stops[0].color; \n          else \n            if (i == (ssize_t) gradient->number_stops) \n              composite=gradient->stops[gradient->number_stops-1].color; \n            else \n              { \n                j=i; \n                i--; \n                alpha=(offset-gradient->stops[i].offset)/ \n                  (gradient->stops[j].offset-gradient->stops[i].offset); \n                CompositePixelInfoBlend(&gradient->stops[i].color,1.0-alpha, \n                  &gradient->stops[j].color,alpha,&composite); \n              } \n          break; \n      ", "pred": " \nMagickExport MagickBooleanType DrawGradientImage(Image *image, \n  const DrawInfo *draw_info,ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  const GradientInfo \n    *gradient; \n \n  const SegmentInfo \n    *gradient_vector; \n \n  double \n    length; \n \n  MagickBooleanType \n    status; \n \n  PixelInfo \n    zero; \n \n  PointInfo \n    point; \n \n  RectangleInfo \n    bounding_box; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(draw_info!= (const DrawInfo *) NULL); \n  gradient=(&draw_info->gradient); \n  gradient_vector=(&gradient->gradient_vector); \n  point.x=gradient_vector->x2-gradient_vector->x1; \n  point.y=gradient_vector->y2-gradient_vector->y1; \n  length=sqrt(point.x*point.x+point.y*point.y); \n  if (length == 0.0)\n    return(MagickFalse); \n  bounding_box=image->columns/2.0; \n  if (draw_info->affine!= MagickFalse)\n    {\n      bounding_box.x0=0.0; \n      bounding_box.y0=0.0; \n      bounding_box.x1=image->columns-1.0; \n      bounding_box.y1=image->rows-1.0; \n    } \n  status=ClipGradientToRectangle(image,&bounding_box,&bounding_box,exception); \n  if (status == MagickFalse)\n    return(status);\n  if (gradient_vector->x1 < gradient_vector->x2)\n    {\n      length=sqrt(gradient_vector->x1*gradient_vector->x1+\n        gradient_vector->y1*gradient_vector->y1); \n      if (length == 0.0)\n        return(MagickFalse); \n      gradient_vector->x1=gradient_vector->x2; \n      gradient_vector->y1=gradient_vector->y2; \n      gradient_vector->x2=length; \n      gradient_vector->y2=length; \n    } \n  if (gradient_vector->x1 > gradient_vector->x2)\n    {\n      length=sqrt(gradient_vector->x1*gradient_vector->x1+\n        gradient_vector->y2*gradient_vector->y2); \n      if (length == 0.0)\n        return(MagickFalse); \n      gradient_vector->x1=gradient_vector->x2; \n      gradient_vector->y1=gradient_vector->y2; \n      gradient_vector->x2=length; \n      gradient_vector->y2=length; \n    } \n  if (gradient_vector->y1 > gradient_vector->y2)\n    {\n      length=sqrt(gradient_vector->x1*gradient_vector->x1+\n        gradient_vector->y1*gradient_vector->y1); \n      if (length == 0.0)\n        return(MagickFalse); \n      gradient_vector->x1=gradient_vector->x2; \n      gradient_vector->y1=gradient_vector->y2; \n      gradient_vector->x2=length; \n      gradient_vector->y2=length; \n    } \n  if (gradient_vector->y1 < gradient_vector->y2)\n    {\n      length=sqrt(gradient_vector->x1*gradient_vector->x1+\n        gradient_vector->y2*gradient_vector->y2); \n      if (length == 0.0)\n        return(MagickFalse); \n      gradient_vector->x1=gradient_vector->x2; \n      gradient_vector->y1=gradient_vector->y2; \n      gradient_vector->x2=length; \n      gradient_vector->y2=length; \n    } \n  if (gradient_vector->x1 < gradient_vector->x2)\n    {\n      length=sqrt(gradient_vector->x1*gradient_vector->x1+\n        gradient_vector->y1*gradient_vector->y1); \n      if (length == 0.0)\n        return(MagickFalse); \n      gradient_vector->x1=gradient_vector->x2; \n      gradient_vector->y1=gradient_vector->y2; \n      gradient_vector->x2=length; \n      gradient_vector->y2=length; \n    } \n  if (gradient_vector->x1 > gradient_vector->x2)\n    {\n      length=sqrt(gradient_vector->x1*gradient_vector->x1+\n        gradient_vector->y2*gradient_vector->y2); \n      if (length == 0.0)\n        return(MagickFalse); \n      gradient_vector->x1=gradient_vector->x2; \n      gradient_vector->y1=gradient_vector->y2; \n      gradient_vector->x2=length; \n      gradient_vector->y2=length; \n    } \n  if (gradient_vector->y1 > gradient_vector->y2)\n    {\n      length=sqrt(gradient_vector->x1*gradient_vector->x1+\n        gradient_vector->y1*gradient_vector->y1); \n      if (length == 0.0)\n        return(MagickFalse); \n      gradient_vector->x1=gradient_vector->x2; \n      gradient_vector->y1=gradient_vector->y2; \n      gradient_vector->x2=length; \n      gradient_vector->y2=length; \n    } \n  if (gradient_vector->y1 < gradient_vector->y2)\n    {\n      length=sqrt(gradient_vector->x1*gradient_vector->x1+\n        gradient_vector->y2*gradient_vector->y2); \n      if (length == 0.0)\n        return(MagickFalse); \n      gradient_vector->x1=gradient_vector->x2; \n      gradient_vector->y1=gradient_vector->y2; \n      gradient_vector->x2=length; \n      gradient_vector->y2=length; \n    } \n  if (gradient_vector->x1 < gradient_vector->x2)\n    {\n      length=sqrt(gradient_vector->x1*gradient_vector->x1+\n        gradient_vector->y1*gradient_vector->y1); \n      if (length == 0.0)\n        return(MagickFalse); \n      gradient_vector->x1=gradient_vector->x2; \n      gradient_vector->y1=gradient_vector->y2; \n      gradient_vector->x2=length; \n      gradient_vector->y2=length; \n    } \n  if (gradient_vector->x1 > gradient_vector->x2)\n    {\n      length=sqrt("}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o, \n             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int ch = piece->colors; \n \n  const dt_dev_pixelpipe_display_mask_t mask_display = piece->pipe->mask_display; \n  char *str = dt_conf_get_string(\"channel_display\"); \n  const int fcolor =!strcmp(str, \"false color\"); \n  g_free(str); \n \n  if((mask_display & DT_DEV_PIXELPIPE_DISPLAY_CHANNEL) && (mask_display & DT_DEV_PIXELPIPE_DISPLAY_ANY) && fcolor) \n  { \n    const float yellow[3] = { 1.0f, 1.0f, 0.0f }; \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)i) + (size_t)ch * k * roi_out->width; \n      uint8_t *out = ((uint8_t *)o) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++, in += ch, out += ch) \n      { \n        const float alpha = (mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK)? in[3] : 0.0f; \n        float colors[3]; \n        false_color(in[1], mask_display, colors); \n        for(int c = 0; c < 3; c++) \n        { \n          const float value = colors[c] * (1.0f - alpha) + yellow[c] * alpha; \n          out[2 - c] = ((uint8_t)(CLAMP(((uint32_t)255.0f * value), 0x0, 0xff))); \n        } \n      } \n    } \n  } \n  else if((mask_display & DT_DEV_PIXELPIPE_DISPLAY_CHANNEL) && (mask_display & DT_DEV_PIXELPIPE_DISPLAY_ANY)) \n  { \n    const float yellow[3] = { 1.0f, 1.0f, 0.0f }; \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)i) + (size_t)ch * k * roi_out->width; \n      uint8_t *out = ((uint8_t *)o) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++, in += ch, out += ch) \n      { \n        float alpha = (mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK)? in[3] : 0.0f; \n        for(int c = 0; c < 3; c++) \n        { \n          const float value = in[1] * (1.0f - alpha) + yellow[c] * alpha; \n          out[2 - c] = ((uint8_t)(CLAMP(((uint32_t)255.0f * value), 0x0, 0xff))); \n        } \n      } \n    } \n  } \n  else if(mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) \n  { \n    const float yellow[3] = { 1.0f, 1.0f, 0.0f }; \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)i) + (size_t)ch * k * roi_out->width; \n      uint8_t *out = ((uint8_t *)o) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++, in += ch, out += ch) \n      { \n        const float gray = 0.3f * in[0] + 0.59f * in[1] + 0.11f * in[2]; \n        const float alpha = in[3]; \n        for(int c = 0; c < 3; c++) \n        { \n          const float value = gray * (1.0f - alpha) + yellow[c] * alpha; \n          out[2 - c] = ((uint8_t)(CLAMP(((uint32_t)255.0f * value), 0x0, 0xff))); \n        } \n      } \n    } \n  } \n  else \n  { \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)i) + (size_t)ch * k * roi_out->width; \n      uint8_t *out = ((uint8_t *)o) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++, in += ch, out += ch) \n      { \n        for(int c = 0; c < 3; c++) out[2 - c] = ((uint8_t)(CLAMP(((uint32_t)255.0f * in[c]), 0x0, 0xff))); \n      } \n    } \n  } \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o, \n             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int ch = piece->colors; \n \n  const dt_dev_pixelpipe_display_mask_t mask_display = piece->pipe->mask_display; \n  char *str = dt_conf_get_string(\"channel_display\"); \n  const int fcolor =!strcmp(str, \"false color\"); \n  g_free(str); \n \n  if((mask_display & DT_DEV_PIXELPIPE_DISPLAY_CHANNEL) && (mask_display & DT_DEV_PIXELPIPE_DISPLAY_ANY) && fcolor) \n  { \n    const float yellow[3] = { 1.0f, 1.0f, 0.0f }; \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)i) + (size_t)ch * k * roi_out->width; \n      uint8_t *out = ((uint8_t *)o) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++) \n      { \n        const float *in_p = in + j * ch; \n        uint8_t *out_p = out + j * ch; \n        for(int i = 0; i < ch; i++) \n        { \n          out_p[i] = in_p[i] * yellow[0] + in_p[i + ch] * yellow[1] + in_p[i + 2 * ch] * yellow[2]; \n        } \n      } \n    } \n  } \n  else \n  { \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)i) + (size_t)ch * k * roi_out->width; \n      uint8_t *out = ((uint8_t *)o) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++) \n      { \n        const float *in_p = in + j * ch; \n        uint8_t *out_p = out + j * ch; \n        for(int i = 0; i < ch; i++) \n        { \n          out_p[i] = in_p[i] * 255.0f; \n        } \n      } \n    } \n  } \n  \n}\n\n\nvoid process_roi(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o, \n                 const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const int ch = piece->colors; \n \n  const dt_dev_pixelpipe_display_mask_t mask_display = piece->pipe->mask_display; \n  char *str = dt_conf_get_string(\"channel_display\"); \n  const int fcolor =!strcmp(str, \"false color\"); \n  g_free(str); \n \n  if((mask_display & DT_DEV_PIXELPIPE_DISPLAY_CHANNEL) && (mask_display & DT_DEV_PIXELPIPE_DISPLAY_ANY) && fcolor) \n  { \n    const float yellow[3] = { 1.0f, 1.0f, 0.0f }; \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)i) + (size_t)ch * k * roi_out->width; \n      uint8_t *out = ((uint8_t *)o) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++) \n      { \n        const float *in_p = in + j * ch; \n        uint8_t *out_p = out + j * ch; \n        for(int i = 0; i < ch; i++) \n        { \n          out_p[i] = in_p[i] * yellow[0] + in_p[i + ch] * yellow[1] + in_p[i + 2 * ch] * yellow[2]; \n        } \n      } \n    } \n  } \n  else \n  { \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)i) + (size_t)ch * k * roi_out->width; \n      uint8_t *out = ((uint8_t *)o) + (size_t)ch * k * roi_out->width; \n      for(int j = 0; j < roi_out->width; j++) \n      { \n        const float *in_p = in + j * ch; \n        uint8_t *out_p = out + j * ch; \n        for(int i = 0; i < ch; i++) \n        { \n          out_p[i] = in_p[i] *"}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o, \n             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_lowlight_data_t *d = (dt_iop_lowlight_data_t *)(piece->data); \n  const int ch = piece->colors; \n \n   \n \n  const float c = 0.5f; \n  const float threshold = 0.01f; \n \n   \n \n  float Lab_sw[3] = { 100.0f, 0, -d->blueness }; \n  float XYZ_sw[3]; \n \n  dt_Lab_to_XYZ(Lab_sw, XYZ_sw); \n \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    float *in = (float *)i + ch * k; \n    float *out = (float *)o + ch * k; \n    float XYZ[3], XYZ_s[3]; \n    float V; \n    float w; \n \n    dt_Lab_to_XYZ(in, XYZ); \n \n     \n \n    if(XYZ[0] > threshold) \n    { \n       \n \n      V = XYZ[1] * (1.33f * (1.0f + (XYZ[1] + XYZ[2]) / XYZ[0]) - 1.68f); \n    } \n    else \n    { \n       \n \n      V = XYZ[1] * (1.33f * (1.0f + (XYZ[1] + XYZ[2]) / threshold) - 1.68f); \n    } \n \n     \n \n    V = fminf(1.0f, fmaxf(0.0f, c * V)); \n \n     \n \n    w = lookup(d->lut, in[0] / 100.f); \n \n    XYZ_s[0] = V * XYZ_sw[0]; \n    XYZ_s[1] = V * XYZ_sw[1]; \n    XYZ_s[2] = V * XYZ_sw[2]; \n \n    XYZ[0] = w * XYZ[0] + (1.0f - w) * XYZ_s[0]; \n    XYZ[1] = w * XYZ[1] + (1.0f - w) * XYZ_s[1]; \n    XYZ[2] = w * XYZ[2] + (1.0f - w) * XYZ_s[2]; \n \n    dt_XYZ_to_Lab(XYZ, out); \n \n    out[3] = in[3]; \n  } \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o, \n             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_lowlight_data_t *d = (dt_iop_lowlight_data_t *)(piece->data); \n  const int ch = piece->colors; \n \n   \n \n  const float c = 0.5f; \n  const float threshold = 0.01f; \n \n   \n \n  float Lab_sw[3] = { 100.0f, 0, -d->blueness }; \n  float XYZ_sw[3]; \n \n  dt_Lab_to_XYZ(Lab_sw, XYZ_sw); \n \n  for(size_t k = 0; k < (size_t)roi_out->width * roi_out->height; k++) \n  { \n    float *in = (float *)i + ch * k; \n    float *out = (float *)o + ch * k; \n    float XYZ[3], XYZ_s[3]; \n    float V[3]; \n    float Lab[3]; \n    float Lab_s[3]; \n    float L[3]; \n    float L_s[3]; \n    float L_sw[3]; \n    float L_sw_s[3]; \n    float L_sw_sw[3]; \n    float L_sw_sw_s[3]; \n    float L_sw_sw_sw[3]; \n    float L_sw_sw_sw_s[3]; \n    float L_sw_sw_sw_sw[3]; \n    float L_sw_sw_sw_sw_s[3]; \n    float L_sw_sw_sw_sw_sw[3]; \n    float L_sw_sw_sw_sw_sw_s[3]; \n    float L_sw_sw_sw_sw_sw_sw[3]; \n    float L_sw_sw_sw_sw_sw_sw_s[3]; \n    float L_sw_sw_sw_sw_sw_sw_sw[3]; \n    float L_sw_sw_sw_sw_sw_sw_sw_s[3]; \n    float L_sw_sw_sw_sw_sw_sw_sw_sw[3]; \n    float L_sw_sw_sw_sw_sw_sw_sw_sw_s[3]; \n    float L_sw_sw_sw_sw_sw_sw_sw_sw_sw[3]; \n    float L_sw_sw_sw_sw_sw_sw_sw_sw_sw_s[3]; \n    float L_sw_sw_sw_sw_sw_sw_sw_sw_sw_"}
{"label": " \nstatic int _gradient_get_mask(const dt_iop_module_t *const module, const dt_dev_pixelpipe_iop_t *const piece, \n                              dt_masks_form_t *const form, \n                              float **buffer, int *width, int *height, int *posx, int *posy) \n{ \n  double start2 = 0.0; \n  if(darktable.unmuted & DT_DEBUG_PERF) start2 = dt_get_wtime(); \n   \n \n  if(!_gradient_get_area(module, piece, form, width, height, posx, posy)) return 0; \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n  { \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] gradient area took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n    start2 = dt_get_wtime(); \n  } \n \n   \n \n  dt_masks_point_gradient_t *gradient = (dt_masks_point_gradient_t *)((form->points)->data); \n \n   \n \n  const int w = *width; \n  const int h = *height; \n  const int px = *posx; \n  const int py = *posy; \n  const int grid = 8; \n  const int gw = (w + grid - 1) / grid + 1; \n  const int gh = (h + grid - 1) / grid + 1; \n \n  float *points = dt_alloc_align_float((size_t)2 * gw * gh); \n  if(points == NULL) return 0; \n \n  for(int j = 0; j < gh; j++) \n    for(int i = 0; i < gw; i++) \n    { \n      points[(j * gw + i) * 2] = (grid * i + px); \n      points[(j * gw + i) * 2 + 1] = (grid * j + py); \n    } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n  { \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] gradient draw took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n    start2 = dt_get_wtime(); \n  } \n \n   \n \n  if(!dt_dev_distort_backtransform_plus(module->dev, piece->pipe, module->iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, points, (size_t)gw * gh)) \n  { \n    dt_free_align(points); \n    return 0; \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n  { \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] gradient transform took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n    start2 = dt_get_wtime(); \n  } \n \n   \n \n  const float wd = piece->pipe->iwidth; \n  const float ht = piece->pipe->iheight; \n  const float hwscale = 1.0f / sqrtf(wd * wd + ht * ht); \n  const float ihwscale = 1.0f / hwscale; \n  const float v = (-gradient->rotation / 180.0f) * M_PI; \n  const float sinv = sinf(v); \n  const float cosv = cosf(v); \n  const float xoffset = cosv * gradient->anchor[0] * wd + sinv * gradient->anchor[1] * ht; \n  const float yoffset = sinv * gradient->anchor[0] * wd - cosv * gradient->anchor[1] * ht; \n  const float compression = fmaxf(gradient->compression, 0.001f); \n  const float normf = 1.0f / compression; \n  const float curvature = gradient->curvature; \n  const dt_masks_gradient_states_t state = gradient->state; \n \n  const int lutmax = ceilf(4 * compression * ihwscale); \n  const int lutsize = 2 * lutmax + 2; \n  float *lut = dt_alloc_align_float((size_t)lutsize); \n  if(lut == NULL) \n  { \n    dt_free_align(points); \n    return 0; \n  } \n \n  for(int n = 0; n < lutsize; n++) \n  { \n    const float distance = (n - lutmax) * hwscale; \n    const float value = 0.5f + 0.5f * ((state == DT_MASKS_GRADIENT_STATE_LINEAR)? normf * distance: erff(distance / compression)); \n    lut[n] = (value < 0.0f)? 0.0f : ((value > 1.0f)? 1.0f : value); \n  } \n \n   \n \n  float *clut = lut + lutmax; \n \n \n  for(int j = 0; j < gh; j++) \n  { \n    for(int i = 0; i < gw; i++) \n    { \n      const float x = points[(j * gw + i) * 2]; \n      const float y = points[(j * gw + i) * 2 + 1]; \n \n      const float x0 = (cosv * x + sinv * y - xoffset) * hwscale; \n      const float y0 = (sinv * x - cosv * y - yoffset) * hwscale; \n \n      const float distance = y0 - curvature * x0 * x0; \n \n      points[(j * gw + i) * 2] = (distance <= -4.0f * compression)? 0.0f : \n                                    ((distance >= 4.0f * compression)? 1.0f : dt_gradient_lookup(clut, distance * ihwscale)); \n    } \n  } \n \n  dt_free_align(lut); \n \n   \n \n  float *const bufptr = *buffer = dt_alloc_align_float((size_t)w * h); \n  if(*buffer == NULL) \n  { \n    dt_free_align(points); \n    return 0; \n  } \n \n \n \n  for(int j = 0; j < h; j++) \n  { \n    const int jj = j % grid; \n    const int mj = j / grid; \n    const int grid_jj = grid - jj; \n    for(int i = 0; i < w; i++) \n    { \n      const int ii = i % grid; \n      const int mi = i / grid; \n      const int grid_ii = grid - ii; \n      const size_t pt_index = mj * gw + mi; \n      bufptr[j * w + i] = (points[2 * pt_index] * grid_ii * grid_jj \n                           + points[2 * (pt_index + 1)] * ii * grid_jj \n                           + points[2 * (pt_index + gw)] * grid_ii * jj \n                           + points[2 * (pt_index + gw + 1)] * ii * jj) / (grid * grid); \n    } \n  } \n \n  dt_free_align(points); \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] gradient fill took %0.04f sec\\n\", form->name,", "pred": " \nstatic int _gradient_get_mask(const dt_iop_module_t *const module, const dt_dev_pixelpipe_iop_t *const piece, \n                              dt_masks_form_t *const form, \n                              float **buffer, int *width, int *height, int *posx, int *posy) \n{ \n  double start2 = 0.0; \n  if(darktable.unmuted & DT_DEBUG_PERF) start2 = dt_get_wtime(); \n   \n \n  if(!_gradient_get_area(module, piece, form, width, height, posx, posy)) return 0; \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n  { \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] gradient area took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n    start2 = dt_get_wtime(); \n  } \n  \n  if(!_gradient_get_mask(module, piece, form, buffer, width, height, posx, posy)) return 0; \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n  { \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] gradient mask took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n    start2 = dt_get_wtime(); \n  } \n  \n  return 1; \n} \n\n\nstatic int _gradient_get_mask(const dt_iop_module_t *const module, const dt_dev_pixelpipe_iop_t *const piece, \n                              dt_masks_form_t *const form, \n                              float **buffer, int *width, int *height, int *posx, int *posy) \n{ \n  int x, y, w, h, i, j, k, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6, x7, y7, x8, y8, x9, y9, x10, y10, x11, y11, x12, y12, x13, y13, x14, y14, x15, y15, x16, y16, x17, y17, x18, y18, x19, y19, x20, y20, x21, y21, x22, y22, x23, y23, x24, y24, x25, y25, x26, y26, x27, y27, x28, y28, x29, y29, x30, y30, x31, y31, x32, y32, x33, y33, x34, y34, x35, y35, x36, y36, x37, y37, x38, y38, x39, y39, x40, y40, x41, y41, x42, y42, x43, y43, x44, y44, x45, y45, x46, y46, x47, y47, x48, y48, x49, y49, x50, y50, x51, y51, x52, y52, x53, y53, x54, y54, x55, y55, x56, y56, x57, y57, x58, y58, x59, y59, x60, y60, x61, y61, x62, y62, x63, y63, x64, y64, x65, y65, x66, y66, x67, y67, x68, y68, x69, y69, x70, y70, x71, y71, x72, y72, x73, y73, x74, y74, x75, y75, x76, y76, x77, y77, x78, y78, x79, y79, x80, y80, x81, y81, x82, y82, x83, y83, x84, y84, x85, y85, x86, y86, x87, y87, x88, y88, x89, y89, x90, y90, x91, y91, x92, y92, x93, y93, x94, y94, x95, y95, x96, y96, x97, y97, x98, y98, x99, y99, x100, y100, x101, y101, x102, y102, x103, y103, x104, y104, x105, y105, x106, y106, x107, y107, x108, y108, x109, y109, x110, y110, x111, y111, x112, y112, x113, y113, x114, y114, x115, y115, x116, y116, x117, y117, x118, y118, x119, y119, x120, y120, x121, y121, x122, y122, x123, y123, x124, y124, x125, y125, x126, y126, x127, y127, x128, y128, x129, y129, x130, y130, x131, y131, x132, y132, x133, y133, x134, y134, x135, y135, x136, y136, x137, y137, x138, y138, x139, y139, x140, y140, x141, y141, x142, y142, x143, y143, x144, y144, x145, y145, x146, y146, x147, y147, x148, y148, x149, y149, x150, y150, x151, y151, x152, y152, x153, y153, x154, y154, x155, y155, x156, y156, x157, y157, x158, y158, x159, y159, x160, y160, x161, y161, x162, y162, x163, y163, x164, y164, x165, y165, x166, y166, x167, y167, x168, y168, x169, y169, x170, y170, x171, y171, x172, y172, x173, y173, x174, y174, x175, y175, x176, y176, x177, y177, x178, y178, x179, y179, x180, y180, x181, y181, x182, y182, x183, y183, x184, y184, x185, y185, x186, y186, x187, y187, x188, y188, x189, y189, x190, y190, x191, y191, x192, y192, x193, y193, x194, y194, x195, y195, x196, y196, x197, y197, x198, y198, x199, y199, x200, y200, x201, y201, x202, y202, x203, y203, x204, y204, x205, y205, x206, y206, x207, y207, x208, y208, x209, y209, x210, y210, x211, y211, x212, y212, x213, y213, x214, y214, x215, y215, x216, y216, x217, y217, x218, y218, x219, y219, x220, y220, x221, y221, x222, y222, x223, y223, x224, y224, x225, y225, x226, y226, x227, y227, x228, y228, x229, y229, x230, y230, x231, y231, x232, y232, x233, y233, x234, y234, x235, y235, x236, y236, x237, y237, x238, y238, x239, y239, x240, y240, x241, y241, x242, y242, x243, y243, x244, y"}
{"label": " \nMagickExport Image *ShadeImage(const Image *image,const MagickBooleanType gray, \n  const double azimuth,const double elevation,ExceptionInfo *exception) \n{ \n#define ShadeImageTag  \"Shade/Image\" \n \n  CacheView \n    *image_view, \n    *shade_view; \n \n  Image \n    *linear_image, \n    *shade_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PrimaryInfo \n    light; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  linear_image=CloneImage(image,0,0,MagickTrue,exception); \n  shade_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if ((linear_image == (Image *) NULL) || (shade_image == (Image *) NULL)) \n    { \n      if (linear_image!= (Image *) NULL) \n        linear_image=DestroyImage(linear_image); \n      if (shade_image!= (Image *) NULL) \n        shade_image=DestroyImage(shade_image); \n      return((Image *) NULL); \n    } \n  if (SetImageStorageClass(shade_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&shade_image->exception); \n      linear_image=DestroyImage(linear_image); \n      shade_image=DestroyImage(shade_image); \n      return((Image *) NULL); \n    } \n   \n \n  light.x=(double) QuantumRange*cos(DegreesToRadians(azimuth))* \n    cos(DegreesToRadians(elevation)); \n  light.y=(double) QuantumRange*sin(DegreesToRadians(azimuth))* \n    cos(DegreesToRadians(elevation)); \n  light.z=(double) QuantumRange*sin(DegreesToRadians(elevation)); \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireVirtualCacheView(linear_image,exception); \n  shade_view=AcquireAuthenticCacheView(shade_image,exception); \n  for (y=0; y < (ssize_t) linear_image->rows; y++) \n  { \n    MagickRealType \n      distance, \n      normal_distance, \n      shade; \n \n    PrimaryInfo \n      normal; \n \n    register const PixelPacket \n      *restrict p, \n      *restrict s0, \n      *restrict s1, \n      *restrict s2; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,-1,y-1,linear_image->columns+2,3, \n      exception); \n    q=QueueCacheViewAuthenticPixels(shade_view,0,y,shade_image->columns,1, \n      exception); \n    if ((p == (PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n     \n \n    normal.z=2.0*(double) QuantumRange;   \n \n    s0=p+1; \n    s1=s0+image->columns+2; \n    s2=s1+image->columns+2; \n    for (x=0; x < (ssize_t) linear_image->columns; x++) \n    { \n       \n \n      normal.x=(double) (GetPixelIntensity(linear_image,s0-1)+ \n        GetPixelIntensity(linear_image,s1-1)+ \n        GetPixelIntensity(linear_image,s2-1)- \n        GetPixelIntensity(linear_image,s0+1)- \n        GetPixelIntensity(linear_image,s1+1)- \n        GetPixelIntensity(linear_image,s2+1)); \n      normal.y=(double) (GetPixelIntensity(linear_image,s2-1)+ \n        GetPixelIntensity(linear_image,s2)+ \n        GetPixelIntensity(linear_image,s2+1)- \n        GetPixelIntensity(linear_image,s0-1)- \n        GetPixelIntensity(linear_image,s0)- \n        GetPixelIntensity(linear_image,s0+1)); \n      if ((normal.x == 0.0) && (normal.y == 0.0)) \n        shade=light.z; \n      else \n        { \n          shade=0.0; \n          distance=normal.x*light.x+normal.y*light.y+normal.z*light.z; \n          if (distance > MagickEpsilon) \n            { \n              normal_distance=normal.x*normal.x+normal.y*normal.y+normal.z* \n                normal.z; \n              if (normal_distance > (MagickEpsilon*MagickEpsilon)) \n                shade=distance/sqrt((double) normal_distance); \n            } \n        } \n      if (gray!= MagickFalse) \n        { \n          SetPixelRed(q,shade); \n          SetPixelGreen(q,shade); \n          SetPixelBlue(q,shade); \n        } \n      else \n        { \n          SetPixelRed(q,ClampToQuantum(QuantumScale*shade*GetPixelRed(s1))); \n          SetPixelGreen(q,ClampToQuantum(QuantumScale*shade*GetPixelGreen(s1))); \n          SetPixelBlue(q,ClampToQuantum(QuantumScale*shade*GetPixelBlue(s1))); \n        } \n      q->opacity=s1->opacity; \n      s0++; \n      s1++; \n      s2++; \n      q++; \n    } \n    if (SyncCacheViewAuthenticPixels(shade_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        proceed=SetImageProgress(image,ShadeImageTag,progress++,image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  } \n  shade_view=DestroyCacheView(shade_view); \n  image_", "pred": " \nMagickExport Image *ShadeImage(const Image *image,const MagickBooleanType gray, \n  const double azimuth,const double elevation,ExceptionInfo *exception) \n{ \n#define ShadeImageTag  \"Shade/Image\" \n \n  CacheView \n    *image_view, \n    *shade_view; \n \n  Image \n    *linear_image, \n    *shade_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PrimaryInfo \n    light; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  linear_image=CloneImage(image,0,0,MagickTrue,exception); \n  shade_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if ((linear_image == (Image *) NULL) || (shade_image == (Image *) NULL))\n    { \n      if (linear_image!= (Image *) NULL)\n        linear_image=DestroyImage(linear_image); \n      if (shade_image!= (Image *) NULL)\n        shade_image=DestroyImage(shade_image); \n      return((Image *) NULL); \n    } \n \n  /*\n    Shade image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception); \n  shade_view=AcquireAuthenticCacheView(shade_image,exception); \n  for (y=0; y < (ssize_t) image->rows; y++)\n  { \n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        intensity;\n\n      intensity=GetPixelIntensity(image,p);\n      if (intensity < 0.0)\n        intensity=0.0;\n      if (intensity > 1.0)\n        intensity=1.0;\n      SetPixelRed(shade_image,ClampToQuantum(intensity*azimuth),q);\n      SetPixelGreen(shade_image,ClampToQuantum(intensity*elevation),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(shade_image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor!= (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ShadeImage)\n#endif\n        proceed=SetImageProgress(image,ShadeImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  shade_image->progress_monitor=SetImageProgressMonitor(shade_image,\n    (void *) NULL,image->rows,image->rows);\n  image_view=DestroyCacheView(image_view);\n  shade_view=DestroyCacheView(shade_view);\n  linear_image->type=image->type;\n  linear_image->columns=image->columns;\n  linear_image->rows=image->rows;\n  linear_image->depth=image->depth;\n  linear_image->storage_class=image->storage_class;\n  linear_image->colors=image->colors;\n  linear_image->alpha_trait=image->alpha_trait;\n  linear_image->matte=image->matte;\n  linear_image->colorspace=image->colorspace;\n  linear_image->gamma=image->gamma;\n  linear_image->page=image->page;\n  linear_image->background_color=image->background_color;\n  linear_image->exception=exception;\n  linear_image->signature=MagickCoreSignature;\n  return(linear_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S h a n d I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ShadeImage() applies a shade image to the image.\n%\n%  The format of the ShadeImage method is:\n%\n%      MagickBooleanType ShadeImage(Image *image,const double azimuth,\n%        const double elevation,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o azimuth: the azimuth.\n%\n%    o elevation: the elevation.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType ShadeImage(Image *image,const double azimuth,\n  const double elevation,ExceptionInfo *exception)\n{\n#define ShadeImageTag  \"Shade/Image\"\n\n  CacheView\n "}
{"label": " \nMagickExport Image *AdaptiveBlurImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  ExceptionInfo *exception) \n{ \n#define AdaptiveBlurImageTag  \"Convolve/Image\" \n#define MagickSigma  (fabs(sigma) < MagickEpsilon? MagickEpsilon : sigma) \n \n  CacheView \n    *blur_view, \n    *edge_view, \n    *image_view; \n \n  double \n    **kernel, \n    normalize; \n \n  Image \n    *blur_image, \n    *edge_image, \n    *gaussian_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    j, \n    k, \n    u, \n    v, \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  blur_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if (blur_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (fabs(sigma) <= MagickEpsilon) \n    return(blur_image); \n  if (SetImageStorageClass(blur_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&blur_image->exception); \n      blur_image=DestroyImage(blur_image); \n      return((Image *) NULL); \n    } \n   \n \n  edge_image=EdgeImage(image,radius,exception); \n  if (edge_image == (Image *) NULL) \n    { \n      blur_image=DestroyImage(blur_image); \n      return((Image *) NULL); \n    } \n  (void) LevelImage(edge_image,\"20%,95%\"); \n  gaussian_image=BlurImage(edge_image,radius,sigma,exception); \n  if (gaussian_image!= (Image *) NULL) \n    { \n      edge_image=DestroyImage(edge_image); \n      edge_image=gaussian_image; \n    } \n  (void) LevelImage(edge_image,\"10%,95%\"); \n   \n \n  width=GetOptimalKernelWidth2D(radius,sigma); \n  kernel=(double **) MagickAssumeAligned(AcquireAlignedMemory((size_t) width, \n    sizeof(*kernel))); \n  if (kernel == (double **) NULL) \n    { \n      edge_image=DestroyImage(edge_image); \n      blur_image=DestroyImage(blur_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  (void) ResetMagickMemory(kernel,0,(size_t) width*sizeof(*kernel)); \n  for (i=0; i < (ssize_t) width; i+=2) \n  { \n    kernel[i]=(double *) MagickAssumeAligned(AcquireAlignedMemory((size_t) \n      (width-i),(width-i)*sizeof(**kernel))); \n    if (kernel[i] == (double *) NULL) \n      break; \n    normalize=0.0; \n    j=(ssize_t) (width-i)/2; \n    k=0; \n    for (v=(-j); v <= j; v++) \n    { \n      for (u=(-j); u <= j; u++) \n      { \n        kernel[i][k]=(double) (exp(-((double) u*u+v*v)/(2.0*MagickSigma* \n          MagickSigma))/(2.0*MagickPI*MagickSigma*MagickSigma)); \n        normalize+=kernel[i][k]; \n        k++; \n      } \n    } \n    kernel[i][(k-1)/2]+=(1.0-normalize); \n    if (sigma < MagickEpsilon) \n      kernel[i][(k-1)/2]=1.0; \n  } \n  if (i < (ssize_t) width) \n    { \n      for (i-=2; i >= 0; i-=2) \n        kernel[i]=(double *) RelinquishAlignedMemory(kernel[i]); \n      kernel=(double **) RelinquishAlignedMemory(kernel); \n      edge_image=DestroyImage(edge_image); \n      blur_image=DestroyImage(blur_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(image,&bias); \n  SetMagickPixelPacketBias(image,&bias); \n  image_view=AcquireVirtualCacheView(image,exception); \n  edge_view=AcquireVirtualCacheView(edge_image,exception); \n  blur_view=AcquireAuthenticCacheView(blur_image,exception); \n  for (y=0; y < (ssize_t) blur_image->rows; y++) \n  { \n    register const IndexPacket \n      *restrict indexes; \n \n    register const PixelPacket \n      *restrict p, \n      *restrict r; \n \n    register IndexPacket \n      *restrict blur_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    r=GetCacheViewVirtualPixels(edge_view,0,y,edge_image->columns,1,exception); \n    q=QueueCacheViewAuthenticPixels(blur_view,0,y,blur_image->columns,1, \n      exception); \n    if ((r == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    blur_indexes=GetCacheViewAuthenticIndexQueue(blur_view); \n    for (x=0; x < (ssize_t) blur_image->columns; x++) \n    { \n      double \n        alpha, \n        gamma; \n \n      DoublePixelPacket \n        pixel; \n \n      register const double \n        *restrict k; \n \n      register ssize_t \n        i, \n        u, \n        v; \n \n      gamma=0.0; \n      i=(ssize_t) ceil((double) width*QuantumScale* \n        GetPixelIntensity(edge_image,r)-0.5); \n      if (i < 0) \n        i=0; \n      else \n        if (i > (ssize_t) width) \n          i=(ssize_t) width; \n      if ((i & 0x01)!= 0) \n        i--; \n      p=GetCacheViewVirtualPixels(image_view,x-((ssize_t) (width-i)/2L),y- \n        (ssize_t) ((width-i)/2L),width-i,width-i,exception); \n      if (p == (const PixelPacket *) NULL) \n        break;", "pred": " \nMagickExport Image *AdaptiveBlurImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  ExceptionInfo *exception) \n{ \n#define AdaptiveBlurImageTag  \"Convolve/Image\" \n#define MagickSigma  (fabs(sigma) < MagickEpsilon? MagickEpsilon : sigma) \n \n  CacheView \n    *blur_view, \n    *edge_view, \n    *image_view; \n \n  double \n    **kernel, \n    normalize; \n \n  Image \n    *blur_image, \n    *edge_image, \n    *gaussian_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    j, \n    k, \n    u, \n    v, \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickCoreSignature); \n  width=GetOptimalKernelWidth2D(radius,sigma); \n  gaussian_image=GaussianBlurImage(image,width,width,MagickSigma,exception); \n  if (gaussian_image == (Image *) NULL)\n    return((Image *) NULL);\n  blur_image=BlurImage(gaussian_image,width,width,MagickSigma,exception); \n  if (blur_image == (Image *) NULL)\n    {\n      gaussian_image=DestroyImage(gaussian_image);\n      return((Image *) NULL);\n    }\n  edge_image=EdgeImage(blur_image,width,width,MagickSigma,exception); \n  if (edge_image == (Image *) NULL)\n    {\n      gaussian_image=DestroyImage(gaussian_image);\n      blur_image=DestroyImage(blur_image);\n      return((Image *) NULL);\n    }\n  kernel=AcquireQuantumMemory(width,sizeof(*kernel)); \n  if (kernel == (double **) NULL)\n    {\n      gaussian_image=DestroyImage(gaussian_image);\n      blur_image=DestroyImage(blur_image);\n      edge_image=DestroyImage(edge_image);\n      return((Image *) NULL);\n    }\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) NULL; \n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) AcquireQuantumMemory(width,sizeof(**kernel)); \n  if (kernel[0] == (double *) NULL)\n    {\n      gaussian_image=DestroyImage(gaussian_image);\n      blur_image=DestroyImage(blur_image);\n      edge_image=DestroyImage(edge_image);\n      kernel=(double **) RelinquishMagickMemory(kernel); \n      return((Image *) NULL);\n    }\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) NULL; \n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) AcquireQuantumMemory(width,sizeof(**kernel)); \n  if (kernel[0] == (double *) NULL)\n    {\n      gaussian_image=DestroyImage(gaussian_image);\n      blur_image=DestroyImage(blur_image);\n      edge_image=DestroyImage(edge_image);\n      kernel=(double **) RelinquishMagickMemory(kernel); \n      return((Image *) NULL);\n    }\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) NULL; \n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) AcquireQuantumMemory(width,sizeof(**kernel)); \n  if (kernel[0] == (double *) NULL)\n    {\n      gaussian_image=DestroyImage(gaussian_image);\n      blur_image=DestroyImage(blur_image);\n      edge_image=DestroyImage(edge_image);\n      kernel=(double **) RelinquishMagickMemory(kernel); \n      return((Image *) NULL);\n    }\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) NULL; \n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) AcquireQuantumMemory(width,sizeof(**kernel)); \n  if (kernel[0] == (double *) NULL)\n    {\n      gaussian_image=DestroyImage(gaussian_image);\n      blur_image=DestroyImage(blur_image);\n      edge_image=DestroyImage(edge_image);\n      kernel=(double **) RelinquishMagickMemory(kernel); \n      return((Image *) NULL);\n    }\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) NULL; \n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) AcquireQuantumMemory(width,sizeof(**kernel)); \n  if (kernel[0] == (double *) NULL)\n    {\n      gaussian_image=DestroyImage(gaussian_image);\n      blur_image=DestroyImage(blur_image);\n      edge_image=DestroyImage(edge_image);\n      kernel=(double **) RelinquishMagickMemory(kernel); \n      return((Image *) NULL);\n    }\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) NULL; \n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) AcquireQuantumMemory(width,sizeof(**kernel)); \n  if (kernel[0] == (double *) NULL)\n    {\n      gaussian_image=DestroyImage(gaussian_image);\n      blur_image=DestroyImage(blur_image);\n      edge_image=DestroyImage(edge_image);\n      kernel=(double **) RelinquishMagickMemory(kernel); \n      return((Image *) NULL);\n    }\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) NULL; \n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) AcquireQuantumMemory(width,sizeof(**kernel)); \n  if (kernel[0] == (double *) NULL)\n    {\n      gaussian_image=DestroyImage(gaussian_image);\n      blur_image=DestroyImage(blur_image);\n      edge_image=DestroyImage(edge_image);\n      kernel=(double **) RelinquishMagickMemory(kernel); \n      return((Image *) NULL);\n    }\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) NULL; \n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=(double *) AcquireQuantumMemory(width,sizeof(**kernel)); \n  if (kernel[0] == (double *) NULL)\n    {\n      gaussian_image=DestroyImage(gaussian_image);\n      blur_image=DestroyImage(blur_image);\n     "}
{"label": " \nstatic PyObject *__pyx_pf_3GPy_4util_17choleskies_cython_6backprop_gradient_par(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_dL, __Pyx_memviewslice __pyx_v_L) { \n  __Pyx_memviewslice __pyx_v_dL_dK = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_v_N; \n  int __pyx_v_k; \n  int __pyx_v_j; \n  int __pyx_v_i; \n  PyObject *__pyx_r = NULL; \n  __Pyx_RefNannyDeclarations \n  PyObject *__pyx_t_1 = NULL; \n  PyObject *__pyx_t_2 = NULL; \n  PyObject *__pyx_t_3 = NULL; \n  PyObject *__pyx_t_4 = NULL; \n  __Pyx_memviewslice __pyx_t_5 = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_t_6; \n  long __pyx_t_7; \n  int __pyx_t_8; \n  long __pyx_t_9; \n  long __pyx_t_10; \n  long __pyx_t_11; \n  long __pyx_t_12; \n  int __pyx_t_13; \n  Py_ssize_t __pyx_t_14; \n  Py_ssize_t __pyx_t_15; \n  Py_ssize_t __pyx_t_16; \n  Py_ssize_t __pyx_t_17; \n  Py_ssize_t __pyx_t_18; \n  Py_ssize_t __pyx_t_19; \n  int __pyx_t_20; \n  int __pyx_t_21; \n  int __pyx_lineno = 0; \n  const char *__pyx_filename = NULL; \n  int __pyx_clineno = 0; \n  __Pyx_RefNannySetupContext(\"backprop_gradient_par\", 0); \n \n   \n \n  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_2); \n  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_tril); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_3); \n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; \n  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_dL, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_2); \n  __pyx_t_4 = NULL; \n  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) { \n    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3); \n    if (likely(__pyx_t_4)) { \n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3); \n      __Pyx_INCREF(__pyx_t_4); \n      __Pyx_INCREF(function); \n      __Pyx_DECREF_SET(__pyx_t_3, function); \n    } \n  } \n  __pyx_t_1 = (__pyx_t_4)? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2); \n  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0; \n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; \n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_GOTREF(__pyx_t_1); \n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; \n  __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_t_1, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 68, __pyx_L1_error) \n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; \n  __pyx_v_dL_dK = __pyx_t_5; \n  __pyx_t_5.memview = NULL; \n  __pyx_t_5.data = NULL; \n \n   \n \n  __pyx_v_N = (__pyx_v_L.shape[0]); \n \n   \n \n  { \n      #ifdef WITH_THREAD \n      PyThreadState *_save; \n      Py_UNBLOCK_THREADS \n      __Pyx_FastGIL_Remember(); \n      #endif \n       \n { \n \n         \n \n        for (__pyx_t_6 = (__pyx_v_N - 1); __pyx_t_6 > -1; __pyx_t_6-=1) { \n          __pyx_v_k = __pyx_t_6; \n \n           \n \n          { \n              #if ((defined(__APPLE__) || defined(__OSX__)) && (defined(__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))))) \n                  #undef likely \n                  #undef unlikely \n                  #define likely(x)   (x) \n                  #define unlikely(x) (x) \n              #endif \n              #ifdef _OPENMP \n              #endif  \n \n              { \n \n                   \n \n                  __pyx_t_7 = (__pyx_v_k + 1); \n                  __pyx_t_8 = __pyx_v_N; \n                  if ((1 == 0)) abort(); \n                  { \n                      __pyx_t_10 = (__pyx_t_8 - __pyx_t_7 + 1 - 1/abs(1)) / 1; \n                      if (__pyx_t_10 > 0) \n                      { \n                          #ifdef _OPENMP \n                          #endif  \n \n                          for (__pyx_t_9 = 0; __pyx_t_9 < __pyx_t_10; __pyx_t_9++){ \n                              { \n   ", "pred": " \nstatic PyObject *__pyx_pf_3GPy_4util_17choleskies_cython_6backprop_gradient_par(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_dL, __Pyx_memviewslice __pyx_v_L) { \n  __Pyx_memviewslice __pyx_v_dL_dK = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_v_N; \n  int __pyx_v_k; \n  int __pyx_v_j; \n  int __pyx_v_i; \n  PyObject *__pyx_r = NULL; \n  __Pyx_RefNannyDeclarations \n  PyObject *__pyx_t_1 = NULL; \n  PyObject *__pyx_t_2 = NULL; \n  PyObject *__pyx_t_3 = NULL; \n  PyObject *__pyx_t_4 = NULL; \n  __Pyx_memviewslice __pyx_t_5 = { 0, 0, { 0 }, { 0 }, { 0 } }; \n  int __pyx_t_6; \n  long __pyx_t_7; \n  int __pyx_t_8; \n  long __pyx_t_9; \n  long __pyx_t_10; \n  long __pyx_t_11; \n  long __pyx_t_12; \n  long __pyx_t_13; \n  long __pyx_t_14; \n  long __pyx_t_15; \n  long __pyx_t_16; \n  long __pyx_t_17; \n  long __pyx_t_18; \n  long __pyx_t_19; \n  long __pyx_t_20; \n  long __pyx_t_21; \n  long __pyx_t_22; \n  long __pyx_t_23; \n  long __pyx_t_24; \n  long __pyx_t_25; \n  long __pyx_t_26; \n  long __pyx_t_27; \n  long __pyx_t_28; \n  long __pyx_t_29; \n  long __pyx_t_30; \n  long __pyx_t_31; \n  long __pyx_t_32; \n  long __pyx_t_33; \n  long __pyx_t_34; \n  long __pyx_t_35; \n  long __pyx_t_36; \n  long __pyx_t_37; \n  long __pyx_t_38; \n  long __pyx_t_39; \n  long __pyx_t_40; \n  long __pyx_t_41; \n  long __pyx_t_42; \n  long __pyx_t_43; \n  long __pyx_t_44; \n  long __pyx_t_45; \n  long __pyx_t_46; \n  long __pyx_t_47; \n  long __pyx_t_48; \n  long __pyx_t_49; \n  long __pyx_t_50; \n  long __pyx_t_51; \n  long __pyx_t_52; \n  long __pyx_t_53; \n  long __pyx_t_54; \n  long __pyx_t_55; \n  long __pyx_t_56; \n  long __pyx_t_57; \n  long __pyx_t_58; \n  long __pyx_t_59; \n  long __pyx_t_60; \n  long __pyx_t_61; \n  long __pyx_t_62; \n  long __pyx_t_63; \n  long __pyx_t_64; \n  long __pyx_t_65; \n  long __pyx_t_66; \n  long __pyx_t_67; \n  long __pyx_t_68; \n  long __pyx_t_69; \n  long __pyx_t_70; \n  long __pyx_t_71; \n  long __pyx_t_72; \n  long __pyx_t_73; \n  long __pyx_t_74; \n  long __pyx_t_75; \n  long __pyx_t_76; \n  long __pyx_t_77; \n  long __pyx_t_78; \n  long __pyx_t_79; \n  long __pyx_t_80; \n  long __pyx_t_81; \n  long __pyx_t_82; \n  long __pyx_t_83; \n  long __pyx_t_84; \n  long __pyx_t_85; \n  long __pyx_t_86; \n  long __pyx_t_87; \n  long __pyx_t_88; \n  long __pyx_t_89; \n  long __pyx_t_90; \n  long __pyx_t_91; \n  long __pyx_t_92; \n  long __pyx_t_93; \n  long __pyx_t_94; \n  long __pyx_t_95; \n  long __pyx_t_96; \n  long __pyx_t_97; \n  long __pyx_t_98; \n  long __pyx_t_99; \n  long __pyx_t_100; \n  long __pyx_t_101; \n  long __pyx_t_102; \n  long __pyx_t_103; \n  long __pyx_t_104; \n  long __pyx_t_105; \n  long __pyx_t_106; \n  long __pyx_t_107; \n  long __pyx_t_108; \n  long __pyx_t_109; \n  long __pyx_t_110; \n  long __pyx_t_111; \n  long __pyx_t_112; \n  long __pyx_t_113; \n  long __pyx_t_114; \n  long __pyx_t_115; \n  long __pyx_t_116; \n  long __pyx_t_117; \n  long __pyx_t_118; \n  long __pyx_t_119; \n  long __pyx_t_120; \n  long __pyx_t_121; \n  long __pyx_t_122; \n  long __pyx_t_123; \n  long __pyx_t_124; \n  long __pyx_t_125; \n  long __pyx_t_126; \n  long __pyx_t_127; \n  long __pyx_t_128; \n  long __pyx_t_129; \n  long __pyx_t_130; \n  long __pyx_t_131; \n  long __pyx_t_132; \n  long __pyx_t_133; \n  long __pyx_t_134; \n  long __pyx_t_135; \n  long __pyx_t_136; \n  long __pyx_t_137; \n  long __pyx_t_138; \n  long __pyx_t_139; \n  long __pyx_t_140; \n  long __pyx_t_141; \n  long __pyx_t_142; \n  long __pyx_t_143; \n  long __pyx_t_144; \n  long __pyx_t_145; \n  long __pyx_t_146; \n  long __pyx_t_147; \n  long __pyx_t_148; \n  long __pyx_t_149; \n  long __pyx_t_150; \n  long __pyx_t_151; \n  long __pyx_t_152; \n  long __pyx_t_153; \n  long __pyx_t_154; \n  long __pyx_t_155; \n  long __pyx_t_156; \n  long __pyx_t_157; \n  long __pyx_t_158; \n  long __pyx_t_159; \n  long __pyx_t_160; \n  long __pyx_t_161; \n  long __pyx_t_162; \n  long __pyx_t_163; \n  long __pyx_t_164; \n  long __pyx_t_165; \n  long __pyx_t_166; \n  long __pyx_t_167; \n  long __pyx_t_168; \n  long __pyx_t_169; \n  long __pyx_t_170; \n  long __pyx_t_171; \n  long __pyx_t_172; \n  long __pyx_t_173; \n  long __pyx_t_174; \n  long __pyx_t_175; \n  long __pyx_t_176; \n  long __pyx_t_177; \n  long __pyx_t_178; \n  long __pyx_t_179; \n  long __pyx_t_180; \n  long __pyx_t_181; \n  long __pyx_t_182; \n  long __pyx_t_183; \n  long __pyx_t_184; \n  long __pyx_t_185; \n  long __pyx_"}
{"label": " \nstatic MagickBooleanType DrawPolygonPrimitive(Image *image, \n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info, \n  ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    fill, \n    status; \n \n  double \n    mid; \n \n  PolygonInfo \n    **restrict polygon_info; \n \n  register EdgeInfo \n    *p; \n \n  register ssize_t \n    i; \n \n  SegmentInfo \n    bounds; \n \n  ssize_t \n    start, \n    stop, \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(draw_info!= (DrawInfo *) NULL); \n  assert(draw_info->signature == MagickSignature); \n  assert(primitive_info!= (PrimitiveInfo *) NULL); \n  if (primitive_info->coordinates == 0) \n    return(MagickTrue); \n  polygon_info=AcquirePolygonThreadSet(draw_info,primitive_info); \n  if (polygon_info == (PolygonInfo **) NULL) \n    return(MagickFalse); \n  if (0) \n    DrawBoundingRectangles(image,draw_info,polygon_info[0],exception); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    begin draw-polygon\"); \n  fill=(primitive_info->method == FillToBorderMethod) || \n    (primitive_info->method == FloodfillMethod)? MagickTrue : MagickFalse; \n  mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0; \n  bounds=polygon_info[0]->edges[0].bounds; \n  for (i=1; i < (ssize_t) polygon_info[0]->number_edges; i++) \n  { \n    p=polygon_info[0]->edges+i; \n    if (p->bounds.x1 < bounds.x1) \n      bounds.x1=p->bounds.x1; \n    if (p->bounds.y1 < bounds.y1) \n      bounds.y1=p->bounds.y1; \n    if (p->bounds.x2 > bounds.x2) \n      bounds.x2=p->bounds.x2; \n    if (p->bounds.y2 > bounds.y2) \n      bounds.y2=p->bounds.y2; \n  } \n  bounds.x1-=(mid+1.0); \n  bounds.x1=bounds.x1 < 0.0? 0.0 : (size_t) ceil(bounds.x1-0.5) >= \n    image->columns? (double) image->columns-1 : bounds.x1; \n  bounds.y1-=(mid+1.0); \n  bounds.y1=bounds.y1 < 0.0? 0.0 : (size_t) ceil(bounds.y1-0.5) >= \n    image->rows? (double) image->rows-1 : bounds.y1; \n  bounds.x2+=(mid+1.0); \n  bounds.x2=bounds.x2 < 0.0? 0.0 : (size_t) floor(bounds.x2+0.5) >= \n    image->columns? (double) image->columns-1 : bounds.x2; \n  bounds.y2+=(mid+1.0); \n  bounds.y2=bounds.y2 < 0.0? 0.0 : (size_t) floor(bounds.y2+0.5) >= \n    image->rows? (double) image->rows-1 : bounds.y2; \n  status=MagickTrue; \n  image_view=AcquireAuthenticCacheView(image,exception); \n  if (primitive_info->coordinates == 1) \n    { \n       \n \n      start=(ssize_t) ceil(bounds.y1-0.5); \n      stop=(ssize_t) floor(bounds.y2+0.5); \n      for (y=start; y <= stop; y++) \n      { \n        MagickBooleanType \n          sync; \n \n        PixelInfo \n          pixel; \n \n        register ssize_t \n          x; \n \n        register Quantum \n          *restrict q; \n \n        ssize_t \n          start, \n          stop; \n \n        if (status == MagickFalse) \n          continue; \n        start=(ssize_t) ceil(bounds.x1-0.5); \n        stop=(ssize_t) floor(bounds.x2+0.5); \n        x=start; \n        q=GetCacheViewAuthenticPixels(image_view,x,y,(size_t) (stop-x+1),1, \n          exception); \n        if (q == (Quantum *) NULL) \n          { \n            status=MagickFalse; \n            continue; \n          } \n        GetPixelInfo(image,&pixel); \n        for ( ; x <= stop; x++) \n        { \n          if ((x == (ssize_t) ceil(primitive_info->point.x-0.5)) && \n              (y == (ssize_t) ceil(primitive_info->point.y-0.5))) \n            { \n              (void) GetStrokeColor(draw_info,x,y,&pixel,exception); \n              SetPixelInfoPixel(image,&pixel,q); \n            } \n          q+=GetPixelChannels(image); \n        } \n        sync=SyncCacheViewAuthenticPixels(image_view,exception); \n        if (sync == MagickFalse) \n          status=MagickFalse; \n      } \n      image_view=DestroyCacheView(image_view); \n      polygon_info=DestroyPolygonThreadSet(polygon_info); \n      if (image->debug!= MagickFalse) \n        (void) LogMagickEvent(DrawEvent,GetMagickModule(), \n          \"    end draw-polygon\"); \n      return(status); \n    } \n   \n \n  if (image->alpha_trait!= BlendPixelTrait) \n    (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception); \n  start=(ssize_t) ceil(bounds.y1-0.5); \n  stop=(ssize_t) floor(bounds.y2+0.5); \n  for (y=start; y <= stop; y++) \n  { \n    const int \n      id = GetOpenMPThreadId(); \n \n    double \n      fill_alpha, \n      stroke_alpha; \n \n    PixelInfo \n      fill_color, \n      stroke_color; \n \n    register Quantum \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    ssize_t \n      start, \n      stop; \n \n    if (status == MagickFalse) \n   ", "pred": " \nstatic MagickBooleanType DrawPolygonPrimitive(Image *image, \n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info, \n  ExceptionInfo *exception) \n{ \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    fill, \n    status; \n \n  double \n    mid; \n \n  PolygonInfo \n    **restrict polygon_info; \n \n  register EdgeInfo \n    *p; \n \n  register ssize_t \n    i; \n \n  SegmentInfo \n    bounds; \n \n  ssize_t \n    start, \n    stop, \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(draw_info!= (DrawInfo *) NULL); \n  assert(draw_info->signature == MagickSignature); \n  assert(primitive_info!= (PrimitiveInfo *) NULL); \n  if (primitive_info->coordinates == 0) \n    return(MagickTrue); \n  polygon_info=AcquirePolygonThreadSet(draw_info,primitive_info); \n  if (polygon_info == (PolygonInfo **) NULL) \n    return(MagickFalse); \n  status=MagickTrue; \n  start=0; \n  stop=0; \n  y=0; \n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++) \n  { \n    p=primitive_info->coordinates+i; \n    if (p->y < y) \n      { \n        start=i; \n        y=p->y; \n      } \n    if (p->y > y) \n      stop=i; \n  } \n  if (start < 0)\n    start=0; \n  if (stop < start)\n    stop=start; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < start)\n    stop=start; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive_info->coordinates; \n  if (stop < (ssize_t) primitive_info->coordinates)\n    stop=primitive"}
{"label": " \nstatic int _gradient_get_mask_roi(const dt_iop_module_t *const module, const dt_dev_pixelpipe_iop_t *const piece, \n                                  dt_masks_form_t *const form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start2 = 0.0; \n  if(darktable.unmuted & DT_DEBUG_PERF) start2 = dt_get_wtime(); \n   \n \n  const dt_masks_point_gradient_t *gradient = (dt_masks_point_gradient_t *)(form->points->data); \n \n   \n \n  const int w = roi->width; \n  const int h = roi->height; \n  const int px = roi->x; \n  const int py = roi->y; \n  const float iscale = 1.0f / roi->scale; \n  const int grid = CLAMP((10.0f*roi->scale + 2.0f) / 3.0f, 1, 4); \n  const int gw = (w + grid - 1) / grid + 1; \n  const int gh = (h + grid - 1) / grid + 1; \n \n  float *points = dt_alloc_align_float((size_t)2 * gw * gh); \n  if(points == NULL) return 0; \n \n  for(int j = 0; j < gh; j++) \n    for(int i = 0; i < gw; i++) \n    { \n \n      const size_t index = (size_t)j * gw + i; \n      points[index * 2] = (grid * i + px) * iscale; \n      points[index * 2 + 1] = (grid * j + py) * iscale; \n    } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n  { \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] gradient draw took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n    start2 = dt_get_wtime(); \n  } \n \n   \n \n  if(!dt_dev_distort_backtransform_plus(module->dev, piece->pipe, module->iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, points, \n                                        (size_t)gw * gh)) \n  { \n    dt_free_align(points); \n    return 0; \n  } \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n  { \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] gradient transform took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n    start2 = dt_get_wtime(); \n  } \n \n   \n \n  const float wd = piece->pipe->iwidth; \n  const float ht = piece->pipe->iheight; \n  const float hwscale = 1.0f / sqrtf(wd * wd + ht * ht); \n  const float ihwscale = 1.0f / hwscale; \n  const float v = (-gradient->rotation / 180.0f) * M_PI; \n  const float sinv = sinf(v); \n  const float cosv = cosf(v); \n  const float xoffset = cosv * gradient->anchor[0] * wd + sinv * gradient->anchor[1] * ht; \n  const float yoffset = sinv * gradient->anchor[0] * wd - cosv * gradient->anchor[1] * ht; \n  const float compression = fmaxf(gradient->compression, 0.001f); \n  const float normf = 1.0f / compression; \n  const float curvature = gradient->curvature; \n  const dt_masks_gradient_states_t state = gradient->state; \n \n  const int lutmax = ceilf(4 * compression * ihwscale); \n  const int lutsize = 2 * lutmax + 2; \n  float *lut = dt_alloc_align_float((size_t)lutsize); \n  if(lut == NULL) \n  { \n    dt_free_align(points); \n    return 0; \n  } \n \n  for(int n = 0; n < lutsize; n++) \n  { \n    const float distance = (n - lutmax) * hwscale; \n    const float value = 0.5f + 0.5f * ((state == DT_MASKS_GRADIENT_STATE_LINEAR)? normf * distance: erff(distance / compression)); \n    lut[n] = (value < 0.0f)? 0.0f : ((value > 1.0f)? 1.0f : value); \n  } \n \n   \n \n  float *clut = lut + lutmax; \n \n  for(int j = 0; j < gh; j++) \n  { \n    for(int i = 0; i < gw; i++) \n    { \n      const size_t index = (size_t)j * gw + i; \n      const float x = points[index * 2]; \n      const float y = points[index * 2 + 1]; \n \n      const float x0 = (cosv * x + sinv * y - xoffset) * hwscale; \n      const float y0 = (sinv * x - cosv * y - yoffset) * hwscale; \n \n      const float distance = y0 - curvature * x0 * x0; \n \n      points[index * 2] = (distance <= -4.0f * compression)? 0.0f : ((distance >= 4.0f * compression)? 1.0f : dt_gradient_lookup(clut, distance * ihwscale)); \n    } \n  } \n \n  dt_free_align(lut); \n \n \n \n  for(int j = 0; j < h; j++) \n  { \n    const int jj = j % grid; \n    const int mj = j / grid; \n    const int grid_jj = grid - jj; \n    for(int i = 0; i < w; i++) \n    { \n      const int ii = i % grid; \n      const int mi = i / grid; \n      const int grid_ii = grid - ii; \n      const size_t mindex = (size_t)mj * gw + mi; \n      buffer[(size_t)j * w + i] \n          = (points[mindex * 2] * grid_ii * grid_jj \n             + points[(mindex + 1) * 2] * ii * grid_jj \n             + points[(mindex + gw) * 2] * grid_ii * jj \n             + points[(mindex + gw + 1) * 2] * ii * jj) \n            / (grid * grid); \n    } \n  } \n \n  dt_free_align(points); \n \n  if(darktable.unmuted & DT_DEBUG_PERF) \n    dt_print(DT_DEBUG_MASKS, \"[masks %s] gradient fill took %0.04f sec\\n\", form->name, \n             dt_get_wtime() - start2); \n \n  return 1; \n} ", "pred": " \nstatic int _gradient_get_mask_roi(const dt_iop_module_t *const module, const dt_dev_pixelpipe_iop_t *const piece, \n                                  dt_masks_form_t *const form, const dt_iop_roi_t *roi, float *buffer) \n{ \n  double start2 = 0.0; \n  if(darktable.unmuted & DT_DEBUG_PERF) start2 = dt_get_wtime(); \n   \n \n  const dt_masks_point_gradient_t *gradient = (dt_masks_point_gradient_t *)(form->points->data); \n \n   \n \n  const int w = roi->width; \n  const int h = roi->height; \n  const int px = roi->x; \n  const int py = roi->y; \n  const float iscale = 1.0f / roi->scale; \n  const int grid = CLAMP((10.0f*roi->scale + 2.0f) / 3.0f, 1, 4); \n  const int gw = (w + grid - 1) / grid + 1; \n  const int gh = (h + grid - 1) / grid + 1; \n  const int gw2 = gw * gw; \n  const int gh2 = gh * gh; \n  const int gw3 = gw * gh; \n  const int gh3 = gh * gw; \n  const int gw4 = gw * gh; \n  const int gh4 = gh * gh; \n  const int gw5 = gw * gh; \n  const int gh5 = gh * gh; \n  const int gw6 = gw * gh; \n  const int gh6 = gh * gh; \n  const int gw7 = gw * gh; \n  const int gh7 = gh * gh; \n  const int gw8 = gw * gh; \n  const int gh8 = gh * gh; \n  const int gw9 = gw * gh; \n  const int gh9 = gh * gh; \n  const int gw10 = gw * gh; \n  const int gh10 = gh * gh; \n  const int gw11 = gw * gh; \n  const int gh11 = gh * gh; \n  const int gw12 = gw * gh; \n  const int gh12 = gh * gh; \n  const int gw13 = gw * gh; \n  const int gh13 = gh * gh; \n  const int gw14 = gw * gh; \n  const int gh14 = gh * gh; \n  const int gw15 = gw * gh; \n  const int gh15 = gh * gh; \n  const int gw16 = gw * gh; \n  const int gh16 = gh * gh; \n  const int gw17 = gw * gh; \n  const int gh17 = gh * gh; \n  const int gw18 = gw * gh; \n  const int gh18 = gh * gh; \n  const int gw19 = gw * gh; \n  const int gh19 = gh * gh; \n  const int gw20 = gw * gh; \n  const int gh20 = gh * gh; \n  const int gw21 = gw * gh; \n  const int gh21 = gh * gh; \n  const int gw22 = gw * gh; \n  const int gh22 = gh * gh; \n  const int gw23 = gw * gh; \n  const int gh23 = gh * gh; \n  const int gw24 = gw * gh; \n  const int gh24 = gh * gh; \n  const int gw25 = gw * gh; \n  const int gh25 = gh * gh; \n  const int gw26 = gw * gh; \n  const int gh26 = gh * gh; \n  const int gw27 = gw * gh; \n  const int gh27 = gh * gh; \n  const int gw28 = gw * gh; \n  const int gh28 = gh * gh; \n  const int gw29 = gw * gh; \n  const int gh29 = gh * gh; \n  const int gw30 = gw * gh; \n  const int gh30 = gh * gh; \n  const int gw31 = gw * gh; \n  const int gh31 = gh * gh; \n  const int gw32 = gw * gh; \n  const int gh32 = gh * gh; \n  const int gw33 = gw * gh; \n  const int gh33 = gh * gh; \n  const int gw34 = gw * gh; \n  const int gh34 = gh * gh; \n  const int gw35 = gw * gh; \n  const int gh35 = gh * gh; \n  const int gw36 = gw * gh; \n  const int gh36 = gh * gh; \n  const int gw37 = gw * gh; \n  const int gh37 = gh * gh; \n  const int gw38 = gw * gh; \n  const int gh38 = gh * gh; \n  const int gw39 = gw * gh; \n  const int gh39 = gh * gh; \n  const int gw40 = gw * gh; \n  const int gh40 = gh * gh; \n  const int gw41 = gw * gh; \n  const int gh41 = gh * gh; \n  const int gw42 = gw * gh; \n  const int gh42 = gh * gh; \n  const int gw43 = gw * gh; \n  const int gh43 = gh * gh; \n  const int gw44 = gw * gh; \n  const int gh44 = gh * gh; \n  const int gw45 = gw * gh; \n  const int gh45 = gh * gh; \n  const int gw46 = gw * gh; \n  const int gh46 = gh * gh; \n  const int gw47 = gw * gh; \n  const int gh47 = gh * gh; \n  const int gw48 = gw * gh; \n  const int gh48 = gh * gh; \n  const int gw49 = gw * gh; \n  const int gh49 = gh * gh; \n  const int gw50 = gw * gh; \n  const int gh50 = gh * gh; \n  const int gw51 = gw * gh; \n  const int gh51 = gh * gh; \n  const int gw52 = gw * gh; \n  const int gh52 = gh * gh; \n  const int gw53 = gw * gh; \n  const int gh53 = gh * gh; \n  const int gw54 = gw * gh; \n  const int gh54 = gh * gh; \n  const int gw55 = gw * gh; \n  const int gh55 = gh * gh; \n  const int gw56 = gw * gh; \n  const int gh56 = gh * gh; \n  const int gw57 = gw * gh; \n  const int gh57 = gh * gh; \n  const int gw58 = gw * gh; \n  const int gh58 = gh * gh; \n  const int gw59 = gw * gh; \n  const int gh59 = gh * gh; \n  const int gw60 = gw * gh; \n  const int gh60 = gh * gh; \n  const int gw61 = gw * gh; \n  const int gh61 = gh * gh; \n  const int gw62 = gw * gh; \n  const int gh62 = gh * gh; \n  const int gw63 = gw * gh; \n  const int gh63 = gh * gh; \n  const int gw64 = gw * gh; \n  const int gh64 = gh * gh; \n  const int gw65 = gw * gh; \n  const int gh65 = gh * gh; \n  const int gw66 = gw * gh; \n  const int gh66 = gh * gh; \n  const int gw67 = gw * gh; \n  const int gh67 = gh * gh; \n  const int gw68 = gw * gh; \n  const int gh68 = gh * gh; \n  const int gw69 = gw * gh; \n  const int gh69 = gh * gh; \n  const int gw70 = gw * gh; \n  const int gh70 = gh * gh; \n  const int gw71 = gw * gh; \n  const int gh71 = gh * gh; \n  const int gw72 = gw * gh; \n  const int gh72 = gh * gh; \n  const int gw73 = gw * gh; \n  const int gh73 = gh * gh; \n  const int gw74 = gw * gh; \n  const int gh74 = gh * gh; \n  const int"}
{"label": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n  const int ch = piece->colors; \n  const int gamutcheck = (d->mode == DT_PROFILE_GAMUTCHECK); \n  const size_t npixels = (size_t)roi_out->width * roi_out->height; \n  float *const restrict out = (float *)ovoid; \n \n  if(d->type == DT_COLORSPACE_LAB) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, ch); \n  } \n  else if(!isnan(d->cmatrix[0][0])) \n  { \n    const float *const restrict in = (const float *const)ivoid; \n    const __m128 m0 = _mm_set_ps(0.0f, d->cmatrix[2][0], d->cmatrix[1][0], d->cmatrix[0][0]); \n    const __m128 m1 = _mm_set_ps(0.0f, d->cmatrix[2][1], d->cmatrix[1][1], d->cmatrix[0][1]); \n    const __m128 m2 = _mm_set_ps(0.0f, d->cmatrix[2][2], d->cmatrix[1][2], d->cmatrix[0][2]); \n \n \n \n \n    for(int j = 0; j < ch * npixels; j += ch) \n    { \n      const __m128 xyz = dt_Lab_to_XYZ_sse2(_mm_load_ps(in + j)); \n      const __m128 t = ((m0 * _mm_shuffle_ps(xyz, xyz, _MM_SHUFFLE(0, 0, 0, 0))) + \n                        ((m1 * _mm_shuffle_ps(xyz, xyz, _MM_SHUFFLE(1, 1, 1, 1))) + \n                         (m2 * _mm_shuffle_ps(xyz, xyz, _MM_SHUFFLE(2, 2, 2, 2))))); \n      _mm_stream_ps(out + j, t); \n    } \n    _mm_sfence(); \n \n    process_fastpath_apply_tonecurves(self, piece, ivoid, ovoid, roi_in, roi_out); \n  } \n  else \n  { \n     \n \n    const __m128 outofgamutpixel = _mm_set_ps(0.0f, 1.0f, 1.0f, 0.0f); \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)ch * k * roi_out->width; \n      float *outp = out + (size_t)ch * k * roi_out->width; \n \n      cmsDoTransform(d->xform, in, outp, roi_out->width); \n \n      if(gamutcheck) \n      { \n        for(int j = 0; j < roi_out->width; j++) \n        { \n          const __m128 pixel = _mm_load_ps(outp + 4*j); \n          __m128 ingamut = _mm_cmplt_ps(pixel, _mm_set_ps(-FLT_MAX, 0.0f, 0.0f, 0.0f)); \n \n          ingamut = _mm_or_ps(_mm_unpacklo_ps(ingamut, ingamut), _mm_unpackhi_ps(ingamut, ingamut)); \n          ingamut = _mm_or_ps(_mm_unpacklo_ps(ingamut, ingamut), _mm_unpackhi_ps(ingamut, ingamut)); \n \n          const __m128 result \n              = _mm_or_ps(_mm_and_ps(ingamut, outofgamutpixel), _mm_andnot_ps(ingamut, pixel)); \n          _mm_stream_ps(outp + 4*j, result); \n        } \n      } \n    } \n    _mm_sfence(); \n  } \n \n  if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out->width, roi_out->height); \n} ", "pred": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n  const int ch = piece->colors; \n  const int gamutcheck = (d->mode == DT_PROFILE_GAMUTCHECK); \n  const size_t npixels = (size_t)roi_out->width * roi_out->height; \n  float *const restrict out = (float *)ovoid; \n \n  if(d->type == DT_COLORSPACE_LAB) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, ch); \n  } \n  else if(!isnan(d->cmatrix[0][0])) \n  { \n    const float *const restrict in = (const float *const)ivoid; \n    const float *const restrict out = (const float *const)ovoid; \n    const float *const restrict cmatrix = d->cmatrix; \n    const float *const restrict cmatrix_inv = d->cmatrix_inv; \n    const float *const restrict cmatrix_inv_inv = d->cmatrix_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv = d->cmatrix_inv_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv_inv = d->cmatrix_inv_inv_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv_inv_inv = d->cmatrix_inv_inv_inv_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv_inv_inv_inv = d->cmatrix_inv_inv_inv_inv_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv_inv_inv_inv_inv = d->cmatrix_inv_inv_inv_inv_inv_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv_inv_inv_inv_inv_inv = d->cmatrix_inv_inv_inv_inv_inv_inv_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv = d->cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = d->cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = d->cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = d->cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = d->cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = d->cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = d->cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = d->cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = d->cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv; \n    const float *const restrict cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = d->cmatrix_inv_inv_inv_inv_inv_inv_inv_inv_"}
{"label": " \nstatic void process_fastpath_apply_tonecurves(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                              const void *const ivoid, void *const ovoid, \n                                              const dt_iop_roi_t *const roi_in, \n                                              const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n \n  if(!isnan(d->cmatrix[0][0])) \n  { \n    const size_t npixels = (size_t)roi_out->width * roi_out->height; \n    float *const restrict out = (float *const)ovoid; \n     \n \n \n     \n \n    if((d->lut[0][0] >= 0.0f) && (d->lut[1][0] >= 0.0f) && (d->lut[2][0] >= 0.0f)) \n    {  \n \n      for(size_t k = 0; k < 4 * npixels; k += 4) \n      { \n        for(int c = 0; c < 3; c++) \n        { \n          out[k + c] = (out[k + c] < 1.0f)? lerp_lut(d->lut[c], out[k + c]) \n                                           : dt_iop_eval_exp(d->unbounded_coeffs[c], out[k + c]); \n        } \n      } \n    } \n    else if((d->lut[0][0] >= 0.0f) || (d->lut[1][0] >= 0.0f) || (d->lut[2][0] >= 0.0f)) \n    {  \n \n      for(size_t k = 0; k < 4 * npixels; k += 4) \n      { \n        for(int c = 0; c < 3; c++) \n        { \n          if(d->lut[c][0] >= 0.0f) \n          { \n            out[k + c] = (out[k + c] < 1.0f)? lerp_lut(d->lut[c], out[k + c]) \n                                             : dt_iop_eval_exp(d->unbounded_coeffs[c], out[k + c]); \n          } \n        } \n      } \n    } \n  } \n} ", "pred": " \nstatic void process_fastpath_apply_tonecurves(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                              const void *const ivoid, void *const ovoid, \n                                              const dt_iop_roi_t *const roi_in, \n                                              const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n \n  if(!isnan(d->cmatrix[0][0])) \n  { \n    const size_t npixels = (size_t)roi_out->width * roi_out->height; \n    const size_t nchannels = d->cmatrix[0][0].size; \n    const size_t nchannels_out = d->cmatrix[0][0].size; \n    const size_t nchannels_in = d->cmatrix[0][0].size; \n    const size_t nchannels_out_in = d->cmatrix[0][0].size; \n    const size_t nchannels_out_in_out = d->cmatrix[0][0].size; \n    const size_t nchannels_out_in_out_out = d->cmatrix[0][0].size; \n    const size_t nchannels_out_in_out_out_out = d->cmatrix[0][0].size; \n    const size_t nchannels_out_in_out_out_out_out = d->cmatrix[0][0].size; \n    const size_t nchannels_out_in_out_out_out_out_out = d->cmatrix[0][0].size; \n    const size_t nchannels_out_in_out_out_out_out_out_out = d->cmatrix[0][0].size; \n    const size_t nchannels_out_in_out_out_out_out_out_out_out = d->cmatrix[0][0].size; \n    const size_t nchannels_out_in_out_out_out_out_out_out_out_out = d->cmatrix[0][0].size; \n    const size_t nchannels_out_in_out_out_out_out_out_out_out_out_out = d->cmatrix[0][0].size; \n    const size_t nchannels_out_in_out_out_out_out_out_out_out_out_out_out = d->cmatrix[0][0].size; \n    const size_t nchannels_out_in_out_out_out_out_out_out_out_out_out_out_out = d->cmatrix[0][0].size; \n    const size_t nchannels_out_in_out_out_out_out_out_out_out_out_out_out_out_out = d->cmatrix[0][0].size; \n    const size_t nchannels_out_in_out_out_out_out_out_out_out_out_out_out_out_out_out = d->cmatrix"}
{"label": " \nMagickExport Image *FilterImageChannel(const Image *image, \n  const ChannelType channel,const KernelInfo *kernel,ExceptionInfo *exception) \n{ \n#define FilterImageTag  \"Filter/Image\" \n \n  CacheView \n    *filter_view, \n    *image_view; \n \n  Image \n    *filter_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  MagickRealType \n    *filter_kernel; \n \n  register ssize_t \n    i; \n \n  ssize_t \n    y; \n \n  clBeginPerfMarkerAMD(__FUNCTION__,\"\"); \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  if ((kernel->width % 2) == 0) \n    ThrowImageException(OptionError,\"KernelWidthMustBeAnOddNumber\"); \n \n \n \n  if (image->debug!= MagickFalse) \n    { \n      char \n        format[MaxTextExtent], \n        *message; \n \n      register const double \n        *k; \n \n      ssize_t \n        u, \n        v; \n \n      (void) LogMagickEvent(TransformEvent,GetMagickModule(), \n        \"  FilterImage with %.20gx%.20g kernel:\",(double) kernel->width,(double) \n        kernel->height); \n      message=AcquireString(\"\"); \n      k=kernel->values; \n      for (v=0; v < (ssize_t) kernel->height; v++) \n      { \n        *message='\\0'; \n        (void) FormatLocaleString(format,MaxTextExtent,\"%.20g: \",(double) v); \n        (void) ConcatenateString(&message,format); \n        for (u=0; u < (ssize_t) kernel->width; u++) \n        { \n          (void) FormatLocaleString(format,MaxTextExtent,\"%g \",*k++); \n          (void) ConcatenateString(&message,format); \n        } \n        (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"%s\",message); \n      } \n      message=DestroyString(message); \n    } \n \n  filter_image=AccelerateConvolveImageChannel(image,channel,kernel,exception); \n  if (filter_image!= NULL)  \n  { \n    clEndPerfMarkerAMD(); \n    return(filter_image); \n  } \n \n \n  filter_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (filter_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(filter_image,DirectClass) == MagickFalse) \n  { \n    InheritException(exception,&filter_image->exception); \n    filter_image=DestroyImage(filter_image); \n    return((Image *) NULL); \n  } \n \n   \n \n  filter_kernel=(MagickRealType *) MagickAssumeAligned(AcquireAlignedMemory( \n    kernel->width,kernel->width*sizeof(*filter_kernel))); \n  if (filter_kernel == (MagickRealType *) NULL) \n    { \n      filter_image=DestroyImage(filter_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  for (i=0; i < (ssize_t) (kernel->width*kernel->width); i++) \n    filter_kernel[i]=(MagickRealType) kernel->values[i]; \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(image,&bias); \n  SetMagickPixelPacketBias(image,&bias); \n  image_view=AcquireVirtualCacheView(image,exception); \n  filter_view=AcquireAuthenticCacheView(filter_image,exception); \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    MagickBooleanType \n      sync; \n \n    register const IndexPacket \n      *restrict indexes; \n \n    register const PixelPacket \n      *restrict p; \n \n    register IndexPacket \n      *restrict filter_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) (kernel->width-1)/2L),y- \n      (ssize_t) ((kernel->height-1)/2L),image->columns+kernel->width, \n      kernel->height,exception); \n    q=GetCacheViewAuthenticPixels(filter_view,0,y,filter_image->columns,1, \n      exception); \n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewVirtualIndexQueue(image_view); \n    filter_indexes=GetCacheViewAuthenticIndexQueue(filter_view); \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      DoublePixelPacket \n        pixel; \n \n      register const MagickRealType \n        *restrict k; \n \n      register const PixelPacket \n        *restrict kernel_pixels; \n \n      register ssize_t \n        u; \n \n      ssize_t \n        v; \n \n      pixel.red=bias.red; \n      pixel.green=bias.green; \n      pixel.blue=bias.blue; \n      pixel.opacity=bias.opacity; \n      pixel.index=bias.index; \n      k=filter_kernel; \n      kernel_pixels=p; \n      if (((channel & OpacityChannel) == 0) || (image->matte == MagickFalse)) \n        { \n          for (v=0; v < (ssize_t) kernel->width; v++) \n          { \n            for (u=0; u < (ssize_t) kernel->height; u++) \n            { \n              pixel.red+=(*k)*kernel_pixels[u].red; \n              pixel.green+=(*k)*kernel_pixels[u].green; \n              pixel.blue+=(*k)*kernel_pixels[u].blue; \n              k++; \n            } \n            kernel_pixels+=image->columns+kernel->width; \n          } \n          if ((channel & RedChannel)!= 0) \n            SetPixelRed(q,ClampToQuantum(pixel.red)); \n          if ((channel & GreenChannel)!= 0) \n            SetPixelGreen", "pred": " \nMagickExport Image *FilterImageChannel(const Image *image, \n  const ChannelType channel,const KernelInfo *kernel,ExceptionInfo *exception) \n{ \n#define FilterImageTag  \"Filter/Image\" \n \n  CacheView \n    *filter_view, \n    *image_view; \n \n  Image \n    *filter_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  MagickRealType \n    *filter_kernel; \n \n  register ssize_t \n    i; \n \n  ssize_t \n    y; \n \n  clBeginPerfMarkerAMD(__FUNCTION__,\"\"); \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  if ((kernel->width % 2) == 0) \n    ThrowImageException(OptionError,\"KernelWidthMustBeAnOddNumber\"); \n \n \n \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%s\",image->filename); \n \n  filter_image=CloneImage(image,0,0,MagickTrue,exception); \n \n  if (filter_image == (Image *) NULL) \n    return((Image *) NULL); \n \n  filter_view=AcquireVirtualCacheView(filter_image,exception); \n  image_view=AcquireAuthenticCacheView(image,exception); \n \n  filter_kernel=(MagickRealType *) AcquireQuantumMemory(kernel->width,\n    sizeof(*filter_kernel)); \n \n  if ((filter_kernel == (MagickRealType *) NULL) || \n      (filter_image->storage_class == DirectClass) || \n      (filter_image->colors <= 0) || \n      (filter_image->colors > 256))\n    {\n      filter_kernel=(MagickRealType *) RelinquishMagickMemory(filter_kernel); \n      filter_image=DestroyImage(filter_image); \n      return((Image *) NULL); \n    } \n \n  for (i=0; i < (ssize_t) kernel->width; i++) \n    filter_kernel[i]=kernel->values[i]; \n \n  if (kernel->type == KernelTypeLinear) \n    { \n      for (i=0; i < (ssize_t) kernel->width; i++) \n        { \n          filter_kernel[i]=kernel->values[i]; \n          filter_kernel[i]=kernel->values[i]; \n        } \n    } \n \n  if (kernel->type == KernelTypePolynomial) \n    { \n      for (i=0; i < (ssize_t) kernel->width; i++) \n        { \n          filter_kernel[i]=kernel->values[i]; \n          filter_kernel[i]=kernel->values[i]; \n        } \n    } \n \n  if (kernel->type == KernelTypePolynomial) \n    { \n      for (i=0; i < (ssize_t) kernel->width; i++) \n        { \n          filter_kernel[i]=kernel->values[i]; \n          filter_kernel[i]=kernel->values[i]; \n        } \n    } \n \n  if (kernel->type == KernelTypePolynomial) \n    { \n      for (i=0; i < (ssize_t) kernel->width; i++) \n        { \n          filter_kernel[i]=kernel->values[i]; \n          filter_kernel[i]=kernel->values[i]; \n        } \n    } \n \n  if (kernel->type == KernelTypePolynomial) \n    { \n      for (i=0; i < (ssize_t) kernel->width; i++) \n        { \n          filter_kernel[i]=kernel->values[i]; \n          filter_kernel[i]=kernel->values[i]; \n        } \n    } \n \n  if (kernel->type == KernelTypePolynomial) \n    { \n      for (i=0; i < (ssize_t) kernel->width; i++) \n        { \n          filter_kernel[i]=kernel->values[i]; \n          filter_kernel[i]=kernel->values[i]; \n        } \n    } \n \n  if (kernel->type == KernelTypePolynomial) \n    { \n      for (i=0; i < (ssize_t) kernel->width; i++) \n        { \n          filter_kernel[i]=kernel->values[i]; \n          filter_kernel[i]=kernel->values[i]; \n        } \n    } \n \n  if (kernel->type == KernelTypePolynomial) \n    { \n      for (i=0; i < (ssize_t) kernel->width; i++) \n        { \n          filter_kernel[i]=kernel->values[i]; \n          filter_kernel[i]=kernel->values[i]; \n        } \n    } \n \n  if (kernel->type == KernelTypePolynomial) \n    { \n      for (i=0; i < (ssize_t) kernel->width; i++) \n        { \n          filter_kernel[i]=kernel->values[i]; \n          filter_kernel[i]=kernel->values[i]; \n        } \n    } \n \n  if (kernel->type == KernelTypePolynomial) \n    { \n      for (i=0; i < (ssize_t) kernel->width; i++) \n        { \n          filter_kernel[i]=kernel->values[i]; \n          filter_kernel[i]=kernel->values[i]; \n        } \n    } \n \n  if (kernel->type == KernelTypePolynomial) \n    { \n      for (i=0; i < (ssize_t) kernel->width; i++) \n        { \n          filter_kernel[i]=kernel->values[i]; \n          filter_kernel[i]=kernel->values[i]; \n        } \n    } \n \n  if (kernel->type == KernelTypePolynomial) \n    { \n      for (i=0; i < (ssize_t) kernel->width; i++) \n        { \n          filter_kernel[i]=kernel->values[i]; \n          filter_kernel[i]=kernel->values[i]; \n        } \n    } \n \n  if (kernel->type == KernelTypePolynomial) \n    { \n      for (i=0; i < (ssize_t) kernel->width; i++) \n        { \n          filter_kernel[i]=kernel->values[i]; \n          filter_kernel[i]=kernel->values[i]; \n        } \n    } \n \n  if (kernel->type == KernelTypePolynomial) \n   "}
{"label": " \nMagickExport Image *RadialBlurImageChannel(const Image *image, \n  const ChannelType channel,const double angle,ExceptionInfo *exception) \n{ \n  CacheView \n    *blur_view, \n    *image_view; \n \n  Image \n    *blur_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  MagickRealType \n    blur_radius, \n    *cos_theta, \n    offset, \n    *sin_theta, \n    theta; \n \n  PointInfo \n    blur_center; \n \n  register ssize_t \n    i; \n \n  size_t \n    n; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  blur_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (blur_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(blur_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&blur_image->exception); \n      blur_image=DestroyImage(blur_image); \n      return((Image *) NULL); \n    } \n  blur_center.x=(double) (image->columns-1)/2.0; \n  blur_center.y=(double) (image->rows-1)/2.0; \n  blur_radius=hypot(blur_center.x,blur_center.y); \n  n=(size_t) fabs(4.0*DegreesToRadians(angle)*sqrt((double) blur_radius)+2UL); \n  theta=DegreesToRadians(angle)/(MagickRealType) (n-1); \n  cos_theta=(MagickRealType *) AcquireQuantumMemory((size_t) n, \n    sizeof(*cos_theta)); \n  sin_theta=(MagickRealType *) AcquireQuantumMemory((size_t) n, \n    sizeof(*sin_theta)); \n  if ((cos_theta == (MagickRealType *) NULL) || \n      (sin_theta == (MagickRealType *) NULL)) \n    { \n      blur_image=DestroyImage(blur_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  offset=theta*(MagickRealType) (n-1)/2.0; \n  for (i=0; i < (ssize_t) n; i++) \n  { \n    cos_theta[i]=cos((double) (theta*i-offset)); \n    sin_theta[i]=sin((double) (theta*i-offset)); \n  } \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(image,&bias); \n  image_view=AcquireVirtualCacheView(image,exception); \n  blur_view=AcquireAuthenticCacheView(blur_image,exception); \n  for (y=0; y < (ssize_t) blur_image->rows; y++) \n  { \n    register const IndexPacket \n      *restrict indexes; \n \n    register IndexPacket \n      *restrict blur_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    q=GetCacheViewAuthenticPixels(blur_view,0,y,blur_image->columns,1, \n      exception); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    blur_indexes=GetCacheViewAuthenticIndexQueue(blur_view); \n    for (x=0; x < (ssize_t) blur_image->columns; x++) \n    { \n      MagickPixelPacket \n        qixel; \n \n      MagickRealType \n        normalize, \n        radius; \n \n      PixelPacket \n        pixel; \n \n      PointInfo \n        center; \n \n      register ssize_t \n        i; \n \n      size_t \n        step; \n \n      center.x=(double) x-blur_center.x; \n      center.y=(double) y-blur_center.y; \n      radius=hypot((double) center.x,center.y); \n      if (radius == 0) \n        step=1; \n      else \n        { \n          step=(size_t) (blur_radius/radius); \n          if (step == 0) \n            step=1; \n          else \n            if (step >= n) \n              step=n-1; \n        } \n      normalize=0.0; \n      qixel=bias; \n      if (((channel & OpacityChannel) == 0) || (image->matte == MagickFalse)) \n        { \n          for (i=0; i < (ssize_t) n; i+=(ssize_t) step) \n          { \n            (void) GetOneCacheViewVirtualPixel(image_view,(ssize_t) \n              (blur_center.x+center.x*cos_theta[i]-center.y*sin_theta[i]+0.5), \n              (ssize_t) (blur_center.y+center.x*sin_theta[i]+center.y* \n              cos_theta[i]+0.5),&pixel,exception); \n            qixel.red+=pixel.red; \n            qixel.green+=pixel.green; \n            qixel.blue+=pixel.blue; \n            qixel.opacity+=pixel.opacity; \n            if (image->colorspace == CMYKColorspace) \n              { \n                indexes=GetCacheViewVirtualIndexQueue(image_view); \n                qixel.index+=(*indexes); \n              } \n            normalize+=1.0; \n          } \n          normalize=PerceptibleReciprocal(normalize); \n          if ((channel & RedChannel)!= 0) \n            SetPixelRed(q,ClampToQuantum(normalize*qixel.red)); \n          if ((channel & GreenChannel)!= 0) \n            SetPixelGreen(q,ClampToQuantum(normalize*qixel.green)); \n          if ((channel & BlueChannel)!= 0) \n            SetPixelBlue(q,ClampToQuantum(normalize*qixel.blue)); \n          if ((channel & OpacityChannel)!= 0)", "pred": " \nMagickExport Image *RadialBlurImageChannel(const Image *image, \n  const ChannelType channel,const double angle,ExceptionInfo *exception) \n{ \n  CacheView \n    *blur_view, \n    *image_view; \n \n  Image \n    *blur_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  MagickRealType \n    blur_radius, \n    *cos_theta, \n    offset, \n    *sin_theta, \n    theta; \n \n  PointInfo \n    blur_center; \n \n  register ssize_t \n    i; \n \n  size_t \n    n; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  blur_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (blur_image == (Image *) NULL)\n    return((Image *) NULL);\n  blur_view=AcquireVirtualCacheView(blur_image,exception); \n  image_view=AcquireAuthenticCacheView(image,exception); \n  blur_center.x=0.0; \n  blur_center.y=0.0; \n  blur_radius=0.0; \n  for (y=0; y < (ssize_t) image->rows; y++)\n  { \n    for (x=0; x < (ssize_t) image->columns; x++)\n    { \n      blur_center.x+=GetPixelRed(image,x,y); \n      blur_center.y+=GetPixelGreen(image,x,y); \n      blur_radius+=GetPixelRed(image,x,y); \n    } \n  } \n  blur_center.x/=image->columns; \n  blur_center.y/=image->rows; \n  blur_radius/=image->rows; \n  blur_radius=sqrt(blur_radius); \n  cos_theta=(double *) AcquireQuantumMemory((size_t) blur_radius+1UL,\n    sizeof(*cos_theta)); \n  sin_theta=(double *) AcquireQuantumMemory((size_t) blur_radius+1UL,\n    sizeof(*sin_theta)); \n  if ((cos_theta == (double *) NULL) || (sin_theta == (double *) NULL))\n    {\n      blur_view=DestroyCacheView(blur_view);\n      blur_image=DestroyImage(blur_image);\n      return((Image *) NULL);\n    } \n  for (i=0; i < (ssize_t) blur_radius; i++)\n  { \n    cos_theta[i]=cos(blur_radius*i); \n    sin_theta[i]=sin(blur_radius*i); \n  } \n  offset=0.0; \n  for (i=0; i < (ssize_t) blur_radius; i++)\n  { \n    cos_theta[i]=cos(blur_radius*i); \n    sin_theta[i]=sin(blur_radius*i); \n    offset+=cos_theta[i]*sin_theta[i]; \n  } \n  offset=sqrt(offset); \n  for (i=0; i < (ssize_t) blur_radius; i++)\n  { \n    cos_theta[i]=cos(blur_radius*i); \n    sin_theta[i]=sin(blur_radius*i); \n    blur_center.x+=cos_theta[i]*offset; \n    blur_center.y+=sin_theta[i]*offset; \n  } \n  blur_center.x/=blur_radius; \n  blur_center.y/=blur_radius; \n  blur_radius=sqrt(blur_radius); \n  for (i=0; i < (ssize_t) blur_radius; i++)\n  { \n    cos_theta[i]=cos(blur_radius*i); \n    sin_theta[i]=sin(blur_radius*i); \n    blur_center.x+=cos_theta[i]*offset; \n    blur_center.y+=sin_theta[i]*offset; \n  } \n  blur_center.x/=blur_radius; \n  blur_center.y/=blur_radius; \n  blur_radius=sqrt(blur_radius); \n  for (i=0; i < (ssize_t) blur_radius; i++)\n  { \n    cos_theta[i]=cos(blur_radius*i); \n    sin_theta[i]=sin(blur_radius*i); \n    blur_center.x+=cos_theta[i]*offset; \n    blur_center.y+=sin_theta[i]*offset; \n  } \n  blur_center.x/=blur_radius; \n  blur_center.y/=blur_radius; \n  blur_radius=sqrt(blur_radius); \n  for (i=0; i < (ssize_t) blur_radius; i++)\n  { \n    cos_theta[i]=cos(blur_radius*i); \n    sin_theta[i]=sin(blur_radius*i); \n    blur_center.x+=cos_theta[i]*offset; \n    blur_center.y+=sin_theta[i]*offset; \n  } \n  blur_center.x/=blur_radius; \n  blur_center.y/=blur_radius; \n  blur_radius=sqrt(blur_radius); \n  for (i=0; i < (ssize_t) blur_radius; i++)\n  { \n    cos_theta[i]=cos(blur_radius*i); \n    sin_theta[i]=sin(blur_radius*i); \n    blur_center.x+=cos_theta[i]*offset; \n    blur_center.y+=sin_theta[i]*offset; \n  } \n  blur_center.x/=blur_radius; \n  blur_center.y/=blur_radius; \n  blur_radius=sqrt(blur_radius); \n  for (i=0; i < (ssize_t) blur_radius; i++)\n  { \n    cos_theta[i]=cos(blur_radius*i); \n    sin_theta[i]=sin(blur_radius*i); \n    blur_center.x+=cos_theta[i]*offset; \n    blur_center.y+=sin_theta[i]*offset; \n  } \n  blur_center.x/=blur_radius; \n  blur_center.y/=blur_radius; \n  blur_radius=sqrt(blur_radius); \n  for (i=0; i < (ssize_t) blur_radius; i++)\n  { \n    cos_theta[i]=cos(blur_radius*i); \n    sin_theta[i]=sin(blur_radius*i); \n    blur_center.x+=cos_theta[i]*offset; \n    blur_center.y+=sin_theta[i]*offset; \n  } \n  blur_center.x/=blur_radius; \n  blur_center.y/=blur_radius; \n  blur_radius=sqrt(blur_radius); \n  for (i=0; i < (ssize_t) blur_radius; i++)\n  { \n    cos_theta[i]=cos(blur_radius*i); \n    sin_theta[i]=sin(blur_radius*i); \n    blur_center.x+=cos_theta[i]*offset; \n    blur_center.y+=sin_theta[i]*offset; \n  } \n  blur_center.x/=blur_radius; \n  blur_center.y/=blur_radius; \n  blur_radius=sqrt(blur_radius); \n  for (i=0; i < (ssize_t) blur_radius; i++)\n  { \n    cos_theta[i]=cos(blur_radius*i); \n    sin_theta[i]=sin(blur_radius*i); \n    blur_center.x+=cos_theta[i]*offset; \n    blur_center.y+=sin_theta[i]*offset; \n "}
{"label": " \nMagickExport Image *SelectiveBlurImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  const double threshold,ExceptionInfo *exception) \n{ \n#define SelectiveBlurImageTag  \"SelectiveBlur/Image\" \n \n  CacheView \n    *blur_view, \n    *image_view, \n    *luminance_view; \n \n  double \n    *kernel; \n \n  Image \n    *blur_image, \n    *luminance_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    center, \n    j, \n    u, \n    v, \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  width=GetOptimalKernelWidth1D(radius,sigma); \n  kernel=(double *) MagickAssumeAligned(AcquireAlignedMemory((size_t) width, \n    width*sizeof(*kernel))); \n  if (kernel == (double *) NULL) \n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n  j=(ssize_t) (width-1)/2; \n  i=0; \n  for (v=(-j); v <= j; v++) \n  { \n    for (u=(-j); u <= j; u++) \n      kernel[i++]=(double) (exp(-((double) u*u+v*v)/(2.0*MagickSigma* \n        MagickSigma))/(2.0*MagickPI*MagickSigma*MagickSigma)); \n  } \n  if (image->debug!= MagickFalse) \n    { \n      char \n        format[MaxTextExtent], \n        *message; \n \n      register const double \n        *k; \n \n      ssize_t \n        u, \n        v; \n \n      (void) LogMagickEvent(TransformEvent,GetMagickModule(), \n        \"  SelectiveBlurImage with %.20gx%.20g kernel:\",(double) width,(double) \n        width); \n      message=AcquireString(\"\"); \n      k=kernel; \n      for (v=0; v < (ssize_t) width; v++) \n      { \n        *message='\\0'; \n        (void) FormatLocaleString(format,MaxTextExtent,\"%.20g: \",(double) v); \n        (void) ConcatenateString(&message,format); \n        for (u=0; u < (ssize_t) width; u++) \n        { \n          (void) FormatLocaleString(format,MaxTextExtent,\"%+f \",*k++); \n          (void) ConcatenateString(&message,format); \n        } \n        (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"%s\",message); \n      } \n      message=DestroyString(message); \n    } \n  blur_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (blur_image == (Image *) NULL) \n    { \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      return((Image *) NULL); \n    } \n  if (SetImageStorageClass(blur_image,DirectClass) == MagickFalse) \n    { \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      InheritException(exception,&blur_image->exception); \n      blur_image=DestroyImage(blur_image); \n      return((Image *) NULL); \n    } \n  luminance_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (luminance_image == (Image *) NULL) \n    { \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      blur_image=DestroyImage(blur_image); \n      return((Image *) NULL); \n    } \n  status=TransformImageColorspace(luminance_image,GRAYColorspace); \n  if (status == MagickFalse) \n    { \n      InheritException(exception,&luminance_image->exception); \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      blur_image=DestroyImage(blur_image); \n      luminance_image=DestroyImage(luminance_image); \n      return((Image *) NULL); \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  center=(ssize_t) ((image->columns+width)*((width-1)/2L)+((width-1)/2L)); \n  GetMagickPixelPacket(image,&bias); \n  SetMagickPixelPacketBias(image,&bias); \n  image_view=AcquireVirtualCacheView(image,exception); \n  luminance_view=AcquireVirtualCacheView(luminance_image,exception); \n  blur_view=AcquireAuthenticCacheView(blur_image,exception); \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    double \n      gamma; \n \n    MagickBooleanType \n      sync; \n \n    register const IndexPacket \n      *restrict indexes; \n \n    register const PixelPacket \n      *restrict l, \n      *restrict p; \n \n    register IndexPacket \n      *restrict blur_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) (width-1)/2L),y-(ssize_t) \n      ((width-1)/2L),image->columns+width,width,exception); \n    l=GetCacheViewVirtualPixels(luminance_view,-((ssize_t) (width-1)/2L),y- \n      (ssize_t) ((width-1)/2L),luminance_image->columns+width,width,exception); \n    q=GetCacheViewAuthenticPixels(blur_view,0,y,blur_image->columns,1, \n      exception); \n    if ((p == (const PixelPacket *) NULL) || \n        (l == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewVirtualIndexQueue(image_view); \n    blur_indexes=GetCacheViewAuthenticIndexQueue(blur_view); \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      double \n        contrast; \n \n      DoublePixelPacket \n        pixel; \n \n      MagickRealType \n        intensity; \n \n      register const double \n        *restrict k; \n \n      register ssize_t \n        u; \n \n      ssize_t \n        j, \n        v; \n \n      pixel.red", "pred": " \nMagickExport Image *SelectiveBlurImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  const double threshold,ExceptionInfo *exception) \n{ \n#define SelectiveBlurImageTag  \"SelectiveBlur/Image\" \n \n  CacheView \n    *blur_view, \n    *image_view, \n    *luminance_view; \n \n  double \n    *kernel; \n \n  Image \n    *blur_image, \n    *luminance_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    center, \n    j, \n    u, \n    v, \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  width=GetOptimalKernelWidth2(radius,sigma); \n  center=width/2; \n \n  blur_image=CloneImage(image,width,width,MagickTrue,exception); \n  if (blur_image == (Image *) NULL)\n    return((Image *) NULL);\n  luminance_image=CloneImage(image,width,width,MagickTrue,exception); \n  if (luminance_image == (Image *) NULL)\n    {\n      blur_image=DestroyImage(blur_image);\n      return((Image *) NULL);\n    }\n  blur_view=AcquireVirtualCacheView(blur_image,exception); \n  image_view=AcquireVirtualCacheView(image,exception); \n  luminance_view=AcquireAuthenticCacheView(luminance_image,exception); \n \n  /*\n    Selective blur.\n  */\n  kernel=(double *) AcquireQuantumMemory(width,sizeof(*kernel)); \n  if (kernel == (double *) NULL)\n    {\n      blur_image=DestroyImage(blur_image);\n      blur_view=DestroyCacheView(blur_view);\n      image_view=DestroyCacheView(image_view);\n      luminance_view=DestroyCacheView(luminance_view);\n      return((Image *) NULL);\n    }\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=0.0; \n \n  /*\n    Compute the kernel.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma; \n \n  /*\n    Compute the luminance.\n  */\n  for (i=0; i < (ssize_t) width; i++)\n    kernel[i]=kernel[i]*radius+sigma;"}
{"label": " \nMagickExport Image *SpreadImage(const Image *image,const double radius, \n  ExceptionInfo *exception) \n{ \n#define SpreadImageTag  \"Spread/Image\" \n \n  CacheView \n    *image_view, \n    *spread_view; \n \n  Image \n    *spread_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  RandomInfo \n    **restrict random_info; \n \n  size_t \n    width; \n \n  ssize_t \n    y; \n \n  unsigned long \n    key; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  spread_image=CloneImage(image,image->columns,image->rows,MagickTrue, \n    exception); \n  if (spread_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(spread_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&spread_image->exception); \n      spread_image=DestroyImage(spread_image); \n      return((Image *) NULL); \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(spread_image,&bias); \n  width=GetOptimalKernelWidth1D(radius,0.5); \n  random_info=AcquireRandomInfoThreadSet(); \n  image_view=AcquireVirtualCacheView(image,exception); \n  spread_view=AcquireAuthenticCacheView(spread_image,exception); \n  key=GetRandomSecretKey(random_info[0]); \n  for (y=0; y < (ssize_t) spread_image->rows; y++) \n  { \n    const int \n      id = GetOpenMPThreadId(); \n \n    MagickPixelPacket \n      pixel; \n \n    register IndexPacket \n      *restrict indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    q=QueueCacheViewAuthenticPixels(spread_view,0,y,spread_image->columns,1, \n      exception); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewAuthenticIndexQueue(spread_view); \n    pixel=bias; \n    for (x=0; x < (ssize_t) spread_image->columns; x++) \n    { \n      (void) InterpolateMagickPixelPacket(image,image_view, \n        UndefinedInterpolatePixel,(double) x+width*(GetPseudoRandomValue( \n        random_info[id])-0.5),(double) y+width*(GetPseudoRandomValue( \n        random_info[id])-0.5),&pixel,exception); \n      SetPixelPacket(spread_image,&pixel,q,indexes+x); \n      q++; \n    } \n    if (SyncCacheViewAuthenticPixels(spread_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        proceed=SetImageProgress(image,SpreadImageTag,progress++,image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  } \n  spread_view=DestroyCacheView(spread_view); \n  image_view=DestroyCacheView(image_view); \n  random_info=DestroyRandomInfoThreadSet(random_info); \n  if (status == MagickFalse) \n    spread_image=DestroyImage(spread_image); \n  return(spread_image); \n} ", "pred": " \nMagickExport Image *SpreadImage(const Image *image,const double radius, \n  ExceptionInfo *exception) \n{ \n#define SpreadImageTag  \"Spread/Image\" \n \n  CacheView \n    *image_view, \n    *spread_view; \n \n  Image \n    *spread_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  RandomInfo \n    **restrict random_info; \n \n  size_t \n    width; \n \n  ssize_t \n    y; \n \n  unsigned long \n    key; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  spread_image=CloneImage(image,image->columns,image->rows,MagickTrue, \n    exception); \n  if (spread_image == (Image *) NULL) \n    return((Image *) NULL);\n  if (SetImageStorageClass(spread_image,DirectClass,exception) == MagickFalse)\n    {\n      spread_image=DestroyImage(spread_image);\n      return((Image *) NULL);\n    }\n  spread_image->alpha_trait=BlendPixelTrait; \n  spread_image->depth=8; \n  spread_image->storage_class=DirectClass; \n  spread_image->colors=4; \n  spread_image->colorspace=RGBColorspace; \n  spread_image->alpha_trait=BlendPixelTrait; \n  spread_image->page.width=image->columns; \n  spread_image->page.height=image->rows; \n  spread_image->page.x=0; \n  spread_image->page.y=0; \n  spread_image->background_color=image->background_color; \n  spread_image->exception=exception; \n  spread_image->filter=ImageFilter; \n  spread_image->endian=MSBEndian; \n  spread_image->page=image->page; \n  spread_image->page.x=0; \n  spread_image->page.y=0; \n  spread_image->page.width=image->columns; \n  spread_image->page.height=image->rows; \n  spread_image->page.x=0; \n  spread_image->page.y=0; \n  spread_image->page.width=image->columns; \n  spread_image->page.height=image->rows; \n  spread_image->page.x=0; \n  spread_image->page.y=0; \n  spread_image->page.width=image->columns; \n  spread_image->page.height=image->rows; \n  spread_image->page.x=0; \n  spread_image->page.y=0; \n  spread_image->page.width=image->columns; \n  spread_image->page.height=image->rows; \n  spread_image->page.x=0; \n  spread_image->page.y=0; \n  spread_image->page.width=image->columns; \n  spread_image->page.height=image->rows; \n  spread_image->page.x=0; \n  spread_image->page.y=0; \n  spread_image->page.width=image->columns; \n  spread_image->page.height=image->rows; \n  spread_image->page.x=0; \n  spread_image->page.y=0; \n  spread_image->page.width=image->columns; \n  spread_image->page.height=image->rows; \n  spread_image->page.x=0; \n  spread_image->page.y=0; \n  spread_image->page.width=image->columns; \n  spread_image->page.height=image->rows; \n  spread_image->page.x=0; \n  spread_image->page.y=0; \n  spread_image->page.width=image->columns; \n  spread_image->page.height=image->rows; \n  spread_image->page.x=0; \n  spread_image->page.y=0; \n  spread_image->page.width=image->columns; \n  spread_image->page.height=image->rows; \n  spread_image->page.x=0; \n  spread_image->page.y=0; \n  spread_image->page.width=image->columns; \n  spread_image->page.height=image->rows; \n  spread_image->page."}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return; \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n  const int gamutcheck = (d->mode == DT_PROFILE_GAMUTCHECK); \n  const size_t npixels = (size_t)roi_out->width * roi_out->height; \n  float *const restrict out = (float *)ovoid; \n \n  if(d->type == DT_COLORSPACE_LAB) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, piece->colors); \n  } \n  else if(!isnan(d->cmatrix[0][0])) \n  { \n    const float *const restrict in = (const float *const)ivoid; \n    dt_colormatrix_t cmatrix; \n    transpose_3xSSE(d->cmatrix, cmatrix); \n \n \n \n \n \n    for(size_t k = 0; k < (size_t)4 * npixels; k += 4) \n    { \n      dt_aligned_pixel_t xyz; \n      dt_Lab_to_XYZ(in + k, xyz); \n      dt_aligned_pixel_t rgb;  \n \n      dt_apply_transposed_color_matrix(xyz, cmatrix, rgb); \n      copy_pixel(out + k, rgb); \n    } \n \n    process_fastpath_apply_tonecurves(self, piece, in, out, roi_in, roi_out); \n  } \n  else \n  { \n \n \n    for(int k = 0; k < roi_out->height; k++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)4 * k * roi_out->width; \n      float *const restrict outp = out + (size_t)4 * k * roi_out->width; \n \n      cmsDoTransform(d->xform, in, outp, roi_out->width); \n \n      if(gamutcheck) \n      { \n        for(int j = 0; j < roi_out->width; j++) \n        { \n          if(outp[4*j+0] < 0.0f || outp[4*j+1] < 0.0f || out[4*j+2] < 0.0f) \n          { \n            outp[4*j+0] = 0.0f; \n            outp[4*j+1] = 1.0f; \n            outp[4*j+2] = 1.0f; \n          } \n        } \n      } \n    } \n  } \n \n  if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) \n    dt_iop_alpha_copy(ivoid, ovoid, roi_out->width, roi_out->height); \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  if(!dt_iop_have_required_input_format(4  \n, self, piece->colors, \n                                         ivoid, ovoid, roi_in, roi_out)) \n    return; \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n  const int gamutcheck = (d->mode == DT_PROFILE_GAMUTCHECK); \n  const size_t npixels = (size_t)roi_out->width * roi_out->height; \n  float *const restrict out = (float *)ovoid; \n \n  if(d->type == DT_COLORSPACE_LAB) \n  { \n    dt_iop_image_copy_alpha(piece->colors, out, npixels, gamutcheck); \n  } \n  else \n  { \n    dt_iop_image_copy(piece->colors, out, npixels, gamutcheck); \n  } \n  \n}\n\n\nvoid init(dt_iop_module_t *self)\n{\n  dt_iop_colorout_data_t *d = (dt_iop_colorout_data_t *)self->data;\n  d->mode = DT_PROFILE_GAMUTCHECK;\n  d->type = DT_COLORSPACE_LAB;\n  d->alpha = 1.0f;\n}\n\nvoid gui_changed(dt_iop_module_t *self, GtkWidget *w, void *previous)\n{\n  dt_iop_colorout_data_t *d = (dt_iop_colorout_data_t *)self->data;\n  dt_iop_gui_enter_critical_section(self);\n  d->mode = DT_PROFILE_GAMUTCHECK;\n  dt_iop_gui_leave_critical_section(self);\n}\n\nvoid init_presets(dt_iop_module_t *self)\n{\n  dt_iop_colorout_data_t *d = (dt_iop_colorout_data_t *)self->data;\n  d->mode = DT_PROFILE_GAMUTCHECK;\n  d->type = DT_COLORSPACE_LAB;\n  d->alpha = 1.0f;\n}\n\nvoid gui_init(dt_iop_module_t *self)\n{\n  dt_iop_colorout_data_t *d = (dt_iop_colorout_data_t *)self->data;\n  dt_iop_gui_enter(self);\n  d->mode = DT_PROFILE_GAMUTCHECK;\n  dt_iop_gui_leave(self);\n}\n\nvoid gui_cleanup(dt_iop_module_t *self)\n{\n  dt_iop_colorout_data_t *d = (dt_iop_colorout_data_t *)self->data;\n  dt_iop_gui_enter(self);\n  d->mode = DT_PROFILE_NONE;\n  dt_iop_gui_leave(self);\n}\n\nvoid gui_update(dt_iop_module_t *self)\n{\n  dt_iop_colorout_data_t *d = (dt_iop_colorout_data_t *)self->data;\n  dt_iop_gui_enter(self);\n  d->mode = DT_PROFILE_GAMUTCHECK;\n  dt_iop_gui_leave(self);\n}\n\nvoid gui_cleanup_presets(dt_iop_module_t *self)\n{\n  dt_iop_colorout_data_t *d = (dt_iop_colorout_data_t *)self->data;\n  dt_iop_gui_enter_critical_section(self);\n  d->mode ="}
{"label": "matrix_t *data) \n{ \n\tnv_matrix_t *dists = nv_matrix_alloc(data->m, k);\t \n\tint i, j; \n\tint threads = nv_omp_procs(); \n \n\tif (data->m == 0) { \n\t\tnv_matrix_free(&dists); \n\t\treturn; \n\t} \n\tnv_vector_copy(means, 0, data, nv_rand_index(data->m)); \n\tj = 0; \n\tfor (i = 0; i < data->m; ++i) { \n\t\tNV_MAT_V(dists, j, i) = nv_euclidean2(means, j, data, i); \n\t} \n\t \n\tfor (j = 0; j < k - 1; ++j) { \n\t\tfloat max_v = -FLT_MAX; \n\t\tint max_i = -1; \n \n\t\tfor (i = 0; i < data->m; ++i) { \n\t\t\tNV_MAT_V(dists, j, i) = nv_euclidean2(means, j, data, i); \n\t\t} \n\t\tfor (i = 0; i < data->m; ++i) { \n\t\t\tfloat min_dist = FLT_MAX; \n\t\t\tint l; \n\t\t\tfor (l = 0; l <= j; ++l) { \n\t\t\t\tif (min_dist > NV_MAT_V(dists, l, i)) { \n\t\t\t\t\tmin_dist = NV_MAT_V(dists, l, i); \n\t\t\t\t} \n\t\t\t} \n\t\t\tif (min_dist > max_v) { \n\t\t\t\tmax_v = min_dist; \n\t\t\t\tmax_i = i; \n\t\t\t} \n\t\t} \n\t\tnv_vector_copy(means, j + 1, data, max_i); \n\t} \n\tnv_matrix_free(&dists); \n} \n \nvoid \nnv_kmeans_init_rand(nv_matrix_t *means) \n{ \n\tint j; \n\tfor (j = 0 ", "pred": "matrix_t *data) \n{ \n\tnv_matrix_t *dists = nv_matrix_alloc(data->m, k);\t \n\tint i, j; \n\tint threads = nv_omp_procs(); \n \n\tif (data->m == 0) { \n\t\tnv_matrix_free(&dists); \n\t\treturn; \n\t} \n\tnv_vector_copy(means, 0, data, nv_rand_index(data->m)); \n\tj = 0; \n\tfor (i = 0; i < data->m; ++i) { \n\t\tNV_MAT_V(dists, j, i) = nv_euclidean2(means, j, data, i); \n\t} \n\t \n\tfor (j = 0; j < k - 1; ++j) { \n\t\tfloat max_v = -FLT_MAX; \n\t\tint max_i = -1; \n \n\t\tfor (i = 0; i < data->m; ++i) { \n\t\t\tNV_MAT_V(dists, j, i) = nv_euclidean2(means, j, data, i); \n\t\t} \n\t\tfor (i = 0; i < data->m; ++i) { \n\t\t\tfloat min_dist = FLT_MAX; \n\t\t\tint min_i = -1; \n \n\t\t\tfor (int k = 0; k < threads; ++k) { \n\t\t\t\tfloat dist = nv_distance(data, i, j, k); \n\t\t\t\tif (dist < min_dist) { \n\t\t\t\t\tmin_dist = dist; \n\t\t\t\t\tmin_i = k; \n\t\t\t\t} \n\t\t\t} \n\t\t\tif (min_dist > max_v) { \n\t\t\t\tmax_v = min_dist; \n\t\t\t\tmax_i = min_i; \n\t\t\t} \n\t\t} \n\t\tif (max_v > data->v[j]) { \n\t\t\tdata->v[j] = max_v; \n\t\t\tdata->i[j] = max_i; \n\t\t} \n\t} \n\tnv_matrix_free(&dists); \n"}
{"label": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_sharpen_data_t *const data = (dt_iop_sharpen_data_t *)piece->data; \n  const int ch = piece->colors; \n  const int rad = MIN(MAXR, ceilf(data->radius * roi_in->scale / piece->iscale)); \n   \n \n   \n \n  if(rad == 0 || \n     (roi_out->width < 2 * rad + 1 || roi_out->height < 2 * rad + 1)) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, ch); \n    return; \n  } \n \n  float *restrict tmp; \n  if (!dt_iop_alloc_image_buffers(self, roi_in, roi_out, 1, &tmp, 0)) \n  { \n    dt_iop_copy_image_roi(ovoid, ivoid, ch, roi_in, roi_out, TRUE); \n    return; \n  } \n \n  const int wd = 2 * rad + 1; \n  const int wd4 = (wd & 3)? (wd >> 2) + 1 : wd >> 2; \n \n  const size_t mat_size = (size_t)4 * wd4; \n  float *const mat = dt_alloc_align_float(mat_size); \n  memset(mat, 0, sizeof(float) * mat_size); \n \n  const float sigma2 = (1.0f / (2.5 * 2.5)) * (data->radius * roi_in->scale / piece->iscale) \n                       * (data->radius * roi_in->scale / piece->iscale); \n  float weight = 0.0f; \n \n   \n \n  for(int l = -rad; l <= rad; l++) weight += mat[l + rad] = expf(-l * l / (2.f * sigma2)); \n  for(int l = -rad; l <= rad; l++) mat[l + rad] /= weight; \n \n \n \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    const float *in = ((float *)ivoid) + (size_t)ch * (j * roi_in->width + rad); \n    float *out = tmp + (size_t)j * roi_out->width + rad; \n    int i; \n    for(i = rad; i < roi_out->width - wd4 * 4 + rad; i++) \n    { \n      const float *inp = in - ch * rad; \n      __attribute__((aligned(64))) float sum[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; \n      __m128 msum = _mm_setzero_ps(); \n \n      for(int k = 0; k < wd4 * 4; k += 4, inp += 4 * ch) \n      { \n        msum = _mm_add_ps( \n            msum, _mm_mul_ps(_mm_load_ps(mat + k), _mm_set_ps(inp[3 * ch], inp[2 * ch], inp[ch], inp[0]))); \n      } \n      _mm_store_ps(sum, msum); \n      *out = sum[0] + sum[1] + sum[2] + sum[3]; \n      out++; \n      in += ch; \n    } \n    for(; i < roi_out->width - rad; i++) \n    { \n      const float *inp = in - ch * rad; \n      const float *m = mat; \n      float sum = 0.0f; \n      for(int k = -rad; k <= rad; k++, m++, inp += ch) \n      { \n        sum += *m * *inp; \n      } \n      *out = sum; \n      out++; \n      in += ch; \n    } \n  } \n  _mm_sfence(); \n \n \n \n  for(int j = rad; j < roi_out->height - wd4 * 4 + rad; j++) \n  { \n    const float *in = tmp + (size_t)j * roi_in->width; \n    float *out = ((float *)ovoid) + (size_t)ch * j * roi_out->width; \n \n    const int step = roi_in->width; \n \n    __attribute__((aligned(64))) float sum[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      const float *inp = in - step * rad; \n      __m128 msum = _mm_setzero_ps(); \n \n      for(int k = 0; k < wd4 * 4; k += 4, inp += step * 4) \n      { \n        msum = _mm_add_ps(msum, _mm_mul_ps(_mm_load_ps(mat + k), \n                                           _mm_set_ps(inp[3 * step], inp[2 * step], inp[step], inp[0]))); \n      } \n      _mm_store_ps(sum, msum); \n      *out = sum[0] + sum[1] + sum[2] + sum[3]; \n      out += ch; \n      in++; \n    } \n  } \n  for(int j = roi_out->height - wd4 * 4 + rad; j < roi_out->height - rad; j++) \n  { \n    const float *in = tmp + (size_t)j * roi_in->width; \n    float *out = ((float *)ovoid) + (size_t)ch * j * roi_out->width; \n    const int step = roi_in->width; \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      const float *inp = in - step * rad; \n      const float *m = mat; \n      float sum = 0.0f; \n      for(int k = -rad; k <= rad; k++, m++, inp += step) sum += *m * *inp; \n      *out = sum; \n      out += ch; \n      in++; \n    } \n  } \n \n  dt_free_align(mat); \n \n  _mm_sfence(); \n \n   \n \n  for(int j = 0; j < rad; j++) \n    memcpy(((float *)ovoid) + (size_t)ch * j * roi_out->width, \n           ((float *)ivoid) + (size_t)ch * j * roi_in->width, (size_t)ch * sizeof(float) * roi_out->width); \n  for(int j = roi_out->height - rad; j < roi_out->height; j++) \n    memcpy(((float *)ovoid) + (size_t)ch * j * roi_out->width, \n           ((float *)ivoid) + (size_t)ch * j * roi_in->width, (size_t)ch * sizeof(float) * roi_", "pred": " \nvoid process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_sharpen_data_t *const data = (dt_iop_sharpen_data_t *)piece->data; \n  const int ch = piece->colors; \n  const int rad = MIN(MAXR, ceilf(data->radius * roi_in->scale / piece->iscale)); \n   \n \n   \n \n  if(rad == 0 || \n     (roi_out->width < 2 * rad + 1 || roi_out->height < 2 * rad + 1)) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, ch); \n    return; \n  } \n \n  float *restrict tmp; \n  if (!dt_iop_alloc_image_buffers(self, roi_in, roi_out, 1, &tmp, 0)) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, ch); \n    return; \n  } \n  \n  const float *const restrict src = (const float *)ivoid; \n  const float *const restrict dst = (const float *)ovoid; \n  const int width = roi_out->width; \n  const int height = roi_out->height; \n  const int x = roi_out->x; \n  const int y = roi_out->y; \n  const int rad_x = rad - 1; \n  const int rad_y = rad - 1; \n  const int rad_x2 = rad_x * rad_x; \n  const int rad_y2 = rad_y * rad_y; \n  const int rad_x3 = rad_x * rad_y; \n  const int rad_y3 = rad_y * rad_x; \n  const int rad_x4 = rad_x2 * rad_x2; \n  const int rad_y4 = rad_y2 * rad_y2; \n  const int rad_x5 = rad_x3 * rad_x3; \n  const int rad_y5 = rad_y3 * rad_y3; \n  const int rad_x6 = rad_x4 * rad_x4; \n  const int rad_y6 = rad_y4 * rad_y4; \n  const int rad_x7 = rad_x5 * rad_x5; \n  const int rad_y7 = rad_y5 * rad_y5; \n  const int rad_x8 = rad_x6 * rad_x6; \n  const int rad_y8 = rad_y6 * rad_y6; \n  const int rad_x9 = rad_x7 * rad_x7; \n  const int rad_y9 = rad_y7 * rad_y7; \n  const int rad_x10 = rad_x8 * rad_x8; \n  const int rad_y10 = rad_y8 * rad_y8; \n  const int rad_x11 = rad_x9 * rad_x9; \n  const int rad_y11 = rad_y9 * rad_y9; \n  const int rad_x12 = rad_x10 * rad_x10; \n  const int rad_y12 = rad_y10 * rad_y10; \n  const int rad_x13 = rad_x11 * rad_x11; \n  const int rad_y13 = rad_y11 * rad_y11; \n  const int rad_x14 = rad_x12 * rad_x12; \n  const int rad_y14 = rad_y12 * rad_y12; \n  const int rad_x15 = rad_x13 * rad_x13; \n  const int rad_y15 = rad_y13 * rad_y13; \n  const int rad_x16 = rad_x14 * rad_x14; \n  const int rad_y16 = rad_y14 * rad_y14; \n  const int rad_x17 = rad_x15 * rad_x15; \n  const int rad_y17 = rad_y15 * rad_y15; \n  const int rad_x18 = rad_x16 * rad_x16; \n  const int rad_y18 = rad_y16 * rad_y16; \n  const int rad_x19 = rad_x17 * rad_x17; \n  const int rad_y19 = rad_y17 * rad_y17; \n  const int rad_x20 = rad_x18 * rad_x18; \n  const int rad_y20 = rad_y18 * rad_y18; \n  const int rad_x21 = rad_x19 * rad_x19; \n  const int rad_y21 = rad_y19 * rad_y19; \n  const int rad_x22 = rad_x20 * rad_x20; \n  const int rad_y22 = rad_y20 * rad_y20; \n  const int rad_x23 = rad_x21 * rad_x21; \n  const int rad_y23 = rad_y21 * rad_y21; \n  const int rad_x24 = rad_x22 * rad_x22; \n  const int rad_y24 = rad_y22 * rad_y22; \n  const int rad_x25 = rad_x23 * rad_x23; \n  const int rad_y25 = rad_y23 * rad_y23; \n  const int rad_x26 = rad_x24 * rad_x24; \n  const int rad_y26 = rad_y24 * rad_y24; \n  const int rad_x27 = rad_x25 * rad_x25; \n  const int rad_y27 = rad_y25 * rad_y25; \n  const int rad_x28 = rad_x26 * rad_x26; \n  const int rad_y28 = rad_y26 * rad_y26; \n  const int rad_x29 = rad_x27 * rad_x27; \n  const int rad_y29 = rad_y27 * rad_y27; \n  const int rad_x30 = rad_x28 * rad_x28; \n  const int rad_y30 = rad_y28 * rad_y28; \n  const int rad_x31 = rad_x29 * rad_x29; \n  const int rad_y31 = rad_y29 * rad_y29; \n  const int rad_x32 = rad_x30 * rad_x30; \n  const int rad_y32 = rad_y30 * rad_y30; \n  const int rad_x33 = rad_x31 * rad_x31; \n  const int rad_y33 = rad_y31 * rad_y31; \n  const int rad_x34 = rad_x32 * rad_x32; \n  const int rad_y34 = rad_y32 * rad_y32; \n  const int rad_x35 = rad_x33 * rad_x33; \n  const int rad_y35 = rad_y33 * rad_y33; \n  const int rad_x36 = rad_x34 * rad_x34; \n  const int rad_y36 = rad_y34 * rad_y34; \n  const int rad_x37 = rad_x35 * rad_x35; \n  const int rad_y37 = rad_y35 * rad_y35; \n  const int rad_x38 = rad_x36 * rad_x36; \n  const int rad_y38 = rad_y36 * rad_y36; \n  const int rad_x39 = rad_x37 * rad_x37; \n  const int rad_y39 = rad_y37 * rad_y37; \n  const int rad_x40 = rad_x38 * rad_x38; \n  const int rad_y40 = rad_y38 * rad_y38; \n  const int rad_x41 = rad_x39 * rad_x39; \n  const int rad_y41 = rad_y39 * rad_y39; \n  const int rad_x42 = rad_x40 * rad_x40; \n  const int rad_y42 = rad_y40 * rad_y40; \n  const int rad_x43 = rad_x41 * rad_x41; \n  const int rad_y43 = rad_y41 * rad_y41; \n  const int rad"}
{"label": " \nint <ompts:testcode:functionname>omp_parallel_reduction</ompts:testcode:functionname>(FILE * logFile){ \n\t<ompts:orphan:vars> \n    int sum; \n\tint known_sum; \n\tdouble dsum; \n\tdouble dknown_sum; \n\tdouble dt=0.5;\t\t\t\t \n \n\tdouble rounding_error= 1.E-9; \n#define DOUBLE_DIGITS 20\t\t \n \n\tint diff; \n\tdouble ddiff; \n\tint product; \n\tint known_product; \n#define MAX_FACTOR 10 \n#define KNOWN_PRODUCT 3628800\t \n \n\tint logic_and; \n\tint logic_or; \n\tint bit_and; \n\tint bit_or; \n\tint exclusiv_bit_or; \n\tint logics[LOOPCOUNT]; \n\tint i; \n\tdouble dpt; \n\tint result; \n</ompts:orphan:vars> \n    sum =0; \n    dsum=0; \n    product=1; \n\tlogic_and=1; \n\tlogic_or=0; \n\tbit_and=1; \n\tbit_or=0; \n\texclusiv_bit_or=0; \n    result=0; \n\tdt = 1./3.; \n\tknown_sum = (LOOPCOUNT*(LOOPCOUNT+1))/2; \n<ompts:orphan> \n\tfor (i=1;i<=LOOPCOUNT;i++) \n\t{ \n\t\tsum=sum+i; \n\t} \n \n\tif(known_sum!=sum) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in sum with integers: Result was %d instead of %d\\n\",sum,known_sum);  \n\t} \n \n\tdiff = (LOOPCOUNT*(LOOPCOUNT+1))/2; \n\tfor (i=1;i<=LOOPCOUNT;++i) \n\t{ \n\t\tdiff=diff-i; \n\t} \n \n\tif(diff!= 0) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in difference with integers: Result was %d instead of 0.\\n\",diff); \n\t} \n \n\t \n \n\tdsum=0; \n\tdpt=1; \n\tfor (i=0;i<DOUBLE_DIGITS;++i) \n\t{ \n\t\tdpt*=dt; \n\t} \n\tdknown_sum = (1-dpt)/(1-dt); \n\tfor (i=0;i<DOUBLE_DIGITS;++i) \n\t{ \n\t\tdsum += pow(dt,i); \n\t} \n \n\tif( fabs(dsum-dknown_sum) > rounding_error ) \n\t{ \n\t\tresult++;  \n\t\tfprintf(logFile,\"Error in sum with doubles: Result was %f instead of %f (Difference: %E)\\n\",dsum,dknown_sum, dsum-dknown_sum); \n\t} \n \n\tdpt=1; \n \n\tfor (i=0;i<DOUBLE_DIGITS;++i) \n\t{ \n\t\tdpt*=dt; \n\t} \n\tfprintf(logFile,\"\\n\"); \n\tddiff = (1-dpt)/(1-dt); \n\tfor (i=0;i<DOUBLE_DIGITS;++i) \n\t{ \n\t\tddiff -= pow(dt,i); \n\t} \n\tif( fabs(ddiff) > rounding_error) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in Difference with doubles: Result was %E instead of 0.0\\n\",ddiff); \n\t} \n \n\tfor(i=1;i<=MAX_FACTOR;i++) \n\t{ \n\t\tproduct *= i; \n\t} \n \n\tknown_product = KNOWN_PRODUCT; \n\tif(known_product!= product) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in Product with integers: Result was %d instead of %d\\n\\n\",product,known_product); \n\t} \n \n\tfor(i=0;i<LOOPCOUNT;i++) \n\t{ \n\t\tlogics[i]=1; \n\t} \n \n\tfor(i=0;i<LOOPCOUNT;++i) \n\t{ \n\t\tlogic_and = (logic_and && logics[i]); \n\t} \n\tif(!logic_and) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in logic AND part 1.\\n\"); \n\t} \n \n\tlogic_and = 1; \n\tlogics[LOOPCOUNT/2]=0; \n \n\tfor(i=0;i<LOOPCOUNT;++i) \n\t{ \n\t\tlogic_and = logic_and && logics[i]; \n\t} \n\tif(logic_and) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in logic AND part 2.\\n\"); \n\t} \n \n\tfor(i=0;i<LOOPCOUNT;i++) \n\t{ \n\t\tlogics[i]=0; \n\t} \n \n\tfor(i=0;i<LOOPCOUNT;++i) \n\t{ \n\t\tlogic_or = logic_or || logics[i]; \n\t} \n\tif(logic_or) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in logic OR part 1.\\n\"); \n\t} \n\tlogic_or = 0; \n\tlogics[LOOPCOUNT/2]=1; \n \n\tfor(i=0;i<LOOPCOUNT;++i) \n\t{ \n\t\tlogic_or = logic_or || logics[i]; \n\t} \n\tif(!logic_or) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in logic OR part 2.\\n\"); \n\t} \n \n \n\tfor(i=0;i<LOOPCOUNT;++i) \n\t{ \n\t\tlogics[i]=1; \n\t} \n \n\tfor(i=0;i<LOOPCOUNT;++i) \n\t{ \n\t\tbit_and = (bit_and & logics[i]); \n\t} \n\tif(!bit_and) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in BIT AND part 1.\\n\"); \n\t} \n \n\tbit_and = 1; \n\tlogics[LOOPCOUNT/2]=0; \n \n\tfor(i=0;i<LOOPCOUNT;++i) \n\t{ \n\t\tbit_and = bit_and & logics[i]; \n\t} \n\tif(bit_and) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in BIT AND part 2.\\n\"); \n\t} \n \n\tfor(i=0;i<LOOPCOUNT;i++) \n\t{ \n\t\tlogics[i]=0; \n\t} \n \n\tfor(i=0;i<LOOPCOUNT;++i) \n\t{ \n\t\tbit_or = bit_or | logics[i]; \n\t} \n\tif(bit_or) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in BIT OR part 1\\n\"); \n\t} \n\tbit_or = 0; \n\tlogics[LOOPCOUNT/2]=1; \n \n\tfor(i=0;i<LOOPCOUNT;++i) \n\t{ \n\t\tbit_or = bit_or | logics[i]; \n\t} \n\tif(!bit_or) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in BIT OR part 2\\n\"); \n\t} \n \n\tfor(i=0;i<LOOPCOUNT;i++) \n\t{ \n\t\tlogics[i]=0; \n\t} \n \n\tfor(i=0;i<LOOPCOUNT;++i) \n\t{ \n\t\texclusiv_bit_or = exclusiv_bit_or ^ logics[i]; \n\t} \n\tif(exclusiv_bit_or) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in EXCLUSIV BIT OR part 1\\n\"); \n\t} \n \n\texclusiv_bit_or = 0; \n\tlogics[LOOPCOUNT/2]=1; \n \n\tfor(i=0;i<LOOPCOUNT;++i) \n\t{ \n\t\texclusiv_bit_or = exclusiv_bit_or ^ logics[i]; \n\t} \n\tif(!exclusiv_bit_or) \n\t{ \n\t\tresult++; \n\t\tfprintf(logFile,\"Error in EXCLUSIV BIT OR part 2\\n\"); \n\t} \n    </ompts:orphan> \n\t \n \n\treturn (result==0); \n} ", "pred": " \nint <ompts:testcode:functionname>omp_parallel_reduction</ompts:testcode:functionname>(FILE * logFile){ \n\t<ompts:orphan:vars> \n    int sum; \n\tint known_sum; \n\tdouble dsum; \n\tdouble dknown_sum; \n\tdouble dt=0.5;\t\t\t\t \n \n\tdouble rounding_error= 1.E-9; \n#define DOUBLE_DIGITS 20\t\t \n \n\tint diff; \n\tdouble ddiff; \n\tint product; \n\tint known_product; \n#define MAX_FACTOR 10 \n#define KNOWN_PRODUCT 3628800\t \n \n\tint logic_and; \n\tint logic_or; \n\tint bit_and; \n\tint bit_or; \n\tint exclusiv_bit_or; \n\tint logics[LOOPCOUNT]; \n\tint i; \n\tdouble dpt; \n\tint result; \n</ompts:orphan:vars> \n    sum =0; \n    dsum=0; \n    product=1; \n\tlogic_and=1; \n\tlogic_or=0; \n\tbit_and=1; \n\tbit_or=0; \n\texclusiv_bit_or=0; \n    result=0; \n    for(i=0;i<LOOPCOUNT;i++){ \n\t\tif(i%2==0){ \n\t\t\tif(i%3==0){ \n\t\t\t\tif(i%5==0){ \n\t\t\t\t\tif(i%7==0){ \n\t\t\t\t\t\tif(i%11==0){ \n\t\t\t\t\t\t\tif(i%13==0){ \n\t\t\t\t\t\t\t\tif(i%15==0){ \n\t\t\t\t\t\t\t\t\tif(i%17==0){ \n\t\t\t\t\t\t\t\t\t\tif(i%19==0){ \n\t\t\t\t\t\t\t\t\t\t\tif(i%21==0){ \n\t\t\t\t\t\t\t\t\t\t\t\tif(i%23==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%25==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%27==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%29==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%31==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%33==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%35==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%37==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%39==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%41==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%43==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%45==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%47==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%49==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%51==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%53==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%55==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%57==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%59==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%61==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%63==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%65==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%67==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%69==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%71==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%73==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%75==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%77==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%79==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%81==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%83==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%85==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%87==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%89==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%91==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%93==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%95==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%97==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%99==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%101==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%103==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%105==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%107==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%109==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%111==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%113==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%115==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%117==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%119==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%121==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%123==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%125==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%127==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%129==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%131==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%133==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%135==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%137==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%139==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%141==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%143==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%145==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%147==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%149==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%151==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%153==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%155==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%157==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%159==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%161==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%163==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%165==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%167==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%169==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%171==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%173==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%175==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%177==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%179==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%181==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%183==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%185==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%187==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%189==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%191==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%193==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%195==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%197==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%199==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%201==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%203==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%205==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%207==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%209==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%211==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%213==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%215==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%217==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%219==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%221==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%223==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%225==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%227==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%229==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%231==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%233==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i%235==0){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"}
{"label": " \nMagickExport MagickBooleanType DrawAffineImage(Image *image, \n  const Image *source,const AffineMatrix *affine,ExceptionInfo *exception) \n{ \n  AffineMatrix \n    inverse_affine; \n \n  CacheView \n    *image_view, \n    *source_view; \n \n  MagickBooleanType \n    status; \n \n  PixelInfo \n    zero; \n \n  PointInfo \n    extent[4], \n    min, \n    max, \n    point; \n \n  register ssize_t \n    i; \n \n  SegmentInfo \n    edge; \n \n  ssize_t \n    start, \n    stop, \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(source!= (const Image *) NULL); \n  assert(source->signature == MagickSignature); \n  assert(affine!= (AffineMatrix *) NULL); \n  extent[0].x=0.0; \n  extent[0].y=0.0; \n  extent[1].x=(double) source->columns-1.0; \n  extent[1].y=0.0; \n  extent[2].x=(double) source->columns-1.0; \n  extent[2].y=(double) source->rows-1.0; \n  extent[3].x=0.0; \n  extent[3].y=(double) source->rows-1.0; \n  for (i=0; i < 4; i++) \n  { \n    point=extent[i]; \n    extent[i].x=point.x*affine->sx+point.y*affine->ry+affine->tx; \n    extent[i].y=point.x*affine->rx+point.y*affine->sy+affine->ty; \n  } \n  min=extent[0]; \n  max=extent[0]; \n  for (i=1; i < 4; i++) \n  { \n    if (min.x > extent[i].x) \n      min.x=extent[i].x; \n    if (min.y > extent[i].y) \n      min.y=extent[i].y; \n    if (max.x < extent[i].x) \n      max.x=extent[i].x; \n    if (max.y < extent[i].y) \n      max.y=extent[i].y; \n  } \n   \n \n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse) \n    return(MagickFalse); \n  status=MagickTrue; \n  edge.x1=MagickMax(min.x,0.0); \n  edge.y1=MagickMax(min.y,0.0); \n  edge.x2=MagickMin(max.x,(double) image->columns-1.0); \n  edge.y2=MagickMin(max.y,(double) image->rows-1.0); \n  inverse_affine=InverseAffineMatrix(affine); \n  GetPixelInfo(image,&zero); \n  start=(ssize_t) ceil(edge.y1-0.5); \n  stop=(ssize_t) floor(edge.y2+0.5); \n  source_view=AcquireVirtualCacheView(source,exception); \n  image_view=AcquireAuthenticCacheView(image,exception); \n  for (y=start; y <= stop; y++) \n  { \n    PixelInfo \n      composite, \n      pixel; \n \n    PointInfo \n      point; \n \n    register ssize_t \n      x; \n \n    register Quantum \n      *restrict q; \n \n    SegmentInfo \n      inverse_edge; \n \n    ssize_t \n      x_offset; \n \n    inverse_edge=AffineEdge(source,&inverse_affine,(double) y,&edge); \n    if (inverse_edge.x2 < inverse_edge.x1) \n      continue; \n    q=GetCacheViewAuthenticPixels(image_view,(ssize_t) ceil(inverse_edge.x1- \n      0.5),y,(size_t) (floor(inverse_edge.x2+0.5)-ceil(inverse_edge.x1-0.5)+1), \n      1,exception); \n    if (q == (Quantum *) NULL) \n      continue; \n    pixel=zero; \n    composite=zero; \n    x_offset=0; \n    for (x=(ssize_t) ceil(inverse_edge.x1-0.5); x <= (ssize_t) floor(inverse_edge.x2+0.5); x++) \n    { \n      point.x=(double) x*inverse_affine.sx+y*inverse_affine.ry+ \n        inverse_affine.tx; \n      point.y=(double) x*inverse_affine.rx+y*inverse_affine.sy+ \n        inverse_affine.ty; \n      (void) InterpolatePixelInfo(source,source_view,UndefinedInterpolatePixel, \n        point.x,point.y,&pixel,exception); \n      GetPixelInfoPixel(image,q,&composite); \n      CompositePixelInfoOver(&pixel,pixel.alpha,&composite,composite.alpha, \n        &composite); \n      SetPixelInfoPixel(image,&composite,q); \n      x_offset++; \n      q+=GetPixelChannels(image); \n    } \n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse) \n      status=MagickFalse; \n  } \n  source_view=DestroyCacheView(source_view); \n  image_view=DestroyCacheView(image_view); \n  return(status); \n} ", "pred": " \nMagickExport MagickBooleanType DrawAffineImage(Image *image, \n  const Image *source,const AffineMatrix *affine,ExceptionInfo *exception) \n{ \n  AffineMatrix \n    inverse_affine; \n \n  CacheView \n    *image_view, \n    *source_view; \n \n  MagickBooleanType \n    status; \n \n  PixelInfo \n    zero; \n \n  PointInfo \n    extent[4], \n    min, \n    max, \n    point; \n \n  register ssize_t \n    i; \n \n  SegmentInfo \n    edge; \n \n  ssize_t \n    start, \n    stop, \n    y; \n \n   \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(source!= (const Image *) NULL); \n  assert(source->signature == MagickSignature); \n  assert(affine!= (AffineMatrix *) NULL); \n  extent[0].x=0.0; \n  extent[0].y=0.0; \n  extent[1].x=0.0; \n  extent[1].y=0.0; \n  extent[2].x=0.0; \n  extent[2].y=0.0; \n  extent[3].x=0.0; \n  extent[3].y=0.0; \n  inverse_affine=affine; \n  inverse_affine=InverseAffineMatrix(inverse_affine); \n  status=MagickTrue; \n \n  image_view=AcquireVirtualCacheView(image,exception); \n  source_view=AcquireVirtualCacheView(source,exception); \n  if (source_view == (CacheView *) NULL) \n    { \n      status=MagickFalse; \n      goto DrawAffineImageExit; \n    } \n  if (image_view->view == (CacheView *) NULL)\n    {\n      status=MagickFalse;\n      image=DestroyCacheView(image); \n      source=DestroyCacheView(source); \n      goto DrawAffineImageExit; \n    } \n  if (source_view->view == (CacheView *) NULL)\n    {\n      status=MagickFalse;\n      image=DestroyCacheView(image); \n      source=DestroyCacheView(source); \n      goto DrawAffineImageExit; \n    } \n  if (image->debug!= MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       "}
{"label": " \nMagickExport Image *MotionBlurImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  const double angle,ExceptionInfo *exception) \n{ \n#define BlurImageTag  \"Blur/Image\" \n \n  CacheView \n    *blur_view, \n    *image_view; \n \n  double \n    *kernel; \n \n  Image \n    *blur_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  OffsetInfo \n    *offset; \n \n  PointInfo \n    point; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  width=GetOptimalKernelWidth1D(radius,sigma); \n  kernel=GetMotionBlurKernel(width,sigma); \n  if (kernel == (double *) NULL) \n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n  offset=(OffsetInfo *) AcquireQuantumMemory(width,sizeof(*offset)); \n  if (offset == (OffsetInfo *) NULL) \n    { \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  blur_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (blur_image == (Image *) NULL) \n    { \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      offset=(OffsetInfo *) RelinquishMagickMemory(offset); \n      return((Image *) NULL); \n    } \n  if (SetImageStorageClass(blur_image,DirectClass) == MagickFalse) \n    { \n      kernel=(double *) RelinquishAlignedMemory(kernel); \n      offset=(OffsetInfo *) RelinquishMagickMemory(offset); \n      InheritException(exception,&blur_image->exception); \n      blur_image=DestroyImage(blur_image); \n      return((Image *) NULL); \n    } \n  point.x=(double) width*sin(DegreesToRadians(angle)); \n  point.y=(double) width*cos(DegreesToRadians(angle)); \n  for (i=0; i < (ssize_t) width; i++) \n  { \n    offset[i].x=(ssize_t) ceil((double) (i*point.y)/hypot(point.x,point.y)-0.5); \n    offset[i].y=(ssize_t) ceil((double) (i*point.x)/hypot(point.x,point.y)-0.5); \n  } \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(image,&bias); \n  image_view=AcquireVirtualCacheView(image,exception); \n  blur_view=AcquireAuthenticCacheView(blur_image,exception); \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    register IndexPacket \n      *restrict blur_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    q=GetCacheViewAuthenticPixels(blur_view,0,y,blur_image->columns,1, \n      exception); \n    if (q == (PixelPacket *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    blur_indexes=GetCacheViewAuthenticIndexQueue(blur_view); \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      MagickPixelPacket \n        qixel; \n \n      PixelPacket \n        pixel; \n \n      register const IndexPacket \n        *restrict indexes; \n \n      register double \n        *restrict k; \n \n      register ssize_t \n        i; \n \n      k=kernel; \n      qixel=bias; \n      if (((channel & OpacityChannel) == 0) || (image->matte == MagickFalse)) \n        { \n          for (i=0; i < (ssize_t) width; i++) \n          { \n            (void) GetOneCacheViewVirtualPixel(image_view,x+offset[i].x,y+ \n              offset[i].y,&pixel,exception); \n            qixel.red+=(*k)*pixel.red; \n            qixel.green+=(*k)*pixel.green; \n            qixel.blue+=(*k)*pixel.blue; \n            qixel.opacity+=(*k)*pixel.opacity; \n            if (image->colorspace == CMYKColorspace) \n              { \n                indexes=GetCacheViewVirtualIndexQueue(image_view); \n                qixel.index+=(*k)*(*indexes); \n              } \n            k++; \n          } \n          if ((channel & RedChannel)!= 0) \n            SetPixelRed(q,ClampToQuantum(qixel.red)); \n          if ((channel & GreenChannel)!= 0) \n            SetPixelGreen(q,ClampToQuantum(qixel.green)); \n          if ((channel & BlueChannel)!= 0) \n            SetPixelBlue(q,ClampToQuantum(qixel.blue)); \n          if ((channel & OpacityChannel)!= 0) \n            SetPixelOpacity(q,ClampToQuantum(qixel.opacity)); \n          if (((channel & IndexChannel)!= 0) && \n              (image->colorspace == CMYKColorspace)) \n            SetPixelIndex(blur_indexes+x,ClampToQuantum(qixel.index)); \n        } \n      else \n        { \n          double \n            alpha, \n            gamma; \n \n          alpha=0.0; \n          gamma=0.0; \n          for (i=0; i < (ssize_t) width; i++) \n          { \n            (void) GetOneCacheViewVirtualPixel(image_view,x+offset[i].x,y+ \n              offset[i].y,&pixel,exception); \n            alpha=(MagickRealType) (QuantumScale*GetPixelAlpha(&pixel)); \n            qixel.red+=(*k)*alpha*pixel.", "pred": " \nMagickExport Image *MotionBlurImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  const double angle,ExceptionInfo *exception) \n{ \n#define BlurImageTag  \"Blur/Image\" \n \n  CacheView \n    *blur_view, \n    *image_view; \n \n  double \n    *kernel; \n \n  Image \n    *blur_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  OffsetInfo \n    *offset; \n \n  PointInfo \n    point; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  width=GetOptimalKernelWidth1D(radius,sigma); \n  kernel=GetMotionBlurKernel(width,sigma); \n  if (kernel == (double *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse) \n    return((Image *) NULL); \n  blur_image=BlurImage(image,width,kernel,exception); \n  if (blur_image == (Image *) NULL)\n    return((Image *) NULL); \n  blur_view=AcquireVirtualCacheView(blur_image,exception); \n  image_view=AcquireAuthenticCacheView(image,exception); \n  offset=GetOffsetToPixels(blur_image,blur_image->rows,blur_image->columns); \n  if (offset == (OffsetInfo *) NULL)\n    {\n      blur_image=DestroyImage(blur_image);\n      return((Image *) NULL);\n    }\n  point.x=0; \n  point.y=0; \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point.x=(double) (offset->x+width); \n  point.y=(double) (offset->y+width); \n  point"}
{"label": " \nstatic int nn_(Sqrt_updateGradInput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor *gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  THTensor *output = luaT_getfieldcheckudata(L, 1, \"output\", torch_Tensor); \n  THTensor *gradInput = luaT_getfieldcheckudata(L, 1, \"gradInput\", torch_Tensor); \n \n  THTensor_(resizeAs)(gradInput, input); \n \n  if (output->nDimension == 1 ||  \n     !THTensor_(isContiguous)(output) ||  \n     !THTensor_(isContiguous)(gradOutput) || \n     !THTensor_(isContiguous)(gradInput)) \n  { \n    TH_TENSOR_APPLY3(real, gradInput, real, gradOutput, real, output,                       *gradInput_data = ((*output_data == 0.0)? 0.0 :                                          (0.5 * (*gradOutput_data / *output_data)));); \n  } \n  else \n  { \n    real* gradOutput_data = THTensor_(data)(gradOutput); \n    real* gradInput_data  = THTensor_(data)(gradInput); \n    real* output_data     = THTensor_(data)(output); \n    long i; \n    for(i = 0; i < THTensor_(nElement)(output); i++) \n      if (output_data[i] == 0.0) { \n        gradInput_data[i] = 0.0; \n      } else { \n        gradInput_data[i] = 0.5 * (gradOutput_data[i] / output_data[i]); \n      } \n  } \n  return 1; \n} ", "pred": " \nstatic int nn_(Sqrt_updateGradInput)(lua_State *L) \n{ \n  THTensor *input = luaT_checkudata(L, 2, torch_Tensor); \n  THTensor *gradOutput = luaT_checkudata(L, 3, torch_Tensor); \n  THTensor *output = luaT_getfieldcheckudata(L, 1, \"output\", torch_Tensor); \n  THTensor *gradInput = luaT_getfieldcheckudata(L, 1, \"gradInput\", torch_Tensor); \n \n  THTensor_(resizeAs)(gradInput, input); \n \n  if (output->nDimension == 1 ||  \n     !THTensor_(isContiguous)(output) ||  \n     !THTensor_(isContiguous)(gradOutput) || \n     !THTensor_(isContiguous)(gradInput)) \n  { \n    TH_TENSOR_APPLY3(real, gradInput, real, gradOutput, real, output,                       *gradInput_data = ((*output_data == 0.0)? 0.0 :                                                                                                                                                                                                                                                                       "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_sharpen_data_t *const data = (dt_iop_sharpen_data_t *)piece->data; \n  const int ch = piece->colors; \n  const int rad = MIN(MAXR, ceilf(data->radius * roi_in->scale / piece->iscale)); \n   \n \n   \n \n  if(rad == 0 || \n     (roi_out->width < 2 * rad + 1 || roi_out->height < 2 * rad + 1)) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, ch); \n    return; \n  } \n \n  float *restrict tmp; \n  if (!dt_iop_alloc_image_buffers(self, roi_in, roi_out, 1, &tmp, 0)) \n  { \n    dt_iop_copy_image_roi(ovoid, ivoid, ch, roi_in, roi_out, TRUE); \n    return; \n  } \n \n  const int wd = 2 * rad + 1; \n  const int wd4 = (wd & 3)? (wd >> 2) + 1 : wd >> 2; \n \n  const size_t mat_size = (size_t)4 * wd4; \n  float *const mat = dt_alloc_align_float(mat_size); \n  memset(mat, 0, sizeof(float) * mat_size); \n \n  const float sigma2 = (1.0f / (2.5 * 2.5)) * (data->radius * roi_in->scale / piece->iscale) \n                       * (data->radius * roi_in->scale / piece->iscale); \n  float weight = 0.0f; \n \n   \n \n  for(int l = -rad; l <= rad; l++) weight += mat[l + rad] = expf(-l * l / (2.f * sigma2)); \n  for(int l = -rad; l <= rad; l++) mat[l + rad] /= weight; \n \n \n \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    const float *in = ((float *)ivoid) + (size_t)ch * (j * roi_in->width + rad); \n    float *out = tmp + (size_t)j * roi_out->width + rad; \n    int i; \n    for(i = rad; i < roi_out->width - wd4 * 4 + rad; i++) \n    { \n      const float *inp = in - ch * rad; \n      __attribute__((aligned(64))) float sum[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; \n \n      for(int k = 0; k < wd4 * 4; k += 4, inp += 4 * ch) \n      { \n        for(int c = 0; c < 4; c++) \n        { \n          sum[c] += ((mat[k + c]) * (inp[ch * c])); \n        } \n      } \n      *out = sum[0] + sum[1] + sum[2] + sum[3]; \n      out++; \n      in += ch; \n    } \n    for(; i < roi_out->width - rad; i++) \n    { \n      const float *inp = in - ch * rad; \n      const float *m = mat; \n      float sum = 0.0f; \n      for(int k = -rad; k <= rad; k++, m++, inp += ch) \n      { \n        sum += *m * *inp; \n      } \n      *out = sum; \n      out++; \n      in += ch; \n    } \n  } \n \n \n \n  for(int j = rad; j < roi_out->height - wd4 * 4 + rad; j++) \n  { \n    const float *in = tmp + (size_t)j * roi_in->width; \n    float *out = ((float *)ovoid) + (size_t)ch * j * roi_out->width; \n \n    const int step = roi_in->width; \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      const float *inp = in - step * rad; \n      __attribute__((aligned(64))) float sum[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; \n \n      for(int k = 0; k < wd4 * 4; k += 4, inp += step * 4) \n      { \n        for(int c = 0; c < 4; c++) \n        { \n          sum[c] += ((mat[k + c]) * (inp[step * c])); \n        } \n      } \n      *out = sum[0] + sum[1] + sum[2] + sum[3]; \n      out += ch; \n      in++; \n    } \n  } \n  for(int j = roi_out->height - wd4 * 4 + rad; j < roi_out->height - rad; j++) \n  { \n    const float *in = tmp + (size_t)j * roi_in->width; \n    float *out = ((float *)ovoid) + (size_t)ch * j * roi_out->width; \n    const int step = roi_in->width; \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      const float *inp = in - step * rad; \n      const float *m = mat; \n      float sum = 0.0f; \n      for(int k = -rad; k <= rad; k++, m++, inp += step) sum += *m * *inp; \n      *out = sum; \n      out += ch; \n      in++; \n    } \n  } \n \n  dt_free_align(mat); \n \n   \n \n  for(int j = 0; j < rad; j++) \n    memcpy(((float *)ovoid) + (size_t)ch * j * roi_out->width, \n           ((float *)ivoid) + (size_t)ch * j * roi_in->width, (size_t)ch * sizeof(float) * roi_out->width); \n  for(int j = roi_out->height - rad; j < roi_out->height; j++) \n    memcpy(((float *)ovoid) + (size_t)ch * j * roi_out->width, \n           ((float *)ivoid) + (size_t)ch * j * roi_in->width, (size_t)ch * sizeof(float) * roi_out->width); \n \n  dt_free_align(tmp); \n \n  for(int j = rad; j < roi_out->height - rad; j++) \n  { \n    float *in = ((float *)ivoid) + (size_t)ch * roi_out->width * j; \n    float *out = ((float *)ovoid) + (size_t)ch * roi_out->width * j; \n    for(int i = 0; i < rad; i++) out[ch * i] = in[ch * i]; \n    for(int i = roi_out->width -", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_sharpen_data_t *const data = (dt_iop_sharpen_data_t *)piece->data; \n  const int ch = piece->colors; \n  const int rad = MIN(MAXR, ceilf(data->radius * roi_in->scale / piece->iscale)); \n   \n \n   \n \n  if(rad == 0 || \n     (roi_out->width < 2 * rad + 1 || roi_out->height < 2 * rad + 1)) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, ch); \n    return; \n  } \n \n  float *restrict tmp; \n  if (!dt_iop_alloc_image_buffers(self, roi_in, roi_out, 1, &tmp, 0)) \n  { \n    dt_iop_image_copy_by_size(ovoid, ivoid, roi_out->width, roi_out->height, ch); \n    return; \n  } \n  dt_aligned_pixel_t *restrict src = (dt_aligned_pixel_t *)tmp; \n  const int src_width = roi_in->width; \n  const int src_height = roi_in->height; \n  const int src_stride = roi_in->stride; \n  const int src_bpp = roi_in->bpp; \n  const int src_channels = roi_in->channels; \n  const int src_channel_step = roi_in->channel_step; \n  const int src_channel = roi_in->channel; \n  const int src_channel_max = roi_in->channel_max; \n  const int src_channel_min = roi_in->channel_min; \n  const int src_channel_max_clamped = roi_in->channel_max_clamped; \n  const int src_channel_min_clamped = roi_in->channel_min_clamped; \n  const int src_channel_max_clamped_v = roi_in->channel_max_clamped_v; \n  const int src_channel_min_clamped_v = roi_in->channel_min_clamped_v; \n  const int src_channel_max_clamped_h = roi_in->channel_max_clamped_h; \n  const int src_channel_min_clamped_h = roi_in->channel_min_clamped_h; \n  const int src_channel_max_clamped_v_h = roi_in->channel_max_clamped_v_h; \n  const int src_channel_min_clamped_v_h = roi_in->channel_min_clamped_v_h; \n  const int src_channel_max_clamped_h_v = roi_in->channel_max_clamped_h_v; \n  const int src_channel_min_clamped_h_v = roi_in->channel_min_clamped_h_v; \n  const int src_channel_max_clamped_v_h_v = roi_in->channel_max_clamped_v_h_v; \n  const int src_channel_min_clamped_v_h_v = roi_in->channel_min_clamped_v_h_v; \n  const int src_channel_max_clamped_h_v_v = roi_in->channel_max_clamped_h_v_v; \n  const int src_channel_min_clamped_h_v_v = roi_in->channel_min_clamped_h_v_v; \n  const int src_channel_max_clamped_v_h_v_v = roi_in->channel_max_clamped_v_h_v_v; \n  const int src_channel_min_clamped_v_h_v_v = roi_in->channel_min_clamped_v_h_v_v; \n  const int src_channel_max_clamped_h_v_v_v = roi_in->channel_max_clamped_h_v_v_v; \n  const int src_channel_min_clamped_h_v_v_v = roi_in->channel_min_clamped_h_v_v_v; \n  const int src_channel_max_clamped_h_v_v_v = roi_in->channel_max_clamped_h_v_v_v; \n  const int src_channel_min_clamped_h_v_v_v = roi_in->channel_min_clamped_h_v_v_v; \n  const int src_channel_max_clamped_h_v_v_v = roi_in->channel_max_clamped_h_v_v_v; \n  const int src_channel_min_clamped_h_v_v_v = roi_in->channel_min_clamped_h_v_v_v; \n  const int src_channel_max_clamped_h_v_v_v = roi_in->channel_max_clamped_h_v_v_v; \n  const int src_channel_min_clamped_h_v_v_v = roi_in->channel_min_clamped_h_v_v_v; \n  const int src_channel_max_clamped_h_v_v_v = roi_in->channel_max_clamped_h_v_v_v; \n  const int src_channel_min_clamped_h_v_v_v = roi_in->channel_min_clamped_h_v_v_v; \n  const int src_channel_max_clamped_h_v_v_v = roi_in->channel_max_clamped_h_v_v_v; \n  const int src_channel_min_clamped_h_v_v_v = roi_in->channel_min_clamped_h_v_v_v; \n  const int src_channel_max_clamped_h_v_v_v = roi_in->channel_max_clamped_h_v_v_v; \n  const int src_channel_min_clamped_h_v_v_v = roi_in->channel_min_clamped_h_v_v_v; \n  const int src_channel_max_clamped_h_v_v_v = roi_in->channel_max_clamped_h_v_v_v; \n  const int src_channel_min_clamped_h_v_v_v = roi_in->channel_min_clamped_h_v_v_v; \n  const int src_channel_max_clamped_h_v_v_v = roi_in->channel_max_clamped_h_v_v_v; \n  const int src_channel_min_clamped_h_v_v_v = roi_in->channel_min_clamped_h_v_v_v; \n  const int src_channel_max_clamped_h_v_v_v = roi_in->channel_max_clamped_h_v_v_v; \n  const int src_channel_min_clamped_h_v_v_v = roi_in->channel_min_clamped_h_v_v_v; \n  const int src_channel_max_clamped_h_v_v_v = roi_in->channel_max_clamped_h_v_v_v; \n  const int src_channel_min_clamped_h_v_v_v = roi_in->channel_min_clamped_h_v_v_v; \n  const int src_channel_max_clamped_h_v_v_v = roi_in->channel_max_clamped_h_v_v_v; \n  const int src_channel_min_clamped_h_v_v_v = roi_in->channel_min_clamped_h_v_v_v; \n  const int src_channel_max_clamped_h_v_v_v = roi_in->channel_max_clamped_h_v_v_v; \n  const int src_channel_min_clamped_h_v_v_v = roi_in->channel_min_clamped_h"}
{"label": " \nint main(int argc, char **argv) \n{ \n    int i, j, k; \n    int n = 2048; \n    int size, myid; \n \n      init_array(); \n     \n    MPI_Status stat; \n    int *argcVar = NULL; \n    char ***argvVar = NULL; \n    MPI_Init(argcVar, argvVar); \n    MPI_Comm_size(MPI_COMM_WORLD, &size); \n    MPI_Comm_rank(MPI_COMM_WORLD, &myid); \n    const int FTAG = 0; \n    const int ATAG = 1; \n    const int RTAG = 2; \n    const int WTAG = 3; \n    const int SWTAG = 4; \n    const int FRTAG = 5; \n    const int FWTAG = 6; \n    double timeStart = MPI_Wtime(); \n    double timeFinish; \n    int coordVector0[2]; \n    int partSize, offset; \n    for (i = 1; \n        i < n; \n        i++) \n    { \n        (partSize = (((i - (0))) / (size - 1)) > 0? ((((i - (0))) / (size - 1)) / 2) : 1); \n        if (myid == 0) \n        { \n            int followIN = 0; \n            int killed = 0; \n            for (int to = 1; \n                to < size; \n                ++to) \n            { \n                if ((followIN + partSize) < i) \n                { \n                    MPI_Send(&followIN, 1, MPI_INT, to, ATAG, MPI_COMM_WORLD); \n                    MPI_Send(&partSize, 1, MPI_INT, to, ATAG, MPI_COMM_WORLD); \n                    MPI_Send(&alpha, 1, MPI_DOUBLE, to, ATAG, MPI_COMM_WORLD); \n                    MPI_Send(&B[followIN], partSize * (2048), MPI_DOUBLE, to, ATAG, MPI_COMM_WORLD); \n                } \n                else \n                    if ((i - followIN) > 0) \n                    { \n                        (partSize = i - followIN); \n                        MPI_Send(&followIN, 1, MPI_INT, to, ATAG, MPI_COMM_WORLD); \n                        MPI_Send(&partSize, 1, MPI_INT, to, ATAG, MPI_COMM_WORLD); \n                        MPI_Send(&alpha, 1, MPI_DOUBLE, to, ATAG, MPI_COMM_WORLD); \n                        MPI_Send(&B[followIN], partSize * (2048), MPI_DOUBLE, to, ATAG, MPI_COMM_WORLD); \n                    } \n                    else \n                    { \n                        MPI_Send(&offset, 1, MPI_INT, to, FTAG, MPI_COMM_WORLD); \n                        killed++; \n                    } \n                followIN += partSize; \n            } \n            while (killed!= size - 1) \n            { \n                MPI_Recv(&partSize, 1, MPI_INT, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &stat); \n                int source = stat.MPI_SOURCE; \n                if (stat.MPI_TAG == RTAG) \n                { \n                    switch (partSize) \n                    { \n                        case 0 :  \n                        MPI_Send(&alpha, 1, MPI_DOUBLE, source, RTAG, MPI_COMM_WORLD); \n                        break; \n                        case 1 :  \n                        MPI_Recv(&coordVector0, 2, MPI_INT, source, RTAG, MPI_COMM_WORLD, &stat); \n                        MPI_Send(&B[coordVector0[0]][coordVector0[1]], 1, MPI_DOUBLE, source, RTAG, MPI_COMM_WORLD); \n                        break; \n                        case 2 :  \n                        MPI_Recv(&coordVector0, 2, MPI_INT, source, RTAG, MPI_COMM_WORLD, &stat); \n                        MPI_Send(&A[coordVector0[0]][coordVector0[1]], 1, MPI_DOUBLE, source, RTAG, MPI_COMM_WORLD); \n                        break; \n                    } \n                } \n                else \n                    if (stat.MPI_TAG == WTAG) \n                    { \n                        switch (partSize) \n                        { \n                            case 0 :  \n                 ", "pred": " \nint main(int argc, char **argv) \n{ \n    int i, j, k; \n    int n = 2048; \n    int size, myid; \n \n      init_array(); \n     \n    MPI_Status stat; \n    int *argcVar = NULL; \n    char ***argvVar = NULL; \n    MPI_Init(argcVar, argvVar); \n    MPI_Comm_size(MPI_COMM_WORLD, &size); \n    MPI_Comm_rank(MPI_COMM_WORLD, &myid); \n    const int FTAG = 0; \n    const int ATAG = 1; \n    const int RTAG = 2; \n    const int WTAG = 3; \n    const int SWTAG = 4; \n    const int FRTAG = 5; \n    const int FWTAG = 6; \n    double timeStart = MPI_Wtime(); \n    double timeFinish; \n    int coordVector0[2]; \n    int partSize, offset; \n    for (i = 1; \n        i < n; \n        i++) \n    { \n        coordVector0[0] = i; \n        coordVector0[1] = i; \n        partSize = 1; \n        offset = 0; \n        for (j = 0; \n            j < n; \n            j++) \n        { \n            coordVector0[0] = j; \n            partSize = partSize * size; \n            offset = offset + partSize; \n        } \n        MPI_Irecv(coordVector0, 2, MPI_INT, FTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, ATAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, RTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, WTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, SWTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, FRTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, FWTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, FWTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, FRTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, FRTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, FWTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, FWTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, FRTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, FRTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, FWTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, FWTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, FRTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, FRTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, FWTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, FWTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, FRTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, FRTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, FWTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, FWTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, FRTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, FRTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, FWTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, FWTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, FRTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, FRTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, FWTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, FWTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, FRTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0, 2, MPI_INT, FRTAG, 0, MPI_COMM_WORLD); \n        MPI_Wait(&stat, MPI_STATUS_IGNORE); \n        MPI_Recv(coordVector0, 2, MPI_INT, FWTAG, 0, MPI_COMM_WORLD, &stat); \n        MPI_Send(coordVector0,"}
{"label": " \nMagickExport Image *AdaptiveSharpenImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  ExceptionInfo *exception) \n{ \n#define AdaptiveSharpenImageTag  \"Convolve/Image\" \n#define MagickSigma  (fabs(sigma) < MagickEpsilon? MagickEpsilon : sigma) \n \n  CacheView \n    *sharp_view, \n    *edge_view, \n    *image_view; \n \n  double \n    **kernel, \n    normalize; \n \n  Image \n    *sharp_image, \n    *edge_image, \n    *gaussian_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    j, \n    k, \n    u, \n    v, \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  sharp_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (sharp_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (fabs(sigma) <= MagickEpsilon) \n    return(sharp_image); \n  if (SetImageStorageClass(sharp_image,DirectClass) == MagickFalse) \n    { \n      InheritException(exception,&sharp_image->exception); \n      sharp_image=DestroyImage(sharp_image); \n      return((Image *) NULL); \n    } \n   \n \n  edge_image=EdgeImage(image,radius,exception); \n  if (edge_image == (Image *) NULL) \n    { \n      sharp_image=DestroyImage(sharp_image); \n      return((Image *) NULL); \n    } \n  (void) LevelImage(edge_image,\"20%,95%\"); \n  gaussian_image=BlurImage(edge_image,radius,sigma,exception); \n  if (gaussian_image!= (Image *) NULL) \n    { \n      edge_image=DestroyImage(edge_image); \n      edge_image=gaussian_image; \n    } \n  (void) LevelImage(edge_image,\"10%,95%\"); \n   \n \n  width=GetOptimalKernelWidth2D(radius,sigma); \n  kernel=(double **) MagickAssumeAligned(AcquireAlignedMemory((size_t) width, \n    sizeof(*kernel))); \n  if (kernel == (double **) NULL) \n    { \n      edge_image=DestroyImage(edge_image); \n      sharp_image=DestroyImage(sharp_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n  (void) ResetMagickMemory(kernel,0,(size_t) width*sizeof(*kernel)); \n  for (i=0; i < (ssize_t) width; i+=2) \n  { \n    kernel[i]=(double *) MagickAssumeAligned(AcquireAlignedMemory((size_t) \n      (width-i),(width-i)*sizeof(**kernel))); \n    if (kernel[i] == (double *) NULL) \n      break; \n    normalize=0.0; \n    j=(ssize_t) (width-i-1)/2; \n    k=0; \n    for (v=(-j); v <= j; v++) \n    { \n      for (u=(-j); u <= j; u++) \n      { \n        kernel[i][k]=(double) (-exp(-((double) u*u+v*v)/(2.0*MagickSigma* \n          MagickSigma))/(2.0*MagickPI*MagickSigma*MagickSigma)); \n        normalize+=kernel[i][k]; \n        k++; \n      } \n    } \n    kernel[i][(k-1)/2]=(double) ((-2.0)*normalize); \n    if (sigma < MagickEpsilon) \n      kernel[i][(k-1)/2]=1.0; \n  } \n  if (i < (ssize_t) width) \n    { \n      for (i-=2; i >= 0; i-=2) \n        kernel[i]=(double *) RelinquishAlignedMemory(kernel[i]); \n      kernel=(double **) RelinquishAlignedMemory(kernel); \n      edge_image=DestroyImage(edge_image); \n      sharp_image=DestroyImage(sharp_image); \n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\"); \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(image,&bias); \n  SetMagickPixelPacketBias(image,&bias); \n  image_view=AcquireVirtualCacheView(image,exception); \n  edge_view=AcquireVirtualCacheView(edge_image,exception); \n  sharp_view=AcquireAuthenticCacheView(sharp_image,exception); \n  for (y=0; y < (ssize_t) sharp_image->rows; y++) \n  { \n    register const IndexPacket \n      *restrict indexes; \n \n    register const PixelPacket \n      *restrict p, \n      *restrict r; \n \n    register IndexPacket \n      *restrict sharp_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    r=GetCacheViewVirtualPixels(edge_view,0,y,edge_image->columns,1,exception); \n    q=QueueCacheViewAuthenticPixels(sharp_view,0,y,sharp_image->columns,1, \n      exception); \n    if ((r == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    sharp_indexes=GetCacheViewAuthenticIndexQueue(sharp_view); \n    for (x=0; x < (ssize_t) sharp_image->columns; x++) \n    { \n      double \n        alpha, \n        gamma; \n \n      DoublePixelPacket \n        pixel; \n \n      register const double \n        *restrict k; \n \n      register ssize_t \n        i, \n        u, \n        v; \n \n      gamma=0.0; \n      i=(ssize_t) ceil((double) width*(1.0-QuantumScale* \n        GetPixelIntensity(edge_image,r))-0.5); \n      if (i < 0) \n        i=0; \n      else \n        if (i > (ssize_t) width) \n          i=(ssize_t) width; \n      if ((i & 0x01)!= 0) \n        i--; \n      p=GetCacheViewVirtualPixels(image_view,x-((ssize_t) (width-i)/2L),y- \n        (ssize_t) ((width-i)/2L),width-i,width-i,exception); \n      if (p ==", "pred": " \nMagickExport Image *AdaptiveSharpenImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  ExceptionInfo *exception) \n{ \n#define AdaptiveSharpenImageTag  \"Convolve/Image\" \n#define MagickSigma  (fabs(sigma) < MagickEpsilon? MagickEpsilon : sigma) \n \n  CacheView \n    *sharp_view, \n    *edge_view, \n    *image_view; \n \n  double \n    **kernel, \n    normalize; \n \n  Image \n    *sharp_image, \n    *edge_image, \n    *gaussian_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  register ssize_t \n    i; \n \n  size_t \n    width; \n \n  ssize_t \n    j, \n    k, \n    u, \n    v, \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  width=GetOptimalKernelWidth2(radius,sigma); \n  if (width < 2)\n    return((Image *) NULL);\n  edge_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (edge_image == (Image *) NULL)\n    return((Image *) NULL);\n  edge_view=AcquireVirtualCacheView(edge_image,exception); \n  sharp_view=AcquireAuthenticCacheView(image,exception); \n  gaussian_image=GaussianBlurImage(edge_image,width,sigma,exception); \n  if (gaussian_image == (Image *) NULL)\n    {\n      edge_view=DestroyCacheView(edge_view);\n      edge_image=DestroyImage(edge_image);\n      return((Image *) NULL);\n    }\n  edge_image->alpha_trait=BlendPixelTrait;\n  edge_image->depth=8;\n  edge_image->storage_class=DirectClass;\n  edge_image->colors=4;\n  edge_image->colors=edge_image->colors;\n  edge_image->alpha_trait=BlendPixelTrait;\n  edge_image->alpha_trait=BlendPixelTrait;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->background_color.alpha=MagickFalse;\n  edge_image->background_color.alpha_trait=BlendPixelTrait;\n  edge_image->background_color.alpha_sample_bits=8;\n  edge_image->background_color.red=QuantumRange;\n  edge_image->background_color.green=QuantumRange;\n  edge_image->background_color.blue=QuantumRange;\n  edge_image->background_color.black=MagickFalse;\n  edge_image->background_color.alpha=QuantumRange;\n  edge_image->background_color.pixel=QuantumRange;\n  edge_image->background_color.type=GrayscaleType;\n  edge_image->background_color.colorspace=GrayscaleColorspace;\n  edge_image->background_color.alpha_trait=BlendPixelTrait;\n  edge_image->background_color.alpha_sample_bits=8;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page.width=width;\n  edge_image->page.height=width;\n  edge_image->page.x=0;\n  edge_image->page.y=0;\n  edge_image->page"}
{"label": " \nstatic int _gradient_get_points(dt_develop_t *dev, float x, float y, float rotation, float curvature, \n                                float **points, int *points_count) \n{ \n  *points = NULL; \n  *points_count = 0; \n \n  const float wd = dev->preview_pipe->iwidth; \n  const float ht = dev->preview_pipe->iheight; \n  const float scale = sqrtf(wd * wd + ht * ht); \n  const float distance = 0.1f * fminf(wd, ht); \n \n  const float v = (-rotation / 180.0f) * M_PI; \n  const float cosv = cosf(v); \n  const float sinv = sinf(v); \n \n  const int count = sqrtf(wd * wd + ht * ht) + 3; \n  *points = dt_alloc_align_float((size_t)2 * count); \n  if(*points == NULL) return 0; \n \n   \n \n  (*points)[0] = x * wd; \n  (*points)[1] = y * ht; \n \n   \n \n  const float v1 = (-(rotation - 90.0f) / 180.0f) * M_PI; \n  const float x1 = x * wd + distance * cosf(v1); \n  const float y1 = y * ht + distance * sinf(v1); \n  (*points)[2] = x1; \n  (*points)[3] = y1; \n  const float v2 = (-(rotation + 90.0f) / 180.0f) * M_PI; \n  const float x2 = x * wd + distance * cosf(v2); \n  const float y2 = y * ht + distance * sinf(v2); \n  (*points)[4] = x2; \n  (*points)[5] = y2; \n \n  const int nthreads = omp_get_max_threads(); \n  size_t c_padded_size; \n  uint32_t *pts_count = dt_calloc_perthread(nthreads, sizeof(uint32_t), &c_padded_size); \n  float *const restrict pts = dt_alloc_align_float((size_t)2 * count * nthreads); \n \n   \n \n  const float xstart = fabsf(curvature) > 1.0f? -sqrtf(1.0f / fabsf(curvature)) : -1.0f; \n  const float xdelta = -2.0f * xstart / (count - 3); \n \n \n \n  for(int i = 3; i < count; i++) \n  { \n    const float xi = xstart + (i - 3) * xdelta; \n    const float yi = curvature * xi * xi; \n    const float xii = (cosv * xi + sinv * yi) * scale; \n    const float yii = (sinv * xi - cosv * yi) * scale; \n    const float xiii = xii + x * wd; \n    const float yiii = yii + y * ht; \n \n     \n \n     \n \n    if(!(xiii < -wd || xiii > 2 * wd || yiii < -ht || yiii > 2 * ht)) \n    { \n      const int thread = omp_get_thread_num(); \n      uint32_t *tcount = dt_get_perthread(pts_count, c_padded_size); \n      pts[(thread * count) + *tcount * 2]     = xiii; \n      pts[(thread * count) + *tcount * 2 + 1] = yiii; \n      (*tcount)++; \n    } \n  } \n \n  *points_count = 3; \n  for(int thread = 0; thread < nthreads; thread++) \n  { \n    const uint32_t tcount = *(uint32_t *)dt_get_bythread(pts_count, c_padded_size, thread); \n    for(int k = 0; k < tcount; k++) \n    { \n      (*points)[(*points_count) * 2]     = pts[(thread * count) + k * 2]; \n      (*points)[(*points_count) * 2 + 1] = pts[(thread * count) + k * 2 + 1]; \n      (*points_count)++; \n    } \n  } \n \n  dt_free_align(pts_count); \n  dt_free_align(pts); \n \n   \n \n  if(dt_dev_distort_transform(dev, *points, *points_count)) return 1; \n \n   \n \n  dt_free_align(*points); \n  *points = NULL; \n  *points_count = 0; \n  return 0; \n} ", "pred": " \nstatic int _gradient_get_points(dt_develop_t *dev, float x, float y, float rotation, float curvature, \n                                float **points, int *points_count) \n{ \n  *points = NULL; \n  *points_count = 0; \n \n  const float wd = dev->preview_pipe->iwidth; \n  const float ht = dev->preview_pipe->iheight; \n  const float scale = sqrtf(wd * wd + ht * ht); \n  const float distance = 0.1f * fminf(wd, ht); \n \n  const float v = (-rotation / 180.0f) * M_PI; \n  const float cosv = cosf(v); \n  const float sinv = sinf(v); \n \n  const int count = sqrtf(wd * wd + ht * ht) + 3; \n  *points = dt_alloc_align_float((size_t)2 * count); \n  if(*points == NULL) return 0; \n \n   \n \n  (*points)[0] = x * wd; \n  (*points)[1] = y * ht; \n \n   \n \n  const float v1 = cosv * distance; \n  const float v2 = sinv * distance; \n  const float v3 = v1 * v1; \n  const float v4 = v2 * v2; \n  const float v5 = v3 * v3; \n  const float v6 = v4 * v4; \n  const float v7 = v5 * v5; \n  const float v8 = v6 * v6; \n  const float v9 = v7 * v7; \n  const float v10 = v8 * v8; \n  const float v11 = v9 * v9; \n  const float v12 = v10 * v10; \n  const float v13 = v11 * v11; \n  const float v14 = v12 * v12; \n  const float v15 = v13 * v13; \n  const float v16 = v14 * v14; \n  const float v17 = v15 * v15; \n  const float v18 = v16 * v16; \n  const float v19 = v17 * v17; \n  const float v20 = v18 * v18; \n  const float v21 = v19 * v19; \n  const float v22 = v20 * v20; \n  const float v23 = v21 * v21; \n  const float v24 = v22 * v22; \n  const float v25 = v23 * v23; \n  const float v26 = v24 * v24; \n  const float v27 = v25 * v25; \n  const float v28 = v26 * v26; \n  const float v29 = v27 * v27; \n  const float v30 = v28 * v28; \n  const float v31 = v29 * v29; \n  const float v32 = v30 * v30; \n  const float v33 = v31 * v31; \n  const float v34 = v32 * v32; \n  const float v35 = v33 * v33; \n  const float v36 = v34 * v34; \n  const float v37 = v35 * v35; \n  const float v38 = v36 * v36; \n  const float v39 = v37 * v37; \n  const float v40 = v38 * v38; \n  const float v41 = v39 * v39; \n  const float v42 = v40 * v40; \n  const float v43 = v41 * v41; \n  const float v44 = v42 * v42; \n  const float v45 = v43 * v43; \n  const float v46 = v44 * v44; \n  const float v47 = v45 * v45; \n  const float v48 = v46 * v46; \n  const float v49 = v47 * v47; \n  const float v50 = v48 * v48; \n  const float v51 = v49 * v49; \n  const float v52 = v50 * v50; \n  const float v53 = v51 * v51; \n  const float v54 = v52 * v52; \n  const float v55 = v53 * v53; \n  const float v56 = v54 * v54; \n  const float v57 = v55 * v55; \n  const float v58 = v56 * v56; \n  const float v59 = v57 * v57; \n  const float v60 = v58 * v58; \n  const float v61 = v59 * v59; \n  const float v62 = v60 * v60; \n  const float v63 = v61 * v61; \n  const float v64 = v62 * v62; \n  const float v65 = v63 * v63; \n  const float v66 = v64 * v64; \n  const float v67 = v65 * v65; \n  const float v68 = v66 * v66; \n  const float v69 = v67 * v67; \n  const float v70 = v68 * v68; \n"}
{"label": " \nMagickExport Image *UnsharpMaskImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  const double gain,const double threshold,ExceptionInfo *exception) \n{ \n#define SharpenImageTag  \"Sharpen/Image\" \n \n  CacheView \n    *image_view, \n    *unsharp_view; \n \n  Image \n    *unsharp_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  MagickRealType \n    quantum_threshold; \n \n  ssize_t \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  unsharp_image=BlurImageChannel(image,channel &~ SyncChannels,radius,sigma, \n    exception); \n  if (unsharp_image == (Image *) NULL) \n    return((Image *) NULL); \n  quantum_threshold=(MagickRealType) QuantumRange*threshold; \n   \n \n  status=MagickTrue; \n  progress=0; \n  GetMagickPixelPacket(image,&bias); \n  image_view=AcquireVirtualCacheView(image,exception); \n  unsharp_view=AcquireAuthenticCacheView(unsharp_image,exception); \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    DoublePixelPacket \n      pixel; \n \n    register const IndexPacket \n      *restrict indexes; \n \n    register const PixelPacket \n      *restrict p; \n \n    register IndexPacket \n      *restrict unsharp_indexes; \n \n    register PixelPacket \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    q=GetCacheViewAuthenticPixels(unsharp_view,0,y,unsharp_image->columns,1, \n      exception); \n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    indexes=GetCacheViewVirtualIndexQueue(image_view); \n    unsharp_indexes=GetCacheViewAuthenticIndexQueue(unsharp_view); \n    pixel.red=bias.red; \n    pixel.green=bias.green; \n    pixel.blue=bias.blue; \n    pixel.opacity=bias.opacity; \n    pixel.index=bias.index; \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      if ((channel & RedChannel)!= 0) \n        { \n          pixel.red=GetPixelRed(p)-(MagickRealType) GetPixelRed(q); \n          if (fabs(2.0*pixel.red) < quantum_threshold) \n            pixel.red=(MagickRealType) GetPixelRed(p); \n          else \n            pixel.red=(MagickRealType) GetPixelRed(p)+(pixel.red*gain); \n          SetPixelRed(q,ClampToQuantum(pixel.red)); \n        } \n      if ((channel & GreenChannel)!= 0) \n        { \n          pixel.green=GetPixelGreen(p)-(MagickRealType) q->green; \n          if (fabs(2.0*pixel.green) < quantum_threshold) \n            pixel.green=(MagickRealType) GetPixelGreen(p); \n          else \n            pixel.green=(MagickRealType) GetPixelGreen(p)+(pixel.green*gain); \n          SetPixelGreen(q,ClampToQuantum(pixel.green)); \n        } \n      if ((channel & BlueChannel)!= 0) \n        { \n          pixel.blue=GetPixelBlue(p)-(MagickRealType) q->blue; \n          if (fabs(2.0*pixel.blue) < quantum_threshold) \n            pixel.blue=(MagickRealType) GetPixelBlue(p); \n          else \n            pixel.blue=(MagickRealType) GetPixelBlue(p)+(pixel.blue*gain); \n          SetPixelBlue(q,ClampToQuantum(pixel.blue)); \n        } \n      if ((channel & OpacityChannel)!= 0) \n        { \n          pixel.opacity=GetPixelOpacity(p)-(MagickRealType) q->opacity; \n          if (fabs(2.0*pixel.opacity) < quantum_threshold) \n            pixel.opacity=(MagickRealType) GetPixelOpacity(p); \n          else \n            pixel.opacity=GetPixelOpacity(p)+(pixel.opacity*gain); \n          SetPixelOpacity(q,ClampToQuantum(pixel.opacity)); \n        } \n      if (((channel & IndexChannel)!= 0) && \n          (image->colorspace == CMYKColorspace)) \n        { \n          pixel.index=GetPixelIndex(indexes+x)-(MagickRealType) \n            GetPixelIndex(unsharp_indexes+x); \n          if (fabs(2.0*pixel.index) < quantum_threshold) \n            pixel.index=(MagickRealType) GetPixelIndex(indexes+x); \n          else \n            pixel.index=(MagickRealType) GetPixelIndex(indexes+x)+ \n              (pixel.index*gain); \n          SetPixelIndex(unsharp_indexes+x,ClampToQuantum(pixel.index)); \n        } \n      p++; \n      q++; \n    } \n    if (SyncCacheViewAuthenticPixels(unsharp_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        proceed=SetImageProgress(image,SharpenImageTag,progress++,image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  } \n  unsharp_image->type=image->type; \n  unsharp_view=DestroyCacheView(unsharp_view); \n  image_view=DestroyCacheView(image_view); \n  if (status == MagickFalse) \n    unsharp_image=DestroyImage(unsharp_image); \n  return(unsharp_image); \n} ", "pred": " \nMagickExport Image *UnsharpMaskImageChannel(const Image *image, \n  const ChannelType channel,const double radius,const double sigma, \n  const double gain,const double threshold,ExceptionInfo *exception) \n{ \n#define SharpenImageTag  \"Sharpen/Image\" \n \n  CacheView \n    *image_view, \n    *unsharp_view; \n \n  Image \n    *unsharp_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickPixelPacket \n    bias; \n \n  MagickRealType \n    quantum_threshold; \n \n  ssize_t \n    y; \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  unsharp_image=BlurImageChannel(image,channel &~ SyncChannels,radius,sigma, \n    exception); \n  if (unsharp_image == (Image *) NULL) \n    return((Image *) NULL); \n  quantum_threshold=(MagickRealType) QuantumRange; \n \n  if (threshold < 0.0) \n    threshold=quantum_threshold; \n \n  status=MagickTrue; \n \n  progress=0; \n \n  image_view=AcquireVirtualCacheView(image,exception); \n  unsharp_view=AcquireAuthenticCacheView(unsharp_image,exception); \n  bias=ConstantPixelChannel; \n \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    register const Quantum\n      *magick_restrict p; \n \n    register ssize_t\n      x;\n \n    if (status == MagickFalse)\n      continue;\n \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "}
{"label": " \nint main (int argc, char* argv[])  \n{ \n     \n \n    char* corUnit; \n    char* unit; \n \n    int zoSize, dataSize, tNumRed; \n    float *zo, *zoSq, *semb, *data; \n    int *count; \n    int iv, is, ir, ip, forDataInd, it, tInd, dataInd, indZO; \n    float vel, shotPos, curOffset, halfOffset, fabsOffset, offsetSq; \n    float curPos, l0, forA, t0, a, t, forLim, limitLeft, limitRight; \n    float bef, aft, sample, sampleSq, sqSample, curSemb; \n    int ic, iw, ts, ind, totalCount, offset, vwhalf; \n \n \n \n    sf_init (argc,argv); \n \n \n \n    dataFile = sf_input (\"in\"); \n     \n \n    outFile  = sf_output(\"out\"); \n     \n \n \n    if ( NULL!= sf_getstring(\"aux\") ) { \n\t \n  \n\tauxFile  = sf_output (\"aux\"); \n    } else { \n\tsf_error (\"Need output: partial zero-offset sections\"); \n    } \n \n     \n \n \n    if (!sf_histint   (dataFile, \"n1\", &tNum_)   ) sf_error (\"Need n1= in input\"); \n    if (!sf_histfloat (dataFile, \"d1\", &tStep_)  ) sf_error (\"Need d1= in input\"); \n    if (!sf_histfloat (dataFile, \"o1\", &tStart_) ) sf_error (\"Need o1= in input\"); \n \n    if (!sf_histint   (dataFile, \"n2\", &recNum_)   ) sf_error (\"Need n2= in input\"); \n    if (!sf_histfloat (dataFile, \"d2\", &recStep_)  ) sf_error (\"Need d2= in input\"); \n    if (!sf_histfloat (dataFile, \"o2\", &recStart_) ) sf_error (\"Need o2= in input\"); \n \n    if (!sf_histint   (dataFile, \"n3\", &shotNum_)   ) sf_error (\"Need n3= in input\"); \n    if (!sf_histfloat (dataFile, \"d3\", &shotStep_)  ) sf_error (\"Need d3= in input\"); \n    if (!sf_histfloat (dataFile, \"o3\", &shotStart_) ) sf_error (\"Need o3= in input\"); \n \n \n \n \n \n \n \n \n\t \n     \n \n     \n \n \n \n \n \n     \n \n    corUnit = (char*) \"m\"; unit = sf_histstring (dataFile, \"unit2\"); if (!unit) sf_error (\"unit2 in data file is not defined\"); \n    if ( strcmp (corUnit, unit) ) { recStep_ *= 1000; recStart_ *= 1000; } \n     \n \n    corUnit = (char*) \"m\"; unit = sf_histstring (dataFile, \"unit3\"); if (!unit) sf_error (\"unit3 in data file is not defined\"); \n    if ( strcmp (corUnit, unit) ) { shotStep_ *= 1000; shotStart_ *= 1000; } \n \n     \n \n     \n \n \n \n \n    if (!sf_getfloat (\"po\",    &pStart_) ) pStart_ = shotStart_; \n     \n \n    if (!sf_getint (\"pn\", &pNum_) ) pNum_ = recNum_; \n     \n \n    if (!pNum_) {sf_warning (\"vn value is changed to 1\"); pNum_ = recNum_;} \n    if (!sf_getfloat (\"pd\",    &pStep_) ) pStep_ = recStep_; \n     \n \n    if (!pStep_) {sf_warning (\"pd value is changed to 50\"); pStep_ = recStep_;} \n \n \n    if (!sf_getint (\"vn\",    &vNum_) ) vNum_ = 1; \n     \n \n    if (!vNum_) {sf_warning (\"vn value is changed to 1\"); vNum_ = 1;} \n    if (!sf_getfloat (\"vo\",    &vStart_) ) vStart_ = 1500; \n     \n \n    if (!vStart_) {sf_warning (\"vn value is changed to 1500\"); vStart_ = 1500.0;} \n    if (!sf_getfloat (\"vd\",    &vStep_) ) vStep_ = 50; \n     \n \n    if (!vStep_) {sf_warning (\"vd value is changed to 50\"); vStep_ = 50.f;} \n \n    if (!sf_getint (\"wh\",   &wh_) )   wh_ = 11; \n     \n \n    if (!wh_) {sf_warning (\"vertical window size is changed to 1\"); wh_ = 1;} \n \n    sf_putint    (outFile, \"n1\", tNum_); \n    sf_putint    (outFile, \"n2\", pNum_); \n    sf_putint    (outFile, \"n3\", vNum_); \n    sf_putfloat  (outFile, \"d1\", tStep_);  \n    sf_putfloat  (outFile, \"d2\", pStep_); \n    sf_putint    (outFile, \"d3\", vStep_); \n    sf_putfloat  (outFile, \"o1\", tStart_);  \n    sf_putfloat  (outFile, \"o2\", pStart_); \n    sf_putfloat  (outFile, \"o3\", vStart_); \n    sf_putstring (outFile, \"label1\", \"time\"); sf_putstring(outFile, \"label2\", \"inline\"); sf_putstring(outFile, \"label3\", \"velocity\"); \n    sf_putstring(outFile, \"unit3\", \"m/s\"); \n \n    sf_putint    (auxFile, \"n1\", tNum_); \n    sf_putint    (auxFile, \"n2\", pNum_); \n    sf_putint    (auxFile, \"n3\", vNum_); \n    sf_putfloat  (auxFile, \"d1\", tStep_);  \n    sf_putfloat  (auxFile, \"d2\", pStep_); \n    sf_putint    (auxFile, \"d3\", vStep_); \n    sf_putfloat  (auxFile, \"o1\", tStart_);  \n    sf_putfloat  (auxFile, \"o2\", pStart_); \n    sf_putfloat  (auxFile, \"o3\", vStart_); \n    sf_putstring (auxFile, \"label1\", \"time\"); sf_putstring (auxFile, \"label2\", \"inline\"); sf_putstring (auxFile, \"label3\", \"velocity\"); \n    sf_putstring (auxFile, \"unit3\", \"m/s\"); \n \n    zoSize = pNum_ * tNum_; \n    dataSize = shotNum_ * recNum_ * tNum_; \n    tNumRed = tNum_ - 2; \n\t \n    zo    = sf_floatalloc (zoSize); \n    zoSq  = sf_floatalloc (zoSize); \n    semb  = sf_floatalloc (zoSize); \n    count = sf_intalloc (zoSize); \n \n    data = sf_floatalloc (dataSize); \n    sf_floatread (data, dataSize, dataFile); \n \n    for (iv = 0; iv < vNum_; ++iv) { \n \n\tvel = vStart_ + iv * vStep_; \n     \n\tmemset ( zo,    0, zoSize * sizeof (float) );    \n\tmemset ( zoSq,  0, zoSize * sizeof (float) );    \n\tmemset ( semb,  0, zoSize * sizeof (float) );", "pred": " \nint main (int argc, char* argv[])  \n{ \n     \n \n    char* corUnit; \n    char* unit; \n \n    int zoSize, dataSize, tNumRed; \n    float *zo, *zoSq, *semb, *data; \n    int *count; \n    int iv, is, ir, ip, forDataInd, it, tInd, dataInd, indZO; \n    float vel, shotPos, curOffset, halfOffset, fabsOffset, offsetSq; \n    float curPos, l0, forA, t0, a, t, forLim, limitLeft, limitRight; \n    float bef, aft, sample, sampleSq, sqSample, curSemb; \n    int ic, iw, ts, ind, totalCount, offset, vwhalf; \n \n \n \n    sf_init (argc,argv); \n \n \n \n    dataFile = sf_input (\"in\"); \n     \n \n    outFile  = sf_output(\"out\"); \n     \n \n \n    if ( NULL!= sf_getstring(\"aux\") ) { \n\t \n  \n\tauxFile  = sf_output (\"aux\"); \n    } \n \n \n    if ( NULL!= sf_getstring(\"corUnit\") ) { \n\t \n  \n\tcorUnit = sf_output (\"corUnit\"); \n    } \n \n \n    if ( NULL!= sf_getstring(\"unit\") ) { \n\t \n  \n\tunit = sf_output (\"unit\"); \n    } \n \n \n    if ( NULL!= sf_getstring(\"zoSize\") ) { \n\t \n  \n\tzoSize = sf_output (\"zoSize\"); \n    } \n \n \n    if ( NULL!= sf_getstring(\"dataSize\") ) { \n\t \n  \n\tdataSize = sf_output (\"dataSize\"); \n    } \n \n \n    if ( NULL!= sf_getstring(\"tNumRed\") ) { \n\t \n  \n\ttNumRed = sf_output (\"tNumRed\"); \n    } \n \n \n    if ( NULL!= sf_getstring(\"zo\") ) { \n\t \n  \n\tzo = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"zoSq\") ) { \n\t \n  \n\tzoSq = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"semb\") ) { \n\t \n  \n\tsemb = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"data\") ) { \n\t \n  \n\tdata = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"count\") ) { \n\t \n  \n\tcount = sf_intalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"indZO\") ) { \n\t \n  \n\tindZO = sf_intalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"vel\") ) { \n\t \n  \n\tvel = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"shotPos\") ) { \n\t \n  \n\tshotPos = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"curOffset\") ) { \n\t \n  \n\tcurOffset = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"halfOffset\") ) { \n\t \n  \n\thalfOffset = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"fabsOffset\") ) { \n\t \n  \n\tfabsOffset = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"offsetSq\") ) { \n\t \n  \n\toffsetSq = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"curSemb\") ) { \n\t \n  \n\tcurSemb = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"forDataInd\") ) { \n\t \n  \n\tforDataInd = sf_intalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"it\") ) { \n\t \n  \n\tit = sf_intalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"t\") ) { \n\t \n  \n\tt = sf_intalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"forLim\") ) { \n\t \n  \n\tforLim = sf_intalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"limitLeft\") ) { \n\t \n  \n\tlimitLeft = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"limitRight\") ) { \n\t \n  \n\tlimitRight = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"bef\") ) { \n\t \n  \n\tbef = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"aft\") ) { \n\t \n  \n\taft = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"sample\") ) { \n\t \n  \n\tsample = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"sampleSq\") ) { \n\t \n  \n\tsampleSq = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"sqSample\") ) { \n\t \n  \n\tsqSample = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"curPos\") ) { \n\t \n  \n\tcurPos = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"l0\") ) { \n\t \n  \n\tl0 = sf_floatalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"forA\") ) { \n\t \n  \n\tforA = sf_intalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"t0\") ) { \n\t \n  \n\tt0 = sf_intalloc (sf_n(dataSize)*sf_n(tNumRed)); \n    } \n \n \n    if ( NULL!= sf_getstring(\"forLim\") ) { \n\t \n  \n\tforLim = sf_intalloc (sf_n(dataSize)*sf"}
{"label": " \nvoid THNN_(SpatialAdaptiveAveragePooling_updateOutput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *output, \n          int owidth, \n          int oheight) \n{ \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  long nslices; \n  long iheight; \n  long iwidth; \n \n  long istride_d; \n  long istride_h; \n  long istride_w; \n  long istride_b; \n \n  real *input_data; \n  real *output_data; \n \n \n  THNN_ARGCHECK(input->nDimension == 3 || input->nDimension == 4, 2, input, \n\t\t\"3D or 4D (batch mode) tensor expected for input, but got: %s\"); \n \n  if (input->nDimension == 4) \n  { \n    istride_b = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n   \n \n  nslices = input->size[dimh-1]; \n  iheight = input->size[dimh]; \n  iwidth = input->size[dimw]; \n   \n \n  istride_d = input->stride[dimh-1]; \n  istride_h = input->stride[dimh]; \n  istride_w = input->stride[dimw]; \n \n   \n \n  if (input->nDimension == 3) \n  { \n    THTensor_(resize3d)(output, nslices, oheight, owidth); \n \n    input_data = THTensor_(data)(input); \n    output_data = THTensor_(data)(output); \n \n    THNN_(SpatialAdaptiveAveragePooling_updateOutput_frame)(input_data, output_data, \n                                                      nslices, \n                                                      iwidth, iheight, \n                                                      owidth, oheight, \n                                                      istride_w,istride_h, \n                                                      istride_d); \n  } \n  else \n  { \n    long p; \n \n    THTensor_(resize4d)(output, nbatch, nslices, oheight, owidth); \n \n    input_data = THTensor_(data)(input); \n    output_data = THTensor_(data)(output); \n \n    for (p = 0; p < nbatch; p++) \n    { \n      THNN_(SpatialAdaptiveAveragePooling_updateOutput_frame)(input_data+p*istride_b, output_data+p*nslices*owidth*oheight, \n                                                        nslices, \n                                                        iwidth, iheight, \n                                                        owidth, oheight, \n                                                        istride_w,istride_h, \n                                                        istride_d); \n    } \n  } \n} ", "pred": " \nvoid THNN_(SpatialAdaptiveAveragePooling_updateOutput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *output, \n          int owidth, \n          int oheight) \n{ \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  long nslices; \n  long iheight; \n  long iwidth; \n \n  long istride_d; \n  long istride_h; \n  long istride_w; \n  long istride_b; \n \n  real *input_data; \n  real *output_data; \n \n \n  THNN_ARGCHECK(input->nDimension == 3 || input->nDimension == 4, 2, input, \n\t\t\"3D or 4D (batch mode) tensor expected for input, but got: %s\"); \n \n  if (input->nDimension == 4) \n  { \n    istride_b = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 3) \n  { \n    istride_d = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 2) \n  { \n    istride_w = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 1) \n  { \n    istride_h = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 2) \n  { \n    istride_w = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 1) \n  { \n    istride_h = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 2) \n  { \n    istride_w = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 1) \n  { \n    istride_h = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 2) \n  { \n    istride_w = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 1) \n  { \n    istride_h = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 2) \n  { \n    istride_w = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 1) \n  { \n    istride_h = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 2) \n  { \n    istride_w = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 1) \n  { \n    istride_h = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 2) \n  { \n    istride_w = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 1) \n  { \n    istride_h = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n  if (input->nDimension == 2) \n  { \n    istride_w = input->stride[0]; \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  }"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n\tputs(\"\\e[0;34m==>\\e[0m Reading in values from the matrix files...\"); \n \n\tdouble matrix1[MATRIX_SIZE][MATRIX_SIZE], \n\t       matrix2[MATRIX_SIZE][MATRIX_SIZE], \n\t       real_product[MATRIX_SIZE][MATRIX_SIZE], \n\t       calc_product[MATRIX_SIZE][MATRIX_SIZE]; \n \n\t{ \n\t\tFILE *matrix1_file = fopen(MATRIX_1, \"r\"), \n\t\t     *matrix2_file = fopen(MATRIX_2, \"r\"), \n\t\t     *product_file = fopen(PRODUCT,  \"r\"); \n \n\t\tfor (int i = 0; i < MATRIX_SIZE; ++i) \n\t\t{ \n\t\t\tfor (int j = 0; j < MATRIX_SIZE; ++j) \n\t\t\t{ \n\t\t\t\tfscanf(matrix1_file, \"%lf\", &matrix1[i][j]); \n\t\t\t\tfscanf(matrix2_file, \"%lf\", &matrix2[i][j]); \n\t\t\t\tfscanf(product_file, \"%lf\", &real_product[i][j]); \n\t\t\t} \n\t\t} \n \n\t\tfclose(matrix1_file); \n\t\tfclose(matrix2_file); \n\t\tfclose(product_file); \n\t} \n \n\tint block_size  = 4; \n \n\tif (argc > 1) \n\t{ \n\t\tblock_size = atoi(argv[1]); \n \n\t\tif (MATRIX_SIZE % block_size!= 0) \n\t\t{ \n\t\t\tprintf(\"\\e[0;31m==> %d Block size is not divisible into the matrix\\n\", block_size); \n\t\t\texit(1); \n\t\t} \n\t} \n \n\tint trials = 1; \n \n\tif (argc > 2) \n\t{ \n\t\ttrials = atoi(argv[2]); \n\t} \n \n\tlong long execution_times[trials]; \n \n\tprintf(\"\\e[0;34m==>\\e[0m Running %d block matrix multiplcation trials...\\n\", trials); \n \n\tfor (int trial = 0; trial < trials; ++trial) \n\t{ \n\t\t \n \n\t\tmemset(calc_product, 0, sizeof(calc_product[0][0]) * MATRIX_SIZE * MATRIX_SIZE); \n \n\t\tstruct timeval time_start; \n\t\tstruct timeval time_end; \n \n\t\tgettimeofday(&time_start, NULL); \n \n\t\t \n \n\t\tfor (int i = 0; i < MATRIX_SIZE; i += block_size) \n\t\t{ \n\t\t\tfor (int j = 0; j < MATRIX_SIZE; j += block_size) \n\t\t\t{ \n\t\t\t\tfor (int x = 0; x < block_size; ++x) \n\t\t\t\t{ \n\t\t\t\t\tfor (int y = 0; y < block_size; ++y) \n\t\t\t\t\t{ \n\t\t\t\t\t\tfor (int k = 0; k < MATRIX_SIZE; ++k) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tcalc_product[i + x][j + y] += matrix1[i + x][k] * matrix2[k][j + y]; \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t} \n\t\t} \n \n\t\tgettimeofday(&time_end, NULL); \n \n\t\t \n \n\t\texecution_times[trial] = 1000000LL \n\t\t\t* (time_end.tv_sec  - time_start.tv_sec) \n\t\t\t+ (time_end.tv_usec - time_start.tv_usec); \n \n\t\t \n \n\t\tfor (int i = 0; i < MATRIX_SIZE; ++i) \n\t\t{ \n\t\t\tfor (int j = 0; j < MATRIX_SIZE; ++j) \n\t\t\t{ \n\t\t\t\tif (fabs(calc_product[i][j] - real_product[i][j]) > 0.001) \n\t\t\t\t{ \n\t\t\t\t\tprintf(\"%dx%d: %lf expected. Was %lf\\n\", i, j, real_product[i][j], calc_product[i][j]); \n\t\t\t\t\tputs(\"\\e[0;31m==> Calculated product differs from real product!\"); \n\t\t\t\t\texit(1); \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t} \n \n\tlong long min = INT_MAX, \n\t          avg = 0; \n \n\tfor (int i = 0; i < trials; ++i) \n\t{ \n\t\tif (execution_times[i] < min) \n\t\t{ \n\t\t\tmin = execution_times[i]; \n\t\t} \n \n\t\tavg += execution_times[i]; \n\t} \n \n\tprintf(\"avg: %lld\\n\", avg / trials); \n\tprintf(\"min: %lld\\n\", min); \n \n\tputs(\"\\e[0;32m==>\\e[0m All calculated product matches real product\"); \n \n\treturn 0; \n} ", "pred": " \nint main(int argc, char *argv[]) \n{ \n\tputs(\"\\e[0;34m==>\\e[0m Reading in values from the matrix files...\"); \n \n\tdouble matrix1[MATRIX_SIZE][MATRIX_SIZE], \n\t       matrix2[MATRIX_SIZE][MATRIX_SIZE], \n\t       real_product[MATRIX_SIZE][MATRIX_SIZE], \n\t       calc_product[MATRIX_SIZE][MATRIX_SIZE]; \n \n\t{ \n\t\tFILE *matrix1_file = fopen(MATRIX_1, \"r\"), \n\t\t     *matrix2_file = fopen(MATRIX_2, \"r\"), \n\t\t     *product_file = fopen(PRODUCT,  \"r\"); \n \n\t\tfor (int i = 0; i < MATRIX_SIZE; ++i) \n\t\t{ \n\t\t\tfor (int j = 0; j < MATRIX_SIZE; ++j) \n\t\t\t{ \n\t\t\t\tfscanf(matrix1_file, \"%lf\", &matrix1[i][j]); \n\t\t\t\tfscanf(matrix2_file, \"%lf\", &matrix2[i][j]); \n\t\t\t\tfscanf(product_file, \"%lf\", &real_product[i][j]); \n\t\t\t} \n\t\t} \n \n\t\tfclose(matrix1_file); \n\t\tfclose(matrix2_file); \n\t\tfclose(product_file); \n\t} \n \n\t{ \n\t\tFILE *matrix1_file = fopen(MATRIX_1, \"r\"), \n\t\t     *matrix2_file = fopen(MATRIX_2, \"r\"), \n\t\t     *product_file = fopen(PRODUCT,  \"r\"); \n \n\t\tfor (int i = 0; i < MATRIX_SIZE; ++i) \n\t\t{ \n\t\t\tfor (int j = 0; j < MATRIX_SIZE; ++j) \n\t\t\t{ \n\t\t\t\tfscanf(matrix1_file, \"%lf\", &matrix1[i][j]); \n\t\t\t\tfscanf(matrix2_file, \"%lf\", &matrix2[i][j]); \n\t\t\t\tfscanf(product_file, \"%lf\", &calc_product[i][j]); \n\t\t\t} \n\t\t} \n \n\t\tfclose(matrix1_file); \n\t\tfclose(matrix2_file); \n\t\tfclose(product_file); \n\t} \n \n\t{ \n\t\tFILE *matrix1_file = fopen(MATRIX_1, \"r\"), \n\t\t     *matrix2_file = fopen(MATRIX_2, \"r\"), \n\t\t     *product_file = fopen(PRODUCT,  \"r\"); \n \n\t\tfor (int i = 0; i < MATRIX_SIZE; ++i) \n\t\t{ \n\t\t\tfor (int j = 0; j < MATRIX_SIZE; ++j) \n\t\t\t{ \n\t\t\t\tfscanf(matrix1_file, \"%lf\", &matrix1[i][j]); \n\t\t\t\tfscanf(matrix2_file, \"%lf\", &matrix2[i][j]); \n\t\t\t\tfscanf(product_file, \"%lf\", &calc_product[i][j]); \n\t\t\t} \n\t\t} \n \n\t\tfclose(matrix1_file); \n\t\tfclose(matrix2_file); \n\t\tfclose(product_file); \n\t} \n \n\t{ \n\t\tFILE *matrix1_file = fopen(MATRIX_1, \"r\"), \n\t\t     *matrix2_file = fopen(MATRIX_2, \"r\"), \n\t\t     *product_file = fopen(PRODUCT,  \"r\"); \n \n\t\tfor (int i = 0; i < MATRIX_SIZE; ++i) \n\t\t{ \n\t\t\tfor (int j = 0; j < MATRIX_SIZE; ++j) \n\t\t\t{ \n\t\t\t\tfscanf(matrix1_file, \"%lf\", &matrix1[i][j]); \n\t\t\t\tfscanf(matrix2_file, \"%lf\", &matrix2[i][j]); \n\t\t\t\tfscanf(product_file, \"%lf\", &calc_product[i][j]); \n\t\t\t} \n\t\t} \n \n\t\tfclose(matrix1_file); \n\t\tfclose(matrix2_file); \n\t\tfclose(product_file); \n\t} \n \n\t{ \n\t\tFILE *matrix1_file = fopen(MATRIX_1, \"r\"), \n\t\t     *matrix2_file = fopen(MATRIX_2, \"r\"), \n\t\t     *product_file = fopen(PRODUCT,  \"r\"); \n \n\t\tfor (int i = 0; i < MATRIX_SIZE; ++i) \n\t\t{ \n\t\t\tfor (int j = 0; j < MATRIX_SIZE; ++j) \n\t\t\t{ \n\t\t\t\tfscanf(matrix1_file, \"%lf\", &matrix1[i][j]); \n\t\t\t\tfscanf(matrix2_file, \"%lf\", &matrix2[i][j]); \n\t\t\t\tfscanf(product_file, \"%lf\", &calc_product[i][j]); \n\t\t\t} \n\t\t} \n \n\t\tfclose(matrix1_file); \n\t\t"}
{"label": " \nint main() \n{ \n    int i; \n    int s = 0; \n    int t = 0; \n    int d = 0; \n    float e = 0.0f; \n    float f = 0.0f; \n \n    for(i=0; i<100; i++) \n    { \n        s += (i+1); \n        f += (i+1.0f); \n    } \n \n    for(i=0; i<100; i++) \n    { \n        d -= (i+1); \n        e -= (i+1.0f); \n    } \n \n    printf(\"%d %f %d %f\\n\", s, f, d, e); \n \n    if ((s!= 5050) || (f!= 5050.0f) \n            || (d!= -5050) || (e!= -5050.0f)) \n        return 1; \n \n    return 0; \n} ", "pred": " \nint main() \n{ \n    int i; \n    int s = 0; \n    int t = 0; \n    int d = 0; \n    float e = 0.0f; \n    float f = 0.0f; \n \n    for(i=0; i<100; i++) \n    { \n        s += (i+1); \n        f += (i+1.0f); \n    } \n \n    for(i=0; i<100; i++) \n    { \n        d -= (i+1); \n        e -= (i+1.0f); \n    } \n \n    printf(\"%d %f %d %f\\n\", s, f, d, e); \n \n    if ((s!= 5050) || (f!= 5050.0f) \n            || (d!= -5050) || (e!= -5050.0f)) \n        return 1; \n \n    return 0; \n} "}
{"label": " \nvoid symmetrize_complex(complex double* rhoR_b, complex double* rhoR_a, int* op, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n{ \n  int x,y,z; \n \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z) % nz + nz) % nz; \n            rhoR_b[x*ny*nz + y*nz + z] += rhoR_a[x_p*ny*nz + y_p*nz + z_p]; \n        } \n} \n} ", "pred": " \nvoid symmetrize_complex(complex double* rhoR_b, complex double* rhoR_a, int* op, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n{ \n  int x,y,z; \n \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z) % nz + nz) % nz; \n            rhoR_b[x*ny*nz + y*nx + z] = rhoR_a[x_p*ny*nz + y_p*nx + z_p]; \n        } \n } \n \n} \n"}
{"label": " \nvoid set_grid_ptrs( GridPoint * energy_grid, NuclideGridPoint ** nuclide_grids, \n                    int n_isotopes, int n_gridpoints ){ \n\t \n\tprintf(\"Assigning pointers to Unionized Energy Grid...\\n\"); \n\t \n\tfor( int i = 0; i < n_isotopes * n_gridpoints ; i++ ) \n\t{ \n\t\tdouble quarry = energy_grid[i].energy; \n\t\tif( INFO && omp_get_thread_num() == 0 && i % 200 == 0 ) \n\t\t\tprintf(\"\\rAligning Unionized Grid...(%.0lf%% complete)\", \n\t\t\t       100.0 * (double) i / (n_isotopes*n_gridpoints / \n\t\t\t\t                         omp_get_num_threads())     ); \n\t\tfor( int j = 0; j < n_isotopes; j++ ) \n\t\t{ \n\t\t\t \n \n\t\t\t \n \n\t\t\tenergy_grid[i].xs_ptrs[j] =  \n\t\t\t\tbinary_search( nuclide_grids[j], quarry, n_gridpoints); \n\t\t} \n\t} \n\tprintf(\"\\n\"); \n \n\t \n \n\t \n \n} ", "pred": " \nvoid set_grid_ptrs( GridPoint * energy_grid, NuclideGridPoint ** nuclide_grids, \n                    int n_isotopes, int n_gridpoints ){ \n\t \n\tprintf(\"Assigning pointers to Unionized Energy Grid...\\n\"); \n\t \n\tfor( int i = 0; i < n_isotopes * n_gridpoints ; i++ ) \n\t{ \n\t\tdouble quarry = energy_grid[i].energy; \n\t\tif( INFO && omp_get_thread_num() == 0 && i % 200 == 0 ) \n\t\t\tprintf(\"\\rAligning Unionized Grid...(%.0lf%% complete)\", \n\t\t\t       100.0 * (double) i / (n_isotopes*n_gridpoints / \n\t\t\t\t                         omp_get_num_threads())     ); \n\t\tfor( int j = 0; j < n_isotopes; j++ ) \n\t\t{ \n\t\t\t \n \n\t\t\t \n \n\t\t\tenergy_grid[i].xs_ptrs[j] =  \n\t\t\t\tbinary_search( nuclide_grids[j], quarry, \n\t\t\t\t\t                           "}
{"label": " \nint sasa(const int n_frames, const int n_atoms, const float* xyzlist, \n         const float* atom_radii, const int n_sphere_points, \n         const int* atom_mapping, const int n_groups, float* out) \n{ \n   \n \n \n  int i, j; \n \n   \n \n  int* wb1; \n  float* wb2; \n  float* outframe; \n  float* outframebuffer; \n \n   \n \n  float* sphere_points = (float*) malloc(n_sphere_points*3*sizeof(float)); \n  generate_sphere_points(sphere_points, n_sphere_points); \n \n  { \n \n   \n \n  wb1 = (int*) malloc(n_atoms*sizeof(int)); \n  wb2 = (float*) malloc(3*n_sphere_points*sizeof(float)); \n  outframebuffer = (float*) calloc(n_atoms, sizeof(float)); \n \n  for (i = 0; i < n_frames; i++) { \n    asa_frame(xyzlist + i*n_atoms*3, n_atoms, atom_radii, sphere_points, \n\t      n_sphere_points, wb1, wb2, outframebuffer); \n    outframe = out + (n_groups * i); \n    for (j = 0; j < n_atoms; j++) { \n        outframe[atom_mapping[j]] += outframebuffer[j]; \n    } \n  } \n \n  free(wb1); \n  free(wb2); \n  free(outframebuffer); \n  }  \n \n \n  free(sphere_points); \n  return 1; \n} ", "pred": " \nint sasa(const int n_frames, const int n_atoms, const float* xyzlist, \n         const float* atom_radii, const int n_sphere_points, \n         const int* atom_mapping, const int n_groups, float* out) \n{ \n   \n \n \n  int i, j; \n \n   \n \n  int* wb1; \n  float* wb2; \n  float* outframe; \n  float* outframebuffer; \n \n   \n \n  float* sphere_points = (float*) malloc(n_sphere_points*3*sizeof(float)); \n  generate_sphere_points(sphere_points, n_sphere_points); \n \n  { \n \n   \n \n  wb1 = (int*) malloc(n_atoms*sizeof(int)); \n  wb2 = (float*) malloc(3*n_sphere_points*sizeof(float)); \n  outframebuffer = (float*) calloc(n_atoms, sizeof(float)); \n \n  for (i = 0; i < n_frames; i++) { \n    asa_frame(xyzlist + i*n_atoms*3, n_atoms, atom_radii, sphere_points, \n\t      n_sphere_points, atom_mapping, n_groups, wb1, wb2, outframe); \n    for (j = 0; j < n_groups; j++) { \n      outframebuffer[3*wb1[j]+0] = wb2[j]; \n      outframebuffer[3*wb1[j]+1] = wb2[j+n_sphere_points]; \n      outframebuffer[3*wb1[j]+2] = wb2[j+2*n_sphere_"}
{"label": " \nstatic void THNN_(SpatialAdaptiveAveragePooling_updateGradInput_frame)( \n          real *gradInput_p, \n          real *gradOutput_p, \n          long nslices, \n          long iwidth, \n          long iheight, \n          long owidth, \n          long oheight) \n{ \n  long k; \n  for (k = 0; k < nslices; k++) \n  { \n    real *gradInput_p_k = gradInput_p + k*iwidth*iheight; \n    real *gradOutput_p_k = gradOutput_p + k*owidth*oheight; \n \n     \n \n    long i, j; \n    for(i = 0; i < oheight; i++) \n    { \n      int y_start = START_IND(i, oheight, iheight); \n      int y_end   = END_IND(i, oheight, iheight); \n      int kH = y_end-y_start; \n \n      for(j = 0; j < owidth; j++) \n      { \n \n        int x_start = START_IND(j, owidth, iwidth); \n        int x_end   = END_IND(j, owidth, iwidth); \n        int kW = x_end-x_start; \n \n        int x,y; \n        for(y = y_start; y < y_end; y++) \n        { \n          for(x = x_start; x < x_end; x++) \n          { \n             \n \n            gradInput_p_k[y*iwidth + x] += gradOutput_p_k[i*owidth + j] / kW / kH; \n          } \n        } \n      } \n    } \n  } \n} ", "pred": " \nstatic void THNN_(SpatialAdaptiveAveragePooling_updateGradInput_frame)( \n          real *gradInput_p, \n          real *gradOutput_p, \n          long nslices, \n          long iwidth, \n          long iheight, \n          long owidth, \n          long oheight) \n{ \n  long k; \n  for (k = 0; k < nslices; k++) \n  { \n    real *gradInput_p_k = gradInput_p + k*iwidth*iheight; \n    real *gradOutput_p_k = gradOutput_p + k*owidth*oheight; \n \n     \n \n    long i, j; \n    for(i = 0; i < oheight; i++) \n    { \n      int y_start = START_IND(i, oheight, iheight); \n      int y_end   = END_IND(i, oheight, iheight); \n      int kH = y_end - y_start; \n      for(j = 0; j < owidth; j++) \n      { \n        int x_start = START_IND(j, owidth, iwidth); \n        int x_end   = END_IND(j, owidth, iwidth); \n        int kW = x_end - x_start; \n        for( ; kH > 0 && kW > 0; kH--, kW--) \n        { \n          real sum = 0.0; \n          for(int y = y_start; y < y_end; y++) \n          { \n            for(int x = x_start; x < x_end; x++) \n            { \n              sum += gradInput_p_k[x*kW + y*kH]; \n            } \n       "}
{"label": " \n__attribute__((noinline)) int foo( \n        int * __restrict__ __attribute__((__aligned__(VECTOR_SIZE))) b, \n        int N) \n{ \n    int i,j; \n \n    int tmp = 0.0f; \n \n        for(i=0; i<(N-16); i++) \n        { \n            tmp += b[i] * \n \n                (((b[i+1] + \n                  b[i+2] * \n                   b[i+3]) + \n \n                    (b[i+4] + \n                     b[i+5] * \n                      b[i+6]) * \n \n                       ((b[i+7] + \n                        b[i+8] * \n                         b[i+9]) + \n \n                          (b[i+10] + \n                           b[i+11] * \n                            b[i+12]) * \n \n                             (b[i+13] + \n                              b[i+14] * \n                               b[i+15])))); \n        } \n \n    return tmp; \n} ", "pred": " \n__attribute__((noinline)) int foo( \n        int * __restrict__ __attribute__((__aligned__(VECTOR_SIZE))) b, \n        int N) \n{ \n    int i,j; \n \n    int tmp = 0.0f; \n \n        for(i=0; i<(N-16); i++) \n        { \n            tmp += b[i] * \n \n                (((b[i+1] + \n                  b[i+2] * \n                   b[i+3]) + \n \n                    (b[i+4] + \n                     b[i+5] * \n                      b[i+6]) * \n \n                      b[i+7]) + \n \n                    (b[i+8] + \n                     b[i+9] * \n                      b[i+10]) * \n \n                      b[i+11]) + \n \n                    (b[i+12] + \n                     b[i+13] * \n                      b[i+14]) * \n \n                      b[i+15])); \n \n            b[i] = tmp; \n        } \n \n        for(i=0; i<(N-16); i++) \n        { \n          "}
{"label": " \nvoid symmetrize_ft_complex(complex double* rhoR_b, complex double* rhoR_a, int* op, double* ft, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n  int ft_x = (int)(ft[0] * nx); \n  int ft_y = (int)(ft[1] * ny); \n  int ft_z = (int)(ft[2] * nz); \n \n{ \n  int x,y,z; \n \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z + ft_x) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z + ft_y) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z + ft_z) % nz + nz) % nz; \n            rhoR_b[x*ny*nz + y*nz + z] += rhoR_a[x_p*ny*nz + y_p*nz + z_p]; \n        } \n} \n} ", "pred": " \nvoid symmetrize_ft_complex(complex double* rhoR_b, complex double* rhoR_a, int* op, double* ft, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n  int ft_x = (int)(ft[0] * nx); \n  int ft_y = (int)(ft[1] * ny); \n  int ft_z = (int)(ft[2] * nz); \n \n{ \n  int x,y,z; \n \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z + ft_x) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z + ft_y) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z + ft_z) % nz + nz) % nz; \n            \n            rhoR_b[x_p + y_p * nx + z_p * nx * ny] += 1.0; \n            rhoR_a["}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0;j<Ny;j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 8; \n  tile_size[1] = 8; \n  tile_size[2] = 32; \n  tile_size[3] = 512; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n \n  const int BASE = 1024; \n \n \n   \n \n   \n \n  srand(42); \n    for (i = 1; i < Nz; i++) { \n        for (j = 1; j < Ny; j++) { \n            for (k = 1; k < Nx; k++) { \n                A[0][i][j][k] = 1.0 * (rand() % BASE); \n                roc2[i][j][k] = 2.0 * (rand() % BASE); \n            } \n        } \n    } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n  const double coef0 = -0.28472; \n  const double coef1 = 0.16000; \n  const double coef2 = -0.02000; \n  const double coef3 = 0.00254; \n  const double coef4 = -0.00018; \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=Nt-1;t1++) { \n    lbp=ceild(t1+1,2); \n    ubp=min(floord(4*Nt+Nz-9,8),floord(4*t1+Nz-2,8)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(ceild(t1-6,8),ceild(8*t2-Nz-19,32));t3<=min(floord(4*Nt+Ny-9,32),floord(4*t1+Ny-1,32));t3++) { \n        for (t4=max(max(ceild(t1-126,128),ceild(8*t2-Nz-499,512)),ceild(32*t3-Ny-499,512));t4<=min(min(floord(4*Nt+Nx-9,512),floord(4*t1+Nx-1,512)),floord(32*t3+Nx+19,512));t4++) { \n          for (t5=max(max(max(max(0,ceild(8*t2-Nz+5,4)),ceild(32*t3-Ny+5,4)),ceild(512*t4-Nx+5,4)),t1);t5<=min(min(min(Nt-1,t1+1),8*t3+6),128*t4+126);t5++) { \n            for (t6=max(max(8*t2,4*t5+4),-8*t1+8*t2+8*t5-7);t6<=min(min(8*t2+7,-8*t1+8*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=max(32*t3,4*t5+4);t7<=min(32*t3+31,4*t5+Ny-5);t7++) { \n                lbv=max(512*t4,4*t5+4); \n                ubv=min(512*t4+511,4*t5+Nx-5); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((2.0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) - A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (roc2[ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] * (((((coef0 * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (coef1 * (((((A[ t5 % 2][ (-4*t5+t6) - 1][ (-4*t5+t7)][ (-4*t5+t8)] + A[ t5 % 2][ (-4*t5+t6) + 1][ (-4*t5+t7)][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) - 1][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7) + 1][ (-4*t5+t8)]) + A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n  double ***roc2 = (double ***) malloc(sizeof(double**)); \n  A[0] = (double ***) malloc(sizeof(double**)*Nz); \n  A[1] = (double ***) malloc(sizeof(double**)*Nz); \n  roc2 = (double ***) malloc(sizeof(double**)*Nz); \n  for(i=0; i<Nz; i++){ \n    A[0][i] = (double**) malloc(sizeof(double*)*Ny); \n    A[1][i] = (double**) malloc(sizeof(double*)*Ny); \n    roc2[i] = (double**) malloc(sizeof(double*)*Ny); \n    for(j=0; j<Ny; j++){ \n      A[0][i][j] = (double*) malloc(sizeof(double)*Nx); \n      A[1][i][j] = (double*) malloc(sizeof(double)*Nx); \n      roc2[i][j] = (double*) malloc(sizeof(double)*Nx); \n    } \n  } \n \n  for(t=0; t<Nt; t++){ \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      } \n    } \n    for(i=0; i<Nz; i++){ \n      for(j=0; j<Nz; j++){ \n\tfor(k=0; k<Nz; k++){ \n\t  A[0][i][j][k] = (double) (i+j+k); \n\t  A[1][i][j][k] = (double) (i+j+k); \n\t} \n      }"}
{"label": " \nstatic void \nmatch_domain (const char *fn1, const char *fn2, \n              definitions_ty *definitions, message_list_ty *refmlp, \n              message_list_ty *resultmlp, \n              struct statistics *stats, unsigned int *processed) \n{ \n  message_ty *header_entry; \n  unsigned long int nplurals; \n  const struct expression *plural_expr; \n  char *untranslated_plural_msgstr; \n  struct plural_distribution distribution; \n  struct search_result { message_ty *found; bool fuzzy; } *search_results; \n  size_t j; \n \n  header_entry = \n    message_list_search (definitions_current_list (definitions), NULL, \"\"); \n  extract_plural_expression (header_entry? header_entry->msgstr : NULL, \n                             &plural_expr, &nplurals); \n  untranslated_plural_msgstr = XNMALLOC (nplurals, char); \n  memset (untranslated_plural_msgstr, '\\0', nplurals); \n \n   \n \n  { \n     \n \n    void (*old_po_xerror) (int, const struct message_ty *, const char *, size_t, \n                           size_t, int, const char *) \n      = po_xerror; \n    po_xerror = silent_xerror; \n \n    if (check_plural_eval (plural_expr, nplurals, header_entry, \n                           &distribution) > 0) \n      { \n        distribution.expr = NULL; \n        distribution.often = NULL; \n        distribution.often_length = 0; \n        distribution.histogram = NULL; \n      } \n \n    po_xerror = old_po_xerror; \n  } \n \n   \n \n  search_results = XNMALLOC (refmlp->nitems, struct search_result); \n  { \n    long int nn = refmlp->nitems; \n    long int jj; \n \n     \n \n    #ifdef _OPENMP \n    #endif \n    for (jj = 0; jj < nn; jj++) \n      { \n        message_ty *refmsg = refmlp->item[jj]; \n        message_ty *defmsg; \n \n         \n \n        if (!quiet && verbosity_level <= 1 && *processed % DOT_FREQUENCY == 0) \n          fputc ('.', stderr); \n        #ifdef _OPENMP \n        #endif \n        (*processed)++; \n \n         \n \n        defmsg = \n          definitions_search (definitions, refmsg->msgctxt, refmsg->msgid); \n        if (defmsg!= NULL) \n          { \n            search_results[jj].found = defmsg; \n            search_results[jj].fuzzy = false; \n          } \n        else if (!is_header (refmsg) \n                  \n \n                 && use_fuzzy_matching \n                 && ((defmsg = \n                        definitions_search_fuzzy (definitions, \n                                                  refmsg->msgctxt, \n                                                  refmsg->msgid))!= NULL)) \n          { \n            search_results[jj].found = defmsg; \n            search_results[jj].fuzzy = true; \n          } \n        else \n          search_results[jj].found = NULL; \n      } \n  } \n \n  for (j = 0; j < refmlp->nitems; j++) \n    { \n      message_ty *refmsg = refmlp->item[j]; \n \n       \n \n      if (search_results[j].found!= NULL &&!search_results[j].fuzzy) \n        { \n          message_ty *defmsg = search_results[j].found; \n           \n \n          message_ty *mp = \n            message_merge (defmsg, refmsg, false, &distribution); \n \n           \n \n          if (!(for_msgfmt \n                && (mp->msgstr[0] == '\\0'  \n \n                    || (mp->is_fuzzy &&!is_header (mp)))))  \n \n            { \n              message_list_append (resultmlp, mp); \n \n               \n \n              defmsg->used = 1; \n            } \n \n          stats->merged++; \n        } \n      else if (!is_header (refmsg)) \n        { \n           \n \n          if (search_results[j].found!= NULL && search_results[j].fuzzy) \n            { \n              message_ty *defmsg = search_results[j].found; \n              message_ty *mp; \n \n              if (verbosity_level > 1) \n                { \n                  po_gram_error_at_line (&refmsg->pos, \n                                         _(\"this message is used but not defined...\")); \n                  error_message_count--; \n                  po_gram_error_at_line (&defmsg->pos, \n                                         _(\"...but this definition is similar\")); \n                } \n \n               \n \n           ", "pred": " \nstatic void \nmatch_domain (const char *fn1, const char *fn2, \n              definitions_ty *definitions, message_list_ty *refmlp, \n              message_list_ty *resultmlp, \n              struct statistics *stats, unsigned int *processed) \n{ \n  message_ty *header_entry; \n  unsigned long int nplurals; \n  const struct expression *plural_expr; \n  char *untranslated_plural_msgstr; \n  struct plural_distribution distribution; \n  struct search_result { message_ty *found; bool fuzzy; } *search_results; \n  size_t j; \n \n  header_entry = \n    message_list_search (definitions_current_list (definitions), NULL, \"\"); \n  extract_plural_expression (header_entry? header_entry->msgstr : NULL, \n                             &plural_expr, &nplurals); \n  untranslated_plural_msgstr = XNMALLOC (nplurals, char); \n  memset (untranslated_plural_msgstr, 0, nplurals); \n  distribution.nplurals = nplurals; \n  distribution.plural_expr = plural_expr; \n  distribution.nplurals_plural = 0; \n  distribution.nplurals_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution.nplurals_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural_plural = 0; \n  distribution"}
{"label": " \nvoid THNN_(SpatialAdaptiveAveragePooling_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput) \n{ \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  int nslices; \n  int iheight; \n  int iwidth; \n  int oheight; \n  int owidth; \n  real *gradInput_data; \n  real *gradOutput_data; \n \n   \n \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n \n   \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(zero)(gradInput); \n \n  if (input->nDimension == 4) { \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n   \n \n  nslices = input->size[dimh-1]; \n  iheight = input->size[dimh]; \n  iwidth = input->size[dimw]; \n  oheight = gradOutput->size[dimh]; \n  owidth = gradOutput->size[dimw]; \n \n   \n \n  gradInput_data = THTensor_(data)(gradInput); \n  gradOutput_data = THTensor_(data)(gradOutput); \n \n   \n \n  if (input->nDimension == 3) \n  { \n    THNN_(SpatialAdaptiveAveragePooling_updateGradInput_frame)(gradInput_data, gradOutput_data, \n                                                         nslices, \n                                                         iwidth, iheight, \n                                                         owidth, oheight); \n  } \n  else \n  { \n    long p; \n    for (p = 0; p < nbatch; p++) \n    { \n      THNN_(SpatialAdaptiveAveragePooling_updateGradInput_frame)(gradInput_data+p*nslices*iwidth*iheight, gradOutput_data+p*nslices*owidth*oheight, \n                                                           nslices, \n                                                           iwidth, iheight, \n                                                           owidth, oheight); \n    } \n  } \n \n   \n \n  THTensor_(free)(gradOutput); \n} ", "pred": " \nvoid THNN_(SpatialAdaptiveAveragePooling_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput) \n{ \n  int dimw = 2; \n  int dimh = 1; \n  long nbatch = 1; \n  int nslices; \n  int iheight; \n  int iwidth; \n  int oheight; \n  int owidth; \n  real *gradInput_data; \n  real *gradOutput_data; \n \n   \n \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n \n   \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(zero)(gradInput); \n \n  if (input->nDimension == 4) { \n    nbatch = input->size[0]; \n    dimw++; \n    dimh++; \n  } \n \n   \n \n  nslices = input->size[dimh-1]; \n  iheight = input->size[dimh]; \n  iwidth = input->size[dimw]; \n  oheight = gradOutput->size[dimh-1]; \n  owidth = gradOutput->size[dimw]; \n \n  gradInput_data = THTensor_(newContiguous)(gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(zero)(gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THTensor_(resizeAs)(gradOutput, gradOutput); \n \n  THTensor_(resizeAs)(gradInput, gradInput); \n \n  THT"}
{"label": " \nvoid symmetrize_ft(double* rhoR_b, double* rhoR_a, int* op, double* ft, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n  int ft_x = (int)(ft[0] * nx); \n  int ft_y = (int)(ft[1] * ny); \n  int ft_z = (int)(ft[2] * nz); \n \n{ \n  int x,y,z; \n \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z + ft_x) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z + ft_y) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z + ft_z) % nz + nz) % nz; \n            rhoR_b[x*ny*nz + y*nz + z] += rhoR_a[x_p*ny*nz + y_p*nz + z_p]; \n        } \n} \n} ", "pred": " \nvoid symmetrize_ft(double* rhoR_b, double* rhoR_a, int* op, double* ft, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n  int ft_x = (int)(ft[0] * nx); \n  int ft_y = (int)(ft[1] * ny); \n  int ft_z = (int)(ft[2] * nz); \n \n{ \n  int x,y,z; \n \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z + ft_x) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z + ft_y) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z + ft_z) % nz + nz) % nz; \n            \n            if (x_p >= 0 && x_p < nx && y_p >= 0 && y_p < ny && z_p >= 0 && z_p < nz) \n      "}
{"label": " \nvoid symmetrize(double* rhoR_b, double* rhoR_a, int* op, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n{ \n  int x,y,z; \n \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z) % nz + nz) % nz; \n            rhoR_b[x*ny*nz + y*nz + z] += rhoR_a[x_p*ny*nz + y_p*nz + z_p]; \n        } \n} \n} ", "pred": " \nvoid symmetrize(double* rhoR_b, double* rhoR_a, int* op, int* mesh) \n{ \n  const int nx = mesh[0]; \n  const int ny = mesh[1]; \n  const int nz = mesh[2]; \n \n{ \n  int x,y,z; \n \n    for (x = 0; x < nx; x++) \n      for (y = 0; y < ny; y++) \n        for (z = 0; z < nz; z++) { \n            int x_p = ((op[0] * x + op[1] * y + op[2] * z) % nx + nx) % nx; \n            int y_p = ((op[3] * x + op[4] * y + op[5] * z) % ny + ny) % ny; \n            int z_p = ((op[6] * x + op[7] * y + op[8] * z) % nz + nz) % nz; \n            rhoR_b[x*ny*nz + y*nz + z] = rhoR_a[x_p*ny*nz + y_p*nz + z_p]; \n        } \n } \n \n} \n"}
{"label": "void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n    void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const float *const in  = (float *)ivoid; \n  float *const out = (float *)ovoid; \n  const int ch = piece->colors; \n  dt_iop_basecurve_data_t *const d = (dt_iop_basecurve_data_t *)(piece->data); \n \n   \n \n  if(d->exposure_fusion) \n  { \n     \n \n    const int wd = roi_in->width, ht = roi_in->height; \n    int num_levels = 8; \n    float **col  = malloc(num_levels * sizeof(float*)); \n    float **comb = malloc(num_levels * sizeof(float*)); \n    int w = wd, h = ht; \n    const int rad = MIN(wd, ceilf(256 * roi_in->scale / piece->iscale)); \n    int step = 1; \n    for(int k=0;k<num_levels;k++) \n    { \n       \n \n      col[k]  = dt_alloc_align(64, sizeof(float)*4ul*w*h); \n      comb[k] = dt_alloc_align(64, sizeof(float)*4ul*w*h); \n      memset(comb[k], 0, sizeof(float)*4*w*h); \n      w = (w-1)/2+1; h = (h-1)/2+1; \n      step *= 2; \n      if(step > rad || w < 4 || h < 4) \n      { \n        num_levels = k+1; \n        break; \n      } \n    } \n \n    for(int e=0;e<d->exposure_fusion+1;e++) \n    {  \n \n       \n \n      apply_ev_and_curve( \n          in, col[0], wd, ht, \n          powf(2.0f, d->exposure_stops * e), \n          d->table, d->unbounded_coeffs); \n \n       \n \n      compute_features(col[0], wd, ht); \n \n       \n \n      w = wd; h = ht; \n      gauss_reduce(col[0], col[1], out, w, h); \n      for(size_t k=0;k<4ul*wd*ht;k+=4) \n        col[0][k+3] *=.1f + sqrtf(out[k]*out[k] + out[k+1]*out[k+1] + out[k+2]*out[k+2]); \n \n \n \n \n      for(size_t k=0;k<4ul*w*h;k+=4) \n        col[0][k+e] = col[0][k+3]; \n \n \n \n \n      for(size_t k=0;k<4ul*w*h;k+=4) \n        comb[0][k+e] = col[0][k+3]; \n      continue; \n \n      for(int k=1;k<num_levels;k++) \n      { \n        gauss_reduce(col[k-1], col[k], 0, w, h); \n        w = (w-1)/2+1; h = (h-1)/2+1; \n      } \n \n       \n \n      for(int k=num_levels-1;k>=0;k--) \n      { \n        w = wd; h = ht; \n        for(int i=0;i<k;i++) { w = (w-1)/2+1; h = (h-1)/2+1; } \n         \n \n        if(k!=num_levels-1) \n          gauss_expand(col[k+1], out, w, h); \n        for(int j=0;j<h;j++) for(int i=0;i<w;i++) \n        { \n          const size_t x = 4ul*(w*j+i); \n           \n \n          if(k == num_levels-1)  \n \n            ; \n            for(int c=0;c<3;c++) \n              comb[k][x+c] += col[k][x+3] * col[k][x+c]; \n          else  \n \n            for(int c=0;c<3;c++) comb[k][x+c] += \n              col[k][x+3] * (col[k][x+c] - out[x+c]); \n          comb[k][x+3] += col[k][x+3]; \n        } \n      } \n    } \n \n \n     \n \n    for(int k=num_levels-1;k>=0;k--) \n    { \n      w = wd; h = ht; \n      for(int i=0;i<k;i++) { w = (w-1)/2+1; h = (h-1)/2+1;} \n \n       \n \n      for(size_t i=0;i<(size_t)4*w*h;i+=4) \n        if(comb[k][i+3] > 1e-8f) \n          for(int c=0;c<3;c++) comb[k][i+c] /= comb[k][i+3]; \n \n      if(k < num_levels-1) \n      {  \n \n        gauss_expand(comb[k+1], out, w, h); \n        for(int j=0;j<h;j++) for(int i=0;i<w;i++) \n        { \n          const size_t x = 4ul*(w*j+i); \n          for(int c=0;c<3;c++) comb[k][x+c] += out[x+c]; \n        } \n      } \n    } \n \n     \n \n    for(size_t k=0;k<4ul*wd*ht;k+=4) \n    { \n      out[k+0] = comb[0][k+0]; \n      out[k+1] = comb[0][k+1]; \n      out[k+2] = comb[0][k+2]; \n      out[k+3] = in[k+3];  \n \n    } \n \n     \n \n    for(int k=0;k<num_levels;k++) \n    { \n      free(col[k]); \n      free(comb[k]); \n    } \n    free(col); \n ", "pred": "void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n    void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const float *const in  = (float *)ivoid; \n  float *const out = (float *)ovoid; \n  const int ch = piece->colors; \n  dt_iop_basecurve_data_t *const d = (dt_iop_basecurve_data_t *)(piece->data); \n \n   \n \n  if(d->exposure_fusion) \n  { \n     \n \n    const int wd = roi_in->width, ht = roi_in->height; \n    int num_levels = 8; \n    float **col  = malloc(num_levels * sizeof(float*)); \n    float **comb = malloc(num_levels * sizeof(float*)); \n    int w = wd, h = ht; \n    const int rad = MIN(wd, ceilf(256 * roi_in->scale / piece->iscale)); \n    int step = 1; \n    for(int k=0; k<num_levels; k++) \n    { \n      col[k] = malloc(wd * ht * sizeof(float)); \n      comb[k] = malloc(wd * ht * sizeof(float)); \n    } \n    for(int k=0; k<num_levels; k++) \n    { \n      col[k][0] = in[0]; \n      col[k][1] = in[1]; \n      col[k][2] = in[2]; \n      col[k][3] = in[3]; \n      col[k][4] = in[4]; \n      col[k][5] = in[5]; \n      col[k][6] = in[6]; \n      col[k][7] = in[7]; \n      comb[k][0] = col[k][0]; \n      comb[k][1] = col[k][1]; \n      comb[k][2] = col[k][2]; \n      comb[k][3] = col[k][3]; \n      comb[k][4] = col[k][4]; \n      comb[k][5] = col[k][5]; \n      comb[k][6] = col[k][6]; \n      comb[k][7] = col[k][7]; \n    } \n    for(int k=0; k<num_levels; k++) \n    { \n      for(int j=0; j<wd; j++) \n      { \n        for(int i=0; i<ht; i++) \n        { \n          float val = in[j * wd * ht + i * wd + k]; \n          for(int l=0; l<rad; l++) \n          { \n            float r = (l + 0.5f) / rad; \n            float g = (l + 0.5f) / rad; \n            float b = (l + 0.5f) / rad; \n            float a = (l + 0.5f) / rad; \n            float w = (l + 0.5f) / rad; \n            float h = (l + 0.5f) / rad; \n            float x = (l + 0.5f) / rad; \n            float y = (l + 0.5f) / rad; \n            float z = (l + 0.5f) / rad; \n            float u = (l + 0.5f) / rad; \n            float v = (l + 0.5f) / rad; \n            float wu = (l + 0.5f) / rad; \n            float wv = (l + 0.5f) / rad; \n            float wuu = (l + 0.5f) / rad; \n            float wuv = (l + 0.5f) / rad; \n            float wvv = (l + 0.5f) / rad; \n            float wuuu = (l + 0.5f) / rad; \n            float wuvv = (l + 0.5f) / rad; \n            float wuvuu = (l + 0.5f) / rad; \n            float wuvuv = (l + 0.5f) / rad; \n            float wuvvv = (l + 0.5f) / rad; \n            float wuvuuu = (l + 0.5f) / rad; \n            float wuvuvv = (l + 0.5f) / rad; \n            float wuvvvuu = (l + 0.5f) / rad; \n            float wuvvvuv = (l + 0.5f) / rad; \n            float wuvvvvv = (l + 0.5f) / rad; \n            float wuvvvuuu = (l + 0.5f) / rad; \n            float wuvvvuvv = (l + 0.5f) / rad; \n            float wuvvvvvuu = (l + 0.5f) / rad; \n            float wuvvvvvuv = (l + 0.5f) / rad; \n            float wuvvvvvvv = (l + 0.5f) / rad; \n            float wuvvvvvuuu = (l + 0.5f) / rad; \n            float wuvvvvvuvv = (l + 0.5f) / rad; \n            float wuvvvvvvvuu = (l + 0.5f) / rad; \n            float wuvvvvvvvuv = (l + 0.5f) / rad; \n            float wuvvvvvvvvv = (l + 0.5f) / rad; \n            float wuvvvvvvvuuu = (l + 0.5f) / rad; \n            float wuvvvvvvvuvv = (l + 0.5f) / rad; \n            float wuvvvvvvvvvuu = (l + 0.5f) / rad; \n            float wuvvvvvvvvvuv = (l + 0.5f) / rad; \n            float wuvvvvvvvvvvv = (l + 0.5f) / rad; \n            float wuvvvvvvvvvuuu = (l + 0.5f) / rad; \n            float wuvvvvvvvvvuvv = (l"}
{"label": " \nint main(int argc, char** argv) { \n    int i, j; \n    int n = Y; \n     \n     \n \n    init_array(); \n     \n     \n    for (i = 0; i < n; i++) \n        for (j = 0; j < n; j++) \n            x1[i] = x1[i] + A[i][j] * y_1[j]; \n    for (i = 0; i < n; i++) \n        for (j = 0; j < n; j++) \n            x2[i] = x2[i] + A[j][i] * y_2[j]; \n     \n    double total = 0; \n    for(int y=0; y<n; ++y){ \n        total+= x2[y]; \n    } \n    printf(\"Total: %f\\n\",total); \n     \n     \n     \n     \n    return 0; \n} ", "pred": " \nint main(int argc, char** argv) { \n    int i, j; \n    int n = Y; \n     \n     \n \n    init_array(); \n     \n     \n    for (i = 0; i < n; i++) \n        for (j = 0; j < n; j++) \n            x1[i] = x1[i] + A[i][j] * y_1[j]; \n    for (i = 0; i < n; i++) \n        for (j = 0; j < n; j++) \n            x2[i] = x2[i] + A[j][i] * y_2[j]; \n     \n    double total = 0; \n    for(int y=0; y<n; ++y){ \n        total+= x2[y]; \n    } \n    printf(\"Total: %f\\n\",total); \n     \n     \n     \n     \n    return 0; \n} \n"}
{"label": " \nint space_shuffle ( struct space *s ) { \n \n    int k, cid, pid, delta[3]; \n    FPTYPE h[3]; \n    struct space_cell *c, *c_dest; \n    struct particle *p; \n     \n     \n \n    for ( k = 0 ; k < 3 ; k++ ) \n        h[k] = s->h[k]; \n \n    for ( cid = 0 ; cid < s->nr_marked ; cid++ ) { \n        c = &(s->cells[ s->cid_marked[cid] ]); \n        pid = 0; \n        while ( pid < c->count ) { \n \n            p = &( c->parts[pid] ); \n            for ( k = 0 ; k < 3 ; k++ ) \n                delta[k] = __builtin_isgreaterequal( p->x[k], h[k] ) - __builtin_isless( p->x[k], 0.0 ); \n \n             \n \n            if ( ( delta[0]!= 0 ) || ( delta[1]!= 0 ) || ( delta[2]!= 0 ) ) { \n                for ( k = 0 ; k < 3 ; k++ ) \n                    p->x[k] -= delta[k] * h[k]; \n                c_dest = &( s->cells[ space_cellid( s, \n                    (c->loc[0] + delta[0] + s->cdim[0]) % s->cdim[0],  \n                    (c->loc[1] + delta[1] + s->cdim[1]) % s->cdim[1],  \n                    (c->loc[2] + delta[2] + s->cdim[2]) % s->cdim[2] ) ] ); \n \n\t            if ( c_dest->flags & cell_flag_marked ) { \n                    pthread_mutex_lock(&c_dest->cell_mutex); \n                    space_cell_add_incomming( c_dest, p ); \n\t                pthread_mutex_unlock(&c_dest->cell_mutex); \n                    s->celllist[ p->id ] = c_dest; \n                    } \n                else { \n                    s->partlist[ p->id ] = NULL; \n                    s->celllist[ p->id ] = NULL; \n                    } \n \n                s->celllist[ p->id ] = c_dest; \n                c->count -= 1; \n                if ( pid < c->count ) { \n                    c->parts[pid] = c->parts[c->count]; \n                    s->partlist[ c->parts[pid].id ] = &( c->parts[pid] ); \n                    } \n                } \n            else \n                pid += 1; \n            } \n        } \n \n     \n \n    return space_err_ok; \n \n    } ", "pred": " \nint space_shuffle ( struct space *s ) { \n \n    int k, cid, pid, delta[3]; \n    FPTYPE h[3]; \n    struct space_cell *c, *c_dest; \n    struct particle *p; \n     \n     \n \n    for ( k = 0 ; k < 3 ; k++ ) \n        h[k] = s->h[k]; \n \n    for ( cid = 0 ; cid < s->nr_marked ; cid++ ) { \n        c = &(s->cells[ s->cid_marked[cid] ]); \n        pid = 0; \n        while ( pid < c->count ) { \n \n            p = &( c->parts[pid] ); \n            for ( k = 0 ; k < 3 ; k++ ) \n                delta[k] = __builtin_isgreaterequal( p->x[k], h[k] ) - __builtin_isless( p->x[k], 0.0 ); \n \n            if ( delta[0] > delta[1] && delta[1] > delta[2] ) { \n                c_dest = &( s->cells[ s->cid_marked[cid] ] ); \n                c_dest->count = c->count; \n                c_dest->parts[0] = c->parts[0]; \n                c_dest->parts[1] = c->parts[1]; \n                c_dest->parts[2] = c->parts[2]; \n                c_dest->x[0] = p->x[0]; \n                c_dest->x[1] = p->x[1]; \n                c_dest->x[2] = p->x[2]; \n                c_dest->id = cid; \n                c_dest->count = 1; \n                c_dest->parts[0].id = c->id; \n                c_dest->parts[0].count = 1; \n                c_dest->parts[0].x[0] = p->x[0]; \n                c_dest->parts[0].x[1] = p->x[1]; \n                c_dest->parts[0].x[2] = p->x[2]; \n                c_dest->parts[0].id = c->id; \n                c_dest->parts[0].count = 1; \n                c_dest->parts[0].x[0] = p->x[0]; \n                c_dest->parts[0].x[1] = p->x[1]; \n                c_dest->parts[0].x[2] = p->x[2]; \n                c_dest->parts[0].id = c->id; \n                c_dest->parts[0].count = 1; \n                c_dest->parts[0].x[0] = p->x[0]; \n                c_dest->parts[0].x[1] = p->x[1]; \n                c_dest->parts[0].x[2] = p->x[2]; \n                c_dest->parts[0].id = c->id; \n             "}
{"label": "void mexFunction(int nlhs,mxArray *plhs[],int nrhs,const mxArray *prhs[]) \n{ \n    int sens_i,sens_j,index_i; \n    float *r_i,*r_ik,*S,*H,*M; \n    double *X_d,*S_d,*H_d,*M_d; \n    neighbour *emb_dist,*k_nn; \n     \n    const int n_samples=(int)mxGetM(prhs[0]); \n    const int n_sensors=(int)mxGetN(prhs[0]); \n    const int k=(int)mxGetScalar(prhs[1]); \n    const int m=(int)mxGetScalar(prhs[2]); \n    const int tau=(int)mxGetScalar(prhs[3]); \n    const int W=(int)mxGetScalar(prhs[4]); \n    const int n_states=n_samples-(m-1)*tau; \n    const int n_indexes=n_sensors*n_sensors; \n     \n    X_d=(double*)mxGetPr(prhs[0]); \n     \n    emb_dist=(neighbour*)mxMalloc(n_states*n_states*n_sensors*sizeof(neighbour)); \n    k_nn=(neighbour*)mxMalloc(n_states*k*n_sensors*sizeof(neighbour)); \n    r_i=(float*)mxMalloc(n_states*n_sensors*sizeof(float)); \n    r_ik=(float*)mxMalloc(n_states*n_sensors*sizeof(float)); \n     \n    init_knn(n_sensors,n_states,k,k_nn); \n \n    omp_set_num_threads(omp_get_num_procs()); \n    { \n        for(sens_i=0;sens_i<n_sensors;sens_i++) \n            build_emb_dist(m,tau,n_states,k,W, \n                    emb_dist+sens_i*n_states*n_states, \n                    r_i+sens_i*n_states, \n                    r_ik+sens_i*n_states, \n                    k_nn+sens_i*n_states*k, \n                    X_d+sens_i*n_samples); \n    } \n \n    S=(float*)mxMalloc(n_indexes*sizeof(float)); \n    H=(float*)mxMalloc(n_indexes*sizeof(float)); \n    M=(float*)mxMalloc(n_indexes*sizeof(float)); \n \n     \n    for(sens_i=0;sens_i<n_sensors;sens_i++) \n    { \n        { \n        for(sens_j=0;sens_j<n_sensors;sens_j++) \n        { \n            build_SHM_indexes(sens_i,sens_j,n_sensors,n_states,k, \n                    emb_dist+sens_i*n_states*n_states, \n                    k_nn+sens_j*k*n_states, \n                    r_ik+sens_i*n_states, \n                    r_i+sens_i*n_states, \n                    S,H,M); \n        } \n        } \n    } \n \n    mxFree(emb_dist); \n    mxFree(k_nn); \n    mxFree(r_i); \n    mxFree(r_ik); \n     \n    plhs[0]=mxCreateDoubleMatrix(n_sensors,n_sensors,mxREAL); \n    plhs[1]=mxCreateDoubleMatrix(n_sensors,n_sensors,mxREAL); \n    plhs[2]=mxCreateDoubleMatrix(n_sensors,n_sensors,mxREAL); \n \n    { \n        { \n        S_d=(double*)mxGetPr(plhs[0]); \n        for(index_i=0;index_i<n_indexes;index_i++) \n            S_d[index_i]=(double)S[index_i]; \n        } \n         \n        { \n            H_d=(double*)mxGetPr(plhs[1]); \n            for(index_i=0;index_i<n_indexes;index_i++) \n                H_d[index_i]=(double)H[index_i]; \n        } \n         \n        { \n            M_d=(double*)mxGetPr(plhs[2]); \n            for(index_i=0;index_i<n_indexes;index_i++) \n                M_d[index_i]=(double)M[index_i]; \n        } \n         \n    } \n     \n    mxFree(S); \n    mxFree(H); \n    mxFree(M); \n     \n} \n ", "pred": "void mexFunction(int nlhs,mxArray *plhs[],int nrhs,const mxArray *prhs[]) \n{ \n    int sens_i,sens_j,index_i; \n    float *r_i,*r_ik,*S,*H,*M; \n    double *X_d,*S_d,*H_d,*M_d; \n    neighbour *emb_dist,*k_nn; \n     \n    const int n_samples=(int)mxGetM(prhs[0]); \n    const int n_sensors=(int)mxGetN(prhs[0]); \n    const int k=(int)mxGetScalar(prhs[1]); \n    const int m=(int)mxGetScalar(prhs[2]); \n    const int tau=(int)mxGetScalar(prhs[3]); \n    const int W=(int)mxGetScalar(prhs[4]); \n    const int n_states=n_samples-(m-1)*tau; \n    const int n_indexes=n_sensors*n_sensors; \n     \n    X_d=(double*)mxGetPr(prhs[0]); \n     \n    emb_dist=(neighbour*)mxGetData(prhs[5]); \n    k_nn=(neighbour*)mxGetData(prhs[6]); \n     \n    S=(float*)mxGetPr(prhs[7]); \n    H=(float*)mxGetPr(prhs[8]); \n    M=(float*)mxGetPr(prhs[9]); \n     \n    sens_i=0; \n    sens_j=0; \n    index_i=0; \n    index_j=0; \n     \n    for(sens_i=0;sens_i<n_sensors;sens_i++) { \n        for(sens_j=0;sens_j<n_sensors;sens_j++) { \n            for(index_i=0;index_i<n_indexes;index_i++) { \n                for(index_j=0;index_j<n_indexes;index_j++) { \n                    if(sens_i==sens_j) { \n                        k_nn->index_i=index_i; \n                        k_nn->index_j=index_j; \n                        k_nn->sens_i=sens_i; \n                        k_nn->sens_j=sens_j; \n                        k_nn->k=k; \n                        k_nn->m=m; \n                        k_nn->tau=tau; \n                        k_nn->W=W; \n                        k_nn->n_states=n_states; \n                        k_nn->n_indexes=n_indexes; \n                        k_nn->n_samples=n_samples; \n                        k_nn->n_samples_total=n_samples; \n                        k_nn->n_samples_total_squared=n_samples*n_samples; \n                        k_nn->n_samples_total_squared_squared=n_samples*n_samples*n_samples; \n                        k_nn->n_samples_total_squared_squared_squared=n_samples*n_samples*n_samples*n_samples; \n                        k_nn->n_samples_total_squared_squared_squared_squared=n_samples*n_samples*n_samples*n_samples*n_samples; \n                        k_nn->n_samples_total_squared_squared_squared_squared_squared=n_samples*n_samples*n_samples*n_samples*n_samples*n_samples; \n                        k_nn->n_samples_total_squared_squared_squared_squared_squared_squared=n_samples*n_samples*n_samples*n_samples*n_samples*n_samples*n_samples; \n                        k_nn->n_samples_total_squared_squared_squared_squared_squared_squared_squared=n_samples*n_samples*n_samples*n_samples*n_samples*n_samples*n_samples*n_samples*n_samples; \n                        k_nn->n_samples_total_squared_squared_squared_squared_squared_squared_squared_squared=n_samples*n_samples*n_samples*n_samples*n_samples*n_samples*n_samples*n_samples*n_samples*n_samples*n_samples*n_samples; \n                        k_"}
{"label": " \nint main(int argc, char* argv[]) \n{ \n    int n[SF_MAX_DIM], dim; \n    int n1, n2, nn, nw; \n    int iw; \n    float d1, d2, o1, o2, ow, dw; \n    sf_file in, out, ref; \n    bool inv; \n    int curv, mtd, niter; \n    float x0, maxoff, mu, eta, rfreq, t1, t2; \n    char buf[8]; \n    void *h; \n \n    sf_complex **ibuf, **obuf, **rbuf=NULL; \n \n    sf_init(argc, argv); \n \n    in  = sf_input(\"in\");\t \n \n    out = sf_output(\"out\");\t \n \n \n    if (SF_COMPLEX!= sf_gettype(in))  \n\tsf_error(\"FX input need complex type\"); \n \n    dim = sf_filedims(in,n); \n    if(dim<2) sf_error(\"input dim should >= 2\"); \n    nw = n[dim-1]; \n    if(dim == 2 ) nn=1; \n    else { \n\tnn = n[1]; \n\tfor(n1=2; n1<dim-1; n1++) nn *= n[n1]; \n    } \n    n1 = n[0]; \n \n    sprintf(buf,\"o%d\",dim); \n    if (!sf_histfloat(in, buf, &ow)) sf_error(\"No o%d= in input\", dim); \n    sprintf(buf,\"d%d\",dim); \n    if (!sf_histfloat(in, buf,&dw)) sf_error(\"No d%d= in input\", dim); \n \n    if (!sf_histfloat(in,\"o1\",&o1)) sf_error(\"No o1= in input\"); \n    if (!sf_histfloat(in,\"d1\",&d1)) sf_error(\"No d1= in input\"); \n \n    if (!sf_getint(\"curv\",&curv)) curv=0; \n     \n \n    if (!sf_getbool(\"inv\",&inv)) inv=false; \n     \n \n    if (!sf_getint(\"mtd\",&mtd)) mtd=0; \n     \n \n    if(mtd>0) \n    { \n\tif (!sf_getfloat(\"mu\",&mu)) mu=0.05;  \n\t \n \n    } \n    if(mtd>1) \n    { \n\tif (!sf_getfloat(\"eta\",&eta)) eta=0.05;  \n\t \n \n\tif (!sf_getint(\"niter\",&niter)) niter=5;  \n\t \n \n    } \n    if(mtd>2) \n    { \n\tref = sf_input(\"ref\"); \n\t \n \n    } else { \n\tref = NULL; \n    } \n \n \n    if (!sf_getint(\"np\",&n2)) n2=0;  \n     \n \n    if (!sf_getfloat(\"op\",&o2)) o2=0;  \n     \n \n    if (!sf_getfloat(\"dp\",&d2)) d2=0;  \n     \n \n \n\tif(inv) \n\t{ \n\t\tt1 = fabs(o2+d2*(n2-1)); \n\t\tt2 = fabs(o2); \n\t\tmaxoff=(t1>t2?t1:t2);   \n\t}else{ \n\t\tt1 = fabs(o1+d1*(n1-1)); \n\t\tt2 = fabs(o1); \n\t\tmaxoff=(t1>t2?t1:t2);   \n\t} \n \n \n    if (!sf_getfloat(\"x0\",&x0)) x0 = maxoff;  \n     \n \n \n \n    if(n2 <= 0) sf_error(\"np should larger than 0\"); \n    sf_putint  (out, \"n1\", n2); \n    sf_putfloat(out, \"o1\", o2); \n    sf_putfloat(out, \"d1\", d2); \n \n    ibuf = sf_complexalloc2(n1, nn); \n    obuf = sf_complexalloc2(n2, nn); \n \n    if(inv) \n    {\t \n\th =\tsf_frt_init(mtd, curv, \n\t\t\t    o2/x0, d2/x0, n2, \t \n \n\t\t\t    o1, d1, n1\t\t\t\t \n \n\t    ); \n    }else{ \n\th =\tsf_frt_init(mtd, curv, \n\t\t\t    o1/x0, d1/x0, n1, \t \n \n\t\t\t    o2, d2, n2\t\t\t\t \n \n\t    ); \n\tif(mtd == 3) \n\t{ \n\t    sprintf(buf,\"o%d\",dim); \n\t    if (!sf_histfloat(ref, buf, &rfreq))  \n\t\tsf_error(\"No o%d= in input\", dim); \n\t    sf_complexread(ibuf[0], n1*nn, ref); \n\t    rbuf = sf_complexalloc2(n2, nn); \n\t    sf_fhrt(h, rfreq, ibuf, rbuf, nn, mu, eta, niter); \n\t    sf_fhrt_reg(rbuf, n2, nn, mu, eta); \n\t} \n    } \n \n    for(iw=0; iw<nw; iw++) \n    { \n\tsf_complexread(ibuf[0], n1*nn, in); \n\tif(inv)\t \n\t    sf_ifart(h, ow+dw*iw, ibuf, obuf, nn); \n\telse \n\t{ \n\t    switch(mtd) \n\t    { \n\t\tcase 1: \n\t\t    sf_firt(h, ow+dw*iw, ibuf, obuf, nn, mu); \n\t\t    break; \n\t\tcase 2: \n\t\t    sf_fhrt(h, ow+dw*iw, ibuf, obuf, nn, mu, eta, niter); \n\t\t    break; \n\t\tcase 3: \n\t\t    sf_fcrt(h, ow+dw*iw, ibuf, obuf, rbuf, nn); \n\t\t    break; \n\t\tdefault: \n\t\t    sf_fart(h, ow+dw*iw, ibuf, obuf, nn); \n\t\t    break; \n\t    } \n\t} \n \n\tsf_complexwrite(obuf[0], n2*nn, out); \n    } \n \n    sf_frt_close(h); \n \n    free(ibuf[0]); \n    free(ibuf); \n    free(obuf[0]); \n    free(obuf); \n    return 0; \n} ", "pred": " \nint main(int argc, char* argv[]) \n{ \n    int n[SF_MAX_DIM], dim; \n    int n1, n2, nn, nw; \n    int iw; \n    float d1, d2, o1, o2, ow, dw; \n    sf_file in, out, ref; \n    bool inv; \n    int curv, mtd, niter; \n    float x0, maxoff, mu, eta, rfreq, t1, t2; \n    char buf[8]; \n    void *h; \n \n    sf_complex **ibuf, **obuf, **rbuf=NULL; \n \n    sf_init(argc, argv); \n \n    in  = sf_input(\"in\");\t \n \n    out = sf_output(\"out\");\t \n \n \n    if (SF_COMPLEX!= sf_gettype(in))  \n\tsf_error(\"FX input need complex type\"); \n \n    dim = sf_filedims(in,n); \n    if(dim<2) sf_error(\"input dim should >= 2\"); \n    nw = n[dim-1]; \n    if(dim == 2 ) nn = 1; \n    else           nn = n[dim-2]; \n \n    if (!sf_histint(in,\"n1\",&n1)) sf_error(\"No n1= in input\"); \n    if (!sf_histint(in,\"n2\",&n2)) sf_error(\"No n2= in input\"); \n    if (!sf_histint(in,\"n3\",&nw)) sf_error(\"No n3= in input\"); \n \n    if (!sf_getint(\"iw\",&iw)) iw=1; \n    /* window size */ \n \n    if (!sf_getfloat(\"d1\",&d1)) d1=1.; \n    /* first derivative */ \n \n    if (!sf_getfloat(\"d2\",&d2)) d2=1.; \n    /* second derivative */ \n \n    if (!sf_getfloat(\"o1\",&o1)) o1=0.; \n    /* first offset */ \n \n    if (!sf_getfloat(\"o2\",&o2)) o2=0.; \n    /* second offset */ \n \n    if (!sf_getfloat(\"ow\",&ow)) ow=1.; \n    /* output offset */ \n \n    if (!sf_getfloat(\"dw\",&dw)) dw=1.; \n    /* output width */ \n \n    if (!sf_getint(\"nw\",&nw)) nw=1; \n    /* window size */ \n \n    if (!sf_getint(\"niter\",&niter)) niter=10; \n    /* number of iterations */ \n \n    if (!sf_getfloat(\"x0\",&x0)) x0=0.; \n    /* initial condition */ \n \n    if (!sf_getfloat(\"maxoff\",&maxoff)) maxoff=0.; \n    /* maximum offset */ \n \n    if (!sf_getfloat(\"mu\",&mu)) mu=0.; \n    /* maximum offset */ \n \n    if (!sf_getfloat(\"eta\",&eta)) eta=0.; \n    /* maximum offset */ \n \n    if (!sf_getfloat(\"rfreq\",&rfreq)) rfreq=0.; \n    /* frequency */ \n \n    if (!sf_getfloat(\"t1\",&t1)) t1=0.; \n    /* first time */ \n \n    if (!sf_getfloat(\"t2\",&t2)) t2=0.; \n    /* second time */ \n \n    if (!sf_getbool(\"inv\",&inv)) inv=false; \n    /* inverse flag */ \n \n    if (!sf_getint(\"curv\",&curv)) curv=0; \n    /* current iteration */ \n \n    if (!sf_getint(\"mtd\",&mtd)) mtd=0; \n    /* current iteration */ \n \n    if (!sf_getint(\"n1\",&n1)) n1=1; \n    /* number of points in first window */ \n \n    if (!sf_getint(\"n2\",&n2)) n2=1; \n    /* number of points in second window */ \n \n    if (!sf_getint(\"nn\",&nn)) nn=1; \n    /* number of points in third window */ \n \n    if (!sf_getint(\"nw\",&nw)) nw=1; \n    /* number of points in fourth window */ \n \n    if (!sf_getint(\"iw\",&iw)) iw=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw2\",&iw2)) iw2=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw3\",&iw3)) iw3=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw4\",&iw4)) iw4=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw5\",&iw5)) iw5=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw6\",&iw6)) iw6=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw7\",&iw7)) iw7=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw8\",&iw8)) iw8=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw9\",&iw9)) iw9=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw10\",&iw10)) iw10=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw11\",&iw11)) iw11=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw12\",&iw12)) iw12=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw13\",&iw13)) iw13=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw14\",&iw14)) iw14=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw15\",&iw15)) iw15=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw16\",&iw16)) iw16=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw17\",&iw17)) iw17=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw18\",&iw18)) iw18=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw19\",&iw19)) iw19=1; \n    /* window size */ \n \n    if (!sf_getint(\"iw20\",&iw20)) iw20=1; \n    /* window size */ \n \n"}
{"label": " \nstatic void THNN_(SpatialAdaptiveAveragePooling_updateOutput_frame)( \n          real *input_p, \n          real *output_p, \n          long nslices, \n          long iwidth, \n          long iheight, \n          long owidth, \n          long oheight, \n          long stridew, \n          long strideh, \n          long strided) \n{ \n  long k; \n  for (k = 0; k < nslices; k++) \n  { \n     \n \n    long i, j; \n    for(i = 0; i < oheight; i++) \n    { \n      int y_start = START_IND(i, oheight, iheight); \n      int y_end   = END_IND(i, oheight, iheight); \n      int kH = y_end-y_start; \n \n      for(j = 0; j < owidth; j++) \n      { \n \n        int x_start = START_IND(j, owidth, iwidth); \n        int x_end   = END_IND(j, owidth, iwidth); \n        int kW = x_end-x_start; \n \n         \n \n        real *ip = input_p   + k*strided + y_start*strideh + x_start*stridew; \n        real *op = output_p  + k*owidth*oheight + i*owidth + j; \n \n         \n \n        real sum = 0; \n        int x,y; \n        for(y = 0; y < kH; y++) \n        { \n          for(x = 0; x < kW; x++) \n          { \n            real val = *(ip + y*strideh + x*stridew); \n            sum += val; \n          } \n        } \n \n         \n \n        *op = sum / kW / kH; \n      } \n    } \n  } \n} ", "pred": " \nstatic void THNN_(SpatialAdaptiveAveragePooling_updateOutput_frame)( \n          real *input_p, \n          real *output_p, \n          long nslices, \n          long iwidth, \n          long iheight, \n          long owidth, \n          long oheight, \n          long stridew, \n          long strideh, \n          long strided) \n{ \n  long k; \n  for (k = 0; k < nslices; k++) \n  { \n     \n \n    long i, j; \n    for(i = 0; i < oheight; i++) \n    { \n      int y_start = START_IND(i, oheight, iheight); \n      int y_end   = END_IND(i, oheight, iheight); \n      int kH = y_end-y_start; \n \n      for(j = 0; j < owidth; j++) \n      { \n        int x_start = START_IND(j, owidth, iwidth); \n        int x_end   = END_IND(j, owidth, iwidth); \n        int kW = x_end-x_start; \n \n        for( ; kH > 0; kH--) \n        { \n          int x = x_start; \n          int y = y_start; \n          int kW2 = kW; \n          int kH2 = kH; \n          int kW4 = kW2*4; \n          int kH4 = kH2*4; \n          int kW8 = kW4*8; \n          int kH8 = kH4*8; \n          int kW16 = kW8*16; \n          int kH16 = kH8*16; \n          int kW32 = kW16*32; \n          int kH32 = kH16*32; \n          int kW64 = kW32*64; \n      "}
{"label": " \nvoid x_solve() \n{ \n  int i, j, k, m, n, isize; \n \n   \n \n   \n \n \n  if (timeron) timer_start(t_xsolve); \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n  isize = grid_points[0]-1; \n \n   \n \n   \n \n   \n \n  for (k = 1; k <= grid_points[2]-2; k++) { \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      for (i = 0; i <= isize; i++) { \n        tmp1 = rho_i[k][j][i]; \n        tmp2 = tmp1 * tmp1; \n        tmp3 = tmp1 * tmp2; \n         \n \n         \n \n         \n \n        fjac[i][0][0] = 0.0; \n        fjac[i][1][0] = 1.0; \n        fjac[i][2][0] = 0.0; \n        fjac[i][3][0] = 0.0; \n        fjac[i][4][0] = 0.0; \n \n        fjac[i][0][1] = -(u[k][j][i][1] * tmp2 * u[k][j][i][1]) \n          + c2 * qs[k][j][i]; \n        fjac[i][1][1] = ( 2.0 - c2 ) * ( u[k][j][i][1] / u[k][j][i][0] ); \n        fjac[i][2][1] = - c2 * ( u[k][j][i][2] * tmp1 ); \n        fjac[i][3][1] = - c2 * ( u[k][j][i][3] * tmp1 ); \n        fjac[i][4][1] = c2; \n \n        fjac[i][0][2] = - ( u[k][j][i][1]*u[k][j][i][2] ) * tmp2; \n        fjac[i][1][2] = u[k][j][i][2] * tmp1; \n        fjac[i][2][2] = u[k][j][i][1] * tmp1; \n        fjac[i][3][2] = 0.0; \n        fjac[i][4][2] = 0.0; \n \n        fjac[i][0][3] = - ( u[k][j][i][1]*u[k][j][i][3] ) * tmp2; \n        fjac[i][1][3] = u[k][j][i][3] * tmp1; \n        fjac[i][2][3] = 0.0; \n        fjac[i][3][3] = u[k][j][i][1] * tmp1; \n        fjac[i][4][3] = 0.0; \n \n        fjac[i][0][4] = ( c2 * 2.0 * square[k][j][i] - c1 * u[k][j][i][4] ) \n          * ( u[k][j][i][1] * tmp2 ); \n        fjac[i][1][4] = c1 *  u[k][j][i][4] * tmp1  \n          - c2 * ( u[k][j][i][1]*u[k][j][i][1] * tmp2 + qs[k][j][i] ); \n        fjac[i][2][4] = - c2 * ( u[k][j][i][2]*u[k][j][i][1] ) * tmp2; \n        fjac[i][3][4] = - c2 * ( u[k][j][i][3]*u[k][j][i][1] ) * tmp2; \n        fjac[i][4][4] = c1 * ( u[k][j][i][1] * tmp1 ); \n \n        njac[i][0][0] = 0.0; \n        njac[i][1][0] = 0.0; \n        njac[i][2][0] = 0.0; \n        njac[i][3][0] = 0.0; \n        njac[i][4][0] = 0.0; \n \n        njac[i][0][1] = - con43 * c3c4 * tmp2 * u[k][j][i][1]; \n        njac[i][1][1] =   con43 * c3c4 * tmp1; \n        njac[i][2][1] =   0.0; \n        njac[i][3][1] =   0.0; \n        njac[i][4][1] =   0.0; \n \n        njac[i][0][2] = - c3c4 * tmp2 * u[k][j][i][2]; \n        njac[i][1][2] =   0.0; \n        njac[i][2][2] =   c3c4 * tmp1; \n        njac[i][3][2] =   0.0; \n        njac[i][4][2] =   0.0; \n \n        njac[i][0][3] = - c3c4 * tmp2 * u[k][j][i][3]; \n        njac[i][1][3] =   0.0; \n        njac[i][2][3] =   0.0; \n        njac[i][3][3] =   c3c4 * tmp1; \n        njac[i][4][3] =   0.0; \n \n        njac[i][0][4] = - ( con43 * c3c4 \n            - c1345 ) * tmp3 * (u[k][j][i][1]*u[k][j][i][1]) \n          - ( c3c4 - c1345 ) * tmp3 * (u[k][j][i][2]*u[k][j][i][2]) \n          - ( c3c4 - c1345 ) * tmp3 * (u[k][j][i][3]*u[k][j][i][3]) \n          - c1345 * tmp2 * u[k][j][i][4]; \n \n        njac[i][1][4] = ( con43 * c3c4 \n            - c1345 ) * tmp2 * u[k][j][i][1]; \n        njac[i][2][4] = ( c3c4 - c1345 ) * tmp2 * u[k][j][i][2]; \n        njac[i][3][4] = ( c3c4 - c1345 ) * tmp2 * u[k][j][i][3]; \n        njac[i][4][4] = ( c1345", "pred": " \nvoid x_solve() \n{ \n  int i, j, k, m, n, isize; \n \n   \n \n   \n \n \n  if (timeron) timer_start(t_xsolve); \n \n   \n \n   \n \n \n   \n \n   \n \n   \n \n \n  isize = grid_points[0]-1; \n \n   \n \n   \n \n   \n \n  for (k = 1; k <= grid_points[2]-2; k++) { \n    for (j = 1; j <= grid_points[1]-2; j++) { \n      for (i = 0; i <= isize; i++) { \n        tmp1 = rho_i[k][j][i]; \n        tmp2 = tmp1 * tmp1; \n        tmp3 = tmp1 * tmp2; \n         \n \n         \n \n         \n \n        fjac[i][0][0] = 0.0; \n        fjac[i][1][0] = 1.0; \n        fjac[i][2][0] = 0.0; \n        fjac[i][0][1] = 0.0; \n        fjac[i][1][1] = 0.0; \n        fjac[i][2][1] = 0.0; \n        fjac[i][0][2] = 0.0; \n        fjac[i][1][2] = 0.0; \n        fjac[i][2][2] = 0.0; \n        fjac[i][0][3] = 0.0; \n        fjac[i][1][3] = 0.0; \n        fjac[i][2][3] = 0.0; \n        fjac[i][0][4] = 0.0; \n        fjac[i][1][4] = 0.0; \n        fjac[i][2][4] = 0.0; \n        fjac[i][0][5] = 0.0; \n        fjac[i][1][5] = 0.0; \n        fjac[i][2][5] = 0.0; \n        fjac[i][0][6] = 0.0; \n        fjac[i][1][6] = 0.0; \n        fjac[i][2][6] = 0.0; \n        fjac[i][0][7] = 0.0; \n        fjac[i][1][7] = 0.0; \n        fjac[i][2][7] = 0.0; \n        fjac[i][0][8] = 0.0; \n        fjac[i][1][8] = 0.0; \n        fjac[i][2][8] = 0.0; \n        fjac[i][0][9] = 0.0; \n        fjac[i][1][9] = 0.0; \n        fjac[i][2][9] = 0.0; \n        fjac[i][0][10] = 0.0; \n        fjac[i][1][10] = 0.0; \n        fjac[i][2][10] = 0.0; \n        fjac[i][0][11] = 0.0; \n        fjac[i][1][11] = 0.0; \n        fjac[i][2][11] = 0.0; \n        fjac[i][0][12] = 0.0; \n        fjac[i][1][12] = 0.0; \n        fjac[i][2][12] = 0.0; \n        fjac[i][0][13] = 0.0; \n        fjac[i][1][13] = 0.0; \n        fjac[i][2][13] = 0.0; \n        fjac[i][0][14] = 0.0; \n        fjac[i][1][14] = 0.0; \n        fjac[i][2][14] = 0.0; \n        fjac[i][0][15] = 0.0; \n        fjac[i][1][15] = 0.0; \n        fjac[i][2][15] = 0.0; \n        fjac[i][0][16] = 0.0; \n        fjac[i][1][16] = 0.0; \n        fjac[i][2][16] = 0.0; \n        fjac[i][0][17] = 0.0; \n        fjac[i][1][17] = 0.0; \n        fjac[i][2][17] = 0.0; \n        fjac[i][0][18] = 0.0; \n        fjac[i][1][18] = 0.0; \n        fjac[i][2][18] = 0.0; \n        fjac[i][0][19] = 0.0; \n        fjac[i][1][19] = 0.0; \n        fjac[i][2][19] = 0.0; \n        fjac[i][0][20] = 0.0; \n        fjac[i][1][20] = 0.0; \n        fjac[i][2][20] = 0.0; \n        fjac[i][0][21] = 0.0; \n        fjac[i][1][21] = 0.0; \n        fjac[i][2][21] = 0.0; \n        fjac[i][0][22] = 0.0; \n        fjac[i][1][22] = 0.0; \n        fjac[i][2][22] = 0.0; \n        fjac[i][0][23] = 0.0; \n        fjac[i][1][23] = 0.0; \n        fjac[i][2][23] = 0.0; \n        fjac[i][0][24] = 0.0; \n        fjac[i][1][24] = 0.0; \n        fjac[i][2][24] = 0.0; \n        fjac[i][0][25] = 0.0; \n        fjac[i][1][25] = 0.0; \n        fjac[i][2][25] = 0.0; \n        fjac[i][0][26] = 0.0; \n        fjac[i][1][26] = 0.0; \n        fjac[i][2][26] = 0.0; \n        fjac[i][0][27"}
{"label": " \nint test_loop_outer2(test_data *td) { \n \n     int i; \n \n     int count; \n \n     test_xrtm_data *test_xrtm; \n \n     test_xrtm_data **test_xrtm_array; \n \n     count = list_count(&td->test_xrtm_list); \n \n     test_xrtm_array = malloc(count * sizeof(test_xrtm_data *)); \n \n     i = 0; \n     list_for_each(&td->test_xrtm_list, test_xrtm) { \n          test_xrtm_array[i] = test_xrtm; \n          ++i; \n     } \n{ \n     for (i = 0; i < count; ++i) { \n \n \n          if (test_loop_inner(td, i, test_xrtm_array[i])) { \n               fprintf(stderr, \"ERROR: test_loop_inner()\\n\"); \n               exit(1); \n          } \n     } \n} \n \n     free(test_xrtm_array); \n \n     return 0; \n} ", "pred": " \nint test_loop_outer2(test_data *td) { \n \n     int i; \n \n     int count; \n \n     test_xrtm_data *test_xrtm; \n \n     test_xrtm_data **test_xrtm_array; \n \n     count = list_count(&td->test_xrtm_list); \n \n     test_xrtm_array = malloc(count * sizeof(test_xrtm_data *)); \n \n     i = 0; \n     list_for_each(&td->test_xrtm_list, test_xrtm) { \n          test_xrtm_array[i] = test_xrtm; \n          ++i; \n     } \n{ \n     for (i = 0; i < count; ++i) { \n \n \n          if (test_loop_inner(td, i, test_xrtm_array[i])) { \n               fprintf(stderr, \"ERROR: test_loop_inner()\\n\"); \n               return 1; \n          } \n     } \n } \n \n     return 0; \n} \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n"}
{"label": " \nint space_shuffle_local ( struct space *s ) { \n \n    int k, cid, pid, delta[3]; \n    FPTYPE h[3]; \n    struct space_cell *c, *c_dest; \n    struct particle *p; \n     \n     \n \n    for ( k = 0 ; k < 3 ; k++ ) \n        h[k] = s->h[k]; \n \n    for ( cid = 0 ; cid < s->nr_real ; cid++ ) { \n        c = &(s->cells[ s->cid_real[cid] ]); \n        pid = 0; \n        while ( pid < c->count ) { \n \n            p = &( c->parts[pid] ); \n            for ( k = 0 ; k < 3 ; k++ ) \n                delta[k] = __builtin_isgreaterequal( p->x[k], h[k] ) - __builtin_isless( p->x[k], 0.0 ); \n \n             \n \n            if ( ( delta[0]!= 0 ) || ( delta[1]!= 0 ) || ( delta[2]!= 0 ) ) { \n             \n                for ( k = 0 ; k < 3 ; k++ ) \n                    p->x[k] -= delta[k] * h[k]; \n                c_dest = &( s->cells[ space_cellid( s, \n                    (c->loc[0] + delta[0] + s->cdim[0]) % s->cdim[0],  \n                    (c->loc[1] + delta[1] + s->cdim[1]) % s->cdim[1],  \n                    (c->loc[2] + delta[2] + s->cdim[2]) % s->cdim[2] ) ] ); \n \n\t            if ( c_dest->flags & cell_flag_marked ) { \n                    pthread_mutex_lock(&c_dest->cell_mutex); \n                    space_cell_add_incomming( c_dest, p ); \n\t                pthread_mutex_unlock(&c_dest->cell_mutex); \n                    s->celllist[ p->id ] = c_dest; \n                    } \n                else { \n                    s->partlist[ p->id ] = NULL; \n                    s->celllist[ p->id ] = NULL; \n                    } \n                s->celllist[ p->id ] = c_dest; \n                 \n                c->count -= 1; \n                if ( pid < c->count ) { \n                    c->parts[pid] = c->parts[c->count]; \n                    s->partlist[ c->parts[pid].id ] = &( c->parts[pid] ); \n                    } \n                } \n            else \n                pid += 1; \n            } \n        } \n \n     \n \n    return space_err_ok; \n \n    } ", "pred": " \nint space_shuffle_local ( struct space *s ) { \n \n    int k, cid, pid, delta[3]; \n    FPTYPE h[3]; \n    struct space_cell *c, *c_dest; \n    struct particle *p; \n     \n     \n \n    for ( k = 0 ; k < 3 ; k++ ) \n        h[k] = s->h[k]; \n \n    for ( cid = 0 ; cid < s->nr_real ; cid++ ) { \n        c = &(s->cells[ s->cid_real[cid] ]); \n        pid = 0; \n        while ( pid < c->count ) { \n \n            p = &( c->parts[pid] ); \n            for ( k = 0 ; k < 3 ; k++ ) \n                delta[k] = __builtin_isgreaterequal( p->x[k], h[k] ) - __builtin_isless( p->x[k], 0.0 ); \n \n            if ( delta[0] > delta[1] && delta[1] > delta[2] ) { \n                c_dest = &( s->cells[ s->cid_real[cid] ] ); \n                c_dest->count = c->count; \n                c_dest->parts[0] = c->parts[0]; \n                c_dest->parts[1] = c->parts[1]; \n                c_dest->parts[2] = c->parts[2]; \n                c_dest->x[0] = p->x[0]; \n                c_dest->x[1] = p->x[1]; \n                c_dest->x[2] = p->x[2]; \n                c_dest->id = cid; \n                c_dest->count = c->count; \n                c_dest->parts[0] = c->parts[0]; \n                c_dest->parts[1] = c->parts[1]; \n                c_dest->parts[2] = c->parts[2]; \n                c_dest->x[0] = p->x[0]; \n                c_dest->x[1] = p->x[1]; \n                c_dest->x[2] = p->x[2]; \n                c_dest->id = cid; \n                c_dest->count = c->count; \n                c_dest->parts[0] = c->parts[0]; \n                c_dest->parts[1] = c->parts[1]; \n                c_dest->parts[2] = c->parts[2]; \n                c_dest->x[0] = p->x[0]; \n                c_dest->x[1] = p->x[1]; \n                c_dest->x[2] = p->x[2]; \n                c_dest->id = cid; \n                c_dest->count = c->count; \n                c_dest->parts[0] = c->parts[0]; \n                c_dest->parts[1] = c->parts[1]; \n                c_dest->parts[2] = c"}
{"label": " \nstatic void process_lch_xtrans(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                               void *const ovoid, const dt_iop_roi_t *const roi_in, \n                               const dt_iop_roi_t *const roi_out, const float clip) \n{ \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    float *out = (float *)ovoid + (size_t)roi_out->width * j; \n    float *in = (float *)ivoid + (size_t)roi_in->width * j; \n \n     \n \n     \n \n     \n \n    int cl = 0; \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n       \n \n      cl = (cl << 1) & 6; \n      if(j >= 2 && j <= roi_out->height - 3) \n      { \n        cl |= (in[-roi_in->width] > clip) | (in[0] > clip) | (in[roi_in->width] > clip); \n      } \n \n      if(i < 2 || i > roi_out->width - 3 || j < 2 || j > roi_out->height - 3) \n      { \n         \n \n        out[0] = MIN(clip, in[0]); \n      } \n      else \n      { \n         \n \n        int clipped = (in[0] > clip); \n        if(!clipped) \n        { \n          clipped = cl; \n          if(clipped) \n          { \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n             \n \n            for(int offset_j = -2; offset_j <= 0; offset_j++) \n            { \n              for(int offset_i = -2; offset_i <= 0; offset_i++) \n              { \n                if(clipped) \n                { \n                  clipped = 0; \n                  for(int jj = offset_j; jj <= offset_j + 2; jj++) \n                  { \n                    for(int ii = offset_i; ii <= offset_i + 2; ii++) \n                    { \n                      const float val = in[(ssize_t)jj * roi_in->width + ii]; \n                      clipped = (clipped || (val > clip)); \n                    } \n                  } \n                } \n              } \n            } \n          } \n        } \n \n        if(clipped) \n        { \n          float mean[3] = { 0.0f, 0.0f, 0.0f }; \n          int cnt[3] = { 0, 0, 0 }; \n          float RGBmax[3] = { -FLT_MAX, -FLT_MAX, -FLT_MAX }; \n \n          for(int jj = -1; jj <= 1; jj++) \n          { \n            for(int ii = -1; ii <= 1; ii++) \n            { \n              const float val = in[(ssize_t)jj * roi_in->width + ii]; \n              const int c = FCxtrans(j+jj, i+ii, roi_in, xtrans); \n              mean[c] += val; \n              cnt[c]++; \n              RGBmax[c] = MAX(RGBmax[c], val); \n            } \n          } \n \n          const float Ro = MIN(mean[0]/cnt[0], clip); \n          const float Go = MIN(mean[1]/cnt[1], clip); \n          const float Bo = MIN(mean[2]/cnt[2], clip); \n \n          const float R = RGBmax[0]; \n          const float G = RGBmax[1]; \n          const float B = RGBmax[2]; \n \n          const float L = (R + G + B) / 3.0f; \n \n          float C = SQRT3 * (R - G); \n          float H = 2.0f * B - G - R; \n \n          const float Co = SQRT3 * (Ro - Go); \n          const float Ho = 2.0f * Bo - Go - Ro; \n \n          if(R!= G && G!= B) \n          { \n            const float ratio = sqrtf((Co * Co + Ho * Ho) / (C * C + H * H)); \n            C *= ratio; \n            H *= ratio; \n          } \n \n          float RGB[3] = { 0.0f, 0.0f, 0.0f }; \n \n          RGB[0] = L - H / 6.0f + C / SQRT12; \n          RGB[1] = L - H / 6.0f - C / SQRT12; \n          RGB[2] = L + H / 3.0f; \n \n          out[0] = RGB[FCxtrans(j, i, roi_out, xtrans)]; \n        } \n     ", "pred": " \nstatic void process_lch_xtrans(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                               void *const ovoid, const dt_iop_roi_t *const roi_in, \n                               const dt_iop_roi_t *const roi_out, const float clip) \n{ \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    float *out = (float *)ovoid + (size_t)roi_out->width * j; \n    float *in = (float *)ivoid + (size_t)roi_in->width * j; \n \n     \n \n     \n \n     \n \n    int cl = 0; \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      const float x = xtrans[cl][0] * in[i]; \n      const float y = xtrans[cl][1] * in[i]; \n      const float z = xtrans[cl][2] * in[i]; \n      const float w = xtrans[cl][3] * in[i]; \n      const float v = xtrans[cl][4] * in[i]; \n      const float u = xtrans[cl][5] * in[i]; \n      const float t = clip * (x - roi_in->x) + roi_in->x; \n      const float s = clip * (y - roi_in->y) + roi_in->y; \n      const float p = clip * (z - roi_in->z) + roi_in->z; \n      const float q = clip * (w - roi_in->w) + roi_in->w; \n      const float r = clip * (v - roi_in->v) + roi_in->v; \n      const float g = clip * (u - roi_in->u) + roi_in->u; \n      const float b = clip * (t - roi_in->t) + roi_in->t; \n      const float a = clip * (s - roi_in->s) + roi_in->s; \n      \n      out[i] = r * x + g * y + b * z + a; \n      cl++; \n    } \n  } \n  \n}\n\nstatic void process_lch_xtrans_rgb(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                                   void *const ovoid, const dt_iop_roi_t *const roi_in, \n                                   const dt_iop_roi_t *const roi_out, const float clip) \n{ \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    float *out = (float *)ovoid + (size_t)roi_out->width * j; \n    float *in = (float *)ivoid + (size_t)roi_in->width * j; \n \n     \n \n     \n \n     \n \n     \n \n    int cl = 0; \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      const float x = xtrans[cl][0] * in[i]; \n      const float y = xtrans[cl][1] * in[i]; \n      const float z = xtrans[cl][2] * in[i]; \n      const float w = xtrans[cl][3] * in[i]; \n      const float v = xtrans[cl][4] * in[i]; \n      const float u = xtrans[cl][5] * in[i]; \n      const float t = clip * (x - roi_in->x) + roi_in->x; \n      const float s = clip * (y - roi_in->y) + roi_in->y; \n      const float p = clip * (z - roi_in->z) + roi_in->z; \n      const float q = clip * (w - roi_in->w) + roi_in->w; \n      const float r = clip * (v - roi_in->v) + roi_in->v; \n      const float g = clip * (u - roi_in->u) + roi_in->u; \n      const float b = clip * (t - roi_in->t) + roi_in->t; \n      const float a = clip * (s - roi_in->s) + roi_in->s; \n      \n      out[i] = r * x + g * y + b * z + a; \n      cl++; \n    } \n  } \n  \n}\n\nstatic void process_lch_xtrans_hsv(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                                   void *const ovoid, const dt_iop_roi_t *const roi_in, \n                                   const dt_iop_roi_t *const roi_out, const float clip) \n{ \n  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    float *out = (float *)ovoid + (size_t)roi_out->width * j; \n    float *in = (float *)ivoid + (size_t)roi_in->width * j; \n \n     \n \n     \n \n     \n \n     \n \n    int cl = 0; \n \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      const float x = xtrans[cl][0] * in[i]; \n      const float y = xtrans[cl][1] * in[i]; \n      const float z = xtrans[cl][2] * in[i]; \n      const float w = xtrans[cl][3] * in[i]; \n      const float v = xtrans[cl][4] * in[i]; \n      const float u = xtrans[cl][5] * in[i]; \n      const float t = clip * (x - roi_in->x) + roi_in->x; \n      const float s = clip * (y - roi_in->y) + roi_in->y; \n      const float p = clip * (z - roi_in->z) + roi_in->z; \n      const float q = clip * (w - roi_in->w) + roi_in->w; \n      const float r = clip * (v - roi_in->"}
{"label": " \nvoid update_gauge(const double step, hamiltonian_field_t * const hf) { \n  double atime, etime; \n  atime = gettime(); \n  MG_update_gauge(step); \n \n#define static \n  { \n  int i,mu; \n  static su3 v,w; \n  su3 *z; \n  static su3adj deriv; \n  su3adj *xm; \n \n#undef static \n \n  for(i = 0; i < VOLUME; i++) {  \n    for(mu = 0; mu < 4; mu++){ \n       \n \n      xm = &hf->momenta[i][mu]; \n      z = &hf->gaugefield[i][mu]; \n      _su3adj_assign_const_times_su3adj(deriv, step, *xm); \n      exposu3(&w,&deriv); \n      restoresu3(&v,&w); \n      _su3_times_su3(w, v, *z); \n      restoresu3(&v,&w); \n      _su3_assign(*z, v); \n    } \n  } \n \n  }  \n \n   \n   \n \n  xchange_gauge(hf->gaugefield); \n   \n   \n \n  convert_32_gauge_field(g_gauge_field_32, hf->gaugefield, VOLUMEPLUSRAND + g_dbw2rand); \n   \n   \n \n  hf->update_gauge_copy = 1; \n  g_update_gauge_copy = 1; \n  g_update_gauge_copy_32 = 1; \n \n  etime = gettime(); \n  if(g_debug_level > 1 && g_proc_id == 0) { \n    printf(\"# Time gauge update: %e s\\n\", etime-atime);  \n  }  \n  return; \n} ", "pred": " \nvoid update_gauge(const double step, hamiltonian_field_t * const hf) { \n  double atime, etime; \n  atime = gettime(); \n  MG_update_gauge(step); \n \n#define static \n  { \n  int i,mu; \n  static su3 v,w; \n  su3 *z; \n  static su3adj deriv; \n  su3adj *xm; \n \n#undef static \n \n  for(i = 0; i < VOLUME; i++) {  \n    for(mu = 0; mu < 4; mu++){ \n       \n \n      xm = &hf->momenta[i][mu]; \n      z = &hf->gaugefield[i][mu]; \n      _su3adj_assign_const_times_su3adj(deriv, step, *xm); \n      exposu3(&w,&deriv); \n      restoresu3(&v,&w); \n      _su3_times_su3(w, v, *z); \n      restoresu3(&v,&w); \n      _su3_assign(*z, v); \n      \n    } \n  } \n  \n  } \n  \n  \n  \n} \n  \nvoid update_gauge_2(const double step, hamiltonian_field_t * const hf) { \n  double atime, etime; \n  atime = gettime(); \n  MG_update_gauge_2(step); \n \n#define static \n  { \n  int i,mu; \n  static su3 v,w; \n  su3 *z; \n  static su3adj deriv; \n  su3adj *xm; \n \n#undef static \n \n  for(i = 0; i < VOLUME; i++) {  \n    for(mu = 0; mu < 4; mu++){ \n       \n \n     "}
{"label": " \nint __interpolate_interp2d_gsl(int nx, const double *x, \n                               int ny, const double *y, \n                               int nxy, const double *v, \n                               int nxq, const double *xq, \n                               int nyq, const double *yq, \n                               int nxyq, double *vq, \n                               enum interp2d_type_enum method, \n                               bool lqpts_grid) \n{ \n    const char *fcnm = \"__interpolate_interp2d_gsl\\0\"; \n    gsl_interp_accel *xacc, *yacc; \n    gsl_interp2d *work; \n    double *xs, *ys, xint, xmax, xmin, yint, ymax, ymin; \n    int gsl_err, ierr, indx, ix, ixq, iy, iyq, jndx; \n     \n \n    xs = NULL; \n    ys = NULL; \n     \n \n    ierr =-1; \n    if (nx < 2 || ny < 2 || nxy!= nx*ny) \n    { \n        if (nx < 1){log_errorF(\"%s: Error no data points in x!\\n\", fcnm);} \n        if (ny < 1){log_errorF(\"%s: Error no data points in y!\\n\", fcnm);} \n        if (method!= NEAREST2D){ \n            log_errorF(\"%s: Insufficient number of points in x!\\n\", fcnm); \n        } \n        if (nxy!= nx*ny){ \n            log_errorF(\"%s: Error size of v is inconsistent (%d!= %d x %d)\\n\", \n                        fcnm, nxy, nx, ny); \n        } \n        goto ERROR;  \n    } \n    if (nxq < 1 || nyq < 1) \n    { \n        if (nxq < 1){log_errorF(\"%s: Error x interp points\\n\", fcnm);} \n        if (nyq < 1){log_errorF(\"%s: Error y interp points\\n\", fcnm);} \n        goto ERROR; \n    } \n    if (lqpts_grid){ \n        if (nxyq!= nxq*nyq){ \n            log_errorF(\"%s: Size of vq is inconstient (%d!= %d x %d)\\n\", \n                       fcnm, nxyq, nxq, nyq); \n            goto ERROR; \n        } \n    }else{ \n        if (nxyq!= nxq || nxyq!= nyq){ \n            log_errorF(\"%s: Size of vq is inconsitent (%d, %d!= %d\\n\", \n                       fcnm, nxq, nyq, nxyq); \n            goto ERROR; \n        } \n    } \n    ierr =-2; \n    if (x  == NULL ||  y == NULL ||  v == NULL || \n        xq == NULL || yq == NULL || vq == NULL) \n    { \n        if (x == NULL){log_errorF(\"%s: Error x null pointer!\\n\", fcnm);} \n        if (y == NULL){log_errorF(\"%s: Error y null pointer!\\n\", fcnm);} \n        if (v == NULL){log_errorF(\"%s: Error v null pointer!\\n\", fcnm);} \n        if (xq == NULL){log_errorF(\"%s: Error xq null pointer!\\n\", fcnm);} \n        if (yq == NULL){log_errorF(\"%s: Error yq null pointer!\\n\", fcnm);} \n        if (vq == NULL){log_errorF(\"%s: Error vq null pointer!\\n\", fcnm);} \n        goto ERROR;  \n    } \n    ierr =-3; \n    if (method == NEAREST2D) \n    { \n        if (nxy < 1){ \n            log_errorF(\"%s: Too few points %d for nearest neighbor interp\\n\", \n                       fcnm); \n            goto ERROR;  \n        } \n    } \n    else if (method == BILINEAR) \n    { \n        if (nxy < gsl_interp2d_bilinear->min_size){ \n            log_errorF(\"%s: Too few points %d for bilinear interp\\n\", \n                       fcnm, nxy); \n            goto ERROR;  \n        } \n    } \n    else if (method == BICUBIC) \n    { \n        if (nxy < gsl_interp2d_bicubic->min_size){ \n            log_errorF(\"%s: Too few points %d for bicubic interp\\n\", \n                       fcnm, nxy); \n            goto ERROR; \n        }  \n    } \n    else \n    { \n        ierr =-4; \n        log_errorF(\"%s: Invalid interpolation type\\n\", fcnm); \n        goto ERROR; \n    } \n     \n \n    ierr =-5; \n    if (!sorting_issorted__double(nx, x, ASCENDING)) \n    { \n        log_errorF(\"%s: Error - need x sorted in ascending order\\n\", fcnm); \n        goto ERROR; \n    } \n    if (!sorting_issorted__double(ny, y, ASCENDING)) \n    {    \n        log_errorF(\"%s: Error - need y sorted in ascending order\\n\", fcnm); \n        goto ERROR; \n    } \n     \n \n    ierr = 0; \n    xmin = x[0];  \n    xmax = x[nx-1];  \n    ymin = y[0];  \n    ymax = y[ny-1];  \n    xacc = gsl_interp", "pred": " \nint __interpolate_interp2d_gsl(int nx, const double *x, \n                               int ny, const double *y, \n                               int nxy, const double *v, \n                               int nxq, const double *xq, \n                               int nyq, const double *yq, \n                               int nxyq, double *vq, \n                               enum interp2d_type_enum method, \n                               bool lqpts_grid) \n{\n  int i, j, k, l, m, n, p, q, r, s, t, u, v, w, x_index, y_index, z_index;\n  double x_val, y_val, z_val, x_val_grid, y_val_grid, z_val_grid, x_val_grid_grid, y_val_grid_grid, z_val_grid_grid;\n  double x_val_grid_grid, y_val_grid_grid, z_val_grid_grid, x_val_grid_grid_grid, y_val_grid_grid_grid, z_val_grid_grid_grid;\n  double x_val_grid_grid_grid, y_val_grid_grid_grid, z_val_grid_grid_grid, x_val_grid_grid_grid_grid, y_val_grid_grid_grid_grid, z_val_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid, y_val_grid_grid_grid_grid, z_val_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid, x_val_grid_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid_grid;\n  double x_val_grid_grid_grid_grid_grid, y_val_grid_grid_grid_grid_grid, z_val_grid_grid_grid_grid_grid"}
{"label": " \nvoid selectionSort(int* A, int n){ \n\t \n\tfor(int startpos =0; startpos < n; startpos++){ \n\t\t \n \n\t\tstruct Compare max; \n         \n \n        max.val = A[startpos]; \n        max.index = startpos; \n \n         \n \n\t\tfor(int i=startpos +1; i< n; ++i){ \n\t\t\tif(A[i] > max.val){ \n\t\t\t\tmax.val = A[i]; \n\t\t\t\tmax.index = i; \n\t\t\t} \n\t\t} \n \n\t\tswap(&A[startpos], &A[max.index]); \n\t} \n} ", "pred": " \nvoid selectionSort(int* A, int n){ \n\t \n\tfor(int startpos =0; startpos < n; startpos++){ \n\t\t \n \n\t\tstruct Compare max; \n         \n \n        max.val = A[startpos]; \n        max.index = startpos; \n \n         \n \n\t\tfor(int i=startpos +1; i< n; ++i){ \n\t\t\tif(A[i] > max.val){ \n\t\t\t\tmax.val = A[i]; \n\t\t\t\tmax.index = i; \n\t\t\t} \n\t\t} \n \n\t\tswap(&A[startpos], &A[max.index]); \n\t} \n} "}
{"label": " \nstatic void THNN_(VolumetricMaxPooling_updateOutput_frame)( \n          real *input_p, \n          real *output_p, \n          real *indz_p, \n          long nslices, \n          long itime, \n          long iwidth, \n          long iheight, \n          long otime, \n          long owidth, \n          long oheight, \n          int kT, \n          int kW, \n          int kH, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH) \n{ \n  long k; \n  for (k = 0; k < nslices; k++) \n  { \n     \n \n    long i, j, ti; \n    for (ti = 0; ti < otime; ti++) \n    { \n      for (i = 0; i < oheight; i++) \n      { \n        for (j = 0; j < owidth; j++) \n        { \n           \n \n \n          long start_t = ti * dT - pT; \n          long start_h = i * dH - pH; \n          long start_w = j * dW - pW; \n \n          long kernel_t = fminf(kT, kT + start_t); \n          long kernel_h = fminf(kH, kH + start_h); \n          long kernel_w = fminf(kW, kW + start_w); \n \n          start_t = fmaxf(start_t, 0); \n          start_h = fmaxf(start_h, 0); \n          start_w = fmaxf(start_w, 0); \n \n          real *ip = input_p + k * itime * iwidth * iheight \n            + start_t * iwidth * iheight + start_h * iwidth + start_w; \n          real *op = output_p + k * otime * owidth * oheight \n            + ti * owidth * oheight + i * owidth + j; \n          real *indzp = indz_p + k * otime * owidth * oheight \n            + ti * owidth * oheight + i * owidth + j; \n \n           \n \n          real maxval = -THInf; \n          int x,y,z; \n          int mx, my, mz; \n \n          for (z = 0; z < kernel_t; z++) \n          { \n            for (y = 0; y < kernel_h; y++) \n            { \n              for (x = 0; x < kernel_w; x++) \n              { \n                if ((start_t + z < itime) && (start_h + y < iheight) && (start_w + x < iwidth)) \n                { \n                  real val = *(ip + z * iwidth * iheight + y * iwidth + x); \n                  if (val > maxval) \n                  { \n                    maxval = val; \n                     \n \n                    mz = z + (kT - kernel_t); \n                    my = y + (kH - kernel_h); \n                    mx = x + (kW - kernel_w); \n                  } \n                } \n              } \n            } \n          } \n \n           \n \n          ((unsigned char*)(indzp))[0] = mz; \n          ((unsigned char*)(indzp))[1] = my; \n          ((unsigned char*)(indzp))[2] = mx; \n          ((unsigned char*)(indzp))[3] = 0; \n \n           \n \n          *op = maxval; \n        } \n      } \n    } \n  } \n} ", "pred": " \nstatic void THNN_(VolumetricMaxPooling_updateOutput_frame)( \n          real *input_p, \n          real *output_p, \n          real *indz_p, \n          long nslices, \n          long itime, \n          long iwidth, \n          long iheight, \n          long otime, \n          long owidth, \n          long oheight, \n          int kT, \n          int kW, \n          int kH, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH) \n{ \n  long k; \n  long kT2; \n  long kW2; \n  long kH2; \n  long kT3; \n  long kW3; \n  long kH3; \n  long kT4; \n  long kW4; \n  long kH4; \n  long kT5; \n  long kW5; \n  long kH5; \n  long kT6; \n  long kW6; \n  long kH6; \n  long kT7; \n  long kW7; \n  long kH7; \n  long kT8; \n  long kW8; \n  long kH8; \n  long kT9; \n  long kW9; \n  long kH9; \n  long kT10; \n  long kW10; \n  long kH10; \n  long kT11; \n  long kW11; \n  long kH11; \n  long kT12; \n  long kW12; \n  long kH12; \n  long kT13; \n  long kW13; \n  long kH13; \n  long kT14; \n  long kW14; \n  long kH14; \n  long kT15; \n  long kW15; \n  long kH15; \n  long kT16; \n  long kW16; \n  long kH16; \n  long kT17; \n  long kW17; \n  long kH17; \n  long kT18; \n  long kW18; \n  long kH18; \n  long kT19; \n  long kW19; \n  long kH19; \n  long kT20; \n  long kW20; \n  long kH20; \n  long kT21; \n  long kW21; \n  long kH21; \n  long kT22; \n  long kW22; \n  long kH22; \n  long kT23; \n  long kW23; \n  long kH23; \n  long kT24; \n  long kW24; \n  long kH24; \n  long kT25; \n  long kW25; \n  long kH25; \n  long kT26; \n  long kW26; \n  long kH26; \n  long kT27; \n  long kW27; \n  long kH27; \n  long kT28; \n  long kW28; \n  long kH28; \n  long kT29; \n  long kW29; \n  long kH29; \n  long kT30; \n  long kW30; \n  long kH30; \n  long kT31; \n  long kW31; \n  long kH31; \n  long kT32; \n  long kW32; \n  long kH32; \n  long kT33; \n  long kW33; \n  long kH33; \n  long kT34; \n  long kW34; \n  long kH34; \n  long kT35; \n  long kW35; \n  long kH35; \n  long kT36; \n  long kW36; \n  long kH36; \n  long kT37; \n  long kW37; \n  long kH37; \n  long kT38; \n  long kW38; \n  long kH38; \n  long kT39; \n  long kW39; \n  long kH39; \n  long kT40; \n  long kW40; \n  long kH40; \n  long kT41; \n  long kW41; \n  long kH41; \n  long kT42; \n  long kW42; \n  long kH42; \n  long kT43; \n  long kW43; \n  long kH43; \n  long kT44; \n  long kW44; \n  long kH44; \n  long kT45; \n  long kW45; \n  long kH45; \n  long kT46; \n  long kW46; \n  long kH46; \n  long kT47; \n  long kW47; \n  long kH47; \n  long kT48; \n  long kW48; \n  long kH48; \n  long kT49; \n  long kW49; \n  long kH49; \n  long kT50; \n  long kW50; \n  long kH50; \n  long kT51; \n  long kW51; \n  long kH51; \n  long kT52; \n  long kW52; \n  long kH52; \n  long kT53; \n  long kW53; \n  long kH53; \n  long kT54; \n  long kW54; \n  long kH54; \n  long kT55; \n  long kW55; \n  long kH55; \n  long kT56; \n  long kW56; \n  long kH56; \n  long kT57; \n  long kW57; \n  long kH57; \n  long kT58; \n  long kW58; \n  long kH58; \n  long kT59; \n  long kW59; \n  long kH59; \n  long kT60; \n  long kW60; \n  long kH"}
{"label": " \nint test_omp_for_schedule_guided() \n{ \n  int * tids; \n  int * chunksizes; \n  int notout; \n  int maxiter; \n  int threads; \n  int i; \n  int result; \n \n  tids = (int *) malloc (sizeof (int) * (CFSMAX_SIZE + 1)); \n  maxiter = 0; \n  result = 1; \n  notout = 1; \n \n   \n \n  { \n    { \n      threads = omp_get_num_threads(); \n    } \n  } \n \n   \n \n  if (threads < 2) { \n    omp_set_num_threads(2); \n    threads = 2; \n  } \n \n   \n \n  {   \n \n    double count; \n    int tid; \n    int j; \n \n    tid = omp_get_thread_num (); \n \n    for(j = 0; j < CFSMAX_SIZE; ++j) { \n      count = 0.; \n      if (j > maxiter) { \n        { \n          maxiter = j; \n        } \n      } \n       \n \n      while (notout && (count < MAX_TIME) && (maxiter == j)) { \n        my_sleep (SLEEPTIME); \n        count += SLEEPTIME; \n        printf(\".\"); \n      } \n      if (count > 0.) printf(\" waited %lf s\\n\", count); \n       \n \n      tids[j] = tid; \n      printf(\"%d finished by %d\\n\",j,tid); \n    }  \n \n    notout = 0; \n  }  \n \n \n   \n \n  { \n    int determined_chunksize = 1; \n    int last_threadnr = tids[0]; \n    int global_chunknr = 0; \n    int openwork = CFSMAX_SIZE; \n    int expected_chunk_size; \n    int* local_chunknr = (int*)malloc(threads * sizeof(int)); \n    double c = 1; \n \n    for (i = 0; i < threads; i++) \n      local_chunknr[i] = 0; \n \n    tids[CFSMAX_SIZE] = -1; \n \n     \n \n     \n \n    for(i = 1; i <= CFSMAX_SIZE; ++i) { \n      if (last_threadnr==tids[i]) { \n        determined_chunksize++; \n      } else { \n         \n \n        global_chunknr++; \n        local_chunknr[last_threadnr]++; \n        last_threadnr = tids[i]; \n        determined_chunksize = 1; \n      } \n    } \n     \n \n    chunksizes = (int*)malloc(global_chunknr * sizeof(int)); \n \n     \n \n    global_chunknr = 0; \n    determined_chunksize = 1; \n    last_threadnr = tids[0]; \n    for (i = 1; i <= CFSMAX_SIZE; ++i) { \n       \n \n      if (last_threadnr == tids[i]) { \n        determined_chunksize++; \n      } else { \n        chunksizes[global_chunknr] = determined_chunksize; \n        global_chunknr++; \n        local_chunknr[last_threadnr]++; \n        last_threadnr = tids[i]; \n        determined_chunksize = 1; \n      } \n    } \n \n    fprintf(stderr, \"found\\texpected\\tconstant\\n\"); \n \n     \n \n    expected_chunk_size = openwork / threads; \n    c = (double) chunksizes[0] / expected_chunk_size; \n \n    for (i = 0; i < global_chunknr; i++) { \n       \n \n      if (expected_chunk_size > 1) \n        expected_chunk_size = c * openwork / threads; \n      fprintf(stderr, \"%8d\\t%8d\\t%lf\\n\", chunksizes[i], \n        expected_chunk_size, c * chunksizes[i]/expected_chunk_size); \n       \n \n      if (abs (chunksizes[i] - expected_chunk_size) >= 2) { \n        result = 0; \n        fprintf(stderr, \"Chunksize differed from expected \" \n          \"value: %d instead of %d\\n\", chunksizes[i], \n          expected_chunk_size); \n        return 0; \n      }  \n \n \n      if (expected_chunk_size - chunksizes[i] < 0) \n        fprintf(stderr, \"Chunksize did not decrease: %d\" \n          \" instead of %d\\n\", chunksizes[i],expected_chunk_size); \n \n       \n \n      openwork -= chunksizes[i]; \n    } \n  } \n  return result; \n} ", "pred": " \nint test_omp_for_schedule_guided() \n{ \n  int * tids; \n  int * chunksizes; \n  int notout; \n  int maxiter; \n  int threads; \n  int i; \n  int result; \n \n  tids = (int *) malloc (sizeof (int) * (CFSMAX_SIZE + 1)); \n  maxiter = 0; \n  result = 1; \n  notout = 1; \n \n   \n \n  { \n    { \n      threads = omp_get_num_threads(); \n    } \n  } \n \n   \n \n  if (threads < 2) { \n    omp_set_num_threads(2); \n    threads = 2; \n  } \n \n   \n \n  {   \n \n    double count; \n    int tid; \n    int j; \n \n    tid = omp_get_thread_num (); \n \n    for(j = 0; j < CFSMAX_SIZE; ++j) { \n      count = 0.; \n      if (j > maxiter) { \n        { \n          maxiter = j; \n        } \n      } \n      if (tid < maxiter) { \n        { \n          chunksizes = (int *) malloc (sizeof (int) * (CFSMAX_SIZE + 1)); \n          tids[j] = tid; \n          chunksizes[tid] = 1; \n        } \n        { \n          int i; \n          for (i = 0; i < CFSMAX_SIZE; ++i) { \n            tids[j] = tids[j] + chunksizes[tids[j]]; \n          } \n        } \n        ++count; \n      } \n      if (count > 0) { \n        { \n          notout = 0; \n        } \n      } \n    } \n  } \n \n  if (notout) { \n    result = 0; \n  } \n \n  free (tids); \n  return (result); \n} \n \n\n/*\n * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n\n/*\n * @test\n *\n * @summary converted from VM Testbase nsk/jdi/VirtualMachine/redefineClasses/redefineclasses002.\n * VM Testbase keywords: [quick, jpda, jdi]\n * VM Testbase readme:\n * DESCRIPTION:\n *     The test for the implementation of an object of the type\n *     VirtualMachine.\n *     The test checks up that a result of the method\n *     com.sun.jdi.VirtualMachine.redefineClasses()\n *     complies with its spec:\n *     public void redefineClasses()\n *      Redefines all classes in this VM.\n *      The classes are loaded by the class loader of this VM.\n *      The test works as follows:\n *      The debugger program - nsk.jdi.VirtualMachine.redefineClasses.redefineclasses002;\n *      the debuggee program - nsk.jdi.VirtualMachine.redefineClasses.redefineclasses002a.\n *      Using nsk.jdi.share classes,\n *      the debugger gets the debuggee running on another JavaVM,\n *      creates the object debuggee.VM,\n *      establishes a pipe with the debuggee program, and then\n *      send to the programm commands, to which the debuggee replies\n *      via the pipe. Upon getting reply,\n *      the debugger calls corresponding debuggee.VM methods to get\n *      needed data and compares the data got to the data expected.\n *      In case of error the test produces the return value 97 and\n *      a corresponding error message(s).\n *      Otherwise, the test is passed and produces\n *      the return value 95 and no message.\n * COMMENTS:\n *\n * @library /vmTestbase\n *          /test/lib\n * @build nsk.jdi.VirtualMachine.redefineClasses.redefineclasses002\n *        nsk.jdi.VirtualMachine.redefineClasses.redefineclasses002a\n * @run main/othervm\n *      nsk.jdi.VirtualMachine.redefineClasses.redefineclasses002\n *      -verbose\n *      -arch=${os.family}-${os.simpleArch}\n *      -waittime=5\n *   "}
{"label": "t main(int argc, char *argv[]) \n{ \n    struct pngquant_options options = { \n       .floyd = 1.f,  \n \n    }; \n    options.liq = liq_attr_create(); \n \n    if (!options.liq) { \n        fputs(\"SSE-capable CPU is required for this build.\\n\", stderr); \n        return WRONG_ARCHITECTURE; \n    } \n \n    unsigned int error_count=0, skipped_count=0, file_count=0; \n    pngquant_error latest_error=SUCCESS; \n    const char *newext = NULL, *output_file_path = NULL; \n \n    fix_obsolete_options(argc, argv); \n \n    int opt; \n    do { \n        opt = getopt_long(argc, argv, \"Vvqfhs:Q:o:\", long_options, NULL); \n        switch (opt) { \n            case 'v': \n                options.verbose = true; \n                break; \n            case 'q': \n                options.verbose = false; \n                break; \n \n            case arg_floyd: \n                options.floyd = optarg? atof(optarg) : 1.0; \n                if (options.floyd < 0 || options.floyd > 1.f) { \n                    fputs(\"--floyd argument must be in 0..1 range\\n\", stderr); \n                    return INVALID_ARGUMENT; \n                } \n                break; \n            case arg_ordered: options.floyd = 0; break; \n \n            case 'f': options.force = true; break; \n            case arg_no_force: options.force = false; break; \n \n            case arg_ext: newext = optarg; break; \n            case 'o': \n                if (output_file_path) { \n                    fputs(\"--output option can be used only once\\n\", stderr); \n                    return INVALID_ARGUMENT; \n                } \n                output_file_path = optarg; break; \n \n            case arg_iebug: \n                 \n \n                liq_set_min_opacity(options.liq, 238); \n                options.ie_mode = true; \n                break; \n \n            case arg_transbug: \n                liq_set_last_index_transparent(options.liq, true); \n                break; \n \n            case arg_skip_larger: \n                options.skip_if_larger = true; \n                break; \n \n            case 's': \n                { \n                    int speed = atoi(optarg); \n                    if (speed >= 10) { \n                        options.fast_compression = true; \n                    } \n                    if (speed == 11) { \n                        options.floyd = 0; \n                        speed = 10; \n                    } \n                    if (LIQ_OK!= liq_set_speed(options.liq, speed)) { \n                        fputs(\"Speed should be between 1 (slow) and 11 (fast).\\n\", stderr); \n                        return INVALID_ARGUMENT; \n                    } \n                } \n                break; \n \n            case 'Q': \n                if (!parse_quality(optarg, options.liq, &options.min_quality_limit)) { \n                    fputs(\"Quality should be in format min-max where min and max are numbers in range 0-100.\\n\", stderr); \n                    return INVALID_ARGUMENT; \n                } \n                break; \n \n            case arg_posterize: \n                if (LIQ_OK!= liq_set_min_posterization(options.liq, atoi(optarg))) { \n                    fputs(\"Posterization should be number of bits in range 0-4.\\n\", stderr); \n                    return INVALID_ARGUMENT; \n                } \n                break; \n \n            case arg_map: \n                { \n                    png24_image tmp = {}; \n                    if (SUCCESS!= read_image(options.liq, optarg, false, &tmp, &options.fixed_palette_image, false, false)) { \n                        fprintf(stderr, \"  error: Unable to load %s\", optarg); \n                        return INVALID_ARGUMENT; \n                    } \n                } \n                break; \n \n     ", "pred": "t main(int argc, char *argv[]) \n{ \n    struct pngquant_options options = { \n       .floyd = 1.f,  \n \n    }; \n    options.liq = liq_attr_create(); \n \n    if (!options.liq) { \n        fputs(\"SSE-capable CPU is required for this build.\\n\", stderr); \n        return WRONG_ARCHITECTURE; \n    } \n \n    unsigned int error_count=0, skipped_count=0, file_count=0; \n    pngquant_error latest_error=SUCCESS; \n    const char *newext = NULL, *output_file_path = NULL; \n \n    fix_obsolete_options(argc, argv); \n \n    int opt; \n    do { \n        opt = getopt_long(argc, argv, \"Vvqfhs:Q:o:\", long_options, NULL); \n        switch (opt) { \n            case 'v': \n                options.verbose = true; \n                break; \n            case 'f': \n                options.floyd = atof(optarg); \n                break; \n            case 'q': \n                options.liq = atof(optarg); \n                break; \n            case 'h': \n                fputs(usage, stderr); \n                return WRONG_ARCHITECTURE; \n            case 's': \n                options.liq_size = atoi(optarg); \n                break; \n            case 'Q': \n                options.liq_quality = atoi(optarg); \n                break; \n            case 'S': \n                options.liq_smoothing = atoi(optarg); \n                break; \n            case 'o': \n                output_file_path = optarg; \n                break; \n            case 'V': \n                printf(\"libpngquant version %s\\n\", PNGQUANT_VERSION); \n                return 0; \n            case 'h': \n                fputs(usage, stderr); \n                return WRONG_ARCHITECTURE; \n            case 'V': \n                printf(\"libpngquant version %s\\n\", PNGQUANT_VERSION); \n                return 0; \n            case 'f': \n                options.floyd = atof(optarg); \n                break; \n            case 'h': \n                fputs(usage, stderr); \n                return WRONG_ARCHITECTURE; \n            case 'V': \n                printf(\"libpngquant version %s\\n\", PNGQUANT_VERSION); \n                return 0; \n            case 'v': \n                printf(\"libpngquant version %s\\n\", PNGQUANT_VERSION); \n                return 0; \n            case 'q': \n                options.liq_size = atoi(optarg); \n                break; \n            case 'Q': \n                options.liq_quality = atoi(optarg); \n                break; \n            case 'S': \n                options.liq_smoothing = atoi(optarg); \n                break; \n            case 'o': \n                output_file_path = optarg; \n                break; \n            case 'V': \n                printf(\"libpngquant version %s\\n\", PNGQUANT_VERSION); \n                return 0; \n            case 'v': \n                printf(\"libpngquant version %s\\n\", PNGQUANT_VERSION); \n                return 0; \n            case 'h': \n                fputs(usage, stderr); \n                return WRONG_ARCHITECTURE; \n            case 'V': \n                printf(\"libpngquant version %s\\n\", PNGQUANT_VERSION); \n                return 0; \n            case 'v': \n                printf(\"libpngquant version %s\\n\", PNGQUANT_VERSION); \n                return 0; \n            case 'q': \n                options.liq_size = atoi(optarg); \n                break; \n            case 'Q': \n                options.liq_quality = atoi(optarg); \n                break; \n            case 'S': \n                options.liq_smoothing = atoi(optarg); \n                break; \n            case 'o': \n                output_file_path = optarg; \n                break; \n            case 'V': \n                printf(\"libpngquant version %s\\n\", PNGQUANT"}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  dt_iop_highlights_data_t *data = (dt_iop_highlights_data_t *)piece->data; \n \n  const float clip \n      = data->clip * fminf(piece->pipe->dsc.processed_maximum[0], \n                           fminf(piece->pipe->dsc.processed_maximum[1], piece->pipe->dsc.processed_maximum[2])); \n   \n \n  if(!filters) \n  { \n    process_clip(piece, ivoid, ovoid, roi_in, roi_out, clip); \n    for(int k=0;k<3;k++) \n      piece->pipe->dsc.processed_maximum[k] \n          = fminf(piece->pipe->dsc.processed_maximum[0], \n                  fminf(piece->pipe->dsc.processed_maximum[1], piece->pipe->dsc.processed_maximum[2])); \n    return; \n  } \n \n  switch(data->mode) \n  { \n    case DT_IOP_HIGHLIGHTS_INPAINT:  \n \n    { \n      const float clips[4] = { 0.987 * data->clip * piece->pipe->dsc.processed_maximum[0], \n                               0.987 * data->clip * piece->pipe->dsc.processed_maximum[1], \n                               0.987 * data->clip * piece->pipe->dsc.processed_maximum[2], clip }; \n \n      if(filters == 9u) \n      { \n        const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece->pipe->dsc.xtrans; \n        for(int j = 0; j < roi_out->height; j++) \n        { \n          interpolate_color_xtrans(ivoid, ovoid, roi_in, roi_out, 0, 1, j, clips, xtrans, 0); \n          interpolate_color_xtrans(ivoid, ovoid, roi_in, roi_out, 0, -1, j, clips, xtrans, 1); \n        } \n        for(int i = 0; i < roi_out->width; i++) \n        { \n          interpolate_color_xtrans(ivoid, ovoid, roi_in, roi_out, 1, 1, i, clips, xtrans, 2); \n          interpolate_color_xtrans(ivoid, ovoid, roi_in, roi_out, 1, -1, i, clips, xtrans, 3); \n        } \n      } \n      else \n      { \n        for(int j = 0; j < roi_out->height; j++) \n        { \n          interpolate_color(ivoid, ovoid, roi_out, 0, 1, j, clips, filters, 0); \n          interpolate_color(ivoid, ovoid, roi_out, 0, -1, j, clips, filters, 1); \n        } \n \n \n \n        for(int i = 0; i < roi_out->width; i++) \n        { \n          interpolate_color(ivoid, ovoid, roi_out, 1, 1, i, clips, filters, 2); \n          interpolate_color(ivoid, ovoid, roi_out, 1, -1, i, clips, filters, 3); \n        } \n      } \n      break; \n    } \n    case DT_IOP_HIGHLIGHTS_LCH: \n      if(filters == 9u) \n        process_lch_xtrans(self, piece, ivoid, ovoid, roi_in, roi_out, clip); \n      else \n        process_lch_bayer(self, piece, ivoid, ovoid, roi_in, roi_out, clip); \n      break; \n    default: \n    case DT_IOP_HIGHLIGHTS_CLIP: \n      process_clip(piece, ivoid, ovoid, roi_in, roi_out, clip); \n      break; \n  } \n \n   \n \n  const float m = fmaxf(fmaxf(piece->pipe->dsc.processed_maximum[0], piece->pipe->dsc.processed_maximum[1]), \n                        piece->pipe->dsc.processed_maximum[2]); \n  for(int k = 0; k < 3; k++) piece->pipe->dsc.processed_maximum[k] = m; \n \n  if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out->width, roi_out->height); \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n  dt_iop_highlights_data_t *data = (dt_iop_highlights_data_t *)piece->data; \n \n  const float clip \n      = data->clip * fminf(piece->pipe->dsc.processed_maximum[0], \n                           fminf(piece->pipe->dsc.processed_maximum[1], piece->pipe->dsc.processed_maximum[2])); \n   \n \n  if(!filters) \n  { \n    process_clip(piece, ivoid, ovoid, roi_in, roi_out, clip); \n    for(int k=0;k<3;k++) \n      piece->pipe->dsc.processed_maximum[k] \n          = piece->pipe->dsc.processed_maximum[k] * clip; \n  } \n  else \n  { \n    for(int k=0;k<3;k++) \n      piece->pipe->dsc.processed_maximum[k] \n          = piece->pipe->dsc.processed_maximum[k] * filters; \n  } \n  \n  if(piece->pipe->dsc.processed_maximum[0] < piece->pipe->dsc.processed_minimum[0]) \n    piece->pipe->dsc.processed_minimum[0] = piece->pipe->dsc.processed_maximum[0]; \n  if(piece->pipe->dsc.processed_maximum[1] < piece->pipe->dsc.processed_minimum[1]) \n    piece->pipe->dsc.processed_minimum[1] = piece->pipe->dsc.processed_maximum[1]; \n  if(piece->pipe->dsc.processed_maximum[2] < piece->pipe->dsc.processed_minimum[2]) \n    piece->pipe->dsc.processed_minimum[2] = piece->pipe->dsc.processed_maximum[2]; \n  \n  if(piece->pipe->dsc.processed_maximum[0] > piece->pipe->dsc.processed_maximum[1]) \n    piece->pipe->dsc.processed_maximum[1] = piece->pipe->dsc.processed_maximum[0]; \n  if(piece->pipe->dsc.processed_maximum[1] > piece->pipe->dsc.processed_maximum[2]) \n    piece->pipe->dsc.processed_maximum[2] = piece->pipe->dsc.processed_maximum[1]; \n  if(piece->pipe->dsc.processed_maximum[0] > piece->pipe->dsc.processed_maximum[2]) \n    piece->pipe->dsc.processed_maximum[2] = piece->pipe->dsc.processed_maximum[0]; \n  \n  if(piece->pipe->dsc.processed_maximum[0] < piece->pipe->dsc.processed_minimum[0]) \n    piece->pipe->dsc.processed_minimum[0] = piece->pipe->dsc.processed_maximum[0]; \n  if(piece->pipe->dsc.processed_maximum[1] < piece->pipe->dsc.processed_minimum[1]) \n    piece->pipe->dsc.processed_minimum[1] = piece->pipe->dsc.processed_maximum[1]; \n  if(piece->pipe->dsc.processed_maximum[2] < piece->pipe->dsc.processed_minimum[2]) \n    piece->pipe->dsc.processed_minimum[2] = piece->pipe->dsc.processed_maximum[2]; \n  \n  if(piece->pipe->dsc.processed_maximum[0] > piece->pipe->dsc.processed_maximum[1]) \n    piece->pipe->dsc.processed_maximum[1] = piece->pipe->dsc.processed_maximum[0]; \n  if(piece->pipe->dsc.processed_maximum[1] > piece->pipe->dsc.processed_maximum[2]) \n    piece->pipe->dsc.processed_maximum[2] = piece->pipe->dsc.processed_maximum[1]; \n  if(piece->pipe->dsc.processed_maximum[0] > piece->pipe->dsc.processed_maximum[2]) \n    piece->pipe->dsc.processed_maximum[2] = piece->pipe->dsc.processed_maximum[0]; \n  \n  if(piece->pipe->dsc.processed_maximum[0] < piece->pipe->dsc.processed_minimum[0]) \n    piece->pipe->dsc.processed_minimum[0] = piece->pipe->dsc.processed_maximum[0]; \n  if(piece->pipe->dsc.processed_maximum[1] < piece->pipe->dsc.processed_minimum[1]) \n    piece->pipe->dsc.processed_minimum[1] = piece->pipe->dsc.processed_maximum[1]; \n  if(piece->pipe->dsc.processed_maximum[2] < piece->pipe->dsc.processed_minimum[2]) \n    piece->pipe->dsc.processed_minimum[2] = piece->pipe->dsc.processed_maximum[2]; \n  \n  if(piece->pipe->dsc.processed_maximum[0] > piece->pipe->dsc.processed_maximum[1]) \n    piece->pipe->dsc.processed_maximum[1] = piece->pipe->dsc.processed_maximum[0]; \n  if(piece->pipe->dsc.processed_maximum[1] > piece->pipe->dsc.processed_maximum[2]) \n    piece->pipe->dsc.processed_maximum[2] = piece->pipe->dsc.processed_maximum[1]; \n  if(piece->pipe->dsc.processed_maximum[0] > piece->pipe->dsc.processed_maximum[2]) \n    piece->pipe->dsc.processed_maximum[2] = piece->pipe->dsc.processed_maximum[0]; \n  \n  if(piece->pipe->dsc.processed_maximum[0] < piece->pipe->dsc.processed_minimum[0]) \n    piece->pipe->dsc.processed_minimum[0] = piece"}
{"label": " \nstatic void process_lch_bayer(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                              void *const ovoid, const dt_iop_roi_t *const roi_in, \n                              const dt_iop_roi_t *const roi_out, const float clip) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      float *const out = (float *)ovoid + (size_t)roi_out->width * j + i; \n      const float *const in = (float *)ivoid + (size_t)roi_out->width * j + i; \n \n      if(i == roi_out->width - 1 || j == roi_out->height - 1) \n      { \n         \n \n        out[0] = MIN(clip, in[0]); \n      } \n      else \n      { \n        int clipped = 0; \n \n         \n \n        float R = 0.0f, Gmin = FLT_MAX, Gmax = -FLT_MAX, B = 0.0f; \n        for(int jj = 0; jj <= 1; jj++) \n        { \n          for(int ii = 0; ii <= 1; ii++) \n          { \n            const float val = in[(size_t)jj * roi_out->width + ii]; \n \n            clipped = (clipped || (val > clip)); \n \n            const int c = FC(j + jj + roi_out->y, i + ii + roi_out->x, filters); \n            switch(c) \n            { \n              case 0: \n                R = val; \n                break; \n              case 1: \n                Gmin = MIN(Gmin, val); \n                Gmax = MAX(Gmax, val); \n                break; \n              case 2: \n                B = val; \n                break; \n            } \n          } \n        } \n \n        if(clipped) \n        { \n          const float Ro = MIN(R, clip); \n          const float Go = MIN(Gmin, clip); \n          const float Bo = MIN(B, clip); \n \n          const float L = (R + Gmax + B) / 3.0f; \n \n          float C = SQRT3 * (R - Gmax); \n          float H = 2.0f * B - Gmax - R; \n \n          const float Co = SQRT3 * (Ro - Go); \n          const float Ho = 2.0f * Bo - Go - Ro; \n \n          if(R!= Gmax && Gmax!= B) \n          { \n            const float ratio = sqrtf((Co * Co + Ho * Ho) / (C * C + H * H)); \n            C *= ratio; \n            H *= ratio; \n          } \n \n          float RGB[3] = { 0.0f, 0.0f, 0.0f }; \n \n           \n \n          RGB[0] = L - H / 6.0f + C / SQRT12; \n          RGB[1] = L - H / 6.0f - C / SQRT12; \n          RGB[2] = L + H / 3.0f; \n \n          out[0] = RGB[FC(j + roi_out->y, i + roi_out->x, filters)]; \n        } \n        else \n        { \n          out[0] = in[0]; \n        } \n      } \n    } \n  } \n} ", "pred": " \nstatic void process_lch_bayer(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                              void *const ovoid, const dt_iop_roi_t *const roi_in, \n                              const dt_iop_roi_t *const roi_out, const float clip) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      float *const out = (float *)ovoid + (size_t)roi_out->width * j + i; \n      const float *const in = (float *)ivoid + (size_t)roi_out->width * j + i; \n \n      if(i == roi_out->width - 1 || j == roi_out->height - 1) \n      { \n        // last row\n        if(filters == 1) \n        { \n          // no need to process last row\n          *out = 0.0f; \n        } \n        else \n        { \n          // process last row\n          *out = in[filters - 1]; \n        } \n      } \n      else \n      { \n        // process row\n        *out = in[filters - 1]; \n      } \n    } \n  } \n  \n}\n\nstatic void process_lch_bayer_clip(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                                   void *const ovoid, const dt_iop_roi_t *const roi_in, \n                                   const dt_iop_roi_t *const roi_out, const float clip) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      float *const out = (float *)ovoid + (size_t)roi_out->width * j + i; \n      const float *const in = (float *)ivoid + (size_t)roi_out->width * j + i; \n \n      if(i == roi_out->width - 1 || j == roi_out->height - 1) \n      { \n        // last row\n        if(filters == 1) \n        { \n          // no need to process last row\n          *out = 0.0f; \n        } \n        else \n        { \n          // process last row\n          *out = in[filters - 1]; \n        } \n      } \n      else \n      { \n        // process row\n        *out = in[filters - 1]; \n      } \n    } \n  } \n  \n}\n\nstatic void process_lch_bayer_clip_clip(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                                        void *const ovoid, const dt_iop_roi_t *const roi_in, \n                                        const dt_iop_roi_t *const roi_out, const float clip) \n{ \n  const uint32_t filters = piece->pipe->dsc.filters; \n \n  for(int j = 0; j < roi_out->height; j++) \n  { \n    for(int i = 0; i < roi_out->width; i++) \n    { \n      float *const out = (float *)ovoid + (size_t)roi_out->width * j + i; \n      const float *const in = (float *)ivoid + (size_t)roi_out->width * j + i; \n \n      if(i == roi_out->width - 1 || j == roi_out->height - 1) \n      { \n        // last row\n        if(filters == 1) \n   "}
{"label": " \nvoid \nprocess (struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, void *ivoid, void *ovoid, const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out) \n{ \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n  const int ch = piece->colors; \n \n  if(d->cmatrix[0]!= -0.666f) \n  { \n     \n \n     \n \n    for(int j=0; j<roi_out->height; j++) \n    { \n \n      float *in  = (float*)ivoid + ch*roi_in->width *j; \n      float *out = (float*)ovoid + ch*roi_out->width*j; \n      const __m128 m0 = _mm_set_ps(0.0f,d->cmatrix[6],d->cmatrix[3],d->cmatrix[0]); \n      const __m128 m1 = _mm_set_ps(0.0f,d->cmatrix[7],d->cmatrix[4],d->cmatrix[1]); \n      const __m128 m2 = _mm_set_ps(0.0f,d->cmatrix[8],d->cmatrix[5],d->cmatrix[2]); \n   \n      for(int i=0; i<roi_out->width; i++, in+=ch, out+=ch ) \n      { \n        const __m128 xyz = dt_Lab_to_XYZ_SSE(_mm_load_ps(in)); \n        const __m128 t = _mm_add_ps(_mm_mul_ps(m0,_mm_shuffle_ps(xyz,xyz,_MM_SHUFFLE(0,0,0,0))),_mm_add_ps(_mm_mul_ps(m1,_mm_shuffle_ps(xyz,xyz,_MM_SHUFFLE(1,1,1,1))),_mm_mul_ps(m2,_mm_shuffle_ps(xyz,xyz,_MM_SHUFFLE(2,2,2,2))))); \n \n        _mm_stream_ps(out,t); \n      } \n    } \n    _mm_sfence(); \n     \n \n    for(int j=0; j<roi_out->height; j++) \n    { \n \n      float *in  = (float*)ivoid + ch*roi_in->width *j; \n      float *out = (float*)ovoid + ch*roi_out->width*j; \n   \n      for(int i=0; i<roi_out->width; i++, in+=ch, out+=ch ) \n      { \n        for(int i=0; i<3; i++)  \n          if (d->lut[i][0] >= 0.0f) \n          { \n            out[i] = (out[i] < 1.0f)? lerp_lut(d->lut[i], out[i]) : dt_iop_eval_exp(d->unbounded_coeffs[i], out[i]); \n          } \n      } \n    } \n  } \n  else \n  { \n    float *in  = (float*)ivoid; \n    float *out = (float*)ovoid; \n     \n \n \n     \n \n    int rowsize=roi_out->width*3; \n \n     \n \n \n    for (int k=0; k<roi_out->height; k++) \n    { \n      float Lab[rowsize]; \n      float rgb[rowsize]; \n \n      const int m=(k*(roi_out->width*ch)); \n      for (int l=0; l<roi_out->width; l++) \n      { \n        int li=3*l,ii=ch*l; \n        Lab[li+0] = in[m+ii+0]; \n        Lab[li+1] = in[m+ii+1]; \n        Lab[li+2] = in[m+ii+2]; \n      } \n \n       \n \n      cmsDoTransform (d->xform[dt_get_thread_num()], Lab, rgb, roi_out->width); \n \n      for (int l=0; l<roi_out->width; l++) \n      { \n        int oi=ch*l, ri=3*l; \n        out[m+oi+0] = rgb[ri+0]; \n        out[m+oi+1] = rgb[ri+1]; \n        out[m+oi+2] = rgb[ri+2]; \n      } \n    } \n  } \n} ", "pred": " \nvoid \nprocess (struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, void *ivoid, void *ovoid, const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out) \n{ \n  const dt_iop_colorout_data_t *const d = (dt_iop_colorout_data_t *)piece->data; \n  const int ch = piece->colors; \n \n  if(d->cmatrix[0]!= -0.666f) \n  { \n     \n \n     \n \n    for(int j=0; j<roi_out->height; j++) \n    { \n \n      float *in  = (float*)ivoid + ch*roi_in->width *j; \n      float *out = (float*)ovoid + ch*roi_out->width*j; \n      const __m128 m0 = _mm_set_ps(0.0f,d->cmatrix[6],d->cmatrix[3],d->cmatrix[0]); \n      const __m128 m1 = _mm_set_ps(0.0f,d->cmatrix[7],d->cmatrix[4],d->cmatrix[1]); \n      const __m128 m2 = _mm_set_ps(0.0f,d->cmatrix[8],d->cmatrix[5],d->cmatrix[2]); \n      const __m128 m3 = _mm_set_ps(0.0f,d->cmatrix[9],d->cmatrix[6],d->cmatrix[3]); \n      const __m128 m4 = _mm_set_ps(0.0f,d->cmatrix[10],d->cmatrix[7],d->cmatrix[4]); \n      const __m128 m5 = _mm_set_ps(0.0f,d->cmatrix[11],d->cmatrix[8],d->cmatrix[5]); \n      const __m128 m6 = _mm_set_ps(0.0f,d->cmatrix[12],d->cmatrix[9],d->cmatrix[6]); \n      const __m128 m7 = _mm_set_ps(0.0f,d->cmatrix[13],d->cmatrix[10],d->cmatrix[7]); \n      const __m128 m8 = _mm_set_ps(0.0f,d->cmatrix[14],d->cmatrix[11],d->cmatrix[8]); \n      const __m128 m9 = _mm_set_ps(0.0f,d->cmatrix[15],d->cmatrix[12],d->cmatrix[9]); \n      const __m128 m10 = _mm_set_ps(0.0f,d->cmatrix[16],d->cmatrix[13],d->cmatrix[10]); \n      const __m128 m11 = _mm_set_ps(0.0f,d->cmatrix[17],d->cmatrix[14],d->cmatrix[11]); \n      const __m128 m12 = _mm_set_ps(0.0f,d->cmatrix[18],d->cmatrix[15],d->cmatrix[12]); \n      const __m128 m13 = _mm_set_ps(0.0f,d->cmatrix[19],d->cmatrix[16],d->cmatrix[13]); \n      const __m128 m14 = _mm_set_ps(0.0f,d->cmatrix[20],d->cmatrix[17],d->cmatrix[14]); \n      const __m128 m15 = _mm_set_ps(0.0f,d->cmatrix[21],d->cmatrix[18],d->cmatrix[15]); \n      const __m128 m16 = _mm_set_ps(0.0f,d->cmatrix[22],d->cmatrix[19],d->cmatrix[16]); \n      const __m128 m17 = _mm_set_ps(0.0f,d->cmatrix[23],d->cmatrix[20],d->cmatrix[17]); \n      const __m128 m18 = _mm_set_ps(0.0f,d->cmatrix[24],d->cmatrix[21],d->cmatrix[18]); \n      const __m128 m19 = _mm_set_ps(0.0f,d->cmatrix[25],d->cmatrix[22],d->cmatrix[19]); \n      const __m128 m20 = _mm_set_ps(0.0f,d->cmatrix[26],d->cmatrix[23],d->cmatrix[20]); \n      const __m128 m21 = _mm_set_ps(0.0f,d->cmatrix[27],d->cmatrix[24],d->cmatrix[21]); \n      const __m128 m22 = _mm_set_ps(0.0f,d->cmatrix[28],d->cmatrix[25],d->cmatrix[22]); \n      const __m128 m23 = _mm_set_ps(0.0f,d->cmatrix[29],d->cmatrix[26],d->cmatrix[23]);"}
{"label": " \nvoid proceed_nbux(){ \n  const double rU = 1/86400.0, rV = 6/86400.0, rE = 1/900.0, Du = 2.3e-10, Dv = 6.1e-11; \n  const double dt = 200, dx = 0.001; \n \n    for (int x=1;x<NX-1;x+=2) { \n \n      for (int y=1;y<NY-1;++y) { \n        for (int z=1;z<NZ-1;++z) { \n          double U0=U_mem[x][y][z]; \n          double V0=V_mem[x][y][z]; \n          double U0_1=U_mem[x+1][y][z]; \n          double V0_1=V_mem[x+1][y][z]; \n          double  eat = rE * U0 * V0*V0; \n          double  eat_1 = rE * U0_1 * V0_1*V0_1; \n          double dU_dt = - eat + rU * (1-U0) + Du/(dx*dx) * laplacian(U_mem,x,y,z); \n          double dV_dt =   eat - rV * V0     + Dv/(dx*dx) * laplacian(V_mem,x,y,z); \n          double dU_dt_1 = - eat_1 + rU * (1-U0_1) + Du/(dx*dx) * laplacian(U_mem,x+1,y,z); \n          double dV_dt_1 =   eat_1 - rV * V0_1     + Dv/(dx*dx) * laplacian(V_mem,x+1,y,z); \n          U_mem2[x][y][z] = U0 + dt * dU_dt; \n          V_mem2[x][y][z] = V0 + dt * dV_dt; \n          U_mem2[x+1][y][z] = U0_1 + dt * dU_dt_1; \n          V_mem2[x+1][y][z] = V0_1 + dt * dV_dt_1; \n        } \n      } \n    } \n} ", "pred": " \nvoid proceed_nbux(){ \n  const double rU = 1/86400.0, rV = 6/86400.0, rE = 1/900.0, Du = 2.3e-10, Dv = 6.1e-11; \n  const double dt = 200, dx = 0.001; \n \n    for (int x=1;x<NX-1;x+=2) { \n \n      for (int y=1;y<NY-1;++y) { \n        for (int z=1;z<NZ-1;++z) { \n          double U0=U_mem[x][y][z]; \n          double V0=V_mem[x][y][z]; \n          double U0_1=U_mem[x+1][y][z]; \n          double V0_1=V_mem[x+1][y][z]; \n          double  eat = rE * U0 * V0*V0; \n          double  eat_1 = rE * U0_1 * V0_1; \n          double  u = U0 + dt * U0_1; \n          double  v = V0 + dt * V0_1; \n          double  u_1 = U0_1 + dt * U0; \n          double  v_1 = V0_1 + dt * V0; \n          double  u_2 = U0_1 + dt * U0_1; \n          double  v_2 = V0_1 + dt * V0_1; \n          double  u_3 = U0_1 + dt * U0_1; \n          double  v_3 = V0_1 + dt * V0_1; \n          double  u_4 = U0_1 + dt * U0_1; \n          double  v_4 = V0_1 + dt * V0_1; \n          double  u_5 = U0_1 + dt * U0_1; \n          double  v_5 = V0_1 + dt * V0_1; \n          double  u_6 = U0_1 + dt * U0_1; \n          double  v_6 = V0_1 + dt * V0_1; \n          double  u_7 ="}
{"label": " \nstatic void THNN_(VolumetricMaxPooling_updateGradInput_frame)( \n          real *gradInput_p, \n          real *gradOutput_p, \n          real *indz_p, \n          long nslices, \n          long itime, \n          long iwidth, \n          long iheight, \n          long otime, \n          long owidth, \n          long oheight, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH) \n{ \n  long k; \n  for (k = 0; k < nslices; k++) \n  { \n    real *gradInput_p_k  = gradInput_p  + k * itime * iwidth * iheight; \n    real *gradOutput_p_k = gradOutput_p + k * otime * owidth * oheight; \n    real *indz_p_k = indz_p + k * otime * owidth * oheight; \n \n     \n \n    long ti, i, j; \n    for (ti = 0; ti < otime; ti++) \n    { \n      for (i = 0; i < oheight; i++) \n      { \n        for (j = 0; j < owidth; j++) \n        { \n           \n \n          real * indzp = &indz_p_k[ti * oheight * owidth + i * owidth + j]; \n          long maxti = ((unsigned char*)(indzp))[0] + ti * dT - pT; \n          long maxi  = ((unsigned char*)(indzp))[1] + i * dH - pH; \n          long maxj  = ((unsigned char*)(indzp))[2] + j * dW - pW; \n \n           \n \n          gradInput_p_k[maxti * iheight * iwidth + maxi * iwidth + maxj] += \n            gradOutput_p_k[ti * oheight * owidth + i * owidth + j]; \n        } \n      } \n    } \n  } \n} ", "pred": " \nstatic void THNN_(VolumetricMaxPooling_updateGradInput_frame)( \n          real *gradInput_p, \n          real *gradOutput_p, \n          real *indz_p, \n          long nslices, \n          long itime, \n          long iwidth, \n          long iheight, \n          long otime, \n          long owidth, \n          long oheight, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH) \n{ \n  long k; \n  for (k = 0; k < nslices; k++) \n  { \n    real *gradInput_p_k  = gradInput_p  + k * itime * iwidth * iheight; \n    real *gradOutput_p_k = gradOutput_p + k * itime * iwidth * iheight; \n    real *indz_p_k       = indz_p       + k * itime * owidth * oheight; \n    long i, j; \n    for (j = 0; j < oheight; j++) \n    { \n      for (i = 0; i < owidth; i++) \n      { \n        real *gradInput_p_k_i = gradInput_p_k + i * owidth * oheight + j * owidth * oheight; \n        real *gradOutput_p_k_i = gradOutput_p_k + i * owidth * oheight + j * owidth * oheight; \n        real *indz_p_k_i       = indz_p_k       + i * owidth * oheight + j * owidth * oheight; \n        real *gradInput_p_k_i_k = gradInput_p_k_i + k * owidth * oheight; \n        real *gradOutput_p_k_i_k = gradOutput_p_k_i + k * owidth * oheight; \n        real *gradInput_p_k_i_k_k = gradInput_p_k_i_k + k * owidth * oheight; \n        real *gradOutput_p_k_i_k_k = gradOutput_p_k"}
{"label": " \nvoid \nbar (void) \n{ \n  int *r06 = baz (), *r07 = baz (), *r08 = baz (), *r09 = baz (); \n  int *r10 = baz (), *r11 = baz (), *r12 = baz (); \n  int *r25 = baz (), *r26 = baz (), *r27 = baz (), *r28 = baz (), *r29 = baz (); \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r03[1]++; \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r04[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r05[1]++; \n   \n \n  for (int i = 0; i < 64; i++) \n    r07[1]++; \n   \n \n   \n \n  r09[1]++; \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r10[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r11[1]++; \n   \n \n  { \n    r12[1]++; \n    r12[1]++; \n  } \n   \n \n   \n \n   \n \n   \n \n  r13[1]++; \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r15[1]++; \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  r17[1]++; \n   \n \n   \n \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r18[1]++; \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r20[1]++; \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r21[1]++; \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r23[1]++; \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r24[1]++; \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r25[1]++; \n   \n \n   \n \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r27[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r28[1]++; \n  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(r29\\\\)\" \"gimple\" } } * \n \n  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r29 \\\\+ 4\" \"gimple\" } } * \n \n  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(r29\\\\)\" \"gimple\" } } * \n \n  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r29 \\\\+ 4\" \"gimple\" } } * \n \n  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r29 \\\\+ 4\" \"gimple\" } } * \n \n  for (int i = 0; i < 64; i++) \n    r29[1]++; \n} ", "pred": " \nvoid \nbar (void) \n{ \n  int *r06 = baz (), *r07 = baz (), *r08 = baz (), *r09 = baz (); \n  int *r10 = baz (), *r11 = baz (), *r12 = baz (); \n  int *r25 = baz (), *r26 = baz (), *r27 = baz (), *r28 = baz (), *r29 = baz (); \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r03[1]++; \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r04[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r05[1]++; \n   \n \n  for (int i = 0; i < 64; i++) \n    r07[1]++; \n   \n \n   \n \n  r09[1]++; \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r10[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r11[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r12[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r13[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r14[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r15[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r16[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r17[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r18[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r19[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r20[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r21[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r22[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r23[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r24[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r25[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r26[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r27[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r28[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r29[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r30[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r31[1]++; \n   \n \n   \n \n   \n \n  for (int i = 0; i <"}
{"label": " \nvoid neighbors_extern(FLOAT_TYPE * Xtest, \n\t\tint nXtest, \n\t\tint dXtest, \n\t\tFLOAT_TYPE * distances, \n\t\tint ndistances, \n\t\tint ddistances, \n\t\tint *indices, \n\t\tint nindices, \n\t\tint dindices, \n\t\tKD_TREE_RECORD *kdtree_record, \n\t\tKD_TREE_PARAMETERS *params) { \n \n\tint i, j; \n\tint K = params->n_neighbors; \n \n\t \n \n\tfor (i = 0; i < nXtest; i++) { \n\t\tFLOAT_TYPE *tpattern = Xtest + i * dXtest; \n\t\tkd_tree_query_tree_sequential(tpattern, distances + i * K, \n\t\t\t\tindices + i * K, K, kdtree_record); \n\t} \n \n\tchar *XI = kdtree_record->XI; \n\tint size_elt = dXtest * sizeof(FLOAT_TYPE) + sizeof(int); \n \n\t \n \n\t \n \n\tfor (i = 0; i < nXtest; i++) { \n\t\tfor (j = 0; j < K; j++) { \n \n\t\t\tint index_in_tree = indices[i * K + j]; \n\t\t\tindices[i * K + j] = *((int *) (XI + index_in_tree * size_elt + dXtest * sizeof(FLOAT_TYPE))); \n\t\t\tdistances[i * K + j] = sqrt(distances[i * K + j]); \n \n\t\t} \n\t} \n \n} ", "pred": " \nvoid neighbors_extern(FLOAT_TYPE * Xtest, \n\t\tint nXtest, \n\t\tint dXtest, \n\t\tFLOAT_TYPE * distances, \n\t\tint ndistances, \n\t\tint ddistances, \n\t\tint *indices, \n\t\tint nindices, \n\t\tint dindices, \n\t\tKD_TREE_RECORD *kdtree_record, \n\t\tKD_TREE_PARAMETERS *params) { \n \n\tint i, j; \n\tint K = params->n_neighbors; \n \n\t \n \n\tfor (i = 0; i < nXtest; i++) { \n\t\tFLOAT_TYPE *tpattern = Xtest + i * dXtest; \n\t\tkd_tree_query_tree_sequential(tpattern, distances + i * K, \n\t\t\t\tindices + i * K, K, kdtree_record); \n\t} \n \n\tchar *XI = kdtree_record->XI; \n\tint size_elt = dXtest * sizeof(FLOAT_TYPE) + sizeof(int); \n \n\t \n \n\t \n \n\tfor (i = 0; i < nXtest; i++) { \n\t\tfor (j = 0; j < K; j++) { \n \n\t\t\tint index_in_tree = indices[i * K + j]; \n\t\t\tFLOAT_TYPE *tpattern = Xtest + i * dXtest + index_in_tree; \n\t\t\tFLOAT_TYPE *tpattern_dist = distances + i * K + j; \n\t\t\tFLOAT_TYPE *tpattern_dist_ptr = tpattern_dist; \n\t\t\tint *index_in_tree_"}
{"label": " namespace generic { \n \n \n \nvoid intDriver (const int NUM, const double t, const double t_end, \n                const double *pr_global, double *y_global) \n{ \n    int tid; \n    for (tid = 0; tid < NUM; ++tid) { \n \n         \n \n        double y_local[NSP]; \n        double pr_local = pr_global[tid]; \n \n         \n \n \n        for (int i = 0; i < NSP; i++) \n        { \n            y_local[i] = y_global[tid + i * NUM]; \n        } \n \n         \n \n        check_error(tid, integrate (t, t_end, pr_local, y_local)); \n \n         \n \n \n        for (int i = 0; i < NSP; i++) \n        { \n            y_global[tid + i * NUM] = y_local[i]; \n        } \n \n    }  \n \n \n}  \n \n \n } ", "pred": " namespace generic { \n \n \n \nvoid intDriver (const int NUM, const double t, const double t_end, \n                const double *pr_global, double *y_global) \n{ \n    int tid; \n    for (tid = 0; tid < NUM; ++tid) { \n \n         \n \n        double y_local[NSP]; \n        double pr_local = pr_global[tid]; \n \n         \n \n \n        for (int i = 0; i < NSP; i++) \n        { \n            y_local[i] = y_global[tid + i * NUM]; \n        } \n \n         \n \n        check_error(tid, integrate (t, t_end, pr_local, y_local)); \n \n         \n \n \n        for (int i = 0; i < NSP; i++) \n        { \n            y_global[tid + i * NUM] = y_local[i]; \n        } \n    } \n \n} \n \n \n \n \nvoid intDriver"}
{"label": " \nvoid \nfoo (void) \n{ \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r01[1]++; \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r02[1]++; \n} ", "pred": " \nvoid \nfoo (void) \n{ \n   \n \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r01[1]++; \n   \n \n   \n \n  for (int i = 0; i < 64; i++) \n    r02[1]++; \n} "}
{"label": " \nvoid CLASS green_equilibrate(float thresh) \n \n{   \n\t \n \n\tstatic const int border=8; \n\tstatic const int border2=16; \n\tstatic const int v1=TS, v2=2*TS, v3=3*TS,  \n p1=-TS+1, p2=-2*TS+2, p3=-3*TS+3, m1=TS+1, m2=2*TS+2, m3=3*TS+3; \n\t \n \n \n\tint top, left;  \n \n\tif(half_size) return; \n \n\tint verbose=1; \n\t \n\tstatic const float eps=1.0;\t \n \n\t \n \n\t \n \n\tstatic const float diffthresh=0.25;  \n \n \n\tdouble dt; \n\tclock_t t1, t2; \n\t \n\t \n \n\t \n\t \n \n\tif (verbose) fprintf(stderr,_(\"Green equilibration v1 OMP [E.Martinec] %1.3f...\\n\"),thresh);\t \n\t \n\t \n\t \n\tt1 = clock(); \n{\t\t \n\tint top,left; \n\t\t\tchar\t\t*buffer;\t\t\t \n \n\t\t\tfloat         (*cfa);\t\t \n \n\t\t\tfloat         (*checker);\t\t\t \n \n\t\t\tfloat         (*gvar);\t\t\t \n \n\t\t\tfloat         (*gdiffv);\t\t\t \n \n\t\t\tfloat         (*gdiffh);\t\t\t \n \n\t\t\t \n\t\t\t \n \n\t\t\tbuffer = (char *) calloc((5*sizeof(float)+sizeof(int))*TS*TS,1); \n\t\t\t \n \n\t\t\tmemset(buffer,0,5*sizeof(float)*TS*TS); \n\t\t\t \n\t\t\tcfa         = (float (*))\t\tbuffer; \n\t\t\tchecker\t\t= (float (*))\t\t\t(buffer +\tsizeof(float)*TS*TS); \n\t\t\tgvar\t\t= (float (*))\t\t\t(buffer +\t2*sizeof(float)*TS*TS); \n\t\t\tgdiffv\t\t= (float (*))\t\t\t(buffer +\t3*sizeof(float)*TS*TS); \n\t\t\tgdiffh\t\t= (float (*))\t\t\t(buffer +\t4*sizeof(float)*TS*TS); \n\t \n \n\t \n\t \n \n\t \n\t \n \n\t \n \n \n \n\tfor (top=0; top < height-border; top += TS-border2) \n\t\tfor (left=0; left < width-border; left += TS-border2) { \n\t\t\tint bottom = MIN( top+TS,height); \n\t\t\tint right  = MIN(left+TS, width); \n\t\t\tint numrows = bottom - top; \n\t\t\tint numcols = right - left; \n\t\t\t \n\t\t\tint row, col; \n\t\t\tint rr, cc, c, indx; \n\t\t\tint vote1, vote2; \n\t\t\t \n\t\t\tfloat val1; \n\t\t\t \n\t\t\tfloat gin, gse, gsw, gne, gnw, wtse, wtsw, wtne, wtnw; \n\t\t\tfloat gu, gd, gl, gr; \n\t\t\tfloat mcorr, pcorr; \n\t\t\tfloat ginterp; \n\t\t\tfloat diffvarh, diffvarv, hvwt; \n\t\t\t \n \n\t\t\t \n \n\t\t\tfor (rr=0; rr < numrows; rr++) \n\t\t\t\tfor (row=rr+top, cc=0; cc < numcols; cc++) { \n\t\t\t\t\tcol = cc+left; \n\t\t\t\t\tcfa[rr*TS+cc] = image[row*width+col][FC(row,col)]; \n \n \n \n\t\t\t\t} \n\t\t\t \n\t\t\t \n \n\t\t\t \n\t\t\tfor (rr=2; rr < numrows-2; rr++) \n\t\t\t\t \n \n\t\t\t\tfor (indx=rr*TS+2; indx < rr*TS+numcols-2; indx++) { \n\t\t\t\t\t \n\t\t\t\t\tif (FC(rr,indx)&1) { \n\t\t\t\t\t\tpcorr = (cfa[indx+p1]-cfa[indx])*(cfa[indx-p1]-cfa[indx]); \n\t\t\t\t\t\tmcorr = (cfa[indx+m1]-cfa[indx])*(cfa[indx-m1]-cfa[indx]); \n\t\t\t\t\t\t \n\t\t\t\t\t\tif (pcorr>0 && mcorr>0) {checker[indx]=1;} else {checker[indx]=0;} \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n \n\t\t\t\t\t} else { \n\t\t\t\t\t\tgu=cfa[indx-v1]+0.5*(cfa[indx]-cfa[indx-v2]); \n\t\t\t\t\t\tgd=cfa[indx+v1]+0.5*(cfa[indx]-cfa[indx+v2]); \n\t\t\t\t\t\tgl=cfa[indx-1]+0.5*(cfa[indx]-cfa[indx-2]); \n\t\t\t\t\t\tgr=cfa[indx+1]+0.5*(cfa[indx]-cfa[indx+2]); \n\t\t\t\t\t\t \n\t\t\t\t\t\tgdiffh[indx] = SQR((gl-gr)/(eps+gl+gr)); \n\t\t\t\t\t\tgdiffv[indx] = SQR((gu-gd)/(eps+gu+gd)); \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t\t\t\t \n \n\t\t\t \n\t\t\t \n \n\t\t\tfor (rr=6; rr < numrows-6; rr++) \n\t\t\t\tfor (cc=7-(FC(rr,2)&1), indx=rr*TS+cc; cc < numcols-6; cc+=2, indx+=2) { \n\t\t\t\t\tif (checker[indx]) { \n\t\t\t\t\t\t \n\t\t\t\t\t\tdiffvarh = eps+(gdiffh[indx-v1]+gdiffh[indx-1]+gdiffh[indx+1]+gdiffh[indx+v1]); \n\t\t\t\t\t\tdiffvarv = eps+(gdiffv[indx-v1]+gdiffv[indx-1]+gdiffv[indx+1]+gdiffv[indx+v1]); \n\t\t\t\t\t\thvwt = fabs(diffvarv-diffvarh)/(diffvarv+diffvarh); \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\t\t\t\t\t\tvote1=(checker[indx-v2]+checker[indx-2]+checker[indx+2]+checker[indx+v2]); \n\t\t\t\t\t\tvote2=(checker[indx-m1]+checker[indx+p1]+checker[indx-p1]+checker[indx+m1]); \n\t\t\t\t\t\tif (vote1>0 && vote2>0 && hvwt<diffthresh) { \n\t\t\t\t\t\t\t \n \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tgin=cfa[indx]; \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tgse=(cfa[indx+m1])+0.5*(cfa[indx]-cfa[indx+m2]); \n\t\t\t\t\t\t\tgnw=(cfa[indx-m1])+0.5*(cfa[indx]-cfa[indx-m2]); \n\t\t\t\t\t\t\tgne=(cfa[indx+p1])+0.5*(cfa[indx]-cfa[indx+p2]); \n\t\t\t\t\t\t\tgsw=(cfa[indx-p1])+0.5*(cfa[indx]-cfa[indx-p2]); \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\twtse=1/(eps+SQR(cfa[indx+m2]-cfa[indx])+SQR(cfa[indx+m3]-cfa[indx+m1])); \n\t\t\t\t\t\t\twtnw=1/(eps+SQR(cfa[indx-m2]-cfa[indx])+SQR(cfa[indx-m3]-cfa[indx-m1])); \n\t\t\t\t\t\t\twtne=1/(eps+SQR(cfa[indx+p2]-cfa[indx])+SQR(cfa[indx+p3]-cfa[indx+p1])); \n\t\t\t\t\t\t\twtsw=1/(eps+SQR(cfa[indx-p2]-cfa[indx])+SQR(cfa[indx-p3]-cfa[indx-p1])); \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tginterp=(gse*wtse+gnw*wtnw+gne*wtne+gsw*wtsw)/(wtse+wtnw+wtne+wtsw); \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tif ( \n ((ginterp-gin) < thresh*(ginterp+gin)) ) { \n\t\t\t\t\t\t\t\tcfa[indx]=0.5*(ginterp+gin); \n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t \n\t\t\t \n \n\t\t\t \n\t\t\t \n \n\t\t\tfor (rr=border; rr < numrows-border; rr++) \n\t\t\t\tfor (row=rr+top, cc=border+1-(FC(rr,2)&1), indx=rr*TS+cc; cc < numcols-border; cc+=2, indx+=2) { \n\t\t\t\t\tif (cfa[indx]<1) continue; \n\t\t\t\t\tcol = cc + left; \n\t\t\t\t\tc = FC(row,col); \n\t\t\t\t\timage[row*width + col][c] = CLIP((int)(cfa[indx] + 0.5));  \n \n\t\t\t\t\t \n \n\t\t\t\t}  \n \n", "pred": " \nvoid CLASS green_equilibrate(float thresh) \n \n{   \n\t \n \n\tstatic const int border=8; \n\tstatic const int border2=16; \n\tstatic const int v1=TS, v2=2*TS, v3=3*TS,  \n p1=-TS+1, p2=-2*TS+2, p3=-3*TS+3, m1=TS+1, m2=2*TS+2, m3=3*TS+3; \n\t \n \n \n\tint top, left;  \n \n\tif(half_size) return; \n \n\tint verbose=1; \n\t \n\tstatic const float eps=1.0;\t \n \n\t \n \n\t \n \n\tstatic const float diffthresh=0.25;  \n \n \n\tdouble dt; \n\tclock_t t1, t2; \n\t \n\t \n \n\t \n\t \n \n\tif (verbose) fprintf(stderr,_(\"Green equilibration v1 OMP [E.Martinec] %1.3f...\\n\"),thresh);\t \n\t \n\t \n\t \n\tt1 = clock(); \n{\t\t \n\tint top,left; \n\t\t\tchar\t\t*buffer;\t\t\t \n \n\t\t\tfloat         (*cfa);\t\t \n \n\t\t\tfloat         (*cav);\t\t \n\t\t\tfloat         (*cav2);\t\t \n\t\t\tfloat         (*cav3);\t\t \n\t\t\tfloat         (*cav4);\t\t \n\t\t\tfloat         (*cav5);\t\t \n\t\t\tfloat         (*cav6);\t\t \n\t\t\tfloat         (*cav7);\t\t \n\t\t\tfloat         (*cav8);\t\t \n\t\t\tfloat         (*cav9);\t\t \n\t\t\tfloat         (*cav10);\t\t \n\t\t\tfloat         (*cav11);\t\t \n\t\t\tfloat         (*cav12);\t\t \n\t\t\tfloat         (*cav13);\t\t \n\t\t\tfloat         (*cav14);\t\t \n\t\t\tfloat         (*cav15);\t\t \n\t\t\tfloat         (*cav16);\t\t \n\t\t\tfloat         (*cav17);\t\t \n\t\t\tfloat         (*cav18);\t\t \n\t\t\tfloat         (*cav19);\t\t \n\t\t\tfloat         (*cav20);\t\t \n\t\t\tfloat         (*cav21);\t\t \n\t\t\tfloat         (*cav22);\t\t \n\t\t\tfloat         (*cav23);\t\t \n\t\t\tfloat         (*cav24);\t\t \n\t\t\tfloat         (*cav25);\t\t \n\t\t\tfloat         (*cav26);\t\t \n\t\t\tfloat         (*cav27);\t\t \n\t\t\tfloat         (*cav28);\t\t \n\t\t\tfloat         (*cav29);\t\t \n\t\t\tfloat         (*cav30);\t\t \n\t\t\tfloat         (*cav31);\t\t \n\t\t\tfloat         (*cav32);\t\t \n\t\t\tfloat         (*cav33);\t\t \n\t\t\tfloat         (*cav34);\t\t \n\t\t\tfloat         (*cav35);\t\t \n\t\t\tfloat         (*cav36);\t\t \n\t\t\tfloat         (*cav37);\t\t \n\t\t\tfloat         (*cav38);\t\t \n\t\t\tfloat         (*cav39);\t\t \n\t\t\tfloat         (*cav40);\t\t \n\t\t\tfloat         (*cav41);\t\t \n\t\t\tfloat         (*cav42);\t\t \n\t\t\tfloat         (*cav43);\t\t \n\t\t\tfloat         (*cav44);\t\t \n\t\t\tfloat         (*cav45);\t\t \n\t\t\tfloat         (*cav46);\t\t \n\t\t\tfloat         (*cav47);\t\t \n\t\t\tfloat         (*cav48);\t\t \n\t\t\tfloat         (*cav49);\t\t \n\t\t\tfloat         (*cav50);\t\t \n\t\t\tfloat         (*cav51);\t\t \n\t\t\tfloat         (*cav52);\t\t \n\t\t\tfloat         (*cav53);\t\t \n\t\t\tfloat         (*cav54);\t\t \n\t\t\tfloat         (*cav55);\t\t \n\t\t\tfloat         (*cav56);\t\t \n\t\t\tfloat         (*cav57);\t\t \n\t\t\tfloat         (*cav58);\t\t \n\t\t\tfloat         (*cav59);\t\t \n\t\t\tfloat         (*cav60);\t\t \n\t\t\tfloat         (*cav61);\t\t \n\t\t\tfloat         (*cav62);\t\t \n\t\t\tfloat         (*cav63);\t\t \n\t\t\tfloat         (*cav64);\t\t \n\t\t\tfloat         (*cav65);\t\t \n\t\t\tfloat         (*cav66);\t\t \n\t\t\tfloat         (*cav67);\t\t \n\t\t\tfloat         (*cav68);\t\t \n\t\t\tfloat         (*cav69);\t\t \n\t\t\tfloat         (*cav70);\t\t \n\t\t\tfloat         (*cav71);\t\t \n\t\t\tfloat         (*cav72);\t\t \n\t\t\tfloat         (*cav73);\t\t \n\t\t\tfloat         (*cav74);\t\t \n\t\t\tfloat         (*cav75);\t\t \n\t\t\tfloat         (*cav76);\t\t \n\t\t\tfloat         (*cav77);\t\t \n\t\t\tfloat         (*cav78);\t\t \n\t\t\tfloat         (*cav79);\t\t \n\t\t\tfloat         (*cav80);\t\t \n\t\t\tfloat         (*cav81);\t\t \n\t\t\tfloat         (*cav82);\t\t \n\t\t\tfloat         (*cav83);\t\t \n\t\t\tfloat         (*cav84);\t\t \n\t\t\tfloat         (*cav85);\t\t \n\t\t\tfloat         (*cav86);\t\t \n\t\t\tfloat         (*cav87);\t\t \n\t\t\tfloat         (*cav88);\t\t \n\t\t\tfloat         (*cav89);\t\t \n\t\t\tfloat         (*cav90);\t\t \n\t\t\tfloat         (*cav91);\t\t \n\t\t\tfloat         (*cav92);\t\t \n\t\t\tfloat         (*cav93);\t\t \n\t\t\tfloat         (*cav94);\t\t \n\t\t\tfloat         (*cav95);\t\t \n\t\t\tfloat         (*cav96);\t\t \n\t\t\tfloat         (*cav97);\t\t \n\t\t\tfloat"}
{"label": " \nint main(int argc, const char** argv) \n{ \n \n     \n \n    if (argc > 1 &&!strcmp(argv[1], \"-c\")) \n    { \n        char data_file_name[] = \"data/data_labdarugas.txt\"; \n \n         \n \n        uint32_t rows_count = get_file_rows_count(data_file_name); \n        const uint32_t events_count = rows_count; \n \n         \n \n        event_t events[events_count]; \n \n         \n \n        const uint32_t buffer_size = 255; \n        char buffer[buffer_size]; \n        FILE* fp = fopen(data_file_name, \"r\"); \n        uint32_t event_counter = 0; \n        while(fgets(buffer, buffer_size, (FILE*) fp)) \n        { \n            uint32_t min; \n            char day[10]; \n            char time[10]; \n            char title[200]; \n \n            strcpy(events[event_counter].no, strtok (buffer, \"\\t\")); \n            min = atoi(strtok (NULL, \"\\t\")); \n            min+=0; \n            strcpy(title, strtok (NULL, \"\\t\")); \n            events[event_counter].odds[0] = strtod(strtok (NULL, \"\\t\"), NULL); \n            events[event_counter].odds[1] = strtod(strtok (NULL, \"\\t\"), NULL); \n            events[event_counter].odds[2] = strtod(strtok (NULL, \"\\t\"), NULL); \n            strcpy(day, strtok (NULL, \"\\t\")); \n            strcpy(time, strtok (NULL, \"\\t\")); \n            events[event_counter].hash = odds_to_hash(events[event_counter].odds); \n \n             \n \n \n            event_counter++; \n        } \n \n        fclose(fp); \n \n \n         \n \n        for (uint32_t i = 0; i < events_count; ++i) \n        { \n            for (uint32_t j = i + 1; j < events_count; ++j) \n            { \n                if (events[i].hash > events[j].hash) \n                { \n                    event_t a = events[i]; \n                    events[i] = events[j]; \n                    events[j] = a; \n                } \n            } \n        } \n \n         \n \n        uint32_t counter = 0; \n        uint32_t count = 0; \n        for (uint32_t i = 0; i < events_count; i++) \n        { \n            if (0 == events[i].odds[0] || 0 == events[i].odds[1] || 0 == events[i].odds[2]) \n            { \n                continue; \n            } \n \n            if (0 == i || (0 < i && ((events[i-1].hash!= events[i].hash) || (events[i-1].hash == events[i].hash && counter < 2)))) \n            { \n                 \n \n                printf(\"%u\\n\", events[i].hash); \n \n                 \n \n \n                count++; \n                counter++; \n                continue; \n            } \n \n            counter = 0; \n        } \n    } \n \n     \n \n    if (argc > 2 &&!strcmp(argv[1], \"-s\")) \n    { \n         \n \n        char data_file_name[] = \"data/d\"; \n \n         \n \n        uint32_t rows_count = get_file_rows_count(data_file_name); \n        const uint32_t odds_count = rows_count; \n \n         \n \n        odd_t odds[odds_count]; \n \n         \n \n        const uint32_t buffer_size = 255; \n        char buffer[buffer_size]; \n        FILE* fp = fopen(data_file_name, \"r\"); \n        uint32_t odd_counter = 0; \n        while(fgets(buffer, buffer_size, (FILE*) fp)) \n        { \n            odds[odd_counter].hash = atoi(buffer); \n            hash_to_odds(odds[odd_counter].hash, &odds[odd_counter].odds); \n \n             \n \n \n            odd_counter++; \n        } \n \n        fclose(fp); \n \n         \n \n        uint32_t index = atoi(argv[2]); \n         \n \n \n         \n \n         \n \n         \n \n \n         \n \n        simplex_init(); \n        time_t start = time(NULL); \n        time_t now = time(NULL); \n        uint32_t total; \n        uint32_t left; \n        uint32_t found = 0; \n \n        int threads = omp_get_num_procs(); \n         \n \n \n        for (index = 0; index < odds_count - 3; index++) \n        { \n            total = nCr(odds_count - index - 1, 3); \n            left = total; \n \n", "pred": " \nint main(int argc, const char** argv) \n{ \n \n     \n \n    if (argc > 1 &&!strcmp(argv[1], \"-c\")) \n    { \n        char data_file_name[] = \"data/data_labdarugas.txt\"; \n \n         \n \n        uint32_t rows_count = get_file_rows_count(data_file_name); \n        const uint32_t events_count = rows_count; \n \n         \n \n        event_t events[events_count]; \n \n         \n \n        const uint32_t buffer_size = 255; \n        char buffer[buffer_size]; \n        FILE* fp = fopen(data_file_name, \"r\"); \n        uint32_t event_counter = 0; \n        while(fgets(buffer, buffer_size, (FILE*) fp)) \n        { \n            uint32_t event_id = 0; \n            uint32_t event_time = 0; \n            uint32_t event_value = 0; \n            uint32_t event_type = 0; \n            uint32_t event_channel = 0; \n            uint32_t event_channel_mask = 0; \n            uint32_t event_channel_value = 0; \n            uint32_t event_channel_type = 0; \n            uint32_t event_channel_mask_value = 0; \n            uint32_t event_channel_value_value = 0; \n            uint32_t event_channel_type_value = 0; \n            uint32_t event_channel_mask_value_value = 0; \n            uint32_t event_channel_value_value_value = 0; \n            uint32_t event_channel_type_value_value = 0; \n            uint32_t event_channel_mask_value_value_value = 0; \n            uint32_t event_channel_value_value_value_value = 0; \n            uint32_t event_channel_type_value_value_value = 0; \n            uint32_t event_channel_mask_value_value_value_value = 0; \n            uint32_t event_channel_value_value_value_value_value = 0; \n            uint32_t event_channel_type_value_value_value_value = 0; \n            uint32_t event_channel_mask_value_value_value_value_value = 0; \n            uint32_t event_channel_value_value_value_value_value_value = 0; \n            uint32_t event_channel_type_value_value_value_value_value = 0; \n            uint32_t event_channel_mask_value_value_value_value_value_value = 0; \n            uint32_t event_channel_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_type_value_value_value_value_value_value = 0; \n            uint32_t event_channel_mask_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_type_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_mask_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_type_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_mask_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_value_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_type_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_mask_value_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_value_value_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_type_value_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_mask_value_value_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_value_value_value_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_type_value_value_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_mask_value_value_value_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_value_value_value_value_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_type_value_value_value_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_mask_value_value_value_value_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_value_value_value_value_value_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_type_value_value_value_value_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_mask_value_value_value_value_value_value_value_value_value_value_value_value_value_value = 0; \n            uint32_t event_channel_value_value_value_value_value_value_value_value_value_value_value_value_value_value"}
{"label": " \nvoid THNN_(VolumetricMaxPooling_updateOutput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *output, \n          THTensor *indices, \n          int kT, \n          int kW, \n          int kH, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH, \n          bool ceilMode) \n{ \n  long nslices; \n  long itime; \n  long iheight; \n  long iwidth; \n  long otime; \n  long oheight; \n  long owidth; \n  real *input_data; \n  real *output_data; \n  real *indices_data; \n \n  THArgCheck(input->nDimension == 4 || input->nDimension == 5, 2, \n    \"4D or 5D (batch-mode) tensor expected\" \n  ); \n \n  int dimN = 0; \n  int dimt = 1; \n  int dimh = 2; \n  int dimw = 3; \n \n  if (input->nDimension == 5) \n  { \n    dimN++; \n    dimt++; \n    dimh++; \n    dimw++; \n  } \n \n  THArgCheck(input->size[dimw] >= kW && input->size[dimh] >= kH && input->size[dimt] >= kT, 2, \n    \"input image smaller than kernel size\" \n  ); \n \n  THArgCheck(kT/2 >= pT && kW/2 >= pW && kH/2 >= pH, 2, \n    \"pad should be smaller than half of kernel size\" \n  ); \n \n   \n \n  nslices = input->size[dimN]; \n  itime   = input->size[dimt]; \n  iheight = input->size[dimh]; \n  iwidth  = input->size[dimw]; \n  if (ceilMode) \n  { \n    otime   = (int)(ceil((float)(itime   - kT + 2 * pT) / dT) + 1); \n    oheight = (int)(ceil((float)(iheight - kH + 2 * pH) / dH) + 1); \n    owidth  = (int)(ceil((float)(iwidth  - kW + 2 * pW) / dW) + 1); \n  } \n  else \n  { \n    otime   = (int)(floor((float)(itime   - kT + 2 * pT) / dT) + 1); \n    oheight = (int)(floor((float)(iheight - kH + 2 * pH) / dH) + 1); \n    owidth  = (int)(floor((float)(iwidth  - kW + 2 * pW) / dW) + 1); \n  } \n \n  if (pT || pW || pH) \n  { \n     \n \n    if ((otime - 1)*dT >= itime + pT) \n      --otime; \n    if ((oheight - 1)*dH >= iheight + pH) \n      --oheight; \n    if ((owidth  - 1)*dW >= iwidth  + pW) \n      --owidth; \n  } \n \n   \n \n  input = THTensor_(newContiguous)(input); \n \n  if (input->nDimension == 4)  \n \n  { \n     \n \n    THTensor_(resize4d)(output, nslices, otime, oheight, owidth); \n     \n \n    THTensor_(resize4d)(indices, nslices, otime, oheight, owidth); \n \n    input_data = THTensor_(data)(input); \n    output_data = THTensor_(data)(output); \n    indices_data = THTensor_(data)(indices); \n \n    THNN_(VolumetricMaxPooling_updateOutput_frame)( \n      input_data, output_data, \n      indices_data, \n      nslices, \n      itime, iwidth, iheight, \n      otime, owidth, oheight, \n      kT, kW, kH, \n      dT, dW, dH, \n      pT, pW, pH \n    ); \n  } \n  else  \n \n  { \n    long p; \n    long nBatch = input->size[0]; \n \n    long istride = nslices * itime * iwidth * iheight; \n    long ostride = nslices * otime * owidth * oheight; \n \n     \n \n    THTensor_(resize5d)(output, nBatch, nslices, otime, oheight, owidth); \n     \n \n    THTensor_(resize5d)(indices, nBatch, nslices, otime, oheight, owidth); \n \n    input_data = THTensor_(data)(input); \n    output_data = THTensor_(data)(output); \n    indices_data = THTensor_(data)(indices); \n \n    for (p=0; p < nBatch; p++) \n    { \n      THNN_(VolumetricMaxPooling_updateOutput_frame)( \n        input_data   + p * istride, \n        output_data  + p * ostride, \n        indices_data + p * ostride, \n        nslices, \n        itime, iwidth, iheight, \n        otime, owidth, oheight, \n        kT, kW, kH, \n        dT, dW, dH, \n        pT, pW, pH \n      ); \n    } \n  } \n \n   \n \n  THTensor_(free)(input); \n} ", "pred": " \nvoid THNN_(VolumetricMaxPooling_updateOutput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *output, \n          THTensor *indices, \n          int kT, \n          int kW, \n          int kH, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH, \n          bool ceilMode) \n{ \n  long nslices; \n  long itime; \n  long iheight; \n  long iwidth; \n  long otime; \n  long oheight; \n  long owidth; \n  real *input_data; \n  real *output_data; \n  real *indices_data; \n \n  THArgCheck(input->nDimension == 4, 3, \"volumetricMaxPooling: input must be a 4D tensor\"); \n  THArgCheck(output->nDimension == 4, 3, \"volumetricMaxPooling: output must be a 4D tensor\"); \n  THArgCheck(indices->nDimension == 4, 3, \"volumetricMaxPooling: indices must be a 4D tensor\"); \n  \n  input_data = (real *)input->data; \n  output_data = (real *)output->data; \n  indices_data = (real *)indices->data; \n \n  nslices = input->nDimension; \n  itime = input->time; \n  iheight = input->height; \n  iwidth = input->width; \n  otime = output->time; \n  oheight = output->height; \n  owidth = output->width; \n  \n  if (ceilMode) { \n    if (kT == 0) { \n      THArgCheck(kW == 0, 3, \"volumetricMaxPooling: kT must be > 0\"); \n      THArgCheck(kH == 0, 3, \"volumetricMaxPooling: kH must be > 0\"); \n      THArgCheck(dT == 0, 3, \"volumetricMaxPooling: dT must be > 0\"); \n      THArgCheck(dW == 0, 3, \"volumetricMaxPooling: dW must be > 0\"); \n      THArgCheck(dH == 0, 3, \"volumetricMaxPooling: dH must be > 0\"); \n      THArgCheck(pT == 0, 3, \"volumetricMaxPooling: pT must be > 0\"); \n      THArgCheck(pH == 0, 3, \"volumetricMaxPooling: pH must be > 0\"); \n    } else { \n      THArgCheck(kW == 1, 3, \"volumetricMaxPooling: kT must be > 1\"); \n      THArgCheck(kH == 1, 3, \"volumetricMaxPooling: kH must be > 1\"); \n      THArgCheck(dT == 1, 3, \"volumetricMaxPooling: dT must be > 1\"); \n      THArgCheck(dW == 1, 3, \"volumetricMaxPooling: dW must be > 1\"); \n      THArgCheck(dH == 1, 3, \"volumetricMaxPooling: dH must be > 1\"); \n      THArgCheck(pT == 1, 3, \"volumetricMaxPooling: pT must be > 1\"); \n      THArgCheck(pH == 1, 3, \"volumetricMaxPooling: pH must be > 1\"); \n    } \n  } else { \n    if (kT == 0) { \n      THArgCheck(kW == 0, 3, \"volumetricMaxPooling: kT must be > 0\"); \n      THArgCheck(kH == 0, 3, \"volumetricMaxPooling: kH must be > 0\"); \n      THArgCheck(dT == 0, 3, \"volumetricMaxPooling: dT must be > 0\"); \n      THArgCheck(dW == 0, 3, \"volumetricMaxPooling: dW must be > 0\"); \n      THArgCheck(dH == 0, 3, \"volumetricMaxPooling: dH must be > 0\"); \n      THArgCheck(pT == 0, 3, \"volumetricMaxPooling: pT must be > 0\"); \n      THArgCheck(pH == 0, 3, \"volumetricMaxPooling: pH must be > 0\"); \n    } else { \n      THArgCheck(kW == 1, 3, \"volumetricMaxPooling: kT must be > 1\"); \n      THArgCheck(kH == 1, 3, \"volumetricMaxPooling: kH must be > 1\"); \n      THArgCheck(dT == 1, 3, \"volumetricMaxPooling: dT must be > 1\"); \n      THArgCheck(dW == 1, 3, \"volumetricMaxPooling: dW must be > 1\"); \n      THArgCheck(dH == 1, 3, \"volumetricMaxPooling: dH must be > 1\"); \n      THArgCheck(pT == 1, 3, \"volumetricMaxPooling: pT must be > 1\"); \n      THArgCheck(pH == 1, 3, \"volumetricMaxPooling: pH must be > 1\"); \n    } \n  } \n  \n  if (kT == 0) { \n    if (kW == 0) { \n      THArgCheck(kH == 0, 3, \"volumetricMaxPooling: kW must be > 0\"); \n      THArgCheck(dT == 0, 3, \"volumetricMaxPooling: dT must be > 0\"); \n      THArgCheck(dW == 0, 3, \"volumetricMaxPooling: dW must be > 0\"); \n      THArgCheck(dH == 0, 3, \"volumetricMaxPooling: dH must be > 0\"); \n      THArgCheck(pT == 0, 3, \"volumetricMaxPooling: pT must be > 0\"); \n      THArgCheck(pH == 0, 3, \"volumetricMaxPooling: pH must be > 0\");"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double***)*13); \n  for(m=0; m<13;m++){ \n    coef[m] = (double ***) malloc(sizeof(double**)*Nz); \n \n    for(i=0; i<Nz; i++){ \n      coef[m][i] = (double**) malloc(sizeof(double*)*Ny); \n \n      for(j=0;j<Ny;j++){ \n        coef[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  } \n \n   \n \n  int *tile_size = (int*) malloc(sizeof(int)); \n  tile_size[0] = -1; \n   \n \n  tile_size = (int*) realloc((void *)tile_size, sizeof(int)*5); \n  tile_size[0] = 16; \n  tile_size[1] = 16; \n  tile_size[2] = 4; \n  tile_size[3] = 1024; \n  tile_size[4] = -1; \n \n \n   \n \n  int ts_return = -1; \n  struct timeval start, end, result; \n  double tdiff = 0.0, min_tdiff=1.e100; \n \n  const int BASE = 1024; \n \n   \n \n   \n \n  srand(42); \n  for (i = 1; i < Nz; i++) { \n      for (j = 1; j < Ny; j++) { \n          for (k = 1; k < Nx; k++) { \n              A[0][i][j][k] = 1.0 * (rand() % BASE); \n          } \n      } \n  } \n  for (m=0; m<13; m++) { \n      for (i=1; i<Nz; i++) { \n          for (j=1; j<Ny; j++) { \n              for (k=1; k<Nx; k++) { \n                  coef[m][i][j][k] = 1.0 * (rand() % BASE); \n              } \n          } \n      } \n  } \n \n \n  LIKWID_MARKER_INIT; \n  { \n      LIKWID_MARKER_THREADINIT; \n      LIKWID_MARKER_START(\"calc\"); \n  } \n \n  int num_threads = 1; \n  num_threads = omp_get_max_threads(); \n \n \n  for(test=0; test<TESTS; test++){ \n      gettimeofday(&start, 0); \n   \n \n \n \n \n \n \n \n \n \n  int t1, t2, t3, t4, t5, t6, t7, t8; \n int lb, ub, lbp, ubp, lb2, ub2; \n register int lbv, ubv; \n \n \nif ((Nt >= 1) && (Nx >= 9) && (Ny >= 9) && (Nz >= 9)) { \n  for (t1=-1;t1<=floord(Nt-1,2);t1++) { \n    lbp=max(ceild(t1,2),ceild(4*t1-Nt+2,4)); \n    ubp=min(floord(4*Nt+Nz-9,16),floord(8*t1+Nz+2,16)); \n    for (t2=lbp;t2<=ubp;t2++) { \n      for (t3=max(max(max(1,ceild(16*t2-Nz+9,4)),2*t1+1),4*t1-4*t2+2);t3<=min(min(min(floord(4*Nt+Ny-9,4),floord(8*t1+Ny+7,4)),floord(16*t2+Ny+3,4)),floord(16*t1-16*t2+Nz+Ny+5,4));t3++) { \n        for (t4=max(max(max(0,ceild(t1-127,128)),ceild(16*t2-Nz-1011,1024)),ceild(4*t3-Ny-1011,1024));t4<=min(min(min(min(floord(4*Nt+Nx-9,1024),floord(8*t1+Nx+7,1024)),floord(16*t2+Nx+3,1024)),floord(4*t3+Nx-9,1024)),floord(16*t1-16*t2+Nz+Nx+5,1024));t4++) { \n          for (t5=max(max(max(max(max(0,ceild(16*t2-Nz+5,4)),ceild(4*t3-Ny+5,4)),ceild(1024*t4-Nx+5,4)),2*t1),4*t1-4*t2+1);t5<=min(min(min(min(min(floord(16*t1-16*t2+Nz+10,4),Nt-1),2*t1+3),4*t2+2),t3-1),256*t4+254);t5++) { \n            for (t6=max(max(16*t2,4*t5+4),-16*t1+16*t2+8*t5-15);t6<=min(min(16*t2+15,-16*t1+16*t2+8*t5),4*t5+Nz-5);t6++) { \n              for (t7=4*t3;t7<=min(4*t3+3,4*t5+Ny-5);t7++) { \n                lbv=max(1024*t4,4*t5+4); \n                ubv=min(1024*t4+1023,4*t5+Nx-5); \n                for (t8=lbv;t8<=ubv;t8++) { \n                  A[( t5 + 1) % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] = (((((((((((((coef[0][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)] * A[ t5 % 2][ (-4*t5+t6)][ (-4*t5+t7)][ (-4*t5+t8)]) + (coef[1][ (-4*t5+t6)][ (-4*t5+t7", "pred": " \nint main(int argc, char *argv[]) \n{ \n  int t, i, j, k, m, test; \n  int Nx, Ny, Nz, Nt; \n  if (argc > 3) { \n    Nx = atoi(argv[1])+8; \n    Ny = atoi(argv[2])+8; \n    Nz = atoi(argv[3])+8; \n  } \n  if (argc > 4) \n    Nt = atoi(argv[4]); \n \n \n   \n \n  double ****A = (double ****) malloc(sizeof(double***)*2); \n \n  for(m=0; m<2;m++){ \n    A[m] = (double ***) malloc(sizeof(double**)*Nz); \n    for(i=0; i<Nz; i++){ \n      A[m][i] = (double**) malloc(sizeof(double*)*Ny); \n      for(j=0;j<Ny;j++){ \n        A[m][i][j] = (double*) malloc(sizeof(double)*Nx); \n      } \n    } \n  }   \n \n  double ****coef = (double ****) malloc(sizeof(double**)*2); \n  for(m=0; m<2;m++){ \n    coef[m] = (double **) malloc(sizeof(double*)*2); \n    for(i=0; i<2;i++){ \n      coef[m][i] = (double *) malloc(sizeof(double)*Nx); \n      for(j=0;j<Nx;j++){ \n        coef[m][i][j] = (double) 0.0; \n      } \n    } \n  } \n \n  double ***x = (double ***) malloc(sizeof(double**)*2); \n  for(m=0; m<2;m++){ \n    x[m] = (double **) malloc(sizeof(double*)*2); \n    for(i=0; i<2;i++){ \n      x[m][i] = (double *) malloc(sizeof(double)*Nx); \n      for(j=0;j<Nx;j++){ \n        x[m][i][j] = (double) 0.0; \n      } \n    } \n  } \n \n  double ***y = (double ***) malloc(sizeof(double**)*2); \n  for(m=0; m<2;m++){ \n    y[m] = (double **) malloc(sizeof(double*)*2); \n    for(i=0; i<2;i++){ \n      y[m][i] = (double *) malloc(sizeof(double)*Nx); \n      for(j=0;j<Nx;j++){ \n        y[m][i][j] = (double) 0.0; \n      } \n    } \n  } \n \n  double ***z = (double ***) malloc(sizeof(double**)*2); \n  for(m=0; m<2;m++){ \n    z[m] = (double **) malloc(sizeof(double*)*2); \n    for(i=0; i<2;i++){ \n      z[m][i] = (double *) malloc(sizeof(double)*Nx); \n      for(j=0;j<Nx;j++){ \n        z[m][i][j] = (double) 0.0; \n      } \n    } \n  } \n \n  double ***t = (double ***) malloc(sizeof(double**)*2); \n  for(m=0; m<2;m++){ \n    t[m] = (double **) malloc(sizeof(double*)*2); \n    for(i=0; i<2;i++){ \n      t[m][i] = (double *) malloc(sizeof(double)*Nx); \n      for(j=0;j<Nx;j++){ \n        t[m][i][j] = (double) 0.0; \n      } \n    } \n  } \n \n  double ***u = (double ***) malloc(sizeof(double**)*2); \n  for(m=0; m<2;m++){ \n    u[m] = (double **) malloc(sizeof(double*)*2); \n    for(i=0; i<2;i++){ \n      u[m][i] = (double *) malloc(sizeof(double)*Nx); \n      for(j=0;j<Nx;j++){ \n        u[m][i][j] = (double) 0.0; \n      } \n    } \n  } \n \n  double ***v = (double ***) malloc(sizeof(double**)*2); \n  for(m=0; m<2;m++){ \n    v[m] = (double **) malloc(sizeof(double*)*2); \n    for(i=0; i<2;i++){ \n      v[m][i] = (double *) malloc(sizeof(double)*Nx); \n      for(j=0;j<Nx;j++){ \n        v[m][i][j] = (double) 0.0; \n      } \n    } \n  } \n \n  double ***w = (double ***) malloc(sizeof(double**)*2); \n  for(m=0; m<2;m++){ \n    w[m] = (double **) malloc(sizeof(double*)*2); \n    for(i=0; i<2;i++){ \n      w[m][i] = (double *) malloc(sizeof(double)*Nx); \n      for(j=0;j<Nx;j++){ \n        w[m][i][j] = (double) 0.0; \n      } \n    } \n  } \n \n  double ***x_in = (double ***) malloc(sizeof(double**)*2); \n  for(m=0; m<2;m++){ \n    x_in[m] = (double **) malloc(sizeof(double*)*2); \n    for(i=0; i<2;i++){ \n      x_in[m][i] = (double *) malloc(sizeof(double)*Nx); \n      for(j=0;j<Nx;j++){ \n        x_in[m][i][j] = (double) 0.0; \n      } \n    } \n  } \n \n  double ***y_in = (double ***) malloc(sizeof(double**)*2); \n  for(m=0; m<2;m++){ \n    y_in[m] = (double **) malloc(sizeof(double*)*2); \n    for(i=0; i<2;i++){ \n      y_in[m][i] = (double *) malloc(sizeof(double)*Nx); \n      for(j=0;j<Nx;j++){ \n        y_in[m][i][j] = (double) 0.0; \n      } \n    } \n  } \n \n  double ***z_in = (double ***) malloc(sizeof(double**)*2); \n  for(m=0; m<2;m++){ \n    z_in[m] = (double **) malloc(sizeof(double*)*2); \n    for(i=0; i<2;i++){ \n      z_in[m][i] = (double *) malloc(sizeof(double)*Nx); \n      for(j=0;j<Nx;j++){ \n        z_in[m][i][j] = (double) 0.0; \n      } \n    } \n  } \n \n  double ***t_in = (double ***) malloc(sizeof(double**)*2); \n  for(m=0; m<2;m++){ \n    t_in[m] = (double **) malloc(sizeof(double*)*2); \n "}
{"label": " \nvoid THNN_(VolumetricMaxPooling_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput, \n          THTensor *indices, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH) \n{ \n  int nslices; \n  int itime; \n  int iheight; \n  int iwidth; \n  int otime; \n  int oheight; \n  int owidth; \n  real *gradInput_data; \n  real *gradOutput_data; \n  real *indices_data; \n \n  int dimN = 0; \n  int dimt = 1; \n  int dimh = 2; \n  int dimw = 3; \n \n   \n \n  gradOutput = THTensor_(newContiguous)(gradOutput); \n \n   \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(zero)(gradInput); \n \n  if (input->nDimension == 5) \n  { \n    dimN++; \n    dimt++; \n    dimh++; \n    dimw++; \n  } \n \n   \n \n  nslices = input->size[dimN]; \n  itime = input->size[dimt]; \n  iheight = input->size[dimh]; \n  iwidth = input->size[dimw]; \n  otime = gradOutput->size[dimt]; \n  oheight = gradOutput->size[dimh]; \n  owidth = gradOutput->size[dimw]; \n \n   \n \n  gradInput_data = THTensor_(data)(gradInput); \n  gradOutput_data = THTensor_(data)(gradOutput); \n  indices_data = THTensor_(data)(indices); \n \n   \n \n  if (input->nDimension == 4)  \n \n  { \n    THNN_(VolumetricMaxPooling_updateGradInput_frame)( \n      gradInput_data, gradOutput_data, \n      indices_data, \n      nslices, \n      itime, iwidth, iheight, \n      otime, owidth, oheight, \n      dT, dW, dH, \n      pT, pW, pH \n    ); \n  } \n  else  \n \n  { \n    long p; \n    long nBatch = input->size[0]; \n \n    long istride = nslices * itime * iwidth * iheight; \n    long ostride = nslices * otime * owidth * oheight; \n \n    for (p = 0; p < nBatch; p++) \n    { \n      THNN_(VolumetricMaxPooling_updateGradInput_frame)( \n        gradInput_data + p * istride, \n        gradOutput_data + p * ostride, \n        indices_data + p * ostride, \n        nslices, \n        itime, iwidth, iheight, \n        otime, owidth, oheight, \n        dT, dW, dH, \n        pT, pW, pH \n      ); \n    } \n  } \n \n   \n \n  THTensor_(free)(gradOutput); \n} ", "pred": " \nvoid THNN_(VolumetricMaxPooling_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput, \n          THTensor *indices, \n          int dT, \n          int dW, \n          int dH, \n          int pT, \n          int pW, \n          int pH) \n{ \n  int nslices; \n  int itime; \n  int iheight; \n  int iwidth; \n  int otime; \n  int oheight; \n  int owidth; \n  real *gradInput_data; \n  real *gradOutput_data; \n  real *indices_data; \n \n  int dimN = 0; \n  int dimt = 1; \n  int dimh = 2; \n  int dimw = 3; \n \n   \n \n  gradOutput = THTensor_(newTensor)(state, gradOutput->size, gradOutput->type); \n  gradInput = THTensor_(newTensor)(state, gradInput->size, gradInput->type); \n  indices = THTensor_(newTensor)(state, indices->size, indices->type); \n \n  gradInput_data = THTensor_(data)(gradInput); \n  gradOutput_data = THTensor_(data)(gradOutput); \n  indices_data = THTensor_(data)(indices); \n \n  nslices = state->nslices; \n  itime = state->itime; \n  iheight = state->iheight; \n  iwidth = state->iwidth; \n  otime = state->otime; \n  oheight = state->oheight; \n  owidth = state->owidth; \n \n  for (dimt = 0; dimt < dimN; dimt++) { \n    for (dimh = 0; dimh < dimh; dimh++) { \n      for (dimw = 0; dimw < dimw; dimw++) { \n        gradInput_data[dimt*dimh*dimw] = gradInput_data[dimt*dimh*dimw] + gradInput_data[dimt*dimh*dimw+dimw]; \n        gradOutput_data[dimt*dimh*dimw] = gradOutput_data[dimt*dimh*dimw] + gradOutput_data[dimt*dimh*dimw+dimw]; \n        indices_data[dimt*dimh*dimw+dimw] = indices_data[dimt*dimh*dimw+dimw] + indices_data[dimt*dimh*dimw+dimw+dimw]; \n      } \n    } \n  } \n \n  THTensor_(resizeTensor)(gradInput, gradInput->size, gradInput->type); \n  THTensor_(resizeTensor)(gradOutput, gradOutput->size, gradOutput->type); \n  THTensor_(resizeTensor)(indices, indices->size, indices->type); \n \n  THTensor_(resizeTensor)(gradInput_data, gradInput->size, gradInput->type); \n  THTensor_(resizeTensor)(gradOutput_data, gradOutput->size, gradOutput->type); \n  THTensor_(resizeTensor)(indices_data, indices->size, indices->type); \n \n  THTensor_(resizeTensor)(gradInput_data, gradInput->size, gradInput->type); \n  THTensor_(resizeTensor)(gradOutput_data, gradOutput->size, gradOutput->type); \n  THTensor_(resizeTensor)(indices_data, indices->size, indices->type); \n \n  THTensor_(resizeTensor)(gradInput_data"}
{"label": " \nMagickExport MagickBooleanType SolarizeImage(Image *image, \n  const double threshold,ExceptionInfo *exception) \n{ \n#define SolarizeImageTag  \"Solarize/Image\" \n \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  if (IsGrayColorspace(image->colorspace)!= MagickFalse) \n    (void) SetImageColorspace(image,sRGBColorspace,exception); \n  if (image->storage_class == PseudoClass) \n    { \n      register ssize_t \n        i; \n \n       \n \n      for (i=0; i < (ssize_t) image->colors; i++) \n      { \n        if ((double) image->colormap[i].red > threshold) \n          image->colormap[i].red=QuantumRange-image->colormap[i].red; \n        if ((double) image->colormap[i].green > threshold) \n          image->colormap[i].green=QuantumRange-image->colormap[i].green; \n        if ((double) image->colormap[i].blue > threshold) \n          image->colormap[i].blue=QuantumRange-image->colormap[i].blue; \n      } \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireAuthenticCacheView(image,exception); \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    register ssize_t \n      x; \n \n    register Quantum \n      *restrict q; \n \n    if (status == MagickFalse) \n      continue; \n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception); \n    if (q == (Quantum *) NULL) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      register ssize_t \n        i; \n \n      if (GetPixelReadMask(image,q) == 0) \n        { \n          q+=GetPixelChannels(image); \n          continue; \n        } \n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n      { \n        PixelChannel channel=GetPixelChannelChannel(image,i); \n        PixelTrait traits=GetPixelChannelTraits(image,channel); \n        if ((traits & UpdatePixelTrait) == 0) \n          continue; \n        if ((double) q[i] > threshold) \n          q[i]=QuantumRange-q[i]; \n      } \n      q+=GetPixelChannels(image); \n    } \n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        proceed=SetImageProgress(image,SolarizeImageTag,progress++,image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  } \n  image_view=DestroyCacheView(image_view); \n  return(status); \n} ", "pred": " \nMagickExport MagickBooleanType SolarizeImage(Image *image, \n  const double threshold,ExceptionInfo *exception) \n{ \n#define SolarizeImageTag  \"Solarize/Image\" \n \n  CacheView \n    *image_view; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n  assert(image!= (Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  if (IsGrayColorspace(image->colorspace)!= MagickFalse) \n    (void) SetImageColorspace(image,sRGBColorspace,exception); \n  if (image->storage_class == PseudoClass) \n    { \n      register ssize_t \n        i; \n \n       \n \n      for (i=0; i < (ssize_t) image->colors; i++) \n      { \n        if ((double) image->colormap[i].red > threshold) \n          { \n            SetPixelRed(image,ClampToQuantum(image->colormap[i].red),q); \n            SetPixelGreen(image,ClampToQuantum(image->colormap[i].green),q); \n            SetPixelBlue(image,ClampToQuantum(image->colormap[i].blue),q); \n            break; \n          } \n      } \n    } \n  else \n    { \n      if (image->storage_class == DirectClass) \n        { \n          for (y=0; y < (ssize_t) image->rows; y++) \n          { \n            register ssize_t \n              i; \n \n            for (i=0; i < (ssize_t) image->columns; i++) \n            { \n              if ((double) image->colormap[i].red > threshold) \n                { \n                  SetPixelRed(image,ClampToQuantum(image->colormap[i].red),q); \n                  SetPixelGreen(image,ClampToQuantum(image->colormap[i].green),q); \n                  SetPixelBlue(image,ClampToQuantum(image->colormap[i].blue),q); \n                  break; \n                } \n            } \n            if (i < (ssize_t) image->columns) \n              break; \n          } \n        } \n      else \n        if (image->storage_class == PseudoClass) \n          { \n            for (y=0; y < (ssize_t) image->rows; y++) \n            { \n              register ssize_t \n                i; \n \n              for (i=0; i < (ssize_t) image->columns; i++) \n              { \n                if ((double) image->colormap[i].red > threshold) \n                  { \n                   "}
{"label": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_zonesystem_data_t *const d = (const dt_iop_zonesystem_data_t *const)piece->data; \n \n  process_common_setup(self, piece, ivoid, ovoid, roi_in, roi_out); \n \n  const int ch = piece->colors; \n  const int size = d->params.size; \n \n  const float *const in = (const float *const)ivoid; \n  float *const out = (float *const)ovoid; \n \n  for(size_t k = 0; k < (size_t)ch * roi_out->width * roi_out->height; k += ch) \n  { \n    for(int c = 0; c < 3; c++) \n    { \n       \n \n      const int rz = CLAMPS(in[k] * d->rzscale, 0, size - 2);  \n \n      const float zs = ((rz > 0)? (d->zonemap_offset[rz] / in[k]) : 0) + d->zonemap_scale[rz]; \n \n      const size_t p = (size_t)k + c; \n      out[p] = in[p] * zs; \n    } \n  } \n \n  process_common_cleanup(self, piece, ivoid, ovoid, roi_in, roi_out); \n} ", "pred": " \nvoid process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_zonesystem_data_t *const d = (const dt_iop_zonesystem_data_t *const)piece->data; \n \n  process_common_setup(self, piece, ivoid, ovoid, roi_in, roi_out); \n \n  const int ch = piece->colors; \n  const int size = d->params.size; \n \n  const float *const in = (const float *const)ivoid; \n  float *const out = (float *const)ovoid; \n \n  for(size_t k = 0; k < (size_t)ch * roi_out->width * roi_out->height; k += ch) \n  { \n    for(int c = 0; c < 3; c++) \n    { \n       \n \n      const int rz = CLAMPS(in[k] * d->rzscale, 0, d->rzmax); \n      const int gz = CLAMPS(in[k] * d->gzscale, 0, d->gzmax); \n      const int bz = CLAMPS(in[k] * d->bzscale, 0, d->bzmax); \n      const int r = CLAMPS(in[k] * d->rscale, 0, d->rmax); \n      const int g = CLAMPS(in[k] * d->gscale, 0, d->gmax); \n "}
{"label": " \nstatic void process_common_cleanup(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                   const void *const ivoid, void *const ovoid, \n                                   const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_zonesystem_data_t *d = (dt_iop_zonesystem_data_t *)piece->data; \n  dt_iop_zonesystem_gui_data_t *g = (dt_iop_zonesystem_gui_data_t *)self->gui_data; \n \n  const int width = roi_out->width; \n  const int height = roi_out->height; \n  const int ch = piece->colors; \n  const int size = d->params.size; \n \n  if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, width, height); \n \n   \n \n  if(self->dev->gui_attached && piece->pipe->type == DT_DEV_PIXELPIPE_PREVIEW && g && g->in_preview_buffer \n     && g->out_preview_buffer) \n  { \n    float Lmax[] = { 100.0f }; \n    float Lmin[] = { 0.0f }; \n \n     \n \n    const int radius = 8; \n    const float sigma = 2.5 * (radius * roi_in->scale / piece->iscale); \n \n    dt_gaussian_t *gauss = dt_gaussian_init(width, height, 1, Lmax, Lmin, sigma, DT_IOP_GAUSSIAN_ZERO); \n \n    float *tmp = g_malloc_n((size_t)width * height, sizeof(float)); \n \n    if(gauss && tmp) \n    { \n      for(size_t k = 0; k < (size_t)width * height; k++) tmp[k] = ((float *)ivoid)[ch * k]; \n \n      dt_gaussian_blur(gauss, tmp, tmp); \n \n       \n \n      dt_pthread_mutex_lock(&g->lock); \n      for(size_t k = 0; k < (size_t)width * height; k++) \n      { \n        g->in_preview_buffer[k] = CLAMPS(tmp[k] * (size - 1) / 100.0f, 0, size - 2); \n      } \n      dt_pthread_mutex_unlock(&g->lock); \n \n \n      for(size_t k = 0; k < (size_t)width * height; k++) tmp[k] = ((float *)ovoid)[ch * k]; \n \n      dt_gaussian_blur(gauss, tmp, tmp); \n \n \n       \n \n      dt_pthread_mutex_lock(&g->lock); \n      for(size_t k = 0; k < (size_t)width * height; k++) \n      { \n        g->out_preview_buffer[k] = CLAMPS(tmp[k] * (size - 1) / 100.0f, 0, size - 2); \n      } \n      dt_pthread_mutex_unlock(&g->lock); \n    } \n \n    g_free(tmp); \n    if(gauss) dt_gaussian_free(gauss); \n  } \n} ", "pred": " \nstatic void process_common_cleanup(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, \n                                   const void *const ivoid, void *const ovoid, \n                                   const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  dt_iop_zonesystem_data_t *d = (dt_iop_zonesystem_data_t *)piece->data; \n  dt_iop_zonesystem_gui_data_t *g = (dt_iop_zonesystem_gui_data_t *)self->gui_data; \n \n  const int width = roi_out->width; \n  const int height = roi_out->height; \n  const int ch = piece->colors; \n  const int size = d->params.size; \n \n  if(piece->pipe->mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out->width, roi_out->height, roi_out->width, roi_out->height); \n  else dt_iop_alpha_copy(ovoid, ivoid, roi_out->width, roi_out->height, roi_out->width, roi_out->height); \n \n  if(d->params.mode == DT_IOP_MODE_COLOR) \n  { \n    const int x = roi_out->x; \n    const int y = roi_out->y; \n    const int w = roi_out->width; \n    const int h = roi_out->height; \n    const int i = roi_out->x; \n    const int j = roi_out->y; \n    const int k = roi_out->width; \n    const int l = roi_out->height; \n    const int m = roi_out->x + roi_out->width - 1; \n    const int n = roi_out->y + roi_out->height - 1; \n    const int c = roi_out->channels; \n    const int r = roi_out->red; \n    const int g = roi_out->green; \n    const int b = roi_out->blue; \n    const int a = roi_out->alpha; \n    const int k2 = k * 2; \n    const int l2 = l * 2; \n    const int m2 = m * 2; \n    const int n2 = n * 2; \n    const int c2 = c * 2; \n    const int r2 = r * 2; \n    const int g2 = g * 2; \n    const int b2 = b * 2; \n    const int a2 = a * 2; \n    const int k3 = k * 3; \n    const int l3 = l * 3; \n    const int m3 = m * 3; \n    const int n3 = n * 3; \n    const int c3 = c * 3; \n    const int r3 = r * 3; \n    const int g3 = g * 3; \n    const int b3 = b * 3; \n    const int a3 = a * 3; \n    const int k4 = k * 4; \n    const int l4 = l * 4; \n    const int m4 = m * 4; \n    const int n4 = n * 4; \n    const int c4 = c * 4; \n    const int r4 = r * 4; \n    const int g4 = g * 4; \n    const int b4 = b * 4; \n    const int a4 = a"}
{"label": " \nvoid lbestpso(size_t nDim,  \n \n            fitness_function_ptr fitfunc,  \n \n\t\t\tvoid *ffParams,  \n \n\t\t\tcurrent_result_callback_params_t *callback_params,  \n \n            struct psoParamStruct *psoParams,  \n \n\t\t\tstruct returnData *psoResults  \n){ \n \n\tclock_t time_start = clock(); \n \n\t \n \n\tgsl_rng *rngGen = psoParams->rngGen; \n\t \n\t \n \n\tgsl_multimin_function func2minimz; \n\tfunc2minimz.n = nDim;  \n \n\tfunc2minimz.f = dummyfitfunc; \n \n\tstruct dummyFitFuncParam dffp; \n\tdffp.trufuncPr = fitfunc; \n\tdffp.trufuncParam = ffParams; \n\tfunc2minimz.params = &dffp; \n \n\t \n \n\tgsl_multimin_fminimizer *minimzrState = gsl_multimin_fminimizer_alloc(gsl_multimin_fminimizer_nmsimplex2, nDim); \n\t \n \n\tgsl_vector *locMinStp = gsl_vector_alloc(nDim); \n\tgsl_vector_set_all(locMinStp,psoParams->locMinStpSz); \n\tsize_t lpLocMin; \n \n\tint status; \n\t \n\t \n \n\tsize_t lpParticles, lpPsoIter; \n\t \n \n\tconst size_t popsize = psoParams->popsize; \n\t \n \n\tconst size_t maxSteps = psoParams->maxSteps; \n\t \n \n    struct particleInfo pop[popsize]; \n\t \n \n\tfor (lpParticles = 0; lpParticles < popsize; lpParticles++){ \n\t      initPsoParticles(&pop[lpParticles], nDim, rngGen); \n    }\t \n\t \n \n\tdouble gbestFitVal = GSL_POSINF; \n\tgsl_vector *gbestCoord = gsl_vector_alloc(nDim); \n\tgsl_vector *partSnrCurrCol = gsl_vector_alloc(popsize); \n\tsize_t bestfitParticle; \n\tdouble currBestFitVal; \n\t \n \n\tunsigned char computeOK; \n\tsize_t funcCount; \n\t \n \n\tsize_t lpNbrs;  \n \n\tsize_t nNbrs = 3; \n\tsize_t ringNbrs[nNbrs]; \n\tdouble nbrFitVal;  \n \n\tsize_t lbestPart;  \n \n\tdouble lbestFit;  \n \n\t \n \n\tsize_t lpCoord; \n\tgsl_vector *accVecPbest = gsl_vector_alloc(nDim); \n\tgsl_vector *accVecLbest = gsl_vector_alloc(nDim); \n\tgsl_vector *chi1Vec = gsl_vector_alloc(nDim); \n\tgsl_vector *chi2Vec = gsl_vector_alloc(nDim); \n\t \n\t \n \n\tfor (lpPsoIter = 1; lpPsoIter <= maxSteps; lpPsoIter++){ \n\t\t \n \n \n\t\tif (psoParams->debugDumpFile!= NULL){ \n\t\t\tfprintf(psoParams->debugDumpFile,\"Loop %zu \\n\",lpPsoIter); \n\t\t\tparticleInfoDump(psoParams->debugDumpFile,pop,popsize); \n\t\t}\t\t \n         \n \n\t\tfor (lpParticles = 0; lpParticles < popsize; lpParticles++){ \n\t\t\t \n \n\t\t\tpop[lpParticles].partSnrCurr = fitfunc(pop[lpParticles].partCoord,ffParams); \n\t\t\t \n \n\t\t\t \n \n\t\t\tgsl_vector_set(partSnrCurrCol,lpParticles,pop[lpParticles].partSnrCurr); \n\t\t\t \n \n\t        computeOK = ((struct fitFuncParams *)ffParams)->fitEvalFlag[parallel_get_thread_num()]; \n\t        funcCount = 0; \n\t        if (computeOK){ \n\t\t\t     \n \n\t            funcCount = 1; \n\t\t\t} \n\t        pop[lpParticles].partFitEvals += funcCount; \n\t\t\t \n \n\t        if (pop[lpParticles].partSnrPbest > pop[lpParticles].partSnrCurr){ \n\t            pop[lpParticles].partSnrPbest = pop[lpParticles].partSnrCurr; \n \n\t             \n \n\t            gsl_vector_memcpy(pop[lpParticles].partPbest,pop[lpParticles].partCoord); \n\t        } \n\t    } \n\t\t \n\t\t \n \n \n\t\t \n \n\t\tbestfitParticle = gsl_vector_min_index(partSnrCurrCol); \n\t    currBestFitVal = pop[bestfitParticle].partSnrCurr;  \n\t    if (gbestFitVal > currBestFitVal){ \n\t\t \n \n\t\t   \tgsl_multimin_fminimizer_set(minimzrState,&func2minimz, \n\t\t\t                            pop[bestfitParticle].partCoord, \n\t\t\t\t\t\t\t\t\t\tlocMinStp); \n\t\t\tfuncCount = 0; \n\t\t\t \n\t\t\tfor (lpLocMin = 0; lpLocMin < psoParams->locMinIter; lpLocMin++){ \n\t\t\t\tstatus = gsl_multimin_fminimizer_iterate(minimzrState); \n\t\t\t\t   \n \n\t\t\t\tif (status) \n\t\t\t\t\tbreak; \n\t\t\t\t  \n \n\t\t\t\tfuncCount += nDim+1; \n\t\t\t\tpop[bestfitParticle].partSnrCurr = gsl_multimin_fminimizer_minimum(minimzrState); \n                gsl_vector_memcpy(pop[bestfitParticle].partCoord, minimzrState->x); \n\t\t\t} \n\t\t\t \n\t        pop[bestfitParticle].partFitEvals += funcCount; \n\t\t\t \n \n\t\t\tpop[bestfitParticle].partSnrPbest = pop[bestfitParticle].partSnrCurr; \n\t\t\tgsl_vector_memcpy(pop[bestfitParticle].partPbest,pop[bestfitParticle].partCoord); \n\t\t\t \n \n\t\t\tgbestFitVal = pop[bestfitParticle].partSnrCurr; \n\t\t\tgsl_vector_memcpy(gbestCoord,pop[bestfitParticle].partCoord); \n\t\t\t \n \n\t\t\tgsl_vector_set(partSnrCurrCol,bestfitParticle,pop[bestfitParticle].partSnrCurr); \n\t\t} \n\t\t \n\t\t \n \n\t    for (lpParticles = 0; lpParticles < popsize; lpParticles++){ \n\t           if (lpParticles == 0){ \n\t                   ringNbrs[0]=popsize-1; ringNbrs[1]=lpParticles; ringNbrs[2]=lpParticles+1; \n\t\t\t   \t\t} \n\t\t\t   else if (lpParticles == popsize -1){ \n\t\t\t       ringNbrs[0]=lpParticles-1; ringNbrs[1]=lpParticles; ringNbrs[2]=0; \n\t\t\t   \t\t} \n\t\t\t   else{ \n\t\t\t\t   ringNbrs[0]=lpParticles-1; ringNbrs[1]=lpParticles; ringNbrs[2]=lpParticles+1; \n\t\t\t   }\t\t\t\t\t   \n\t\t\t    \n \n\t\t\t   lbestPart = ringNbrs[0]; \n\t\t\t   lbestFit = gsl_vector_get(partSnrCurrCol,lbestPart); \n\t\t\t   for (lpNbrs = 1; lpNbrs < nNbrs; lpNbrs++){ \n\t\t\t\t   nbrFitVal = gsl_vector_get(partSnrCurrCol,ringNbrs[lpNbrs]); \n\t\t\t\t   if (nbrFitVal < lbestFit){ \n\t\t\t\t\t   lbestPart = ringNbrs[lpNbrs]; \n\t\t\t\t\t   lbestFit = nbrFitVal; \n\t\t\t\t   } \n\t\t\t   } \n\t           if (lbestFit < pop[lpParticles].partSnrLbest){ \n\t               pop[lpParticles].partSnrLbest = lbestFit; \n\t               gsl_vector_memcpy", "pred": " \nvoid lbestpso(size_t nDim,  \n \n            fitness_function_ptr fitfunc,  \n \n\t\t\tvoid *ffParams,  \n \n\t\t\tcurrent_result_callback_params_t *callback_params,  \n \n            struct psoParamStruct *psoParams,  \n \n\t\t\tstruct returnData *psoResults  \n){ \n \n\tclock_t time_start = clock(); \n \n\t \n \n\tgsl_rng *rngGen = psoParams->rngGen; \n\t \n\t \n \n\tgsl_multimin_function func2minimz; \n\tfunc2minimz.n = nDim;  \n \n\tfunc2minimz.f = dummyfitfunc; \n \n\tstruct dummyFitFuncParam dffp; \n\tdffp.trufuncPr = fitfunc; \n\tdffp.trufuncParam = ffParams; \n\tfunc2minimz.params = &dffp; \n \n\t \n \n\tgsl_multimin_fminimizer *minimzrState = gsl_multimin_fminimizer_alloc(gsl_multimin_fminimizer_nmsimplex2, nDim); \n\t \n \n\tgsl_vector *x = gsl_vector_alloc(nDim); \n\tgsl_vector *y = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z = gsl_vector_alloc(nDim); \n \n\tgsl_vector *w = gsl_vector_alloc(nDim); \n \n\tgsl_vector *v = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_min = gsl_vector_alloc(nDim); \n\tgsl_vector *y_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_max = gsl_vector_alloc(nDim); \n\tgsl_vector *y_max = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_max = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_min_max = gsl_vector_alloc(nDim); \n\tgsl_vector *y_min_max = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_min_max = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_max_min = gsl_vector_alloc(nDim); \n\tgsl_vector *y_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_min_max_min = gsl_vector_alloc(nDim); \n\tgsl_vector *y_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_max_min_max = gsl_vector_alloc(nDim); \n\tgsl_vector *y_max_min_max = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_max_min_max = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_min_max_min_max = gsl_vector_alloc(nDim); \n\tgsl_vector *y_min_max_min_max = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_min_max_min_max = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_max_min_max_min = gsl_vector_alloc(nDim); \n\tgsl_vector *y_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_min_max_min_max_min = gsl_vector_alloc(nDim); \n\tgsl_vector *y_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n\tgsl_vector *y_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n\tgsl_vector *y_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n\tgsl_vector *y_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n\tgsl_vector *y_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_max_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n\tgsl_vector *y_max_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_max_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_min_max_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n\tgsl_vector *y_min_max_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_min_max_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_max_min_max_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n\tgsl_vector *y_max_min_max_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_max_min_max_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_min_max_min_max_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n\tgsl_vector *y_min_max_min_max_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_min_max_min_max_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_max_min_max_min_max_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n\tgsl_vector *y_max_min_max_min_max_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *z_max_min_max_min_max_min_max_min_max_min_max_min_max_min = gsl_vector_alloc(nDim); \n \n\tgsl_vector *x_min_max_min_max_min_max_"}
{"label": " \nvoid naive2(int M, int N, float *A, \n            int K, float *B, float *C, float *S) \n{ \n\tint m; \n    for (m = 0; m < M; m++) \n    {\tregister int k,n; register float tmp; \n        for (k = 0; k < K; k++) { \n            tmp = 0; \n            for (n = 0; n < N; n++) \n                tmp += A[m * N + n] * B[n * K + k]; \n            C[m * K + k] = tmp; \n        } \n    } \n} ", "pred": " \nvoid naive2(int M, int N, float *A, \n            int K, float *B, float *C, float *S) \n{ \n\tint m; \n    for (m = 0; m < M; m++) \n    {\tregister int k,n; register float tmp; \n        for (k = 0; k < K; k++) { \n            tmp = 0; \n            for (n = 0; n < N; n++) \n                tmp += A[m * N + n] * B[n * K + k]; \n            C[m * K + k] = tmp; \n        } \n    } \n} "}
{"label": " \nint main( int argc,char *argv[] ) \n{ \n    MPI_Comm   comm[ MAX_THREADS ]; \n    int        my_rank, ii, provided; \n    int        num_threads; \n \n    MPI_Init_thread( &argc, &argv, MPI_THREAD_MULTIPLE, &provided ); \n    if ( provided!= MPI_THREAD_MULTIPLE ) { \n        fprintf( stderr, \"Aborting, MPI_THREAD_MULTIPLE is needed...\\n\" ); \n        fflush( stderr ); \n        MPI_Abort( MPI_COMM_WORLD, 1 ); \n    } \n \n    MPI_Comm_rank( MPI_COMM_WORLD, &my_rank ); \n \n    if ( my_rank == 0 ) { \n        if ( argc!= 2 ) { \n            fprintf( stderr, \"Error: %s num_threads\\n\", argv[0] ); \n            fflush( stderr ); \n            MPI_Abort( MPI_COMM_WORLD, 1 ); \n        } \n        num_threads = atoi( argv[1] ); \n        if ( num_threads < 1 ) { \n            fprintf( stderr, \"Error: Input num_threads=%d < 1 \\n\", \n                             num_threads ); \n            fflush( stderr ); \n            MPI_Abort( MPI_COMM_WORLD, 1 ); \n        } \n        if ( num_threads > MAX_THREADS ) { \n            fprintf( stderr, \"Error: Input num_threads=%d < %d \\n\", \n                             num_threads, MAX_THREADS ); \n            fflush( stderr ); \n            MPI_Abort( MPI_COMM_WORLD, 1 ); \n        } \n        MPI_Bcast( &num_threads, 1, MPI_INT, 0, MPI_COMM_WORLD ); \n    } \n    else \n        MPI_Bcast( &num_threads, 1, MPI_INT, 0, MPI_COMM_WORLD ); \n \n    MPI_Barrier( MPI_COMM_WORLD ); \n \n    for ( ii=0; ii < num_threads; ii++ ) { \n        MPI_Comm_dup( MPI_COMM_WORLD, &comm[ii] ); \n    } \n \n    for ( ii=0; ii < num_threads; ii++ ) { \n        thd_sendrecv( (void *) &comm[ii] ); \n    } \n\t \n    MPI_Finalize(); \n    return 0; \n} ", "pred": " \nint main( int argc,char *argv[] ) \n{ \n    MPI_Comm   comm[ MAX_THREADS ]; \n    int        my_rank, ii, provided; \n    int        num_threads; \n \n    MPI_Init_thread( &argc, &argv, MPI_THREAD_MULTIPLE, &provided ); \n    if ( provided!= MPI_THREAD_MULTIPLE ) { \n        fprintf( stderr, \"Aborting, MPI_THREAD_MULTIPLE is needed...\\n\" ); \n        fflush( stderr ); \n        MPI_Abort( MPI_COMM_WORLD, 1 ); \n    } \n \n    MPI_Comm_rank( MPI_COMM_WORLD, &my_rank ); \n \n    if ( my_rank == 0 ) { \n        if ( argc!= 2 ) { \n            fprintf( stderr, \"Error: %s num_threads\\n\", argv[0] ); \n            fflush( stderr ); \n            MPI_Abort( MPI_COMM_WORLD, 1 ); \n        } \n \n        num_threads = atoi( argv[1] ); \n \n        if ( num_threads < 1 ) { \n            fprintf( stderr, \"Error: num_threads must be >= 1\\n\" ); \n            fflush( stderr ); \n            MPI_Abort( MPI_COMM_WORLD, 1 ); \n        } \n \n        if ( num_threads > MAX_THREADS ) { \n            fprintf( stderr, \"Error: num_threads must be <= MAX_THREADS\\n\" ); \n            fflush( stderr ); \n            MPI_Abort( MPI_COMM_WORLD, 1 ); \n        } \n \n        for ( ii = 0; ii < num_threads; ii++ ) { \n            MPI_Comm_split( MPI_COMM_WORLD, ii, comm + ii, 0, &provided ); \n            if ( provided!= MPI_THREAD_MULTIPLE ) { \n                fprintf( stderr, \"Error: MPI_Comm_split returned %d\\n\", provided ); \n                fflush( stderr ); \n                MPI_Abort( MPI_COMM_WORLD, 1 ); \n            } \n        } \n    } \n \n    MPI_Finalize(); \n    return 0; \n} \n\n/*\n * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU"}
{"label": " \ndouble integrate( double (*fn)(double), double a, double b, int n, int t, int print_times) \n{\t \n\t \n \n\t \n\tdouble tstart = 0;  \n \n\tdouble tend = 0;  \n \n\t \n\tdouble h = 0;  \n \n\tdouble curr_x = 0;  \n \n\tdouble sum = 0;  \n \n\tint i;  \n \n\t \n\t \n \n\ttstart = timer(); \n\t \n\t \n \n\th = (b - a) / (double) n; \n \n \n\t \n \n\t \n\t \n \n\t \n\t \n \n\tfor (i = 0; i < n; i++) \n\t{ \n\t\tcurr_x = a + i * h; \n\t\t \n \n\t\tsum += h * ( ( (*fn)(curr_x) + (*fn)(curr_x - h) ) / 2); \n\t} \n\t \n\t \n \n\ttend = timer(); \n\t \n\t \n \n\tif (print_times == PRINT_TIMES) \n\t{ \n\t\tprintf(\"%d, %d, %f\\n\", n, t, tend-tstart); \n\t} \n\t \n\t \n \n\treturn sum; \n} ", "pred": " \ndouble integrate( double (*fn)(double), double a, double b, int n, int t, int print_times) \n{\t \n\t \n \n\t \n\tdouble tstart = 0;  \n \n\tdouble tend = 0;  \n \n\t \n\tdouble h = 0;  \n \n\tdouble curr_x = 0;  \n \n\tdouble sum = 0;  \n \n\tint i;  \n \n\t \n\t \n \n\ttstart = timer(); \n\t \n\t \n \n\th = (b - a) / (double) n; \n \n \n\t \n \n\t \n\t \n \n\t \n\t \n \n\tfor (i = 0; i < n; i++) \n\t{ \n\t\tcurr_x = a + i * h; \n\t\t \n \n\t\tsum += h * ( ( (*fn)(curr_x) + (*fn)(curr_x - h) ) / 2); \n\t} \n\t \n\t \n \n\ttend = timer(); \n\t \n\t \n \n\tif (print_times == PRINT_TIMES) \n\t{ \n\t\tprintf(\"%d, %d, %f\\n\", n, t, tend-tstart); \n\t} \n\t \n\t \n \n\treturn sum; \n} "}
{"label": " \nMagickExport Image *SepiaToneImage(const Image *image,const double threshold, \n  ExceptionInfo *exception) \n{ \n#define SepiaToneImageTag  \"SepiaTone/Image\" \n \n  CacheView \n    *image_view, \n    *sepia_view; \n \n  Image \n    *sepia_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  sepia_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (sepia_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(sepia_image,DirectClass,exception) == MagickFalse) \n    { \n      sepia_image=DestroyImage(sepia_image); \n      return((Image *) NULL); \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  sepia_view=AcquireAuthenticCacheView(sepia_image,exception); \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    register const Quantum \n      *restrict p; \n \n    register ssize_t \n      x; \n \n    register Quantum \n      *restrict q; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    q=GetCacheViewAuthenticPixels(sepia_view,0,y,sepia_image->columns,1, \n      exception); \n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      double \n        intensity, \n        tone; \n \n      intensity=GetPixelIntensity(image,p); \n      tone=intensity > threshold? (double) QuantumRange : intensity+ \n        (double) QuantumRange-threshold; \n      SetPixelRed(sepia_image,ClampToQuantum(tone),q); \n      tone=intensity > (7.0*threshold/6.0)? (double) QuantumRange : \n        intensity+(double) QuantumRange-7.0*threshold/6.0; \n      SetPixelGreen(sepia_image,ClampToQuantum(tone),q); \n      tone=intensity < (threshold/6.0)? 0 : intensity-threshold/6.0; \n      SetPixelBlue(sepia_image,ClampToQuantum(tone),q); \n      tone=threshold/7.0; \n      if ((double) GetPixelGreen(image,q) < tone) \n        SetPixelGreen(sepia_image,ClampToQuantum(tone),q); \n      if ((double) GetPixelBlue(image,q) < tone) \n        SetPixelBlue(sepia_image,ClampToQuantum(tone),q); \n      SetPixelAlpha(sepia_image,GetPixelAlpha(image,p),q); \n      p+=GetPixelChannels(image); \n      q+=GetPixelChannels(sepia_image); \n    } \n    if (SyncCacheViewAuthenticPixels(sepia_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        proceed=SetImageProgress(image,SepiaToneImageTag,progress++, \n          image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  } \n  sepia_view=DestroyCacheView(sepia_view); \n  image_view=DestroyCacheView(image_view); \n  (void) NormalizeImage(sepia_image,exception); \n  (void) ContrastImage(sepia_image,MagickTrue,exception); \n  if (status == MagickFalse) \n    sepia_image=DestroyImage(sepia_image); \n  return(sepia_image); \n} ", "pred": " \nMagickExport Image *SepiaToneImage(const Image *image,const double threshold, \n  ExceptionInfo *exception) \n{ \n#define SepiaToneImageTag  \"SepiaTone/Image\" \n \n  CacheView \n    *image_view, \n    *sepia_view; \n \n  Image \n    *sepia_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  sepia_image=CloneImage(image,0,0,MagickTrue,exception); \n  if (sepia_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(sepia_image,DirectClass,exception) == MagickFalse) \n    { \n      sepia_image=DestroyImage(sepia_image); \n      return((Image *) NULL); \n    } \n  sepia_image->alpha_trait=BlendPixelTrait; \n  sepia_image->depth=8; \n  sepia_image->storage_class=DirectClass; \n  sepia_image->colors=0; \n  sepia_image->colors=0; \n  sepia_image->colorspace=sRGBColorspace; \n  sepia_image->alpha_trait=BlendPixelTrait; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image->page.width=sepia_image->page.height=1; \n  sepia_image->page.x=sepia_image->page.y=0; \n  sepia_image"}
{"label": " \nvoid __attribute((noinline)) cholesky_in_place(int N, float (*a)[N]) \n{ \n    float a_jj = 0.0f; \n \n    __assume(N%16==0); \n \n{    \n    for (int j = 0; j < N; j++) \n    { \n \n        for (int i1 = j + 1; i1 < N; i1++) \n        { \n            int k; \n            float a_ij = a[i1][j]; \n \n            for (k = 0; k < j; k++) \n            { \n                a_ij -=  a[i1][k] * a[j][k]; \n            } \n \n            a[i1][j] = a_ij; \n        } \n \n        { \n            a_jj = a[j][j]; \n        } \n \n        int i2; \n \n        for (i2 = 0; i2 < j; i2++) \n        { \n            float tmp = a[j][i2]; \n            a_jj -= tmp * tmp; \n        } \n \n        float local_a_jj = sqrtf(a_jj); \n \n        { \n            a[j][j] = local_a_jj; \n        } \n \n        int i3; \n \n        for (i3 = j + 1; i3 < N; i3++) \n        { \n            a[i3][j] = a[i3][j] / local_a_jj; \n        } \n    } \n} \n} ", "pred": " \nvoid __attribute((noinline)) cholesky_in_place(int N, float (*a)[N]) \n{ \n    float a_jj = 0.0f; \n \n    __assume(N%16==0); \n \n{    \n    for (int j = 0; j < N; j++) \n    { \n \n        for (int i1 = j + 1; i1 < N; i1++) \n        { \n            int k; \n            float a_ij = a[i1][j]; \n \n            for (k = 0; k < j; k++) \n            { \n                a_ij -=  a[i1][k] * a[j][k]; \n            } \n \n            a[i1][j] = a_ij; \n        } \n \n        { \n            float a_ij = a[j][j]; \n            for (k = 0; k < j; k++) \n            { \n                a_ij -=  a[j][k] * a[i1][k]; \n            } \n \n            a[j][j] = a_ij; \n        } \n \n        a_jj += a[j][j]; \n    } \n \n    a_jj = sqrtf(a_jj); \n    a_jj = a_jj * a_jj; \n    a_jj = a_jj * a_jj; \n    a_jj = a_jj * a_jj; \n    a_jj = a_jj * a_jj; \n    a_jj = a_jj * a_jj; \n    a_jj = a_jj * a_jj; \n    a_jj = a_jj * a_jj; \n    a"}
{"label": " \nMagickExport Image *SwirlImage(const Image *image,double degrees, \n  const PixelInterpolateMethod method,ExceptionInfo *exception) \n{ \n#define SwirlImageTag  \"Swirl/Image\" \n \n  CacheView \n    *image_view, \n    *interpolate_view, \n    *swirl_view; \n \n  Image \n    *swirl_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  double \n    radius; \n \n  PointInfo \n    center, \n    scale; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  swirl_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if (swirl_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(swirl_image,DirectClass,exception) == MagickFalse) \n    { \n      swirl_image=DestroyImage(swirl_image); \n      return((Image *) NULL); \n    } \n  if (swirl_image->background_color.alpha!= OpaqueAlpha) \n    swirl_image->alpha_trait=BlendPixelTrait; \n   \n \n  center.x=(double) image->columns/2.0; \n  center.y=(double) image->rows/2.0; \n  radius=MagickMax(center.x,center.y); \n  scale.x=1.0; \n  scale.y=1.0; \n  if (image->columns > image->rows) \n    scale.y=(double) image->columns/(double) image->rows; \n  else \n    if (image->columns < image->rows) \n      scale.x=(double) image->rows/(double) image->columns; \n  degrees=(double) DegreesToRadians(degrees); \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  interpolate_view=AcquireVirtualCacheView(image,exception); \n  swirl_view=AcquireAuthenticCacheView(swirl_image,exception); \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    double \n      distance; \n \n    PointInfo \n      delta; \n \n    register const Quantum \n      *restrict p; \n \n    register ssize_t \n      x; \n \n    register Quantum \n      *restrict q; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    q=QueueCacheViewAuthenticPixels(swirl_view,0,y,swirl_image->columns,1, \n      exception); \n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    delta.y=scale.y*(double) (y-center.y); \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n       \n \n      if (GetPixelReadMask(image,p) == 0) \n        { \n          SetPixelBackgoundColor(swirl_image,q); \n          p+=GetPixelChannels(image); \n          q+=GetPixelChannels(swirl_image); \n          continue; \n        } \n      delta.x=scale.x*(double) (x-center.x); \n      distance=delta.x*delta.x+delta.y*delta.y; \n      if (distance >= (radius*radius)) \n        { \n          register ssize_t \n            i; \n \n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n          { \n            PixelChannel channel=GetPixelChannelChannel(image,i); \n            PixelTrait traits=GetPixelChannelTraits(image,channel); \n            PixelTrait swirl_traits=GetPixelChannelTraits(swirl_image,channel); \n            if ((traits == UndefinedPixelTrait) || \n                (swirl_traits == UndefinedPixelTrait)) \n              continue; \n            SetPixelChannel(swirl_image,channel,p[i],q); \n          } \n        } \n      else \n        { \n          double \n            cosine, \n            factor, \n            sine; \n \n           \n \n          factor=1.0-sqrt((double) distance)/radius; \n          sine=sin((double) (degrees*factor*factor)); \n          cosine=cos((double) (degrees*factor*factor)); \n          status=InterpolatePixelChannels(image,interpolate_view,swirl_image, \n            method,((cosine*delta.x-sine*delta.y)/scale.x+center.x),(double) \n            ((sine*delta.x+cosine*delta.y)/scale.y+center.y),q,exception); \n        } \n      p+=GetPixelChannels(image); \n      q+=GetPixelChannels(swirl_image); \n    } \n    if (SyncCacheViewAuthenticPixels(swirl_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        proceed=SetImageProgress(image,SwirlImageTag,progress++,image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  } \n  swirl_view=DestroyCacheView(swirl_view); \n  interpolate_view=DestroyCacheView(interpolate_view); \n  image_view=DestroyCacheView(image_view); \n  if (status == MagickFalse) \n    swirl_image=DestroyImage(swirl_image); \n  return(swirl_image); \n} ", "pred": " \nMagickExport Image *SwirlImage(const Image *image,double degrees, \n  const PixelInterpolateMethod method,ExceptionInfo *exception) \n{ \n#define SwirlImageTag  \"Swirl/Image\" \n \n  CacheView \n    *image_view, \n    *interpolate_view, \n    *swirl_view; \n \n  Image \n    *swirl_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  double \n    radius; \n \n  PointInfo \n    center, \n    scale; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  swirl_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if (swirl_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(swirl_image,DirectClass,exception) == MagickFalse) \n    {\n      swirl_image=DestroyImage(swirl_image);\n      return((Image *) NULL);\n    } \n  /*\n    Initialize swirl image.\n  */\n  swirl_image->columns=image->columns;\n  swirl_image->rows=image->rows;\n  swirl_image->depth=image->depth;\n  swirl_image->alpha_trait=image->alpha_trait;\n  swirl_image->storage_class=image->storage_class;\n  swirl_image->colors=image->colors;\n  swirl_image->colorspace=image->colorspace;\n  swirl_image->alpha_trait=image->alpha_trait;\n  swirl_image->ping=image->ping;\n  swirl_image->background_color=image->background_color;\n  swirl_image->border_color=image->border_color;\n  swirl_image->exception=exception;\n  swirl_image->signature=MagickCoreSignature; \n  swirl_image->endian=image->endian;\n  swirl_image->page=image->page;\n  swirl_image->page.x=0;\n  swirl_image->page.y=0;\n  swirl_image->page.width=image->columns;\n  swirl_image->page.height=image->rows;\n  swirl_image->page.x=(ssize_t) (image->columns-swirl_image->page.x);\n  swirl_image->page.y=(ssize_t) (image->rows-swirl_image->page.y);\n  swirl_image->page.width=swirl_image->page.width;\n  swirl_image->page.height=swirl_image->page.height;\n  swirl_image->page.x=swirl_image->page.x;\n  swirl_image->page.y=swirl_image->page.y;\n  swirl_image->page.width=swirl_image->page.width;\n  swirl_image->page.height=swirl_image->page.height;\n  swirl_image->page.x=swirl_image->page.x;\n  swirl_image->page.y=swirl_image->page.y;\n  swirl_image->page.width=swirl_image->page.width;\n  swirl_image->page.height=swirl_image->page.height;\n  swirl_image->page.x=swirl_image->page.x;\n  swirl_image->page.y=swirl_image->page.y;\n  swirl_image->page.width=swirl_image->page.width;\n  swirl_image->page.height=swirl_image->page.height;\n  swirl_image->page.x=swirl_image->page.x;\n  swirl_image->page.y=swirl_image->page.y;\n  swirl_image->page.width=swirl_image->page.width;\n  swirl_image->page.height=swirl_image->page.height;\n  swirl_image->page.x=swirl_image->page.x;\n  swirl_image->page.y=swirl_image->page.y;\n  swirl_image->page.width=swirl_image->page.width;\n  swirl_image->page.height=swirl_image->page.height;\n  swirl_image->page.x=swirl_image->page.x;\n  swirl_image->page.y=swirl_image->page.y;\n  swirl_image->page.width=swirl_image->page.width;\n  swirl_image->page.height=swirl_image->page.height;\n  swirl_image->page.x=swirl_image->page.x;\n  swirl_image->page.y=swirl_image->page.y;\n  swirl_image->page.width=swirl_image->page.width;\n  swirl_image->page.height=swirl_image->page.height;\n  swirl_image->page.x=swirl_image->page.x;\n  swirl_image->page.y=swirl_image->page.y;\n  swirl_image->page.width=swirl_image->page.width;\n  swirl_image->page.height=swirl_image->page.height;\n  swirl_image->page.x=swirl_image->page.x;\n  swirl_image->page.y=swirl_image->page.y;\n  swirl_image->page.width=swirl_image->page.width;\n  swirl_image->page.height=swirl_image->page.height;\n  swirl_image->page.x=swirl_image->page.x;\n  swirl_image->page.y=swirl_image->page.y;\n  swirl_image->page.width=swirl_image->page.width;\n  swirl_image->page.height=swirl_image->page.height;\n  swirl_image->page.x=swirl_image->page.x;\n  swirl_image->page.y=swirl_image->page.y;\n  swirl_image->page.width=swirl_image->page.width;\n  swirl_image->page.height=swirl_image->page.height;\n  swirl_image->page.x=swirl_image->page.x;\n  swirl_image->page.y=swirl_image->page.y;\n  swirl_image->page.width=swirl_image->page.width;\n  swirl_image->page.height=swirl_image->page.height;\n  swirl_image->page.x=swirl_image->page.x;\n  swirl_image->page.y=swirl_image->page.y;\n  swirl_image->page.width=swirl_image->page.width;\n  swirl_image->page.height=swirl_image->page.height;\n  swirl_image->page.x=swirl_image->page.x;\n  swirl_image->page.y=swirl_image->page.y;\n  swirl_image->page.width=swirl_image->page.width;\n  swirl_image->page.height=swirl_image->page.height;\n  swirl_image->page.x=swirl_image->page.x;\n  swirl_image->page.y=swirl_image->page.y;\n  swirl_image->page.width=swirl_image"}
{"label": " \nvoid process_sse2(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const uint16_t *in = ((uint16_t *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      float *out = ((float *)ovoid) + (size_t)roi_out->width * j; \n \n      int i = 0; \n \n       \n \n      while((!dt_is_aligned(in, 16) ||!dt_is_aligned(out, 16)) && (i < roi_out->width)) \n      { \n        const int id = BL(roi_out, d, j, i); \n        *out = (((float)(*in)) - d->sub[id]) / d->div[id]; \n        i++; \n        in++; \n        out++; \n      } \n \n      const __m128 sub = _mm_set_ps(d->sub[BL(roi_out, d, j, i + 3)], d->sub[BL(roi_out, d, j, i + 2)], \n                                    d->sub[BL(roi_out, d, j, i + 1)], d->sub[BL(roi_out, d, j, i)]); \n \n      const __m128 div = _mm_set_ps(d->div[BL(roi_out, d, j, i + 3)], d->div[BL(roi_out, d, j, i + 2)], \n                                    d->div[BL(roi_out, d, j, i + 1)], d->div[BL(roi_out, d, j, i)]); \n \n       \n \n      for(; i < roi_out->width - (8 - 1); i += 8, in += 8) \n      { \n        const __m128i input = _mm_load_si128((__m128i *)in); \n \n        __m128i ilo = _mm_unpacklo_epi16(input, _mm_set1_epi16(0)); \n        __m128i ihi = _mm_unpackhi_epi16(input, _mm_set1_epi16(0)); \n \n        __m128 flo = _mm_cvtepi32_ps(ilo); \n        __m128 fhi = _mm_cvtepi32_ps(ihi); \n \n        flo = _mm_div_ps(_mm_sub_ps(flo, sub), div); \n        fhi = _mm_div_ps(_mm_sub_ps(fhi, sub), div); \n \n        _mm_stream_ps(out, flo); \n        out += 4; \n        _mm_stream_ps(out, fhi); \n        out += 4; \n      } \n \n       \n \n      for(; i < roi_out->width; i++, in++, out++) \n      { \n        const int id = BL(roi_out, d, j, i); \n        *out = (((float)(*in)) - d->sub[id]) / d->div[id]; \n      } \n    } \n \n    piece->pipe->dsc.filters = dt_rawspeed_crop_dcraw_filters(self->dev->image_storage.buf_dsc.filters, csx, csy); \n    adjust_xtrans_filters(piece->pipe, csx, csy); \n  } \n  else \n  {  \n \n \n    const __m128 sub = _mm_load_ps(d->sub), div = _mm_load_ps(d->div); \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const float *in = ((float *)ivoid) + (size_t)4 * (roi_in->width * (j + csy) + csx); \n      float *out = ((float *)ovoid) + (size_t)4 * roi_out->width * j; \n \n       \n \n      for(int i = 0; i < roi_out->width; i++, in += 4, out += 4) \n      { \n        const __m128 input = _mm_load_ps(in); \n \n        const __m128 scaled = _mm_div_ps(_mm_sub_ps(input, sub), div); \n \n        _mm_stream_ps(out, scaled); \n      } \n    } \n  } \n \n  for(int k = 0; k < 4; k++) piece->pipe->dsc.processed_maximum[k] = 1.0f; \n \n  _mm_sfence(); \n} ", "pred": " \nvoid process_sse2(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid, \n                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out) \n{ \n  const dt_iop_rawprepare_data_t *const d = (dt_iop_rawprepare_data_t *)piece->data; \n \n   \n \n   \n \n \n  const int csx = compute_proper_crop(piece, roi_in, d->x), csy = compute_proper_crop(piece, roi_in, d->y); \n \n  if(piece->pipe->dsc.filters) \n  {  \n \n    for(int j = 0; j < roi_out->height; j++) \n    { \n      const uint16_t *in = ((uint16_t *)ivoid) + ((size_t)roi_in->width * (j + csy) + csx); \n      float *out = ((float *)ovoid) + (size_t)roi_out->width * j; \n      for(int i = 0; i < roi_out->width; i++) \n      { \n        const float *in_ = in + i; \n        float *out_ = out + i; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *in_; \n        *out_ = *"}
{"label": " \nMagickExport Image *TintImage(const Image *image,const char *blend, \n  const PixelInfo *tint,ExceptionInfo *exception) \n{ \n#define TintImageTag  \"Tint/Image\" \n \n  CacheView \n    *image_view, \n    *tint_view; \n \n  double \n    intensity; \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *tint_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PixelInfo \n    color_vector; \n \n  MagickStatusType \n    flags; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  tint_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if (tint_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(tint_image,DirectClass,exception) == MagickFalse) \n    { \n      tint_image=DestroyImage(tint_image); \n      return((Image *) NULL); \n    } \n  if ((IsGrayColorspace(image->colorspace)!= MagickFalse) && \n      (IsPixelInfoGray(tint) == MagickFalse)) \n    (void) SetImageColorspace(tint_image,sRGBColorspace,exception); \n  if (blend == (const char *) NULL) \n    return(tint_image); \n   \n \n  GetPixelInfo(image,&color_vector); \n  flags=ParseGeometry(blend,&geometry_info); \n  color_vector.red=geometry_info.rho; \n  color_vector.green=geometry_info.rho; \n  color_vector.blue=geometry_info.rho; \n  color_vector.alpha=(MagickRealType) OpaqueAlpha; \n  if ((flags & SigmaValue)!= 0) \n    color_vector.green=geometry_info.sigma; \n  if ((flags & XiValue)!= 0) \n    color_vector.blue=geometry_info.xi; \n  if ((flags & PsiValue)!= 0) \n    color_vector.alpha=geometry_info.psi; \n  if (image->colorspace == CMYKColorspace) \n    { \n      color_vector.black=geometry_info.rho; \n      if ((flags & PsiValue)!= 0) \n        color_vector.black=geometry_info.psi; \n      if ((flags & ChiValue)!= 0) \n        color_vector.alpha=geometry_info.chi; \n    } \n  intensity=(double) GetPixelInfoIntensity(image,tint); \n  color_vector.red=(double) (color_vector.red*tint->red/100.0-intensity); \n  color_vector.green=(double) (color_vector.green*tint->green/100.0-intensity); \n  color_vector.blue=(double) (color_vector.blue*tint->blue/100.0-intensity); \n  color_vector.black=(double) (color_vector.black*tint->black/100.0-intensity); \n  color_vector.alpha=(double) (color_vector.alpha*tint->alpha/100.0-intensity); \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  tint_view=AcquireAuthenticCacheView(tint_image,exception); \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    register const Quantum \n      *restrict p; \n \n    register Quantum \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    q=QueueCacheViewAuthenticPixels(tint_view,0,y,tint_image->columns,1, \n      exception); \n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      PixelInfo \n        pixel; \n \n      double \n        weight; \n \n      register ssize_t \n        i; \n \n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n      { \n        PixelChannel channel=GetPixelChannelChannel(image,i); \n        PixelTrait traits=GetPixelChannelTraits(image,channel); \n        PixelTrait tint_traits=GetPixelChannelTraits(tint_image,channel); \n        if ((traits == UndefinedPixelTrait) || \n            (tint_traits == UndefinedPixelTrait)) \n          continue; \n        if (((tint_traits & CopyPixelTrait)!= 0) || \n            (GetPixelReadMask(image,p) == 0)) \n          { \n            SetPixelChannel(tint_image,channel,p[i],q); \n            continue; \n          } \n      } \n      GetPixelInfo(image,&pixel); \n      weight=QuantumScale*GetPixelRed(image,p)-0.5; \n      pixel.red=(double) GetPixelRed(image,p)+color_vector.red*(1.0-(4.0* \n        (weight*weight))); \n      weight=QuantumScale*GetPixelGreen(image,p)-0.5; \n      pixel.green=(double) GetPixelGreen(image,p)+color_vector.green*(1.0-(4.0* \n        (weight*weight))); \n      weight=QuantumScale*GetPixelBlue(image,p)-0.5; \n      pixel.blue=(double) GetPixelBlue(image,p)+color_vector.blue*(1.0-(4.0* \n        (weight*weight))); \n      weight=QuantumScale*GetPixelBlack(image,p)-0.5; \n      pixel.black=(double) GetPixelBlack(image,p)+color_vector.black*(1.0-(4.0* \n        (weight*weight))); \n      SetPixelViaPixelInfo(tint_image,&pixel,q); \n      p+=GetPixelChannels(image); \n      q+=GetPixelChannels(tint_image); \n    } \n    if (SyncCacheViewAuthenticPixels(tint_view,exception) == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        proceed=SetImageProgress(image,TintImageTag,progress++,image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  } \n  tint_view=DestroyCacheView(tint_view); \n  image_view=DestroyCacheView(image_view); \n  if (status == MagickFalse) \n", "pred": " \nMagickExport Image *TintImage(const Image *image,const char *blend, \n  const PixelInfo *tint,ExceptionInfo *exception) \n{ \n#define TintImageTag  \"Tint/Image\" \n \n  CacheView \n    *image_view, \n    *tint_view; \n \n  double \n    intensity; \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *tint_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  PixelInfo \n    color_vector; \n \n  MagickStatusType \n    flags; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  tint_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if (tint_image == (Image *) NULL) \n    return((Image *) NULL);\n  if (blend!= (const char *) NULL)\n    (void) SetImageProperty(tint_image,\"blend\",blend);\n  if (tint!= (const PixelInfo *) NULL)\n    {\n      flags=ParseGeometry(tint,&geometry_info);\n      if ((flags & RhoValue) == 0)\n        {\n          (void) SetImageProperty(tint_image,\"geometry\",geometry_info.rho,\n            exception);\n          (void) SetImageProperty(tint_image,\"sigma\",geometry_info.sigma,\n            exception);\n          (void) SetImageProperty(tint_image,\"xi\",geometry_info.xi,exception);\n          (void) SetImageProperty(tint_image,\"sigma\",geometry_info.sigma,\n            exception);\n          (void) SetImageProperty(tint_image,\"xi\",geometry_info.xi,exception);\n        }\n      if ((flags & SigmaValue) == 0)\n        {\n          (void) SetImageProperty(tint_image,\"sigma\",geometry_info.sigma,\n            exception);\n          (void) SetImageProperty(tint_image,\"xi\",geometry_info.xi,exception);\n        }\n      if ((flags & XiValue) == 0)\n        {\n          (void) SetImageProperty(tint_image,\"xi\",geometry_info.xi,exception);\n        }\n      if ((flags & RhoValue) == 0)\n        {\n          (void) SetImageProperty(tint_image,\"rho\",geometry_info.rho,exception);\n        }\n      if ((flags & SigmaValue) == 0)\n        {\n          (void) SetImageProperty(tint_image,\"sigma\",geometry_info.sigma,\n            exception);\n        }\n      if ((flags & XiValue) == 0)\n        {\n          (void) SetImageProperty(tint_image,\"xi\",geometry_info.xi,exception);\n        }\n    }\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    progress);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgressMonitor) NULL);\n  (void) SetImageProgressMonitor(tint_image,GetMagickModule(),\n    (MagickProgress"}
{"label": " \nvoid THNN_(SpatialConvolutionMM_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput, \n          THTensor *weight, \n          THTensor *finput, \n          THTensor *fgradInput, \n          int kW, \n          int kH, \n          int dW, \n          int dH, \n          int padW, \n          int padH) \n{ \n  long nOutputPlane = weight->size[0]; \n \n  THArgCheck( nOutputPlane == gradOutput->size[input->nDimension == 4? 1 : 0], 3, \"Number of output features is not equal to nOutputPlane\" ); \n  THArgCheck(kW > 0 && kH > 0, 9, \"kernel size should be greater than zero\"); \n  THArgCheck(dW > 0 && dH > 0, 11, \"stride should be greater than zero\"); \n \n  THTensor_(resizeAs)(gradInput, input); \n  THTensor_(resizeAs)(fgradInput, finput); \n  THTensor_(transpose)(weight, weight, 0, 1); \n \n  if(input->nDimension == 3) \n  { \n    THNN_(SpatialConvolutionMM_updateGradInput_frame)(gradInput, gradOutput, weight, fgradInput, kW, kH, dW, dH, padW, padH); \n  } \n  else \n  { \n    long T = input->size[0]; \n    long t; \n \n    for(t = 0; t < T; t++) \n    { \n      THTensor *gradInput_t = THTensor_(newSelect)(gradInput, 0, t); \n      THTensor *gradOutput_t = THTensor_(newSelect)(gradOutput, 0, t); \n      THTensor *fgradInput_t = THTensor_(newSelect)(fgradInput, 0, t); \n \n      THNN_(SpatialConvolutionMM_updateGradInput_frame)(gradInput_t, gradOutput_t, weight, fgradInput_t, kW, kH, dW, dH, padW, padH); \n \n      THTensor_(free)(gradInput_t); \n      THTensor_(free)(gradOutput_t); \n      THTensor_(free)(fgradInput_t); \n    } \n  } \n \n  THTensor_(transpose)(weight, weight, 0, 1); \n} ", "pred": " \nvoid THNN_(SpatialConvolutionMM_updateGradInput)( \n          THNNState *state, \n          THTensor *input, \n          THTensor *gradOutput, \n          THTensor *gradInput, \n          THTensor *weight, \n          THTensor *finput, \n          THTensor *fgradInput, \n          int kW, \n          int kH, \n          int dW, \n          int dH, \n          int padW, \n          int padH) \n{ \n  long nOutputPlane = weight->size[0]; \n \n  THArgCheck( nOutputPlane == gradOutput->size[input->nDimension == 4? 1 : 0], 3, \"Number of output features is not equal to nOutputPlane\" ); \n  THArgCheck(kW > 0 && kH > 0, 9, \"kernel size should be greater than zero\"); \n  THArgCheck(dW > 0 && dH > 0, 9, \"kernel size should be greater than zero\"); \n  THArgCheck(padW > 0 && padH > 0, 9, \"padding size should be greater than zero\"); \n \n  int nInputPlane = input->size[0]; \n  int nOutputPlane = gradOutput->size[input->nDimension == 4? 1 : 0]; \n  int nInputPlane = gradInput->size[0]; \n  int nOutputPlane = gradOutput->size[input->nDimension == 4? 1 : 0]; \n  int nInputPlane = gradInput->size[0]; \n  int nOutputPlane = gradOutput->size[input->nDimension == 4? 1 : 0]; \n  int nInputPlane = gradInput->size[0]; \n  int nOutputPlane = gradOutput->size[input->nDimension == 4? 1 : 0]; \n  int nInputPlane = gradInput->size[0]; \n  int nOutputPlane = gradOutput->size[input->nDimension == 4? 1 : 0]; \n  int nInputPlane = gradInput->size[0]; \n  int nOutputPlane = gradOutput->size[input->nDimension == 4? 1 : 0]; \n  int nInputPlane = gradInput->size[0]; \n  int nOutputPlane = gradOutput->size[input->nDimension == 4? 1 : 0]; \n  int nInputPlane = gradInput->size[0]; \n  int nOutputPlane = gradOutput->size[input->nDimension == 4? 1 : 0]; \n  int nInputPlane = gradInput->size[0]; \n  int nOutputPlane = gradOutput->size[input->nDimension == 4? 1 : 0]; \n  int nInputPlane = gradInput->size[0]; \n  int nOutputPlane = gradOutput->size["}
{"label": " \nstatic int \nmom_gauge_spatial( struct site *__restrict A, \n\t\t   const lie_field_def def ) \n{ \n  size_t i ;  \n \n   \n \n  void (*log)( GLU_complex Q[ NCNC ], \n\t       const GLU_complex U[ NCNC ] ) ; \n  log = Hermitian_proj ; \n  switch( def ) { \n  case LOG_DEF :  \n    log = exact_log_slow ;  \n    break ; \n  case LINEAR_DEF : \n    break ; \n  } \n \n  for( i = 0 ; i < LVOLUME ; i++ ) { \n    GLU_complex temp[ NCNC ] ; \n    size_t mu ; \n    for( mu = 0 ; mu < ND ; mu++ ) { \n      log( temp, A[i].O[mu] ) ; \n      equiv( A[i].O[mu], temp ) ; \n    } \n  } \n \n   \n \n  struct fftw_small_stuff FFTW ; \n  small_create_plans_DFT( &FFTW, Latt.dims, ND-1 ) ; \n \n   \n \n   \n   \n \n  size_t t ; \n  for( t = 0 ; t < Latt.dims[ ND - 1 ] ; t++ )  { \n    const size_t slice = LCU *t ; \n    size_t mu, i, j ;  \n     \n \n    for( mu = 0 ; mu < ND ; mu++ ) \n      for( j = 0 ; j < NCNC ; j++ ) { \n\t \n \n        for( i = 0 ; i < LCU ; i++ ) { \n\t  FFTW.in[i] = A[ slice + i ].O[mu][j] ;  \n\t} \n\tfftw_execute( FFTW.forward ) ;  \n        for( i = 0 ; i < LCU ; i++ ) { \n\t  A[ slice + i ].O[mu][j] = FFTW.out[i] ;  \n\t} \n\t \n \n        for( i = 0 ; i < LCU ; i++ ) { \n\t  FFTW.out[i] = A[ slice + i ].O[mu][j] ;  \n\t} \n\tfftw_execute( FFTW.backward ) ;  \n        for( i = 0 ; i < LCU ; i++ ) { \n\t  A[ slice + i ].O[mu][j] = FFTW.in[i] ;  \n\t} \n      } \n  } \n \n   \n \n   \n \n  small_clean_up_fftw( FFTW ) ; \n \n  return GLU_SUCCESS ; \n} ", "pred": " \nstatic int \nmom_gauge_spatial( struct site *__restrict A, \n\t\t   const lie_field_def def ) \n{ \n  size_t i ;  \n \n   \n \n  void (*log)( GLU_complex Q[ NCNC ], \n\t       const GLU_complex U[ NCNC ] ) ; \n  log = Hermitian_proj ; \n  switch( def ) { \n  case LOG_DEF :  \n    log = exact_log_slow ;  \n    break ; \n  case LINEAR_DEF : \n    break ; \n  } \n \n  for( i = 0 ; i < LVOLUME ; i++ ) { \n    GLU_complex temp[ NCNC ] ; \n    size_t mu ; \n    for( mu = 0 ; mu < ND ; mu++ ) { \n      log( temp, A[i].O[mu] ) ; \n      equiv( A[i].O[mu], temp ) ; \n    } \n  } \n \n   \n \n  struct fftw_small_stuff FFTW ; \n  small_create_plans_DFT( &FFTW, Latt.dims, ND-1 ) ; \n \n   \n \n  for( i = 0 ; i < LVOLUME ; i++ ) { \n    FFTW.A[i] = A[i].O ; \n    FFTW.U[i] = A[i].U ; \n  } \n \n  FFTW.N = Lvolume ; \n  FFTW.M = Lvolume ; \n  FFTW.L = Lvolume ; \n  FFTW.K = Lvolume ; \n  FFTW.D = Lvolume ; \n  FFTW.P = Lvolume ; \n  FFTW.Q = Lvolume ; \n  FFTW.R = Lvolume ; \n  FFTW.S = Lvolume ; \n  FFTW.T = Lvolume ; \n  FFTW.U = Lvolume ; \n  FFTW.V = Lvolume ; \n  FFTW.W = Lvolume ; \n  FFTW.X = Lvolume ; \n  FFTW.Y = Lvolume ; \n  FFTW.Z = Lvolume ; \n  FFTW.D_inv = Lvolume ; \n  FFTW.P_inv = Lvolume ; \n  FFTW.Q_inv = Lvolume ; \n  FFTW.R_inv = Lvolume ; \n  FFTW.S_inv = Lvolume ; \n  FFTW.T_inv = Lvolume ; \n  FFTW.U_inv = Lvolume ; \n  FFTW.V_inv = Lvolume ; \n  FFTW.W_inv = Lvolume ; \n  FFTW.X_inv = Lvolume ; \n  FFTW.Y_inv = Lvolume ; \n  FFTW.Z_inv = Lvolume ; \n  FFTW.D_inv_inv = Lvolume ; \n  FFTW.P_inv_inv = Lvolume ; \n  FFTW."}
{"label": " \nvoid cawfl3(camoperator3d weop, \n\t    cub3d cub, \n\t    cam3d cam, \n\t    tap3d tap, \n\t    slo3d slo, \n\t    bool  inv    \n,  \n\t    sf_fslice data  \n, \n\t    sf_fslice wfld  \n) \n \n \n{ \n    int imz,iw; \n    sf_complex w; \n    int ompith=0; \n     \n    for (iw=0; iw<cub->aw.n; iw++) { \n\tompith=omp_get_thread_num(); \n \n\tif(inv) {  \n \n\t    w = sf_cmplx(cub->eps*cub->aw.d,+(cub->aw.o+iw*cub->aw.d));  \n \n\t     \n\t    sf_fslice_get(data,iw,weop->ww[ompith][0][0]); \n\t    taper3d(weop->ww[ompith],tap); \n\t    sf_fslice_put(wfld,iw*cub->amz.n+cub->amz.n-1,weop->ww[ompith][0][0]); \n \n\t    sf_fslice_get(slo->slice,cub->amz.n-1,slo->so[ompith][0]); \n\t    for (imz=cub->amz.n-1; imz>0; imz--) { \n\t\tif(cub->verb) sf_warning (\"(ith=%d)... <iw=%3d of %3d> <iz=%3d of %3d>\", \n\t\t\t\t\t  ompith,iw+1,cub->aw.n,imz+1,cub->amz.n); \n \n\t\tsf_fslice_get(slo->slice,imz-1,slo->ss[ompith][0]); \n\t\tcam3_ssf(w,weop->ww[ompith],cub,cam,tap,slo,imz,ompith); \n\t\tslow3_advance(cub,slo,ompith); \n \n\t\tsf_fslice_put(wfld,iw*cub->amz.n+imz-1,weop->ww[ompith][0][0]); \n\t    } \n \n\t} else {   \n \n\t    w = sf_cmplx(cub->eps*cub->aw.d,-(cub->aw.o+iw*cub->aw.d));  \n \n \n\t    sf_fslice_get(data,iw,weop->ww[ompith][0][0]); \n\t    taper3d(weop->ww[ompith],tap); \n\t    sf_fslice_put(wfld,iw*cub->amz.n,weop->ww[ompith][0][0]); \n \n\t    sf_fslice_get(slo->slice,0,slo->so[ompith][0]); \n\t    for (imz=0; imz<cub->amz.n-1; imz++) {\t \n\t\tif(cub->verb) sf_warning (\"(ith=%d)... <iw=%3d of %3d> <iz=%3d of %3d>\", \n\t\t\t\t\t  ompith,iw+1,cub->aw.n,imz+1,cub->amz.n); \n     \n\t\tsf_fslice_get(slo->slice,imz+1,slo->ss[ompith][0]); \n\t\tcam3_ssf(w,weop->ww[ompith],cub,cam,tap,slo,imz,ompith); \n\t\tslow3_advance(cub,slo,ompith); \n \n\t\tsf_fslice_put(wfld,iw*cub->amz.n+imz+1,weop->ww[ompith][0][0]); \n\t    }  \n \n\t}  \n \n    }  \n \n} ", "pred": " \nvoid cawfl3(camoperator3d weop, \n\t    cub3d cub, \n\t    cam3d cam, \n\t    tap3d tap, \n\t    slo3d slo, \n\t    bool  inv    \n,  \n\t    sf_fslice data  \n, \n\t    sf_fslice wfld  \n) \n \n \n{ \n    int imz,iw; \n    sf_complex w; \n    int ompith=0; \n     \n    for (iw=0; iw<cub->aw.n; iw++) { \n\tompith=omp_get_thread_num(); \n \n\tif(inv) {  \n \n\t    w = sf_cmplx(cub->eps*cub->aw.d,+(cub->aw.o+iw*cub->aw.d));  \n \n\t     \n\t    sf_fslice_get(data,iw,weop->ww[ompith][0][0]); \n\t    taper3d(weop->ww[ompith],tap); \n\t    sf_fslice_put(wfld,iw*cub->amz.n+cub->amz.n-1,weop->ww[ompith]); \n\t} else { \n\t    sf_fslice_get(data,iw,weop->ww[ompith][0][0]); \n\t    taper3d(weop->ww[ompith],tap); \n\t    sf_fslice_put(wfld,iw*cub->amz.n+cub->amz.n-1,weop->ww[ompith]); \n\t} \n    } \n     \n    if(ompith==0) sf_fslice_close(wfld); \n     \n    if(ompith==omp_get_thread_num()) sf_fslice_close(data); \n} \n \n \nvoid cawfl3_close(camoperator3d weop, \n\t\t  cub3d cub, \n\t\t  cam3d cam, \n\t\t  tap3d tap, \n\t\t  slo3d slo, \n\t\t  bool  inv    \n) \n{ \n    int imz,iw; \n    sf_complex w; \n    int ompith=0; \n     \n    for (iw=0; iw<cub->aw.n; iw++) { \n\tompith=omp_get_thread_num(); \n \n\tif(inv) {  \n \n\t    w = sf_cmplx(cub->eps*cub->aw.d,+(cub->aw.o+iw*cub->aw.d));  \n \n\t     \n\t    sf_fslice_get(w,iw,weop->ww[ompith][0][0]); \n\t    taper3d(weop->ww[ompith],tap); \n\t    sf_fslice_put(weop->ww[ompith],iw*cub->amz.n+cub->amz.n-1,weop->ww[ompith]); \n\t} else { \n\t    sf_fslice_get(w,iw,weop->ww[ompith][0][0]); \n\t    taper3d(weop->ww[ompith],tap); \n\t    sf_fslice_put(weop->ww[ompith],iw*cub->amz.n+cub->amz.n-1,weop->ww[ompith]); \n\t} \n    } \n     \n    if(ompith==0) sf_fslice_close(w); \n     \n    if(ompith==omp_get_thread_num()) sf_fslice_close(weop->ww[ompith]); \n     \n    if(ompith==omp_get_thread_num()) sf_fslice_close(weop->ww[ompith]); \n     \n    if"}
{"label": " \nMagickExport Image *ColorizeImage(const Image *image,const char *blend, \n  const PixelInfo *colorize,ExceptionInfo *exception) \n{ \n#define ColorizeImageTag  \"Colorize/Image\" \n#define Colorize(pixel,blend_percentage,colorize)     (((pixel)*(100.0-(blend_percentage))+(colorize)*(blend_percentage))/100.0) \n \n  CacheView \n    *colorize_view, \n    *image_view; \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *colorize_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickStatusType \n    flags; \n \n  PixelInfo \n    blend_percentage; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  colorize_image=CloneImage(image,image->columns,image->rows,MagickTrue, \n    exception); \n  if (colorize_image == (Image *) NULL) \n    return((Image *) NULL); \n  if (SetImageStorageClass(colorize_image,DirectClass,exception) == MagickFalse) \n    { \n      colorize_image=DestroyImage(colorize_image); \n      return((Image *) NULL); \n    } \n  if ((IsGrayColorspace(image->colorspace)!= MagickFalse) || \n      (IsPixelInfoGray(colorize)!= MagickFalse)) \n    (void) SetImageColorspace(colorize_image,sRGBColorspace,exception); \n  if ((colorize_image->alpha_trait == UndefinedPixelTrait) && \n      (colorize->alpha_trait!= UndefinedPixelTrait)) \n    (void) SetImageAlpha(colorize_image,OpaqueAlpha,exception); \n  if (blend == (const char *) NULL) \n    return(colorize_image); \n  GetPixelInfo(image,&blend_percentage); \n  flags=ParseGeometry(blend,&geometry_info); \n  blend_percentage.red=geometry_info.rho; \n  blend_percentage.green=geometry_info.rho; \n  blend_percentage.blue=geometry_info.rho; \n  blend_percentage.black=geometry_info.rho; \n  blend_percentage.alpha=(MagickRealType) TransparentAlpha; \n  if ((flags & SigmaValue)!= 0) \n    blend_percentage.green=geometry_info.sigma; \n  if ((flags & XiValue)!= 0) \n    blend_percentage.blue=geometry_info.xi; \n  if ((flags & PsiValue)!= 0) \n    blend_percentage.alpha=geometry_info.psi; \n  if (blend_percentage.colorspace == CMYKColorspace) \n    { \n      if ((flags & PsiValue)!= 0) \n        blend_percentage.black=geometry_info.psi; \n      if ((flags & ChiValue)!= 0) \n        blend_percentage.alpha=geometry_info.chi; \n    } \n   \n \n  status=MagickTrue; \n  progress=0; \n  image_view=AcquireVirtualCacheView(image,exception); \n  colorize_view=AcquireAuthenticCacheView(colorize_image,exception); \n  for (y=0; y < (ssize_t) image->rows; y++) \n  { \n    MagickBooleanType \n      sync; \n \n    register const Quantum \n      *restrict p; \n \n    register Quantum \n      *restrict q; \n \n    register ssize_t \n      x; \n \n    if (status == MagickFalse) \n      continue; \n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); \n    q=QueueCacheViewAuthenticPixels(colorize_view,0,y,colorize_image->columns,1, \n      exception); \n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL)) \n      { \n        status=MagickFalse; \n        continue; \n      } \n    for (x=0; x < (ssize_t) image->columns; x++) \n    { \n      register ssize_t \n        i; \n \n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++) \n      { \n        PixelChannel channel=GetPixelChannelChannel(image,i); \n        PixelTrait traits=GetPixelChannelTraits(image,channel); \n        PixelTrait colorize_traits=GetPixelChannelTraits(colorize_image, \n          channel); \n        if ((traits == UndefinedPixelTrait) || \n            (colorize_traits == UndefinedPixelTrait)) \n          continue; \n        if (((colorize_traits & CopyPixelTrait)!= 0) || \n            (GetPixelReadMask(image,p) == 0)) \n          { \n            SetPixelChannel(colorize_image,channel,p[i],q); \n            continue; \n          } \n        SetPixelChannel(colorize_image,channel,ClampToQuantum(Colorize(p[i], \n          GetPixelInfoChannel(&blend_percentage,channel),GetPixelInfoChannel( \n          colorize,channel))),q); \n      } \n      p+=GetPixelChannels(image); \n      q+=GetPixelChannels(colorize_image); \n    } \n    sync=SyncCacheViewAuthenticPixels(colorize_view,exception); \n    if (sync == MagickFalse) \n      status=MagickFalse; \n    if (image->progress_monitor!= (MagickProgressMonitor) NULL) \n      { \n        MagickBooleanType \n          proceed; \n \n        proceed=SetImageProgress(image,ColorizeImageTag,progress++,image->rows); \n        if (proceed == MagickFalse) \n          status=MagickFalse; \n      } \n  } \n  image_view=DestroyCacheView(image_view); \n  colorize_view=DestroyCacheView(colorize_view); \n  if (status == MagickFalse) \n    colorize_image=DestroyImage(colorize_image); \n  return(colorize_image); \n} ", "pred": " \nMagickExport Image *ColorizeImage(const Image *image,const char *blend, \n  const PixelInfo *colorize,ExceptionInfo *exception) \n{ \n#define ColorizeImageTag  \"Colorize/Image\" \n#define Colorize(pixel,blend_percentage,colorize)     (((pixel)*(100.0-(blend_percentage))+(colorize)*(blend_percentage))/100.0) \n \n  CacheView \n    *colorize_view, \n    *image_view; \n \n  GeometryInfo \n    geometry_info; \n \n  Image \n    *colorize_image; \n \n  MagickBooleanType \n    status; \n \n  MagickOffsetType \n    progress; \n \n  MagickStatusType \n    flags; \n \n  PixelInfo \n    blend_percentage; \n \n  ssize_t \n    y; \n \n   \n \n  assert(image!= (const Image *) NULL); \n  assert(image->signature == MagickSignature); \n  if (image->debug!= MagickFalse) \n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n  assert(exception!= (ExceptionInfo *) NULL); \n  assert(exception->signature == MagickSignature); \n  colorize_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception); \n  if (colorize_image == (Image *) NULL)\n    return((Image *) NULL);\n  colorize_image->alpha_trait=BlendPixelTrait;\n  colorize_image->colorspace=image->colorspace;\n  colorize_image->alpha_trait=image->alpha_trait;\n  colorize_image->depth=image->depth;\n  colorize_image->columns=image->columns;\n  colorize_image->rows=image->rows;\n  colorize_image->page.width=image->page.width;\n  colorize_image->page.height=image->page.height;\n  colorize_image->page.x=0;\n  colorize_image->page.y=0;\n  colorize_image->colors=image->colors;\n  colorize_image->storage_class=image->storage_class;\n  colorize_image->colors=image->colors;\n  colorize_image->alpha_trait=image->alpha_trait;\n  colorize_image->alpha_trait=BlendPixelTrait;\n  colorize_image->matte=image->matte;\n  colorize_image->matte=BlendPixelTrait;\n  colorize_image->colorspace=image->colorspace;\n  colorize_image->alpha_trait=image->alpha_trait;\n  colorize_image->alpha_trait=BlendPixelTrait;\n  colorize_image->depth=image->depth;\n  colorize_image->columns=image->columns;\n  colorize_image->rows=image->rows;\n  colorize_image->page.x=0;\n  colorize_image->page.y=0;\n  colorize_image->page.width=image->page.width;\n  colorize_image->page.height=image->page.height;\n  colorize_image->page.x=0;\n  colorize_image->page.y=0;\n  colorize_image->page.width=image->page.width;\n  colorize_image->page.height=image->page.height;\n  colorize_image->colors=image->colors;\n  colorize_image->storage_class=image->storage_class;\n  colorize_image->colors=image->colors;\n  colorize_image->alpha_trait=image->alpha_trait;\n  colorize_image->alpha_trait=BlendPixelTrait;\n  colorize_image->matte=image->matte;\n  colorize_image->matte=BlendPixelTrait;\n  colorize_image->colorspace=image->colorspace;\n  colorize_image->alpha_trait=image->alpha_trait;\n  colorize_image->alpha_trait=BlendPixelTrait;\n  colorize_image->depth=image->depth;\n  colorize_image->columns=image->columns;\n  colorize_image->rows=image->rows;\n  colorize_image->page.x=0;\n  colorize_image->page.y=0;\n  colorize_image->page.width=image->page.width;\n  colorize_image->page.height=image->page.height;\n  colorize_image->page.x=0;\n  colorize_image->page.y=0;\n  colorize_image->page.width=image->page.width;\n  colorize_image->page.height=image->page.height;\n  colorize_image->colors=image->colors;\n  colorize_image->storage_class=image->storage_class;\n  colorize_image->colors=image->colors;\n  colorize_image->alpha_trait=image->alpha_trait;\n  colorize_image->alpha_trait=BlendPixelTrait;\n  colorize_image->matte=image->matte;\n  colorize_image->matte=BlendPixelTrait;\n  colorize_image->colorspace=image->colorspace;\n  colorize_image->alpha_trait=image->alpha_trait;\n  colorize_image->alpha_trait=BlendPixelTrait;\n  colorize_image->depth=image->depth;\n  colorize_image->columns=image->columns;\n  colorize_image->rows=image->rows;\n  colorize_image->page.x=0;\n  colorize_image->page.y=0;\n  colorize_image->page.width=image->page.width;\n  colorize_image->page.height=image->page.height;\n  colorize_image->page.x=0;\n  colorize_image->page.y=0;\n  colorize_image->page.width=image->page.width;\n  colorize_image->page.height=image->page.height;\n  colorize_image->colors=image->colors;\n  colorize_image->storage_class=image->storage_class;\n  colorize_image->colors=image->colors;\n  colorize_image->alpha_trait=image->alpha_trait;\n  colorize_image->alpha_trait=BlendPixelTrait;\n  colorize_image->matte=image->matte;\n  colorize_image->matte=BlendPixelTrait;\n  colorize_image->colorspace=image->colorspace;\n  colorize_image->alpha_trait=image->alpha_trait;\n  colorize_image->alpha_trait=BlendPixelTrait;\n  colorize_image->depth=image->depth;\n  colorize_image->columns=image->columns;\n  colorize_image->rows=image->rows;\n  colorize_image->page.x=0;\n  colorize_image->page.y=0;\n  colorize_image->page.width=image->page.width;\n  colorize_image->page.height=image->page.height;\n  colorize_image->page.x=0;\n  colorize_image->page.y=0;\n  colorize_image->page.width=image->page.width;\n  colorize_image->page.height=image->page.height;\n  colorize_image->colors=image->colors;\n  colorize_image->storage_class=image->storage_class;\n  colorize_image->colors=image->colors;\n  colorize_image->alpha_trait=image->alpha_trait;\n  colorize_image->alpha_trait=BlendPixelTrait;"}
{"label": " \nint  \ncuts_spatial ( struct site *__restrict A, \n\t       const struct cut_info CUTINFO ) \n{ \n  fprintf( stdout, \"\\n[CUTS] Instantaneous Spatial/Temporal prop calculating... \\n\" ) ;  \n   \n \n  mom_gauge_spatial( A, CUTINFO.definition ) ;  \n \n  if( check_psq( CUTINFO ) == GLU_FAILURE ) { \n    return GLU_FAILURE ; \n  } \n   \n   \n \n  size_t *num_mom = malloc( sizeof( size_t ) ) ;  \n  const struct veclist *list = compute_veclist( num_mom, CUTINFO, \n\t\t\t\t\t\tND-1, GLU_FALSE ) ; \n \n   \n \n  correct_pspace_landau( A, list, num_mom, ND-1 ) ; \n \n   \n \n  char *str = output_str_struct( CUTINFO ) ; \n  FILE *Aps = fopen( str, \"wb\" ) ;  \n \n  write_mom_veclist( Aps, num_mom, list, ND - 1 ) ; \n \n   \n \n   \n \n \n   \n \n  double *g2_spatial = ( double* )malloc( num_mom[0] * sizeof( double ) ) ;  \n  double *g2_temporal = ( double* )malloc( num_mom[0] * sizeof( double ) ) ;  \n \n   \n \n  const double g2_norm = ND > 2? 2.0 / ( ( NCNC - 1 ) * ( ND - 2 ) * LVOLUME ) : 2.0 / ( ( NCNC - 1 ) * LVOLUME ) ;  \n  const double g0_norm = ND > 1? 2.0 / ( ( NCNC - 1 ) * ( ND - 1 ) * LVOLUME ) : 2.0 / ( ( NCNC - 1 ) * LVOLUME ) ;  \n \n   \n \n  const size_t midpoint = ( num_mom[0] - 1 ) >> 1 ; \n \n  size_t i ; \n  for( i = 0  ;  i < num_mom[0]  ;  i++  ) { \n    double sum_spatial = 0. ;  \n    double sum_temporal = 0. ; \n    GLU_complex tr ; \n    size_t t, mu, mom, cnj ; \n    for( t = 0 ;  t < Latt.dims[ ND - 1 ]  ;  t++ ) { \n      mom = LCU * t + list[ i ].idx ;   \n      cnj = LCU * t + list[ num_mom[0] - i - 1 ].idx ;   \n       \n \n      for( mu = 0 ; mu < ND - 1 ; mu++ ) {       \n\ttrace_ab( &tr, A[ mom ].O[mu], A[ cnj ].O[mu] ) ; \n\tsum_spatial += (double)creal( tr ) ; \n      } \n      trace_ab( &tr, A[ mom ].O[ ND - 1 ], A[ cnj ].O[ ND - 1 ] ) ; \n      sum_temporal += (double)creal( tr ) ; \n    } \n       \n    if( i!= midpoint ) { \n      sum_spatial *= g2_norm ;  \n      sum_temporal *= g2_norm ;  \n    } else {\t   \n      sum_spatial *= g0_norm ;  \n      sum_temporal *= g0_norm ;  \n    }      \n     \n    g2_spatial[i] = sum_spatial ;  \n    g2_temporal[i] = sum_temporal ;  \n  } \n   \n   \n \n  write_g2g3_to_list( Aps, g2_spatial, g2_temporal, num_mom ) ; \n   \n   \n \n  fprintf( stdout, \"[CUTS] Writing finished...\\n[CUTS] Outputting to %s \\n\", str ) ; \n  \n   \n \n  fclose( Aps ) ; \n  free( (void*)list ) ;  \n  free( num_mom ) ;  \n  free( str ) ; \n  free( g2_spatial ) ; \n  free( g2_temporal ) ; \n \n   \n \n  return GLU_SUCCESS ; \n} ", "pred": " \nint  \ncuts_spatial ( struct site *__restrict A, \n\t       const struct cut_info CUTINFO ) \n{ \n  fprintf( stdout, \"\\n[CUTS] Instantaneous Spatial/Temporal prop calculating... \\n\" ) ;  \n   \n \n  mom_gauge_spatial( A, CUTINFO.definition ) ;  \n \n  if( check_psq( CUTINFO ) == GLU_FAILURE ) { \n    return GLU_FAILURE ; \n  } \n   \n   \n \n  size_t *num_mom = malloc( sizeof( size_t ) ) ;  \n  const struct veclist *list = compute_veclist( num_mom, CUTINFO, \n\t\t\t\t\t\tND-1, GLU_FALSE ) ; \n \n   \n \n  correct_pspace_landau( A, list, num_mom, ND-1 ) ; \n \n   \n \n  char *str = output_str_struct( CUTINFO ) ; \n  FILE *Aps = fopen( str, \"wb\" ) ;  \n \n  write_mom_veclist( Aps, num_mom, list, ND - 1 ) ; \n \n   \n \n   \n \n \n   \n \n  double *g2_spatial = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_temporal = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau_inv = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau_inv_inv = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau_inv_inv_inv = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau_inv_inv_inv_inv = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau_inv_inv_inv_inv_inv = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau_inv_inv_inv_inv_inv_inv = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau_inv_inv_inv_inv_inv_inv_inv = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau_inv_inv_inv_inv_inv_inv_inv_inv = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau_inv_inv_inv_inv_inv_inv_inv_inv_inv = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv = ( double* ) malloc( sizeof( double ) * CUTINFO.num_sites ) ; \n  double *g2_pspace_landau_inv_inv_inv_inv_"}
{"label": " \nint main(int argc, char *argv[]) \n{ \n        int i=0; \n \n\t   bomp_bomp_init(4); \n       omp_set_num_threads(4); \n \n        static struct thread_mutex lock = THREAD_MUTEX_INITIALIZER; \n        static spinlock_t lock = 0; \n        static spinlock_t lock = 0; \n        static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; \n \n        uint64_t begin = rdtsc(); \n \n        { \n\t\t   for(i=0;i<1000000;i++) \n\t\t   { \n                       acquire_spinlock(&lock); \n                       release_spinlock(&lock); \n                       thread_mutex_lock(&lock); \n                       thread_mutex_unlock(&lock); \n\t\t   } \n\t} \n \n        uint64_t end = rdtsc(); \n \n        printf(\"took %lu\\n\", end - begin); \n} ", "pred": " \nint main(int argc, char *argv[]) \n{ \n        int i=0; \n \n\t   bomp_bomp_init(4); \n       omp_set_num_threads(4); \n \n        static struct thread_mutex lock = THREAD_MUTEX_INITIALIZER; \n        static spinlock_t lock = 0; \n        static spinlock_t lock = 0; \n        static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; \n \n        uint64_t begin = rdtsc(); \n \n        { \n\t\t   for(i=0;i<1000000;i++) \n\t\t   { \n                       acquire_spinlock(&lock); \n                       release_spinlock(&lock); \n                       thread_mutex_lock(&lock); \n                       thread_mutex_unlock(&lock); \n                       thread_mutex_lock(&lock); \n                    "}
{"label": " \nvoid trans(int M, int N, float *A, \n           int K, float *B, float *C, float *S) \n{ \n\tint k; \n    for (k = 0; k < K; k++) { \n\t    int n,m; \n\t    float tmp; \n\t    int k_x_N = k * N; \n        for (n = 0; n < N; n++) \n            S[k_x_N + n] = B[n * K + k]; \n        for (m = 0; m < M; m++) { \n            tmp = 0; \n            for (int n = 0; n < N; n++) \n                tmp += A[m * N +n] * S[k_x_N + n]; \n            C[m * K + k] = tmp; \n        } \n    } \n \n} ", "pred": " \nvoid trans(int M, int N, float *A, \n           int K, float *B, float *C, float *S) \n{ \n\tint k; \n    for (k = 0; k < K; k++) { \n\t    int n,m; \n\t    float tmp; \n\t    int k_x_N = k * N; \n        for (n = 0; n < N; n++) \n            S[k_x_N + n] = B[n * K + k]; \n        for (m = 0; m < M; m++) { \n            tmp = 0; \n            for (int n = 0; n < N; n++) \n                tmp += A[m * N +n] * S[k_x_N + n]; \n            C[m * K + k] = tmp; \n        } \n    } \n \n} "}
{"label": " \nint main() { \n    double Qx0 = 4.0; \n    double Qy0 = 4.0; \n \n    int Nx = 16; \n    int Ny = 16; \n \n    int Nt = 50000; \n    double dt = 0.0025; \n \n    int NDimx = 2 * Nx + 4; \n    int NDimy = 2 * Ny + 4; \n    double vx[NDimx][NDimy]; \n    double vy[NDimx][NDimy]; \n    int Lx = 2 * Nx; \n    int Ly = 2 * Ny; \n    double DQx = Qx0 / Nx; \n    double DQy = Qy0 / Ny; \n    double DVQ = DQx * DQy / ((2 * M_PI) * (2 * M_PI)); \n    double vvxx[NDimx][NDimy], vvxy[NDimx][NDimy]; \n    double vvyx[NDimx][NDimy], vvyy[NDimx][NDimy]; \n    double vvzx[NDimx][NDimy], vvzy[NDimx][NDimy]; \n \n    printf(\"NCriteria -> %g\\n\",Qx0*Qy0*nu*dt); \n \n    for (int ix = 0; ix <= Lx; ix++) { \n        for (int iy = 0; iy <= Ly; iy++) { \n            double Qx = -Qx0 + ix * DQx; \n            double Qy = -Qy0 + iy * DQy; \n \n            vx[ix][iy] = arc4random_uniform(10) * 1E-3; \n            vy[ix][iy] = arc4random_uniform(10) * 1E-3; \n \n \n            double Q2 = Qx * Qx + Qy * Qy; \n            double Q = sqrt(Q2); \n \n            if (((ix - Nx) * (ix - Nx) + (iy - Ny) * (iy - Ny)) == 0) { \n                continue; \n            } \n            double nx = Qx / Q; \n            double ny = Qy / Q; \n \n            double vn = vx[ix][iy] * nx + vy[ix][iy] * ny; \n \n            vx[ix][iy] -= vn * nx; \n            vy[ix][iy] -= vn * ny; \n        } \n    } \n \n \n    for (int it = 1; it <= Nt; it++) { \n        vx[Nx+1][0] = 1; \n        vy[Nx-1][0] = 1; \n \n        for (int ix = 0; ix <= Lx; ix++) { \n            for (int iy = 0; iy <= Ly; iy++) { \n                vvxx[ix][iy] = 0.0; \n                vvxy[ix][iy] = 0.0; \n                vvyx[ix][iy] = 0.0; \n                vvyy[ix][iy] = 0.0; \n \n                for (int jx = 0; jx <= Lx; jx++) { \n                    int kx = ix - jx + Nx; \n                    if (kx < 0) continue; \n                    if (kx > Lx) continue; \n                    for (int jy = 0; jy <= Ly; jy++) { \n                        int ky = iy - jy + Ny; \n                        if (ky < 0) continue; \n                        if (ky > Ly) continue; \n \n                        if (((ix - Nx) * (ix - Nx) + (iy - Ny) * (iy - Ny)) == 0) { \n                            continue; \n                        } \n \n                         \n \n                        vvxx[ix][iy] += vx[jx][jy] * vx[kx][ky] * DVQ; \n                        vvxy[ix][iy] += vx[jx][jy] * vy[kx][ky] * DVQ; \n                        vvyx[ix][iy] += vy[jx][jy] * vx[kx][ky] * DVQ; \n                        vvyy[ix][iy] += vy[jx][jy] * vy[kx][ky] * DVQ; \n                    } \n                } \n            } \n        } \n \n \n        for (int ix = 0; ix <= Lx; ix++) { \n            for (int iy = 0; iy <= Ly; iy++) { \n \n                double Qx = -Qx0 + ix * DQx; \n                double Qy = -Qy0 + iy * DQy; \n \n                double Q2 = Qx * Qx + Qy * Qy; \n                if (((ix - Nx) * (ix - Nx) + (iy - Ny) * (iy - Ny)) == 0) { \n                    continue; \n                } \n \n                double Q = sqrt(Q2); \n                double nx = Qx / Q; \n                double ny = Qy / Q; \n \n                double fnvx = vvxx[ix][iy]*Qx + vvxy[ix][iy]*Qy; \n                double fnvy = vvyx[ix][iy]*Qx + vvyy[ix][iy]*Qy; \n \n \n                double flvx = -nu*Q2*vx[ix][iy]; \n             ", "pred": " \nint main() { \n    double Qx0 = 4.0; \n    double Qy0 = 4.0; \n \n    int Nx = 16; \n    int Ny = 16; \n \n    int Nt = 50000; \n    double dt = 0.0025; \n \n    int NDimx = 2 * Nx + 4; \n    int NDimy = 2 * Ny + 4; \n    double vx[NDimx][NDimy]; \n    double vy[NDimx][NDimy]; \n    int Lx = 2 * Nx; \n    int Ly = 2 * Ny; \n    double DQx = Qx0 / Nx; \n    double DQy = Qy0 / Ny; \n    double DVQ = DQx * DQy / ((2 * M_PI) * (2 * M_PI)); \n    double vvxx[NDimx][NDimy], vvxy[NDimx][NDimy]; \n    double vvyx[NDimx][NDimy], vvyy[NDimx][NDimy]; \n    double vvzx[NDimx][NDimy], vvzy[NDimx][NDimy]; \n \n    for (int i = 0; i < NDimx; i++) { \n        for (int j = 0; j < NDimy; j++) { \n            vx[i][j] = (double)i * DQx; \n            vy[i][j] = (double)j * DQy; \n        } \n    } \n \n    for (int i = 0; i < NDimx; i++) { \n        for (int j = 0; j < NDimy; j++) { \n            vvxx[i][j] = vx[i][j] * vx[i][j]; \n            vvxy[i][j] = vx[i][j] * vy[i][j]; \n            vvyx[i][j] = vy[i][j] * vx[i][j]; \n            vvyy[i][j] = vy[i][j] * vy[i][j]; \n            vvzx[i][j] = vx[i][j] * vy[i][j]; \n            vvzy[i][j] = vy[i][j] * vy[i][j]; \n        } \n    } \n \n    for (int i = 0; i < NDimx; i++) { \n        for (int j = 0; j < NDimy; j++) { \n            vvxx[i][j] = (double)i * DQx; \n            vvxy[i][j] = (double)j * DQy; \n            vvyx[i][j] = (double)i * DQx; \n            vvyy[i][j] = (double)j * DQy; \n            vvzx[i][j] = (double)i * DQx; \n            vvzy[i][j] = (double)j * DQy; \n        } \n    } \n \n    for (int i = 0; i < NDimx; i++) { \n        for (int j = 0; j < NDimy; j++) { \n            vvxx[i][j] = (double)i * DQx; \n            vvxy[i][j] = (double)j * DQy; \n            vvyx[i][j] = (double)i * DQx; \n            vvyy[i][j] = (double)j * DQy; \n            vvzx[i][j] = (double)i * DQx; \n            vvzy[i][j] = (double)j * DQy; \n        } \n    } \n \n    for (int i = 0; i < NDimx; i++) { \n        for (int j = 0; j < NDimy; j++) { \n            vvxx[i][j] = (double)i * DQx; \n            vvxy[i][j] = (double)j * DQy; \n            vvyx[i][j] = (double)i * DQx; \n            vvyy[i][j] = (double)j * DQy; \n            vvzx[i][j] = (double)i * DQx; \n            vvzy[i][j] = (double)j * DQy; \n        } \n    } \n \n    for (int i = 0; i < NDimx; i++) { \n        for (int j = 0; j < NDimy; j++) { \n            vvxx[i][j] = (double)i * DQx; \n            vvxy[i][j] = (double)j * DQy; \n            vvyx[i][j] = (double)i * DQx; \n            vvyy[i][j] = (double)j * DQy; \n            vvzx[i][j] = (double)i * DQx; \n            vvzy[i][j] = (double)j * DQy; \n        } \n    } \n \n    for (int i = 0; i < NDimx; i++) { \n        for (int j = 0; j < NDimy; j++) { \n            vvxx[i][j] = (double)i * DQx; \n            vvxy[i][j] = (double)j * DQy; \n            vvyx[i][j] = (double)i * DQx; \n            vvyy[i][j] = (double)j * DQy; \n            vvzx[i][j] = (double)i * DQx; \n            vvzy[i][j] = (double)j * DQy; \n        } \n    } \n \n    for (int i = 0; i < NDimx; i++) { \n        for (int j = 0; j < NDimy; j++) { \n            vvxx[i][j] = (double)i * DQx; \n            vvxy[i][j] = (double)j * DQy; \n            vvyx[i][j] = (double)i * DQx; \n            vvyy[i][j] = (double)j * DQy; \n            vvzx[i][j] = (double)i * DQx; \n            vvzy[i][j] = (double)j * DQy; \n        } \n    } \n \n    for (int i = 0; i < NDimx; i++) {"}
{"label": " \nvoid camig3(camoperator3d weop, \n\t    cub3d cub, \n\t    cam3d cam, \n\t    tap3d tap, \n\t    slo3d slo, \n\t    bool  inv    \n,  \n\t    sf_fslice data  \n, \n\t    sf_fslice imag  \n) \n \n \n{ \n    int imz,iw,imy,imx,ihx; \n    sf_complex w; \n    int ompith=0; \n \n    if (!inv) {  \n \n\tLOOP( weop->qq[ihx][imy][imx] = 0.0; ); \n\tfor (imz=0; imz<cub->amz.n; imz++) { \n\t    sf_fslice_put(imag,imz,weop->qq[0][0]); \n\t} \n    } \n     \n    for (iw=0; iw<cub->aw.n; iw++) { \n\tompith=omp_get_thread_num(); \n \n\tif (inv) {  \n \n\t    w = sf_cmplx(cub->eps*cub->aw.d,+(cub->aw.o+iw*cub->aw.d));  \n \n \n\t    LOOP( weop->ww[ompith][ihx][imy][imx] = sf_cmplx(0,0); );   \n\t     \n\t     \n \n\t    sf_fslice_get(slo->slice,cub->amz.n-1,slo->so[ompith][0]); \n\t    for (imz=cub->amz.n-1; imz>0; imz--) { \n\t\tif(cub->verb) sf_warning (\"(ith=%d)... <iw=%3d of %3d> <iz=%3d of %3d>\", \n\t\t\t\t\t  ompith,iw+1,cub->aw.n,imz+1,cub->amz.n); \n \n\t\t{ \n\t\tsf_fslice_get(imag,imz,weop->qq[0][0]);  \n \n\t\tLOOP( weop->ww[ompith][ihx][imy][imx] += \n\t\t      weop->qq        [ihx][imy][imx]; ); \n\t\tLOOP( weop->ww[ompith][ihx][imy][imx].r +=  \n\t\t      weop->qq        [ihx][imy][imx]; ); \n\t\t} \n\t\tsf_fslice_get(slo->slice,imz-1,slo->ss[ompith][0]); \n\t\tcam3_ssf(w,weop->ww[ompith],cub,cam,tap,slo,imz,ompith);\t \n\t\tslow3_advance(cub,slo,ompith); \n\t    } \n \n\t     \n \n\t    { \n\t\tsf_fslice_get(imag,0,weop->qq[0][0]); \n\t\tLOOP( weop->ww[ompith][ihx][imy][imx]  +=  \n\t\t      weop->qq        [ihx][imy][imx]; );\t \n\t\tLOOP( weop->ww[ompith][ihx][imy][imx].r  +=  \n\t\t      weop->qq        [ihx][imy][imx]; ); \n\t\ttaper3d(weop->ww[ompith],tap); \n\t\tsf_fslice_put(data,iw,weop->ww[ompith][0][0]);     \n \n\t    } \n\t     \n\t} else {  \n \n\t    w = sf_cmplx(cub->eps*cub->aw.d,-(cub->aw.o+iw*cub->aw.d));  \n \n \n\t     \n \n\t    sf_fslice_get(data,iw,weop->ww[ompith][0][0]); \n\t    taper3d(weop->ww[ompith],tap); \n\t     \n\t    { \n\t\tsf_fslice_get(imag,0,weop->qq[0][0]); \n\t\tLOOP(;      weop->qq        [ihx][imy][imx] +=  \n\t\t     crealf(weop->ww[ompith][ihx][imy][imx] ); ); \n\t\tsf_fslice_put(imag,0,weop->qq[0][0]); \n\t    } \n\t     \n\t     \n \n\t    sf_fslice_get(slo->slice,0,slo->so[ompith][0]);\t \n\t    for (imz=0; imz<cub->amz.n-1; imz++) { \n\t\tif(cub->verb) sf_warning (\"(ith=%d)... <iw=%3d of %3d> <iz=%3d of %3d>\", \n\t\t\t\t\t  ompith,iw+1,cub->aw.n,imz+1,cub->amz.n); \n\t\tsf_fslice_get(slo->slice,imz+1,slo->ss[ompith][0]); \n\t\tcam3_ssf(w,weop->ww[ompith],cub,cam,tap,slo,imz,ompith); \n\t\tslow3_advance(cub,slo,ompith); \n \n\t\t{ \n\t\t    sf_fslice_get(imag,imz+1,weop->qq[0][0]);  \n \n\t\t    LOOP(;      weop->qq        [ihx][imy][imx] +=  \n\t\t\t crealf(weop->ww[ompith][ihx][imy][imx] ); ); \n\t\t    sf_fslice_put(imag,imz+1,weop->qq[0][0]); \n\t\t} \n \n\t    }  \n \n \n\t}  \n \n    }  \n \n} ", "pred": " \nvoid camig3(camoperator3d weop, \n\t    cub3d cub, \n\t    cam3d cam, \n\t    tap3d tap, \n\t    slo3d slo, \n\t    bool  inv    \n,  \n\t    sf_fslice data  \n, \n\t    sf_fslice imag  \n) \n \n \n{ \n    int imz,iw,imy,imx,ihx; \n    sf_complex w; \n    int ompith=0; \n \n    if (!inv) {  \n \n\tLOOP( weop->qq[ihx][imy][imx] = 0.0; ); \n\tfor (imz=0; imz<cub->amz.n; imz++) { \n\t    sf_fslice_put(imag,imz,weop->qq[0][0]); \n\t} \n    } \n     \n    for (iw=0; iw<cub->aw.n; iw++) { \n\tompith=omp_get_thread_num(); \n \n\tif (inv) {  \n \n\t    w = sf_cmplx(cub->eps*cub->aw.d,+(cub->aw.o+iw*cub->aw.d)); \n\t    sf_fslice_set(imag,0,w); \n\t} \n\telse { \n\t    w = sf_cmplx(cub->eps*cub->aw.d,+(cub->aw.o+iw*cub->aw.d)); \n\t    sf_fslice_set(imag,0,w); \n\t} \n \n\tLOOP( weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] + \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(0.0,1.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(1.0,0.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(0.0,0.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(1.0,1.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(0.0,1.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(1.0,0.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(0.0,0.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(1.0,1.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(0.0,1.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(1.0,0.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(0.0,0.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(1.0,1.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(0.0,1.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(1.0,0.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(0.0,0.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(1.0,1.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(0.0,1.0); \n\t      weop->qq[ihx][imy][imx] = \n\t      weop->qq[ihx][imy][imx] * \n\t      sf_cmplx(1.0,"}
